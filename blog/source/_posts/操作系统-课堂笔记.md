---
date: 2020/3/30
tags:
- 上课笔记
- 进程
categories:
- 操作系统
- 上课笔记
---
## 2.5 经典进程同步问题

### 2.5.1 生产者消费者问题

<!-- more -->
**1. 概念**

* 代表一类具有相同属性的进程。

* 共享一个大小固定的缓冲区，一个或多个生产者生产数

  据，并将生产的数据存入缓冲区，并有一个消费者从缓冲区中取数据。

* 例如， 在输入时，输入进程是生产者，计算进程是消费者;而在输出时，则计 算进程是生产者，而打印进程是消费者。

分别设置两个指针in和out:
– in指向生产者将存放数据的存储单元 – out指向消费者将取数据的存储单元

*如果不控制生产者与消费者：生产者和消费者可能同时进入缓冲区，甚至可能同时读/写一个存储单**元，将导致执行结果不确定。*

**2. 解决方法1：信号量**

互斥信号量mutex:实现诸进程对缓冲池的互斥使用; 

资源信号量empty:表示缓冲池中空缓冲区的数量;初始值定义为1

资源信号量full:表示满缓冲区的数量; 初始值定义为0

只要缓冲池未满，生产者便可将消息送入缓冲池;只要缓冲池未空，消费者便可从缓冲池中取走一个消息。

生产者

```
var mutex，empty，full:semaphore:=1，n，0; 
	buffer:array[0，...，n-1]of item; 
	in，out:integer:=0，0;
	begin
		parbegin 
			proceducer:begin
				repeat
				...
				producer an item nextp;
				...
				wait(empty);	当empty == 1：1-1=0 
											当empty == 0 说明缓冲区不空
				wait(mutex);  
				buffer(in):=nextp; 
				in:=(in+1)mod n; 
				signal(mutex);释放缓冲区 
				signal(full); full代表数据个数
until false; end
 
```

消费者

```
 consumer :begin 
 						repeat
						wait (full); 
						wait(mutex); 缓冲区是否有其他进程
						nextc :=buffer(out); 
						out:= (out+1)mod n;
						signal(mutex); 
						signal(empty);
						consumer the item in nextc;
					until false; 
				end
			parend 
		end
```

**3. 注意**

* 先申请资源信号量，再申请互斥信号量

  *资源信号量相当于你吃饭先预定个桌子如果你不预定 直接去吃饭 没桌子了你只好一直在那等了 别人吃完了桌子留给了预定的人 你没预定就得一直在那等 就是死锁了*

  *如两个进程都反过来操作，先互斥了，但是没有得到临界资源，发生死锁*

* 对任何信号量的wait与signal操作必须配对。同一进程中的多对wait与signal语句只能嵌套，不能交叉。

* 对同一个资源信号量的wait与signal可以不在同一个进程中。

  – 例如，wait(empty)在计算进程中，而signal(empty)则在打印进程中，计 算进程若因执行wait(empty)而阻塞， 则以后将由打印进程将它唤醒

* wait与signal语句不能颠倒顺序，wait语句一定先于signal语句，否则可能 引起进程死锁。

**4. 解决方法2：and信号量**

![and信号量（合并互斥和资源信号量）](https://img.cetacis.dev/uploads/big/25e90fb77f0065bee3136b76517b5f2b.png)

### 2.5.2 读者和写者问题

**1. 概念**

读者：只读不取

读读不互斥，读写互斥，写写互斥。

**2. 解决方法1：读者优先**

**读者优先**：一旦有读者正在读数据，允许多个读者同时进入读数据，只有 当全部读者退出，才允许写者进入写数据。

可能问题：读者不断进入，写者长时间等待（饥饿）

```
Var rmutex, wmutex:semaphore∶ =1,1;/* 互斥信号量，初始化为1 */
	Readcount:integer∶ =0;; /* 统计读者个数 */ 
	begin
	parbegin
	Reader:begin 
		repeat
		wait(rmutex);# 共享变量，保证互斥
		if readcount=0 then wait(wmutex); # readcount == 0 在此之前没有读者 
																			# 需要判断是否有写进程 如果有，则需要等待写进程
																			# wmutex：用于写进程互斥
			Readcount∶ =Readcount+1;   # 读者进程的共享变量
		signal(rmutex);
...
perform read operation;
...
		wait(rmutex); 
			readcount∶ =readcount-1;
			if readcount=0 then signal(wmutex); # 最后一个读进程，有可能有进程在等，
																					# 判断是否需要唤醒
			signal(rmutex);
			until false;
     end
 
```

**2. 解决方法2：信号量集**

写者

```
var RN integer;/* 控制读者上限RN*/ 
	L, mx:semaphore∶ =RN,1;
	begin
  	parbegin
			reader:begin 
				repeat
					swait(L,1,1);
					/* 每进入一个读者，L减一，控制总数RN个*/ 
					swait(mx,1,0);
					/* 开关，mx=1标识无writer进程写*/
...
					perform read operation; 
					...

```

![](https://img.cetacis.dev/uploads/big/7710f66ad00fa7588b9bc758f3803f08.png)

### 2.5.3 哲学家就餐问题

**1. 问题描述**

![哲学家问题](https://img.cetacis.dev/uploads/big/7e7c738894e76900b2d180fcf1e9e43b.png)

经分析可知，放在桌子上的筷子是临界资源，在一段时间内只允许一位哲学 家使用。为了实现对筷子的互斥使用，可以用一个信号量表示一只筷子，由

这五个信号量构成信号量数组。其描述如下: • Var chopstick: array[0, ..., 4] of semaphore;

**2. 解决方式1：信号量**

* 每个筷子一个初值为1的信号量 
* 每个哲学家是一个进程

```
Var Chopstick;array [0,4]of semaphore; 
 第i个进程描述为(i=0,... ,4)
repeat
	wait(chopstick[i]);取左筷子; 
	wait(chopstick[(i+1)mod 5]);取右筷子; 
	eat;
	signal(chopstick[i]);放左筷子
	signal (Chopstick[(i+1)mod 5];放右筷子; 
	think;
until false;
(这可能导致死锁：只要相邻的两个人同时拿起左筷子就会发生死锁
```

*对wait/signal的理解*

*wait ：在取用一个资源时是否需要wait*

*signal： 在放置一个资源时，设置此资源可获取*

**3. 解决方式2：and信号量（解决死锁**

```
Var chopsiick array [0, ..., 4] of semaphore∶ =(1,1,1,1,1); 
	processi
		repeat
			think;
			sswait(chopstick[(i+1) mod 5], chopstick [i]); 
			eat;
			ssignat(chopstick [(i+1) mod 5], chopstick [i]);
		until false;
```

### 2.5.4 互斥与同步解决方法之四 : 管程

**1. 概念**

* 出现原因：每个要访问临界资源的进程都必须自备**同步操作**wait(S)和signal(s)。这就使大量的同步操作分散在各个进程中。这不仅给系统的管理带来了麻烦，而且还会因同步操作的使用不当而导致系统死锁。

* 定义：将资源访问的同步，资源本身进行封装为一个“class”。同时，只能有一个“class”访问这个数据。Hansan为管程所下的定义是:“一个管程定义了一个数据结构和能为并发进程所执行(在该数据结构上)的一组操作，这组操作能同步进程和改变管程 中的数据”。

* 互斥保证：操作系统- 任何时刻，只能有一个进程在管程中运行

* 组成：1 局部于管程的共享变量说明;

  ​			2 对该数据结构进行操作的一组过程

  ​			3 对局部于管程的数据设置初始值的语句。 

  ​			4 管程的名称

**2. 对生产者消费者问题的解决**

在利用管程方法来解决生产者-消费者问题时， 首先便是为它们建立一个管程，并命名为Proclucer-Consumer, 或简称为PC。其中包括两个过程: 

(1)put(item)过程。 生产者利用该过程将自己生产的产品投放到缓冲池中，

并用整型变量count来表示在缓冲池中已有的产品数目，当count≥n时，表示 缓冲池已满，生产者须等待。
(2) get(item)过程。消费者利用该过程从缓冲池中取出一个产品，当count≤0 时，表示缓冲池中已无可取用的产品， 消费者应等待。

```
producer:begin 
	repeat
		produce an item in nextp;
		PC.put(item); 
		until false;
	end # 生产者进程
consumer:begin
	repeat
		PC.get(item);
		consume the item in nextc;
		until false; 
	end # 消费者进程
```

将所有功能封装在**PC**这个“类”中，直接调用。

## 2.6 进程通信

**概念：**当进程进行通信合作时，各个进程之间需要建立连接，进程通信需要同步和协调。

通讯类型：控制信息（低级）数据（高级）

进程之间同步与互斥是一种低级通信,用来控制进程执行速度。

– 效率低
– 通信对用户不透明

### 通信机制1 基于共享存储区方式

1. 通过程序设计来实现。程序员设计程序时，利用程序指令设置共享数据结构， 并处理通信进程之间的同步等问题，操作系统只需提供共享存储区。

2. 由操作系统在内存中划分出一块区域作为共享存储区。

– 进程在通信前向系统申请共享存储区中的一个分区。

– 然后，申请进程把获得的共享存储分区连接到本进程上，此后便可象读/写 普通存储器一样地读/写共享存储分区。

– 该方式下，通信进程之间的同步与互斥访问共享存储区可以由操作系统实 现。

### 通信机制2 管道通信

- 所谓“管道”，是指用于连接一个读进程和一个写进程以实现他们之间通信 的一个共享文件，又名pipe文件。
- 向管道(共享文件)提供输入的发送进程(即写进程)， 以字符流形式将大量的数 据送入管道;
- 而接受管道输出的接收进程(即读进程)，则从管道中接收(读)数据。由于发送 进程和接收进程是利用管道进行通信的，故又称为管道通信。
- 这种方式首创于UNIX系统，由于它能有效地传送大量数据，因而又被引入到 许多其它操作系统中。

**有名管道  **：通过文件的读写（遵循FIFO原则

**无名管道**：内存

### 通信机制3 信息传递方式

比如网络信息的传递，本机的进程与远端服务器链接并且传递。

进程间的数据交换，是以格式化的消息(message)为单位的(计算机网络称为报文)

## 2.7 线程

线程是一种比进程更小的独立运行单位：线程（threads） 可以比进程更好地提高程序的并行执行程度，并且提高系统的吞吐量。

### 2.7.1 线程的引入

进程特点：

* 资源所有权:一个进程包括一个保存进程映像的虚地址空间，并且随时分配对。资源的的控制或所有权，包括内存、I/O通道、I/O设备、文件等。

  资源：处理机，io

* 调度/执行:进程是被操作系统调度的实体。

为区分这两个特点，调度并分派的部分通常称为线程或轻便进程(lightweight process)，而资源所有权的部分通常称为进程。

#### 线程的属性：

(1) 线程是一个被调度和分派的基本单位，并可独立运行的实体。大多数与 执行相关的信息可以保存在线程级的数据结构中;

(2)线程是可以并发执行; (3)共享进程资源。

(4)线程是轻型实体，在切换时只需保存少量寄存器的内容，不涉及存储器的 管理等，因此系统开销小。

(5)进程中的所有线程共享同一个地址空间，挂起进程则会挂起进程中的所有 线程。类似地，进程的终止会导致进程中所有线程的终止。

#### 线程优点

1. 在一个已有进程中创建一个新线程比创建一个全新进程所需的时间少。 
2. 终止一个线程比终止一个进程花费的时间少。 
3. 线程间切换比进程间切换花费的时间少。
4. 线程提高了不同的执行程序间通信的效率。同一个进程中的线程共享存储空 间和文件，它们无需调用内核就可以互相通信。

### 2.7.2 线程进程比较

1、调度的基本单位 2、并发性 3、拥有资源 4、独立性 5、系统开销 6、支持多处理机

### 线程状态和线程控制块

**线程的状态有: **

运行状态、就绪状态、阻塞状态等。

**在线程切换时保存的线程信息:**

1 一个执行栈。
2 每个线程静态存储局部变量。 3对存储器和其进程资源的访问，并与该进程中的其他线程共享这些资源。如:寄存器状态、堆栈、线程运行状态、 优先级、线程专有存储器、信 号屏蔽等

#### 线程状态变化的4种基本操作

1派生(Spawn):当产生一个新进程时，同时也为该进程派生了一个“初始化 线程”，随后，可以在同一个进程中派生另一个线程，新线程被放置在就绪队列中。

2阻塞(Block):当线程需要等待一个事件时，它将阻塞，此时处理器转而执 行另一个就绪线程。

3解除阻塞(Unblock):当阻塞一个线程的事件发生时，该线程被转移到就绪 队列中。

4结束(Finish):当一个线程完成时，其寄存器的信息和栈都被释放。

### 2.6.3 线程的分类

1. 内核
2. 用户空间 （同时，用户层也可有资源所有权，线程在此层对进程直接进行调度





# 第三章 处理机与死锁

多到程序环境进程数目多于处理机数，处理机是十分重要的资源，如何分配尤为重要，它是由调度程序完成的，需要优秀的调度方法。

调度需要解决的问题：1. 调度算法 2. 何时分配 3. 调度过程及其进程 的上下文切换

## 3.1 处理机调度的层次和调度算法目标

调度对象

- 作业（job） 程序、数据、作业说明书

### 3.1.1 处理机调度的层次

1. 高级调度 

   作业调度或长程调度:用于决定把外存上处于后备队列中的哪些作业调入内存，并为它们创建进程、分配必要的资源，然后，再将新创建的进程排在就 绪队列上，准备执行 。

2. 低级调度

   进程调度或短程调度:用来决定就绪队列中的哪个进程(或内核级线程) 应获得处理机，然后再由分派程序把处理机分配给该进程的具体操作。

3. 中级调度

   目的：提高内存利用率和系统吞吐量。就绪状态--挂起状态 当系统负载过重，*将进程挂起到外存的专*用*区域*

#### 1. 高级调度

作业调度或长程调度:用于决定把外存上处于后备队列中的哪些作业调入内存，并为它们创建进程、分配必要的资源，然后，再将新创建的进程排在就 绪队列上，准备执行 。

* 接受作业数量：取决于多到程序度允许多少作业同时在内存运行
* 接纳那些作业：取决于调度算法 （先入先出、短作业优先、基于作业优先权、相应比高者优先

**阶段与状态：**

收容运行段（后备状态）

运行阶段（运行状态）

完成阶段（完成状态）

#### 2. 低级调度

**进程调度的主要任务**

– 保存处理机的现场信息到进程PCB中，如:程序计数器、通用寄存器等 
– 按某种算法选取进程，如优先级算法、轮转法等
– 由分派程序(Dispatcher)把处理器分配给进程，恢复进程处理机现场

**进程调度机制的三个部分**

– 排队器 对首进程即将要被调用的进程

– 分派器 (分派程序) 将cpu分配

– 上下文切换器 (两对)

当前进程->分派程序->新进程

**调度方式**

* 非抢占式

  1. 正在执行的进程执行完毕，或因发生某事件而不能再继续执(包括:当前执行进程被中断、挂起自己、退出等)

  2. 执行中的进程因提出I/O请求而暂停执行;

  3. 在进程通信或同步过程中执行了某种原语操作，如P操作原语，Block原语， Wakeup原语等。

* 抢占式

  抢占原则： 优先权原则。短作业(进程)优先原则。时间片原则。

  优缺点：优点 满足对响应时间严格的实时任务 缺点 调度开销大

#### 3. 中级调度

目的：提高内存利用率和系统吞吐量。

**挂起状态：**使那些暂时不能运行的进程不再占用内存资源，而将它们调至外存上去等待。

程序重又具备运行条件、且内存又稍有空闲时，由中级调度来决定把 外存上的哪些又具备运行条件的就绪进程，重新调入内存，并修改其状态为 就绪状态。

#### 4. 调度队列模型和调度准则

1. 仅有进程调度的调度队列模型

![](https://img.cetacis.dev/uploads/big/a2f70281a16a73945aab3c237bd18ec3.png)

2. 有高级和低级调度的调度队列模型

![](https://img.cetacis.dev/uploads/big/9c92d3574c203412fcf950aa64936c72.png)

3. 同时具有三级调度的调度队列模型

![](https://img.cetacis.dev/uploads/big/b626a71c9dbaecdccd485b19c9fe8cb6.png)

### 3.1.2 处理机调度算法目标

#### 1. 共同目标

**资源利用率** 最重要

**公平性** 合理cpu时间 合理不仅仅在于先入先出，而在于很多原则，比如优先权原则，短进程原则。

**平衡性** 保持各种cpu的系统资源使用平衡性

策略强制执行

#### 2. 批处理系统目标

![](https://img.cetacis.dev/uploads/big/47dcfdb60f8ab8ca9616e37659a6b8a2.png)

平均周转时间求和即全部的周转时间

平均带权周转时间求和是 周转时间/服务时间

#### 3. 分时系统目标

1. 响应时间快 用户体验好

2. 均衡性 系统响应时间快慢与用户所请求服务的复杂性相适应

#### 4. 实时系统的目标

1. **截止时间的保证** 截止时间指任务必须开始执行或者必须完成的时间。实时系统调度算法的一个重要目标是保证实时任务对截止时间的要求。
2. 可预测性

## 3.3 调度算法

调度算法：根据系统的资源分配策略所规定的资源分配算法。对于不同 的系统目标，通常采用不同的调度算法。

1.先来先服务(FCFS) 2.短作业(短进程)优先(SJF) 3.时间片轮转(RR) 4.基于优先级的调度算法 5.剩余时间最短者优先 6.高响应比优先调度算法 7.多级反馈队列调度法

*有利于否在于带权周转时间的长短*

周转时间 = 完成时间 - 到达时间

带权周转时间 = 周转时间 / 服务时间

### 3.3.1先来先服务

有利于长作业不利于短作业（短作业可能会等待较长时间才能得到短时服务）

非抢占式调度（批处理

### 3.3.2 短作业优先（短作业即服务时间短）

首先从就绪队列调度估计时间最短的作业 

有利于短作业不利于长作业（所有短作业完成以后长作业才可能开始，甚至可能导致长作业长期不被调度）

非抢占式调度（批处理

缺点：1. 有利于短作业不利于长作业 2. 非抢占式调度 3. 对于长短估计不一定准确，不能选到最短的

### 3.3.3 基于优先级的调度算法

把处理机分配给就绪队列中优先级最高的进程

**两种类型**：非抢占式优先权算法   抢占式优先权调度算法

#### 1. 非抢占优先权算法

系统一旦把处理机分配给就绪队列中优先权最高的进程后， 该进程便一直执行下去，直至完成;或因发生某事件使该进程放弃处理机时， 系统方可再将处理机重新分配给另一优先权最高的进程。

#### 2. 抢占式优先权调度算法

 在其执行期间，只要又出现了另一个其优先权更高的进程，进程调度程序就 立即停止当前进程的执行，重新将处理机分配给新到的优先权最高的进程。

**特点**：能更好地满足紧迫作业的要求，故而常用于要求比较严格的实时系统中，以及对性能要求较高的批处理和分时系统中。

#### 3. 优先权的类型

**静态优先权**：在创建进程时确定的，且在进程的整个运行期间保持不变。

**动态优先权**：在创建进程时所赋予的优先权，是可以随进程的推进或随 其等待时间的增加而改变的，以便获得更好的调度性能。

**确定进程优先权的依据有三个方面**：

(1)进程类型。
– 系统进程的优先权高于一般用户进程的优先权。

(2)进程对资源的需求。
– 对执行时间和内存要求少的进程应赋予较高的优先权。

(3)用户要求。
– 按照各进程的执行流程和进程的紧迫程度来指定进程的优先权。

#### 4. 高响应比 优先 调度算法

响应比 Rp = 1 + 等待时间/要求服务时间 = 响应时间 / 要求服务时间 = （等待时间+要求服务时间）/要求服务时间

即：要求服务时间越短，等待时间越长，响应比越大。

分析：

（1）时间同，越短优先权越高，**有利于短作业**

（2）实现的是先来先服务

（3）对于长作业，也可以由等待时间的增加而提高，防止长作业无法被调度。

* 优点 ： 该算法既照顾了短作业，又考虑了作业到达的先后次序，同时不会使 长作业长期得不到服务。

* 缺点： 利用该算法时，每次调度之前，都须先做响应比的计算，会增加系统 开销。

### 3.3.4 时间片轮转调度费RR

#### 1. RR

系统将所有的就绪进程按先来先服务的原则，排成一个 队列，每次调度时，把CPU分配给队首进程，并令执行一个时间片。当执行的时间片用完时，由一个计时器发出时钟中断请求， 调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾;

切换情况： 时间片用完；时间片没有用完，但是进程执行错误/错误。

特点：系统能在给定的时间内，响应所有用户的请求。

时间片大小会影响计算机性能：短时间片有利于短作业，使其较快完成，但会频繁发生中断、进程上下文切换，增加系统开销;

对于短的、计算型进程比较有利，因为该进程充分利用时间片，而I/O型进程 却不利，因为在两次I/O之间仅需很少的CPU时间，却需要等待一个时间片。

常用于分时系统及事务处理系统。

#### 2. 多级反馈队列调度法（抢占式调度算法

* 设置多个继续队列，每个队列有不同的优先级。赋予不用队列的时间片的大小也各不相同。优先级高，时间片小。优先级低，时间片大。第一个队列往后，优先级逐渐降低。

* 当一个新进程进入内存后，首先将它放入第一队列的末尾，按FCFS原则排 队等待调度。

  – 当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统;
  – 如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的

  末尾，再同样地按FCFS原则等待调度执行;
  – 如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队

  列，......
  – 当进程最后被降到第n队列后，在第n队列中按RR方式调度

* 当第一队列空闲，才调度第二队列中的进程运行。当1-（i-1）空闲，i队列才会运行。

  当新进程进入后，会抢占二/三队列的cpu。将正在运行的进程放回i队列末尾。

性能：

(1)终端型作业用户。

能在第一队列所规定的时间片内完成，可使终端型作业用户都感到满意。

(2)对短作业用户有利。

(3)长批处理作业用户。对于长作业，它将依次在第1，2,...，n个队列中运行， 然后再按轮转方式运行，用户不必担心其作业长期得不到处理。

## 3.4 实时系统与实时任务调度

由于在实时系统中都存在着若干个实时进程或任务，
– 实时进程通常带有某种程度的紧迫性
– 需要引入一种新的调度解决实时进程的调度，即实时调度。

### 3.4.1 实现实时调度系统的基本条件

#### 1. 提供必要的信息
(1)就绪时间。 (2)开始截止时间或完成截止时间。 (3)处理时间。

(4)资源要求。 (5)优先级。

#### 2. 系统处理能力强

在实时系统中，通常都有着多个实时任务。若处理机的处理能力不够强，则有 可能因处理机忙不过来而使某些实时任务不能得到及时处理。

解决的方法是提高系统的处理能力，其途径有:

* 对单处理机系统，增强其处理能力，以此显著地减少对每一个任务的处理时间;
*  其二是采用多处理机系统。

#### 3. 采用抢占式调动机制

在含有硬实时任务的实时系统中，广泛采用抢占机制。当一个优先权更高 的任务到达时，允许暂停当前任务，而令高优先权任务立即投入运行，这 样便可满足该硬实时任务对截止时间的要求。

#### 4. 具有快速切换机制

（1）对外部中断的快速响应能力。

（2）快速的任务分派能力。

### 3.4.2 实时调度算法的分类

![实时调度算法的分类](https://img.cetacis.dev/uploads/big/04eae4dfeee38b3ff3a71670585f7df6.png)

### 3.4.3 常用的几种实时调度算法

#### 1. 最早截止时间优先算法(EDF)

* 按照截止时间排序
* 如果新进程截止时间早于当前进程截止时间，则进行抢占。

#### 2. 最低松弛度优先算法(LLF) 

松弛度=完成截至时间–剩余运行时间–当前时间

略

## 3.5 死锁概述

**死锁(Deadlock)**：是指多个进程在运行过程中因争夺资源而造成的一 种僵局。必须由外力解决。

### 3.5.1 死锁原因

（1）资源竞争

（2）进程间推进顺序非法

#### 1.  竞争资源

1) 可剥夺和非剥夺性资源

- 可剥夺性资源: 是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺。如:处理机、内存等
- 非剥夺性资源: 当系统把这类资源分配给某进程后，再不能强行收回，只能 在进程用完后自行释放。如打印机等

2) 竞争非剥夺性资源

* 在系统中所配置的非剥夺性资源，由于它们的数量不能满足诸进程运行的 需要，会使进程在运行过程中，因争夺这些资源而陷入僵局。 

* 例如，系统中只有一台打印机R1和一台磁带机R2，可供进程P1和P2共享。 处理不好，在P1与P2之间会形成僵局，引起死锁。 P1先R1后R2，P2先R2后R1，可能会死锁。

3)竞争临时性资源

• 临时性资源，可以创造(生产)和撤消(消耗)的资源，也称之为消耗性资源，它也可能引起死锁。 

• 如信号量、消息、buffer中的数据等资源。 

• 例如:S1、S2和S3是临时性资源，是由进程P1、P2和P3产生的消息。如果 消息通信处理顺序不当也会发生死锁。 

#### 2. 进程推进顺序不当引起死锁

### 3.5.2 死锁必要条件

(1)互斥条件 : 指进程对所分配到的资源进行排它性使用 。

(2)请求和保持条件 : 指进程已经保持了至少一个资源，但又提出了新的资源 请求 。

(3)不剥夺条件 : 指进程已获得的资源，在未使用完之前，不能被剥夺，只能 在使用完时由自己释放。

(4)环路等待条件 : 指在发生死锁时，必然存在一个进程——资源的环形链 。

### 3.5.3 解决死锁概述

(1)预防死锁:是通过设置某些限制条件，去破坏产生死锁的四个必要条件中 的一个或几个条件，来预防发生死锁。

(2)避免死锁:是在资源的动态分配过程中，用某种方法去防止系统进入不安 全状态，从而避免发生死锁。

(3)检测死锁:通过系统所设置的检测机构，及时地检测出死锁的发生，并精 确地确定与死锁有关的进程和资源;

(4)解除死锁:当检测到系统中已发生死锁时，须将进程从死锁状态中解脱出 来。常用的实施方法是撤消或挂起一些进程。

## 3.6 预防死锁

#### 1. 破坏“请求保持”条件

系统规定所有进程在开始运行之前，都必须一次性地申请其在整个运行过程 所需的全部资源。

从而进程在整个运行期间，便不会再提出资源要求，从而摒弃了请求和保持 条件，由此可以避免发生死锁。

 优点:简单、易于实现且很安全。
 缺点:资源被严重浪费，进程经常会发生饥饿现象。

#### 2. 摒弃“不剥夺”条件

当一个已经保持了某些资源的进程，再提出新的资源请求而不能立即得到满 足时，必须释放它已经保持了的所有资源。待以后需要时再重新申请。从而 摒弃了“不剥夺”条件。

**缺点**:实现起来比较复杂且要付出很大代价。

* 一个资源在使用一段时间后，它的被迫释放可能会造成前段工作的失效。 – 会使进程前后两次运行的信息不连续。
* 因反复地申请和释放资源，致使进程执行被无限推迟，延长进程周转时 间、增加系统开销、降低吞吐量

#### 3. 摒弃”环路等待“条件

这种方法中规定，系统将所有资源按类型进行线性排队，并赋予不同的序号。 所有进程对资源的请求必须严格按照资源序号递增的次序提出，这样，在所 形成的资源分配图中，不可能再出现环路，因而摒弃了“环路等待”条件。

**缺点：**

1. 为系统中各类资源分配的序号必须相对稳定，这就限制了新设备类型的

   增加;

2. 经常发生作业使用资源的顺序与系统规定资源使用顺序不同的情况，造成资源浪费;

3. 增加了程序设计难度。

## 3.7 避免死锁

### 3.7.1 安全状态

- 所谓安全状态，是指系统能按某种进程顺序，如<P1，P2，...，Pn>，依次为n 个进程分配其所需资源，直至其最大需求，使每个进程都可顺利地完成，称 系统处于安全状态。
- 称〈P1，P2，...，Pn〉序列为安全序列。否则，如果系统无法找到这样一个安 全序列，则称系统处于不安全状态。

### 3.7.2 银行家算法

避免死锁的关键在于如何准确的预测是否会出现死锁，从而避免死锁。最有 代表性的避免死锁的算法是Dijkstra的银行家算法。

#### 1. 银行家算法数据结构

(1)可利用资源向量Available:这是一个含有m个元素的数组，其中的每一个 元素代表一类可利用的资源数目。其数值随该类资源的分配和回收而动态地 改变。 Available[j]=k,表示系统中现有Rj类资源k个。

(2)最大需求矩阵Max。这是一个n × m的矩阵，它定义了n个进程中每一个进 程对m类资源的最大需求。Max[i,j]=K，表示进程Pi需要Rj类资源的最大数目 为K。

(3)分配矩阵Allocation是一个nxm矩阵，定义了系统中每一类资源当前已分配给每一进程的资源数。Allocation[i,j]=K，表示进程Pi当前已分 得Rj类资源的数目为K。

(4)需求矩阵Need。这也是一个n×m的矩阵，用以表示每一个进程尚需的各 类资源数。Need[i,j]=K，表示进程Pi还需要Rj类资源K个，方能完成其任务。

• 上述三个矩阵的关系:Need[i,j]=Max[i,j] - Allocation[i,j]

#### 2. 银行家算法

设Requesti，是进程Pi的请求向量，当Pi发出资源请求后，系统按下述步骤进行 检查:

(1)如果Requesti[j]≤Need[i,j],便转向步骤2;否则认为出错，因为它所需要的 资源数已超过它所声明的最大值。

(2)如果Requesti[j]≤Available[j]，便转向步(3)，否则，表示尚无足够资源， Pi须阻塞等待。

(3)系统试探着把资源分配给进程Pi ，并修改下面数据结构中的数值: 

Available[j]:= Available[j] - Requesti[j]; Allocation[i,j] : = Allocation[i,j] + Requesti[j]; Need[i,j]: =Need[i,j] - Requesti[j]; 

(4)系统执行安全性算法，检查此次资源分配后，系统是否处于安全状态。若 安全，才正式将资源分配给进程Pi ，以完成本次分配;否则，将本次的试探 分配作废，恢复原来的资源分配状态，让进程Pi等待。 

#### 3. 安全性算法

系统所执行的安全性算法可描述如下:

 (1)设置两个向量:

1工作向量Work: 它表示系统可提供给进程继续运行所需的各类资源数目，初始值Work:=Available

2设置数组Finish[n]:初始值Finish[i]:=false; 当Finish[i]:=true时，进程Pi可获得其所需的全部资源，从而顺利执行完成。

(2)从进程集合中找到一个能满足下述条件的进程Pi : 

1Finish[i]=false;  2 Need[i,j]≤work; **寻找未完成的进程，它的所需资源量小于系统可用资源量**

若找到，执行步骤(3),否则，执行步骤(4)。 

(3)当进程Pi获得资源后，顺利执行直至完成，并释放出分配给它的资源，故应 执行: 

Work:= Work+Allocation[i,j]; Finish[i] :=true;  go to step 2; 

(4)如果所有进程的Finish[i]=true都满足，则表示系统处于安全状态;否则， 系统处于不安全状态。 

**大题出现 ppt例子**

## 3.8 死锁的检测与解除

### 3.8.1 死锁的检验

#### 1. 死锁检测

如果系统不愿意附加太多约束条件预防死锁，也不希望系统额外开销预测并避 免死锁，那么，只能允许死锁出现，然后，再解除它。

• 因此，系统需要利用某种方法来检测死锁

• 资源分配图 该图是由一组结点N和一组边E所组成的一个对偶G=(N,E)

其中:

(1)把N分为两个互斥的子集，即一组进程结点P={P1,P2，...，Pn)和一组资 源结点R={R1, R2 ，...， Rn}，N=PUR。 

(2)凡属于E中的一个边e∈ E都连接着P中的一个结点和R中的一个结点 – e={Pi,Rj} 

它表示进程Pi请求一个单位的rj资源。 – e={Rj，Pi} 

它表示把一个单位的资源Rj分配给进程Pi 。 

#### 2. 死锁定理

![](https://img.cetacis.dev/uploads/big/a4ed842da08a8e4aa93af662aa37612d.png)

#### 3. 死锁检测算法

若能消去资源分配图中所有结点的连接边，使全部结点都成为孤立结点，则称 该图是可完全简化图;若不能使该图完全简化，则称该图是不可完全化简图。

可以证明:当且仅当系统某状态S所对应的资源分配图是不可完全化简的，则S 是死锁状态。该充分条件称为死锁定理。

#### 4.死锁检测中的数据结构 

(1)可利用资源向量Available，它表示了m类资源中每一类资源的可用数目。

 (2)把不占用资源的进程(Allocation:=0)记入L表中，即Li U L

 (3)从进程集合中找到一个Requesti≤work的进程，做如下处理:

1. Work:=work十Allocationi，

2. 将它记入L表中。

(4)若不能把所有进程都记入L表中，便表明系统状态S的资源分配图是不可 完全简化的。因此，该系统状态将发生死锁。

```
 Work:= Available; 
 	L:={Li|Allocationi=0∩Requesti=0} 
 	for all Li∈L do
		begin
		for all Requesti≤Work do
			begin 
				Work:=Work十Allocationi;
        Li∪L;
			end 
		end
	deadlock:= (L={P1，P2，.... ，Pn});
```

### 3.8.2 死锁的解除

当发现有进程死锁时，常采用的两种方法是解除死锁:

 (1)剥夺资源。从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态。

(2)撤消进程。最简单的撤消进程的方法，是使全部死锁进程都夭折掉;或者 按照某种顺序逐个地撤消进程，直至有足够的资源可用，使死锁状态消除为

止。

按照解除死锁复杂度递增的顺序列出解除死锁的方法:
1. 撤消死锁进程。该方法是目前操作系统中解除死锁的常用方法。
2. 把死锁进程恢复到前一个检查点，重新执行每个进程。
3. 按照某种原则逐个选择死锁进程进行撤消，直到解除系统死锁。
4. 按照某种原则逐个剥夺进程资源，直到解除死锁。

**最小代价原则**

第三种和第四种方法需要选择系统付出代价最小的进程，最小代价原则: 

– 到目前为止，花费处理机的时间最少的进程;

– 到目前为止，产生输出最少的进程;

– 估计未执行部分最多的进程;

– 到目前为止，已获得资源量最少的进程; – 优先级最低的进程。



