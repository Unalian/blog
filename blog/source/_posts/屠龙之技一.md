---
date: 2020/2/5
tags:
- 自学笔记
- 终端基础操作
categories:
- 屠龙之技
---
## 1. 终端压缩

1. 第一种压缩方式

   * **tar - 归档命令** 

     多文件归档：    tar  [参数]  打包文件名  文件1 文件2

     目录归档：      tar  [参数]  打包文件名  目录

     -c	生成档案文件，创建打包文件

     -v	列出归档解档的详细过程，显示进度

     -f	指定档案文件名称，f后面一定是.tar文件，**所以必须放选项最后**

     -t	列出档案中包含的文件

     -x	解开档案文件
<!-- more -->
     ```
     tar -cvf test.tar * # 将当前目录下的所有文件打包归档
     
     tar -xvf test.tar # 将tar文件解开
     ```

   * **gzip - 文件压缩解压**

     tar和gzip结合实现文件打包、压缩。扩展名一般为XXX.tar.gz

     ```
     gzip  [选项]  被压缩文件
     
     gzip xx.tar        压缩
     
     gzip -r xx.tar xx.tar.gz  压缩这个文件的所有子目录，不包括这个文件
     
     gzip -d xx.tar.gz  解压
     ```

   * **tar -z**

     ```
     tar zcvf 压缩包包名 文件1 文件2 ...
     
     -z ：指定压缩包的格式为：file.tar.gz
     
     tar -zcvf test.tar.gz * 将当前路径下所有的文件以及文件夹打包并压缩到test.tar.gz中。
     
     tar -zxvf test.tar.gz解压到当前路径下
     
     tar -zxvf test.tar.gz -C xx 解压到指定路径下。
     ```
2. 第二种压缩方式
    * **bzip2**
    
        压缩: 
    
        ```
        bzip2 filename ---> 删除filename文件，生成 filename.bz2
        ```

        解压缩：
    
        ```
        bzip2 -d filename.bz2 ---> 删除filename.bz2 ，生成 filename文件
        ```
    
    * **tar + bzip2**（tar -jcvf）
    
        扩展名：XXX.tar.gz2
    
        压缩：
    
        ```
        tar -jcvf 压缩包包名 文件...(tar jcvf bk.tar.bz2 *)
        ```
    
        解压缩：
    
        ```
        tar -jxvf 压缩包包名 (tar jxvf bk.tar.bz2)
        ```
    
        *注意：上述方式压缩后保留源文件，解压后保留压缩文件*

3. 第三种压缩方式

   * **zip**

     压缩：

     ```
     zip [-r] 目标文件(可以没有扩展名) 源文件
     
     zip myzip *
     ```

     解压缩：

     ```
     unzip -d 解压后目录文件 压缩文件
     
     unzip -d ./xx myzip.zip
     ```

     *注意：不需要指定扩展名。默认zip*

4. 三种比较

   gzip压缩最小，bzip居中，zip最大

5. 解压 x

## 2. 文章权限

1. 权限表示

![文章权限](https://img.cetacis.dev/uploads/2020/02/05/Screen-Shot-2020-02-05-at-3.01.40-PM.png)

r（可读）、w（可写）、x（可执行）

2. 修改权限**chmod**

   * 字母修改

     ```
     chmod u=rwx,g=rx,o=r filename
     ```

   * 数字修改

     ```
     chmod 751 filename
     ```

3. **-R**递归为目录下所有文件加权限

   ```
   chmod 777 test/ -R 
   ```

## 3. 流

1. Linux有三种流

   * 标准输出流：正常信息的输出，默认输出到屏幕上。

     标准错误输出流：错误的信息的输出，默认输出到屏幕上。

     标准输入流：向系统中输入数据，默认就是键盘输入的数据。

   * 我们可以通过重定向的技术，把输出、输入的信息重定向到其它的地方去。比如，我们可以把系统中的错误信息输出到一个文件中去。

   * 如：ls > test.txt ( test.txt 如果不存在，则创建，存在则覆盖其内容 )

     *注意:>是覆盖原来的内容，>>是添加内容。（这是重定向）*

2. 管道

   左边是写入信息，右边是读取左边的结果作为输入。

## 4. 链接文件 ln

1. 硬链接

   文件有一个或者多个文件名。

   ```
   ln 源文件 链接文件
   ```

2. 软链接

   软链接不占用磁盘空间，源文件删除则软连接就会失效。相当于重命名。

   ```
   ln -s 源文件 链接文件
   ```

3. 关系

   * 软链接和硬链接都可以修改源文件内容，删除源文件后，硬链接仍然可以访问，软连接不可以，删除软连接就相当于删除了快捷方式，对源文件没有影响。
   * 软链接可以跨文件系统，硬链接不可以;
   * 软链接可以对一个不存在的文件名(filename)进行链接(当然此时如果你vi这个软链接文件，linux会自动新建一个文件名为filename的文件),硬链接不可以(其文件必须存在，inode必须存在);
   * 软链接可以对目录进行连接，硬链接不可以

## 5. 文件内容搜索 grep

1. 一般格式

   ```
   grep [-选项] ‘搜索内容串’ 文件名（是对文件内容的搜索）
   ```

2. 选项

   -V 显示不包含文本的所有行 -n 显示匹配行以及行号 -i 忽略大小写进行搜索

3. 正则表达式

   ^a 搜寻以a开头的行。

    ke$搜索以Ke结束的行。

   [Ss]nal[Ll]匹配[]中的任意一个。

   "."匹配一个非换行符的字符。

## 6. 特定文件搜索 find

搜索符合条件的文件，搜索特定用户属主的文件。

![find](https://img.cetacis.dev/uploads/2020/02/05/find.png)

## 7. 特定命令搜索 which is

```
which is gcc
```

## 8. 用户管理

1. 切换到管理员账号 sudo -s $显示为普通用户 #显示为管理员用户

2. 设置用户密码：passwd  修改密码 sudo passwd 账户名

3. 退出登录账户:exit 
4.  查看登录用户。

## 9. 关机重启

* 关机重启：reboot、shutdown、init

  reboot	重新启动操作系统

  shutdown –r now	重新启动操作系统，shutdown会给别的用户提示

  shutdown -h now	立刻关机，其中now相当于时间为0的状态

  shutdown -h 20:25	系统在今天的20:25 会关机

  shutdown -h +10	系统再过十分钟后自动关机

## 10. 二分法

```
int l=1,r=ll;// 1 是答案的最小值，ll是答案的最大值
    while(l<=r)
    {
        int mid=(l+r)>>1,q=check(mid);//“>>1”相当于“/2”
        if(q>m)r=mid-1;
        else l=mid+1;
    }
```
check()函数根据不同的题不一样，其他都是一样的

* 二分查找

```javascript
let a = [1, 2, 3, 4, 5, 20,38,44];
check = 3
let l = 0,r = a.length-1;
while(l <= r){
    let mid = (l + r) >> 1;
    if(check < a[mid])
        r = mid - 1;
    else
        l = mid +1;
}

console.log(r);
```

* 题目描述

伐木工人米尔科需要砍倒M米长的木材。这是一个对米尔科来说很容易的工作，因为他有一个漂亮的新伐木机，可以像野火一样砍倒森林。不过，米尔科只被允许砍倒单行树木。

米尔科的伐木机工作过程如下：米尔科设置一个高度参数H（米），伐木机升起一个巨大的锯片到高度H，并锯掉所有的树比H高的部分（当然，树木不高于H米的部分保持不变）。米尔科就行到树木被锯下的部分。

例如，如果一行树的高度分别为20，15，10和17，米尔科把锯片升到15米的高度，切割后树木剩下的高度将是15，15，10和15，而米尔科将从第1棵树得到5米，从第4棵树得到2米，共得到7米木材。

米尔科非常关注生态保护，所以他不会砍掉过多的木材。这正是他为什么尽可能高地设定伐木机锯片的原因。帮助米尔科找到伐木机锯片的最大的整数高度H，使得他能得到木材至少为M米。换句话说，如果再升高1米，则他将得不到M米木材。

输入输出格式

输入格式： 
第1行：2个整数N和M，N表示树木的数量（1<=N<=1000000）,M表示需要的木材总长度（1<=M<=2000000000）

第2行：N个整数表示每棵树的高度，值均不超过1000000000。所有木材长度之和大于M，因此必有解。

输出格式： 
第1行：1个整数，表示砍树的最高高度。

输入输出样例

输入样例#1： 
5 20 
4 42 40 26 46 
输出样例#1： 
36

这个题的答案有明显的单调性，砍树的高度越低，得到的木材就越多，所以用二分在答案区间里找答案就行了。

```c++
#include<iostream>
#include<cstdio>
long long m,n,a[1000005],temp;//因为我菜，所以就全设成long long；
using namespace std;
long long check(long long x)//这个check函数是二分的最重要的一环
{
    long long ans=0;
    for(int i=1;i<=n;i++)
    {
        if(a[i]>x)
        ans=ans-x+a[i];//ans用来记录能够得到的木材长度
     } 
     return ans;
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
        temp=max(temp,a[i]);//temp用来记录最高的树的高度
    }
    long long l=1,r=temp;//把右边界设成最高的树的高度
    while(l<=r)//二分操作
    {
        long long mid=(l+r)>>1,q=check(mid);
        if(q<m)r=mid-1;
        else l=mid+1;
    }
    printf("%d",r);
    return 0;
}

```

## 11. 终端替换某文本

```
sed -i "" 's/http:\/\/47.101.139.155:23333\/images/https:\/\/img.cetacis.dev\/uploads/g' `grep "http:\/\/47.101.139.155:23333\/images" -rl .` 
```

## 12. 对集合的二进制表示

[引用网站](https://www.cnblogs.com/astonc/p/10859115.html)

## 13. ping

**1）**假设有两个主机，主机A（192.168.0.1）和主机B（192.168.0.2），现在我们要监测主机A和主机B之间网络是否可达，那么我们在主机A上输入命令：ping 192.168.0.2；

**2）**此时，ping命令会在主机A上构建一个 ICMP的请求数据包（数据包里的内容后面再详述），然后 ICMP协议会将这个数据包以及目标IP（192.168.0.2）等信息一同交给IP层协议；

**3）**IP层协议得到这些信息后，将源地址（即本机IP）、目标地址（即目标IP：192.168.0.2）、再加上一些其它的控制信息，构建成一个IP数据包；

**4）**IP数据包构建完成后，还不够，还需要加上MAC地址，因此，还需要通过ARP映射表找出目标IP所对应的MAC地址。当拿到了目标主机的MAC地址和本机MAC后，一并交给数据链路层，组装成一个数据帧，依据以太网的介质访问规则，将它们传送出出去；

**5）**当主机B收到这个数据帧之后，会首先检查它的C目标MAC地址是不是本机，如果是就接收下来处理，接收之后会检查这个数据帧，将数据帧中的IP数据包取出来，交给本机的IP层协议，然后IP层协议检查完之后，再将ICMP数据包取出来交给ICMP协议处理，当这一步也处理完成之后，就会构建一个ICMP应答数据包，回发给主机A；

**6）**在一定的时间内，如果主机A收到了应答包，则说明它与主机B之间网络可达，如果没有收到，则说明网络不可达。除了监测是否可达以外，还可以利用应答时间和发起时间之间的差值，计算出数据包的延迟耗时。

## 14. 域名解析

MX 邮箱服务  txt spf mx

NS指定域名解析服务器

cname  证明域名拥有权

TXT 验证记录

*A ipv4

AAAA ipv6sp

anti-spam：防止垃圾邮件

* [阿里云文档：添加解析记录](https://help.aliyun.com/knowledge_detail/29725.html)

* [CloudFlare API：批量添加域名并添加解析记录](https://blog.51cto.com/xsboke/2115548)

* **dns系统**

  Internet 上的所有计算机，从您的智能手机或笔记本电脑到可提供大量零售网站内容的服务器，均通过使用编号寻找另一方并相互通信。这些编号称为 **IP 地址**。当您打开 Web 浏览器并前往一个网站时，您不必记住和输入长编号。而是输入**域名** (入 example.com)，然后在正确的位置结束。

  Amazon Route 53 等 DNS 服务是一种全球分布式服务，它将人类可读的名称 (如 www.example.com) 转换为数字 IP 地址 (如 192.0.2.1)，供计算机用于相互连接。Internet 的 DNS 系统的工作原理和电话簿相似，都是管理名称和数字之间的映射关系。DNS 服务器可以将名称请求转换为 IP 地址，从而控制最终用户在 Web 浏览器中输入域名时所访问的服务器。这些请求称为**查询**。

  ![dns将流量路由到我的web程序](https://img.cetacis.dev/uploads/big/f443431781d872c8d466bc245975729d.png)

1. 用户打开 Web 浏览器，在地址栏中输入 www.example.com，然后按 Enter 键。
2. www.example.com 的请求被路由到 DNS 解析程序，这一般由用户的 Internet 服务提供商 (ISP) 进行管理，例如有线 Internet 服务提供商、DSL 宽带提供商或公司网络。
3. ISP 的 DNS 解析程序将 www.example.com 的请求转发到 DNS 根名称服务器。
4. ISP 的 DNS 解析程序再次转发 www.example.com 的请求，这次转发到 .com 域的一个 TLD 名称服务器。.com 域的名称服务器使用与 example.com 域相关的四个 Amazon Route 53 名称服务器的名称来响应该请求。
5. ISP 的 DNS 解析程序选择一个 Amazon Route 53 名称服务器，并将 www.example.com 的请求转发到该名称服务器。
6. Amazon Route 53 名称服务器在 example.com 托管区域中查找 www.example.com 记录，获得相关值，例如，Web 服务器的 IP 地址 (192.0.2.44)，并将 IP 地址返回至 DNS 解析程序。
7. ISP 的 DNS 解析程序最终获得用户需要的 IP 地址。解析程序将此值返回至 Web 浏览器。DNS 解析程序还会将 example.com 的 IP 地址缓存 (存储) 您指定的时长，以便它能够在下次有人浏览 example.com 时更快地作出响应。有关更多信息，请参阅存活期 (TTL)。
8. Web 浏览器将 www.example.com 的请求发送到从 DNS 解析程序中获得的 IP 地址。这是您的内容所处位置，例如，在 Amazon EC2 实例中或配置为网站终端节点的 Amazon S3 存储桶中运行的 Web 服务器。
9. 192.0.2.44 上的 Web 服务器或其他资源将 www.example.com 的 Web 页面返回到 Web 浏览器，且 Web 浏览器会显示该页面。

* **json**

  一种轻量级数据交换结构

  ```javascript
  var json = '{"a": "Hello", "b": "World"}';
  ```

  作用：

  简单地说，JSON 可以将 JavaScript 对象中表示的一组数据转换为字符串，然后就可以在网络或者程序之间轻松地传递这个字符串，并在需要的时候将它还原为各编程语言所支持的数据格式，例如在 PHP 中，可以将 JSON 还原为数组或者一个基本对象。在用到AJAX时，如果需要用到数组传值，这时就需要用JSON将数组转化为字符串。

  * 表示对象

  对象是一个无序的“‘名称/值’对”集合。一个对象以{左括号开始，}右括号结束。每个“名称”后跟一个:冒号；“‘名称/值’ 对”之间使用,逗号分隔。

  ```javascript
  `{``"firstName"``: ``"Brett"``, ``"lastName"``: ``"McLaughlin"``}                                        `
  ```

  * 表示数组

  和普通的 JS 数组一样，JSON 表示数组的方式也是使用方括号 []。

  ```javascript
  `{ ``"people":[ ``{``"firstName": "Brett",            ``"lastName":"McLaughlin"        ``},      ``{        ``"firstName":"Jason",``"lastName":"Hunter"``}``]``}`
  ```

  这不难理解。在这个示例中，只有一个名为 people的变量，值是包含两个条目的数组，每个条目是一个人的记录，其中包含名和姓。上面的示例演示如何用括号将记录组合成一个值。当然，可以使用相同的语法表示更过多的值（每个值包含多个记录）。

  * 要实现从JSON字符串转换为JS对象，使用 JSON.parse() 方法：

    ```javascript
    `var` `obj = JSON.parse(``'{"a": "Hello", "b": "World"}'``); ``//结果是 {a: 'Hello', b: 'World'}`
    ```

    要实现从JS对象转换为JSON字符串，使用 JSON.stringify() 方法：

    ```javascript
    `var` `json = JSON.stringify({a: ``'Hello'``, b: ``'World'``}); ``//结果是 '{"a": "Hello", "b": "World"}'`
    ```

## 15. telegram bot nginx

鉴权 ->链接cf ->看cf 的 api

*  https://api.cloudflare.com ：cloudflare 's api ：看网站

  目标：增加A记录（API token）

* bot api 

  git源码 https://github.com/yagop/node-telegram-bot-api

  参考blog  [建立 telegram bot and nginx](https://segmentfault.com/a/1190000018716076)    

## 16. 正则表达式

正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。

* 非打印字符

| \cx  | 匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。 |
| ---- | ------------------------------------------------------------ |
| \f   | 匹配一个换页符。等价于 \x0c 和 \cL。                         |
| \n   | 匹配一个换行符。等价于 \x0a 和 \cJ。                         |
| \r   | 匹配一个回车符。等价于 \x0d 和 \cM。                         |
| \s   | 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符。 |
| \S   | 匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。                  |
| \t   | 匹配一个制表符。等价于 \x09 和 \cI。                         |
| \v   | 匹配一个垂直制表符。等价于 \x0b 和 \cK。                     |

* 特殊字符

| $    | 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 '\n' 或 '\r'。要匹配 $ 字符本身，请使用  \\$。 |
| ---- | ------------------------------------------------------------ |
| ( )  | 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 \\( 和\ \)。 |
| *    | 匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 \\*。    |
| +    | 匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 \\+。    |
| .    | 匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 \\. 。   |
| [    | 标记一个中括号表达式的开始。要匹配 [，请使用 \\[。           |
| ?    | 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \?。 |
| \    | 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， 'n' 匹配字符 'n'。'\n' 匹配换行符。序列 '\\\\' 匹配 "\\"，而 '\\(' 则匹配 "("。 |
| ^    | 匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 \^。 |
| {    | 标记限定符表达式的开始。要匹配 {，请使用 \\{。               |
| \|   | 指明两项之间的一个选择。要匹配 \|，请使用 \\|。              |

* 限定符

| *     | 匹配前面的子表达式零次或多次。例如，zo* 能匹配 "z" 以及 "zoo"。* 等价于{0,}。 |
| ----- | ------------------------------------------------------------ |
| +     | 匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,}。 |
| ?     | 匹配前面的子表达式零次或一次。例如，"do(es)?" 可以匹配 "do" 、 "does" 中的 "does" 、 "doxy" 中的 "do" 。? 等价于 {0,1}。 |
| {n}   | n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个 o。 |
| {n,}  | n 是一个非负整数。至少匹配n 次。例如，'o{2,}' 不能匹配 "Bob" 中的 'o'，但能匹配 "foooood" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。 |
| {n,m} | m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。例如，"o{1,3}" 将匹配 "fooooood" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。``` |

```
/[0-9]{1,2}/    # 至少一位至多两位的数字，设置0-99 缺点在于
```

```
[1-9]?[0-9]   ￥ 
```

* 贪婪非贪婪：

  \* 是贪婪的，他会尽可能多的匹配字符。比如

  ```
  <h1>123</h1>
  ```

  如果用<.*>匹配，他会把<h1>123</h1>全匹配上（贪婪）

  如果同<.*?>匹配，只会匹配<h1>（非贪婪：最小匹配）

* 定位符

定位符用来描述字符串或单词的边界，**^** 和 **$** 分别指字符串的开始与结束，**\b** 描述单词的前或后边界，**\B** 表示非单词边界。

| 字符 | 描述                                                         |
| :--- | :----------------------------------------------------------- |
| ^    | 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。 |
| $    | 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。 |
| \b   | 匹配一个单词边界，即字与空格间的位置。                       |
| \B   | 非单词边界匹配。                                             |

若要在搜索章节标题时使用定位点，下面的正则表达式匹配一个章节标题，该标题只包含两个尾随数字，并且出现在行首：

```
/^Chapter [1-9][0-9]{0,1}/
```

真正的章节标题不仅出现行的开始处，而且它还是该行中仅有的文本。它即出现在行首又出现在同一行的结尾。下面的表达式能确保指定的匹配只匹配章节而不匹配交叉引用。通过创建只匹配一行文本的开始和结尾的正则表达式，就可做到这一点。

```
/^Chapter [1-9][0-9]{0,1}$/
```

匹配单词边界稍有不同，但向正则表达式添加了很重要的能力。单词边界是单词和空格之间的位置。非单词边界是任何其他位置。下面的表达式匹配单词 Chapter 的开头三个字符，因为这三个字符出现在单词边界后面：

```
/\bCha/
```

**\b** 字符的位置是非常重要的。如果它位于要匹配的字符串的开始，它在单词的开始处查找匹配项。如果它位于字符串的结尾，它在单词的结尾处查找匹配项。例如，下面的表达式匹配单词 Chapter 中的字符串 ter，因为它出现在单词边界的前面：

```
/ter\b/
```

下面的表达式匹配 Chapter 中的字符串 apt，但不匹配 aptitude 中的字符串 apt：

```
/\Bapt/
```

字符串 apt 出现在单词 Chapter 中的非单词边界处，但出现在单词 aptitude 中的单词边界处。对于 **\B** 非单词边界运算符，位置并不重要，因为匹配不关心究竟是单词的开头还是结尾。

```javascript
var str = "http://www.runoob.com:80/html/html-tutorial.html";
var patt1 = /(\w+):\/\/([^/:]+)(:\d*)?([^# ]*)/;
arr = str.match(patt1);
for (var i = 0; i < arr.length ; i++) {
    document.write(arr[i]);
    document.write("<br>");
}
```

第三行代码 **str.match(patt1)** 返回一个数组，实例中的数组包含 5 个元素，索引 0 对应的是整个字符串，索引 1 对应第一个匹配符（括号内），以此类推。

第一个括号子表达式捕获 Web 地址的协议部分。该子表达式匹配在冒号和两个正斜杠前面的任何单词。

第二个括号子表达式捕获地址的域地址部分。子表达式匹配非 **:** 和 **/** 之后的一个或多个字符。

第三个括号子表达式捕获端口号（如果指定了的话）。该子表达式匹配冒号后面的零个或多个数字。只能重复一次该子表达式。

最后，第四个括号子表达式捕获 Web 地址指定的路径和 / 或页信息。该子表达式能匹配不包括 # 或空格字符的任何字符序列。

将正则表达式应用到上面的 URI，各子匹配项包含下面的内容：

- 第一个括号子表达式包含 **http**
- 第二个括号子表达式包含 **www.runoob.com**
- 第三个括号子表达式包含 **:80**
- 第四个括号子表达式包含 **/html/html-tutorial.html**

