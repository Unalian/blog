---
date: 2020/3/30
tags:
- 上课笔记
- 运输层
categories:
- 计算机网络
- 自顶向下的计算机网络
- 运输层
---



# 自顶向下的计算机网络3 运输层

# 第三章 运输层

目录：

**传输层服务**

**多路复用和多路分解**

**无连接传输UDP**

**可靠数据传输原理**

**面向连接传输**

**拥塞控制原理**   原因 后果 控制

**TCP** **拥塞控制** 
<!-- more -->

##  3.1 传输层服务

1. 传输层服务和协议

在两个不同的主机上运行的应用程序之间提供逻辑通信

传输层协议运行在**端系统**（核心的交换机部分，只存在下面三层）：

* 发送方: 将应用程序报文分成数据段传递给网络层
* 接受方: 将数据段重新组装成报文传递到应用层 

运输层协议：tcp udp

![逻辑端到端](https://img.cetacis.dev/uploads/big/3aabb85d17bcec6c61b085fc5637f141.png)

**可靠按序递交 (TCP) ：**  拥塞控制（拥塞时减缓发送方） 流量控制 （发送接收速度匹配） 连接建立 （握手）

**不可靠的无序传递（udp）: **  UDP “尽力传递” IP的直接扩展  不提供的服务 : 延迟保证 带宽保证 

tcp是可靠的，udp是不可靠的。网络层不可靠的

------

2. 运输层和网络层

从通信和信息处理的角度看，运输层向它上面的 应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。

类比：家庭类比:

12个孩子向12个孩子发信   • 主机 = 家庭  • 进程 = 孩子  • 应用报文= 信封中的信 

​                                               • 网络层协议= 邮政服务   • 运输协议 = Ann和Bill（家庭分发）

**网络层：**两个主机之间的逻辑通信

**传输层**：两个进程之间的逻辑通信  *可靠, 增强的网络层服务*

## 3.2 多路复用和多路分解

1. 总览

![](https://img.cetacis.dev/uploads/big/ef6baf7007621db3e46d865f2616248b.png)

**在发送主机多路复用:**

从多个套接字收集数据, 用首部 封装数据，然后将报文段传递到 网络层多路复用

**在接收主机多路分解:**

将接收到的数据段传递到正确的套接字(多路分解)

![](https://img.cetacis.dev/uploads/big/23ee20a92cd5b8b75415db0530a62cbf.png)

---

2. 多路分解如何工作

主机接收IP数据报

* 每个数据报承载1个运输层报文段

* 每个段具有源、目的端口号
  端口号代表不同的服务（进程）

 主机使用IP地址 &端口号将段定向到适当的套接字

![](https://img.cetacis.dev/uploads/big/e92bb4c5d174311573d73c7973ef121f.png)

端口扫描：通过端口知悉服务

---

3. Udp无连接多路分解（一对多，多对一，多对多）

* 套接字编程：

  生成具有端口号的套接字: 

```java
DatagramSocket mySocket1 = new DatagramSocket(9911); // mySocket1是一个套接字
```

```python
serverSocket = socket(AF_INET, SOCK_DGRAM)# 创造套接字
serverSocket.bind(('', serverPort))# 将端口号连接
```

* UDP套接字由二元组标识 : (目的ip地址，目的端口号)

* 当主机接收UDP报文段时:

  在报文段中检查目的地端口号

  将UDP段定向到具有该端口号的套接字

具有不同的源IP地址且/或源端口号，但 具有相同的目的IP地址和目的端口号的IP 报文段指向同样的套接字

 ![](https://img.cetacis.dev/uploads/big/6ae3c1f037ac20cb3f39433fedd97c09.png)

原端口号（A.sp)是自动生成的，他在整个过程中不具有定位功能，他只是c在回发时的dp，所以它并不用指定。它为请求报文段中提供返回地址(包括IP地址和端口号)

但是服务器的目的端口一定要指定

---

4. 面向连接的多路分解（TCP）

**TCP 套接字由4部分指定:**

源IP地址 源端口号 目的IP地址 目的端口号 

接收主机使用所有四个值将数据段定位到合适的套接字

**TCP服务器的套接字**

服务器主机支持很多同时的tcp套接字：每个套接字用四个部分来表示

tcp服务器有一个欢迎套接字，接受连接请求，tcp收到请求后会重开一个单独的连接套接字与客户机进行连接。

连接套接字都是80端口，用源ip地址进行区分。

![tcp服务器](https://img.cetacis.dev/uploads/big/a7bfeca2042c5f2cccd546dfe84ce1ed.png)

web：

![](https://img.cetacis.dev/uploads/big/83d9d0dba8a39d31b343997ad1309c02.png)

如图，b发出的两个tcp连接，通过源端口号区分

## 3.3 udp

1. udp：用户数据报协议（udp的报文段有时候叫数据报）

特点：

* 它是“基本要素”互联网传输协议

* 因为是“尽力而为”服务，可能丢包，对应用程序交付失序

* 无连接： 在udp发送方和接收方之间无握手；

  ​				每个udp段的处理独立于其他段（tcp面向流，可能同一个应用分在两个段中）

- UDP 只在 IP 的数据报服务之上增加了很少一点的功能，即端口的功能和 差错检测的功能。 

- 虽然 UDP 用户数据报只能提供不可靠的交付，但 UDP 在某些方面有其 特殊的优点。 

- UDP 是无连接的，即发送数据之前不需要建立连接。 

- UDP 使用尽最大努力交付，即不保证可靠交付，同时也不使用拥塞控制。 

- UDP 没有拥塞控制，很适合多媒体通信的要求。  

- UDP 支持一对一、一对多、多对一和多对多的交互通信。 

- UDP 的首部开销小，只有 8 个字节。 

- UDP 是面向报文的。发送方 UDP 对应用程序交下来的报文，在添加  首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并， 也不拆分，而是保留这些报文的边界。

  *tcp无报文边界* 

- 应用层交给 UDP 多长的报文，UDP 就照样发送，即一次发送一个报文。 

- 接收方 UDP 对 IP 层交上来的 UDP 用户数据报，在去除首部后就原 封不动地交付上层的应用进程，一次交付一个完整的报文。 

- 应用程序必须选择合适大小的报文。

----

2. 为什么用udp？

- 无连接创建（减少时延
- 简单：可并发更多
- 段首部小
- 无拥塞控制：udp能够尽可能快地传输

![面向报文的udp数据包](https://img.cetacis.dev/uploads/big/2dd4c563c7157a58d462f132de254834.png)

---

3. **udp的应用：**

常用于流式多媒体应用 ：丢包容忍、速率敏感

其他UDP应用： DNS（增加速率）、SNMP、RTP（路由选择协议 向其他路由器通报信息）

经UDP的可靠传输 : 在应用层增加可靠性，应用程序特定的差错恢复!

![](https://img.cetacis.dev/uploads/big/bfb81d85950595932dbf162253b0887d.png)

*检验和：检查数据报是否出错*

4. udp检验和与差错检测

* 差错检测

![差错检测](https://img.cetacis.dev/uploads/big/01028c74db7d536acdeb68fe37e9b401.png)

*检错可能出现漏掉的错误（很少；大的校验信息 域能提供更好 的检错能力*

* 检验和

目标：对传输的数据进行差错检测

发送方：将数据段看成16bit的整数序列

​				校验和:段内容进行带循环进位的加法，结果取反码

​				发送者将校验和值放入UDP的校验和域

接收方：计算接收到数据段的校验和 

​				检查 计算的校验和是否等于校验和域中的值:
​				• NO – 检测到错误
​				• YES – 没有检测到错误

​				还是有可能出错

![](https://img.cetacis.dev/uploads/big/559a0e644e35a34f5ae4ee80aa39a8e9.png)

![注意循环进位](https://img.cetacis.dev/uploads/big/31cb0a6d0772550ca5bf8be2393c5055.png)

**记得循环进位**

## 3.4 可靠数据传输原理

运输层需要提供可靠传输，但是网络层没有可靠，所以就需要接口。

![可靠数据传输：基本概念](https://img.cetacis.dev/uploads/big/7a39d15318100c8d1431b69927c59bab.png)

四个函数可以看做动作/事件

逐步开发发送方和接收方的可靠数据传输协议 (rdt)：

* 仅考虑单向数据传输
* 控制信息将在两个方向流动

有限状态机 (FSM)来定义发送方和接收方

![有限状态机<数字逻辑>](https://img.cetacis.dev/uploads/big/72bf5f176f835798782c1dac3f21ad16.png)

1. rdt的发展

**Rdt1.0:** **完全可靠信道上的可靠数据传输**

在完美可靠的信道上
	• 没有bit错误

​	• 没有分组丢失 

发送方，接收方单独的 FSMs : 

​	• 发送方发送数据到下层信道 

​	• 接收方从下层信道接收数据 

![rdt1.0](https://img.cetacis.dev/uploads/big/cffcc44f90050d8d2170c4fe8fbf126f.png)

**Rdt2.0:** **具有bit错误的信道**

下层信道可能让传输分组中的bit受损 

* 校验和将检测到bit错误

问题: 如何从错误中恢复

* 确认(ACKs): 接收方明确告诉发送方 分组接收正确
* 否认 (NAKs):接收方明确告诉发送方 分组接收出错 
* 发送方收到NAK后重发这个分组

在 rdt2.0的新机制 (在 rdt1.0中没有的): 

* 差错检测

* 接收方反馈: 控制信息 (ACK,NAK)
* 重传

![rdt2.0](https://img.cetacis.dev/uploads/big/2998071b3d7db73519ca8bcd2d69b288.png)

rdt2.0是一个停-等协议（字面意思

Rdt2.0的缺陷：如果ACK/NAK受损，将会出现 发送方不知道在接收方会发生 什么情况。

​						  重传可能导致冗余

处理冗余:

• 发送方对每个分组增加序列号

• 如果ACK/NAK受损，发送方重传当前的分组

• 接收方丢弃(不再向上交付)冗 余分组

**rdt2.1**

发送方：

两个序号0/1 够用，为什么？  -因为停等协议

检查是否收到的ACK/NAK 受损

状态增加一倍 状态必须“记住”是否“当前的”分组具有0或1序号

接收方：

检查是否接收到分组时候冗余  状态指示是否0/1是否是起飞的分组序号

注意：接收方不知道它的ack/nal时候被正确接收

发送方

![](https://img.cetacis.dev/uploads/big/b36b7d0725db5c2df42f09cd2668e081.png)





接收方：

![接收方处理受损的ack/nak](https://img.cetacis.dev/uploads/big/d26e255338267a9c4a5750b63487e51a.png)

正确报文序号正确：拆包，上传给上方->等待来自下面的调用1

正确报文序号错误1 ：回发ack（因为发出了1，所以可能是因为上次接收方回发的ack1受损了，所以此时应该回发ack1使发送方发送下一个序号的数据报）->等待来自下面的调用0

错误报文：回发NAK->等待来自下面的调用0

**rdt2.2 : 不要nak的协议 **

同 rdt2.1一样的功能, 只用 ACKs
不用 NAK, 如果上个报文接收正确接收方发送 ACK

* 接收方必须明确包含被确认的报文的序号 

发送方收到重复 ACK 将导致和 NAK一样的 处理: 重发当前报文 

发送方发送0包，但是收到的是ack1，则等于获得了nak.

![](https://img.cetacis.dev/uploads/big/cea7c4f6f57bef7bd7fefab902433f52.png)**rdt3.0**

当下面的信道也能丢失分组：怎么检测丢包？丢包该怎么办？

方法: 

发送方等待ACK一段“合理的”时间 

• 如在这段时间没有收到ACK则重传

• 可能出现问题  如果分组(或ACK)只是延迟(没有丢失):

重传将是冗余的，但序号的使用已经处理了该情况；接收方必须定义被确认的分组序号

 • 需要倒计时定时器

*发送方数据重发只发生在timeout时，收到错误序号包是不会重发的。*

*接收方会回应所有数据发送请求*

![](https://img.cetacis.dev/uploads/big/210ecfd4eb2f6cf1efa886d3229c903d.png)



![](https://img.cetacis.dev/uploads/big/dd47a9b82f26c69d6bea0a5be1ef1dc4.png)

![](https://img.cetacis.dev/uploads/big/7046a71ca26f5ffcaaea651abeb8516d.png)

**rdt3.0的性能**

性能落后：停等协议

![](https://img.cetacis.dev/uploads/big/9a89b4a3aa15d4d84cffb9d09808b36d.png)

**利用率**：发送方实际用于将发送bit送进信道的时间与发送时间的比率

这个例子利用率只有0.027%，网路协议限制了物理资源的使用

2. 流水线技术

序号要多；缓冲区要扩展（放置未收到相应的发送包

![](https://img.cetacis.dev/uploads/big/b372cbc539f2f1ddb75a3d93b3221314.png)

Go-Back-N（滑动窗口协议）GBN

限制已发送未应答的分组数量

分组序号空间使用摸2^k

ACK(n)：累计ACK；只对第一个发送未被确认的报文定时，timeout要重传全部的分组

接收方无缓存

![S](https://img.cetacis.dev/uploads/big/a75be72a5039ecd408dfc96e8108f83b.png)

选择性重传 Selective repeat （SR）

发送方接收方都有缓存；每一个分组都有自己的定时器

![](https://img.cetacis.dev/uploads/big/5e33f383e9633f0682fda94bbd78e4a6.png)



分组n在[rcvbase-N,rcvbase-1]内的原因：之前的N个ack丢失

窗口小于或等于序号空间大小的一半 使不会重复

否则：

![](https://img.cetacis.dev/uploads/big/d08a22b7e97539a46fe1b1a174fbf9e0.png)

## 3.5 面向连接传输 TCP

![](https://img.cetacis.dev/uploads/big/53971cfe3e91069e16ccfd3fe9e3c055.png)

图中上层：**发送和接受缓冲区**

MSS：最大报文段长度。一次从换从中读取的信息长度。

MTU：最大传输单元，一般由与本机相连链路决定。在网络上可能不同。



### 3.5.1 tcp面向流

* 流水线 

  tcp拥塞和流量控制设置滑动窗口协议

* 流量控制

  发送方不能淹没接收方

* 拥塞控制

  防止过度占用网络资源

* 面向连接

  在数据交换前握手(交换控制信息) 初始化发 送方和接收方的状态

* 全双工数据

  同一个连接上的双向数据流

  ![面向流](https://img.cetacis.dev/uploads/big/280aab142b63d9a01cb369c1f2c0383f.png)

  没有吧报文边界，但是最大为MSS

### 3.5.2 报文段结构

#### 1. 首部结构概述

![](https://img.cetacis.dev/uploads/big/c419e17b244a1258d8e17b77a134301b.png)

**序号**：占4字节 确定是否按序收到分组，是否冗余，或者是否丢包。TCP连接中序号是报文段所发送的数据的第一字节的序号。（不是顺序

**确认号字段**：4字节 期望收到对方的下一个报文段的数据的第一字节的序号。告诉发送方，之前的序号已经收到。

**首部长度（数据偏移）**：4位 指出报文段数据距离tcp报文段的起始处有多远。数据偏移的单位是32字。

**保留字段**：6位 拥塞控制可用

**紧急URG**：当URG=1，告诉系统次报文段有紧急数据，优先传送。

**紧急指针：**说明到哪里是紧急数据。当URG=1时，此指针有用

**ACK：**确认号 ACK=1 确认号字段有效

**PSH：**PSH=1的报文段，应尽快交付至上层，而不是等整个缓存填充满了以后再向上交付。

**RST：** =1，表明TCP链接出现差错，必须释放链接，然后再重新建立链接。（端口不存在或者主机崩溃）

**SYN：**=1，表明这是一个连接请求或者链接接受报文。用于建立握手。

**FIN：**=1，请求释放连接，表明数据传送完成

**窗口：**2字节 单位为字节，设置让对方设置发送窗口的依据，用于流量控制。表明接收方愿意接受的长度。

**检验和：**2字节，包括首部和数据两部分。计算校验和要在TCP报文段的前面加上12字节伪首部

**选项字段：**TCP最初只有一种选项，即最大报文段长度MSS。MSS告诉对方TCP：“我缓存能接受的报文段的数据字段的最大长度是MSS字节”。现在还可作为：窗口确定选项；时间戳选项（对ack的确认计算时间）；

**填充**

#### 2. TCP序号和确认

**序号：**

报文段中第一个数据在字节流中的位置编号

*例子 5M的数据 MSS 1000*

*分组一 序号 0 分组二 序号 1000 分组三 序号 2000*

**确认号：**

期望从对方收到的下一个字节的序号

累计确认

*例子： 已发送 0-535 ，接收方会发536的确认号*

*例子二：已发送 0-535 536-899 900-1000，某种原因，536-899丢失。接收方会发536的确认号。*

接收方如何处理失序报文段：TCP无规定，由实现者选择：抛弃/缓存。

![](https://img.cetacis.dev/uploads/big/a43d34595f97615d29fcdd187b6772c2.png)

#### 3. TCP往返时延的估计和超时

### 3.5.3 可靠数据传输

* TCP在IP不可靠服务的基础上

创建可靠数据传输服务：肯定确认和定时器；序号、重传

* 流水线发送报文段

* 累计确认 收到一个确认，则意味着收到之前所有的
* TCP使用单个重传定时器 （定时器管理消耗大。

* 重传被下列事件触发：超时；重复ack

#### 1. tcp发送方事件

1. 从应用程序接收数据:

 用序号创造一个数据段

序号是数据段中第一个数据字节在字节流中的位置编号

如果没有启动定时器，则启动定时器

* 定时器是最早没有被确认的数据 段发送时启动的

* 设置超时间隔: TimeOutInterval

2. 超时：

   重发导致超时的报文段

   重新开始定时器

3. 收到确认：

   如果确认了还没有确认的数据段：

   更新还没有确认的状态；

   还有未完成的数据段，重新开始定时器

   

![](https://img.cetacis.dev/uploads/big/6c57e6c1f8351ddd9a438f88bd29d821.png)

sendbase （sendbase之前都已经被确认

![](https://img.cetacis.dev/uploads/big/1312199c28b46fc684802f2926ba46da.png)



**超时间隔加倍**

tcp每次重传 会把下一次的超时间间隔设置为先前的两倍

当**收到上层应用的数据**或者**收到ack**两个事件中的任意个时，定时器恢复。

这种修改提供了一种形式受限的拥塞控制。

**快速重传**

超时触发重传会导致超时周期长

* 发送方常常一个接一个地发送很多报文段，如果报文段丢失,则发送方将可能接收到很多重复的 ACKs

* 如果发送方收到3个对同样报文段的确认，则发送方认为该报文段之后的数据已经丢失。
*  启动快速重传: 在定时器超时之前重发丢失的报文段 

#### 2. 接收方行为

![](https://img.cetacis.dev/uploads/big/6db99dd0e5267aaa84f5f5f6607db26c.png)

如图3是快速重传的原理

![快速重传](https://img.cetacis.dev/uploads/big/ef4d1bdcb260136ae9feb9b4dcc853d7.png)

![](https://img.cetacis.dev/uploads/big/f800231b2377036999ece5a3bdd56af2.png)

![快速重传&缓存](https://img.cetacis.dev/uploads/big/1f6a31ebf20801f39e32a777e13e679e.png)

### 3.5.4 tcp流控

TCP链接的接收方有一个缓冲区 

速度匹配服务：发送速率和接收应用程序的提取速率匹配

流量控制：发送方不能发送太多太快，让接受缓冲区溢出

tcp报文中窗口字段会告知缓冲区剩余空间 

发送方要限制未确认的数据不超过RcvWindow

当RcWindow已满，会发送试探报文

### 3.5.5 TCP 连接管理

#### 1. 三次握手



建立连接：

步骤一  客户机向服务器发送 TCP SYN报文段（SYN = 1, SEQ = x）

* 指定初试序号
* 没有数据

步骤二 服务器收到SYN报文段, 用SYNACK报文段回复(SYN = 1, ACK = 1, SEQ = y, ack = x+1)(y在于确定客户机的身份)

* 服务器为该连接分配缓冲区和变量

* 指定服务器初始序号

步骤 3: 客户机接收到 SYNACK, 分配缓冲，用ACK报文段回复,可能包含数据 

![](https://img.cetacis.dev/uploads/big/197aa58d6e85a0b8b1f1a90847d59e7a.png)

#### 2. 两次握手错误



![](https://img.cetacis.dev/uploads/big/0a7c53bb51d10be438e91b4a28ebb590.png)

* 服务器请求超时，客户重新发送，服务器多次得到请求，导致“半链接”，分配缓冲区，长时间占用缓冲区。当三次时，半链接会短

![](https://img.cetacis.dev/uploads/big/b5b7c3b19144d506115331453541e7f7.png)

* 碰巧出现客户机不知的链接

#### 3. 关闭连接

关闭链接的一方为客户端

**客户关闭套接字: clientSocket.close** 

Step 1 : 客户发送 TCP FIN 控制报文段到服务器

Step 2 : 服务器接收 FIN, 回复 ACK. 半关闭连接, 并发送FIN到客户 

Step 3: 客户接收 FIN, 回复 ACK.

进入 “timed wait”状态

 等待结束时释放连接资源

Step 4: 服务器接收 ACK. 连接关闭. 

![](https://img.cetacis.dev/uploads/big/db92bfb62bbbb56275bce3431d323dfd.png)

Timed wait for 2 * max segment ligetime （timeout意义）: 客户端结束后，套接字被重用，如果之前的连接中有游荡的报文，可能就会被新的链接接收

![](https://img.cetacis.dev/uploads/big/fb30b019f55978ab648fbe516e5b4d56.png)

![](https://img.cetacis.dev/uploads/big/fb30b019f55978ab648fbe516e5b4d56.png)

## 3.6 拥塞控制

拥塞：从信息角度看: “太多源主机发送太多的数据，速度太快以至于网络来不及处理”

不同于流量控制

表现：丢失分组 (路由器的缓冲区溢出)  长延迟（在路由器的缓冲区排队）

#### 1. **拥塞的代价**

发送方必须执行重传以补偿因缓存溢出而 丢弃的分组。

不必要的重发**:**链路 需要运输多个分组的拷贝

当分组丢失后， 任何上游路由器的发送能力都浪费了!

#### 2. 拥塞控制的方法

端到端的拥塞控制:

- 网路层没有为运算层提 供显示的支持。
- 从端系统根据观察到的 时延和丢失现象推断出 拥塞
- 这是TCP所采用的方法

网络辅助的拥塞控制:

* 一个bit指示一条链路出现拥塞(SNA,DECnet)

* 指示发送方按照一定速率 发送(ATM)

* 两种形式 ：1. 直接告诉发送方 2. 先给接收方，再由接收方发会发送方

## 3.7 TCP拥塞控制

采用端到端控制

### 3.7.1 三个问题：

 一个TCP发送方如何限制它向其连接发送速率的?
 一个TCP发送方如何感知从它到目的地之间的路径上存在拥塞的?
 当发送方感知到端到端的拥塞时，采用何种算法来改变其发送速率?

#### 1. 发送方如何限制发送速率

发送方通过CongWin限制传输: LastByteSent-LastByteAcked <=min{ CongWin，RecWin}

最大平均速率：CongWin/RTT Bytes/s  (忽略传输时间，忽略封装时间，忽略窗口大小影响)

拥塞窗口是动态的, 通过调节 CongWin的值，发送方因此能调整 它向连接发送数据的速率。

#### 2. 发送方如何感知网络拥塞

丢失事件 = 超时或者 3个重复ACK

发生丢失时间，tcp发送降低速率（拥塞窗口）

正常增加发送速率：自计时

#### 3. TCP发送方怎样确定它应当发送的速率呢? 

好的发送策略：既使得网络不会拥塞，与此同时又能充分利用所有可用的带宽。

**TCP策略原则：**

* 一个丢失的报文段意味着拥塞，应当降低TCP发送速率。（超时或者 3个重复ACK）

* 当收到未确认报文段的确认到达时，能够增加发送方的速率。（顺利的指示）

* 带宽探测：*每个TCP发送方根据异步于其他发送的本地信息而行动。*

  （第三点理解：执行拥塞控制的时候，不和其他tcp进行协调，只根据本地信息进行控制）

### 3.7.2 TCP拥塞控制

####1. TCP拥塞控制算法详述

* 慢启动
* 拥塞避免
* 快速恢复

慢启动阶段

MSS ：最大报文段长度

链接开始：Congwin = 1MSS 

​     MSS  = 500 bytes & RTT = 200 sec

​    speed = 20 kbps

**实现：**

1. 当连接开始的时候以指数方式增加速率，直到出现丢包：

* 当传输报文段首次被确认，拥塞窗口增加一个MSS。
* 每RTT倍增拥塞窗口值

2. 何时结束增长：

* 超时事件以后:

• CongWin值设置为1 MSS • Ssthresh= CongWin /2

窗口指数增长(慢启动状态)，到达一 个阈值 (ssthresh) 后，再线性增长(拥 塞避免状态)

* 收到3个冗余确认后:

• CongWin减半+3个MSS • 进入快速恢复阶段（tcp reno）

*不同的丢包事件*

3 个重复的 ACKs 表明网络具有传输一些数据段的能力

 在三个重复的确认之前超时是“更加严重的警告”

3. 拥塞发生后

一旦进入拥塞避免状态，CongWin的值大约是上次遇到拥塞时的一半。每个RTT只将CongWin的值增加一个MSS。

4.  何时结束拥塞避免的线性增长?

* 超时事件以后，

  迁移到慢启动状态:  

  CongWin值设置为1 MSS 

  Ssthresh= CongWin /2

* 收到3个冗余确认后:

  CongWin减半+3个MSS 

  进入快速恢复阶段

*快速恢复*

 对于引起TCP进入快速恢复状态的缺失报文段，每收到一个冗余的 ACK，CongWin的值增加一个MSS。

 最终，当对丢失的报文段的一个ACK到达时，TCP在降低 CongWin后进 入拥塞避免状态。

 如果出现超时事件，迁移到慢启动状态: CongWin值设置为1 MSS Ssthresh= CongWin /2

ssthresh ：阈值    crmd：最大窗口 

![](https://img.cetacis.dev/uploads/big/558c8514b15f21cc581efcbda9f0c647.png)

 ![](https://img.cetacis.dev/uploads/big/3f17b94d3ab78d0ef84d262f45323c8f.png)

reno：有快速恢复   tahoe：无快速恢复 如图

#### 2. 总结

当CongWin < ssthresh时，发送者处于慢启动阶段, CongWin指数增长

当CongWin > ssthresh时，发送者处于拥塞避免阶段, CongWin线性增长

当出现3个冗余确认时,发送者处于快速恢复阶段。阈值ssthresh设置为 CongWin/2，且CongWin设置为ssthresh+3*MSS

当超时发生时，阈值ssthresh设置为CongWin/2，并且CongWin设置为1 MSS.

TCP AIMD （加性增 乘性减）

![](https://img.cetacis.dev/uploads/big/ec1154af7b0e07c03914e08cb42a7e00.png)

#### tcp平均吞吐量

估算： 0.75w / rtt

#### 3. ECN 网络辅助拥塞控制

在网络层 ，IP 数据报首部的服务类型字段中的两个比特被用于ECN。

路由器所使用的一种 ECN 比特设置指示该路由器正在历经拥塞 。 该拥塞指示则由被标记的IP数据报所携带， 送给目的主机 。

再由目的主机通知发送主机（TCP ACK segment）

![](https://img.cetacis.dev/uploads/big/02ca99f8d0957dfe1f01a2068e942653.png)

tcp发送方会减半拥塞窗口，并且将报文段首部中对cwr（拥塞窗口缩减）进行设置。

# 实验：

![](https://img.cetacis.dev/uploads/big/37d074f219036e3c5770d8f7505b53ca.png)

![](https://img.cetacis.dev/uploads/big/db92a4e4bedcab79b59fa577b74c9a2e.png)

b) 检测客户是否在线

![实验要点](https://img.cetacis.dev/uploads/big/c157d44a236d7c0db05060b319fca1bc.png)

PDU JSON-RPC

