{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"themes/melody/source/melody-favicon.ico","path":"melody-favicon.ico","modified":0,"renderable":1},{"_id":"themes/melody/source/js/hexo-theme-melody.js","path":"js/hexo-theme-melody.js","modified":0,"renderable":1},{"_id":"themes/melody/source/css/404.styl","path":"css/404.styl","modified":0,"renderable":1},{"_id":"themes/melody/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/melody/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"themes/melody/source/img/algolia.svg","path":"img/algolia.svg","modified":0,"renderable":1},{"_id":"themes/melody/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"themes/melody/source/js/copy.js","path":"js/copy.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/fancybox.js","path":"js/fancybox.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/fireworks.js","path":"js/fireworks.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/head.js","path":"js/head.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/katex.js","path":"js/katex.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/scroll.js","path":"js/scroll.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/sidebar.js","path":"js/sidebar.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/transition.js","path":"js/transition.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/third-party/canvas-ribbon.js","path":"js/third-party/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/third-party/anime.min.js","path":"js/third-party/anime.min.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/third-party/jquery.fancybox.min.js","path":"js/third-party/jquery.fancybox.min.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/third-party/velocity.min.js","path":"js/third-party/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/third-party/velocity.ui.min.js","path":"js/third-party/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/third-party/jquery.min.js","path":"js/third-party/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/third-party/reveal/markdown.min.js","path":"js/third-party/reveal/markdown.min.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/third-party/reveal/marked.min.js","path":"js/third-party/reveal/marked.min.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/third-party/reveal/math.min.js","path":"js/third-party/reveal/math.min.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/third-party/reveal/notes.min.js","path":"js/third-party/reveal/notes.min.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/third-party/reveal/zoom.min.js","path":"js/third-party/reveal/zoom.min.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/third-party/reveal/head.min.js","path":"js/third-party/reveal/head.min.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/third-party/reveal/reveal.min.js","path":"js/third-party/reveal/reveal.min.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/third-party/reveal/highlight.min.js","path":"js/third-party/reveal/highlight.min.js","modified":0,"renderable":1},{"_id":"themes/melody/source/rushroom.jpg","path":"rushroom.jpg","modified":0,"renderable":1},{"_id":"themes/melody/source/12345.jpg","path":"12345.jpg","modified":0,"renderable":1},{"_id":"themes/melody/source/dog2.ico","path":"dog2.ico","modified":0,"renderable":1},{"_id":"themes/melody/source/123.jpg","path":"123.jpg","modified":0,"renderable":1},{"_id":"themes/melody/source/1234.jpg","path":"1234.jpg","modified":0,"renderable":1},{"_id":"themes/melody/source/lightInDark.jpg","path":"lightInDark.jpg","modified":0,"renderable":1},{"_id":"themes/melody/source/IMG_8764.jpeg","path":"IMG_8764.jpeg","modified":0,"renderable":1},{"_id":"themes/melody/source/pinkcat.ico","path":"pinkcat.ico","modified":1,"renderable":1}],"Cache":[{"_id":"themes/melody/.eslintignore","hash":"55f36fe3be2270ae2746eddbb2982e4e1472bc31","modified":1580296558003},{"_id":"themes/melody/.eslintrc","hash":"cfcd1b454efdd6cc1a0d43be7bc79027b84531f7","modified":1580296558003},{"_id":"themes/melody/.gitignore","hash":"7ed73f0edfb682b12a42070fd2730d5d712ec2fa","modified":1580296558004},{"_id":"themes/melody/.travis.demo.yml","hash":"4482d40a58a035ef96888dfc4ed96c861b8f78a5","modified":1580296558004},{"_id":"themes/melody/CHANGELOG.md","hash":"45ebf7c7497934beee0d3ffa06b2925964364076","modified":1580296558004},{"_id":"themes/melody/FAQ.md","hash":"5984dd5335f8ead64f14d3885de5cc5ef09dfff8","modified":1580296558004},{"_id":"themes/melody/LICENSE","hash":"dbbc2e6e42affa5ac962826f01bffa8c7aecd6b8","modified":1580296558004},{"_id":"themes/melody/README.md","hash":"79b8e7b89fc91455fe9275369c8065a32461837a","modified":1580296558004},{"_id":"themes/melody/_config.yml","hash":"9f3a473669447f758690740b29eb9e56f4a04e28","modified":1585384689000},{"_id":"themes/melody/package-lock.json","hash":"08c71afb662ad2f868ef64cbf7a31aa4bd5e53b5","modified":1580297327993},{"_id":"themes/melody/package.json","hash":"06b4838a97c8625ed544097f2438ee7c2848da63","modified":1580362934000},{"_id":"themes/melody/stylus_format.json","hash":"2fbe63b06901d202773457d7ce658ab6aa85d02b","modified":1580296558027},{"_id":"themes/melody/scripts/hexo-plugins.txt","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1580296558012},{"_id":"source/_posts/hello-world.md","hash":"e728ef72d7e3b6d5307c63349103b5bdb7bf512d","modified":1580464426000},{"_id":"themes/melody/.github/ISSUE_TEMPLATE.md","hash":"66c3f31c24530922420b92f5fd827f69197ee0e2","modified":1580296558004},{"_id":"themes/melody/.vscode/launch.json","hash":"3098e8e395a33fa130747d2fd104a21278f266a6","modified":1580296558004},{"_id":"themes/melody/.vscode/settings.json","hash":"089087413f5b54ef1847f83e101d0e186c7b359d","modified":1580296558004},{"_id":"themes/melody/languages/en.yml","hash":"2af19daf22ec99daf2482af9dac5c3ff641497c4","modified":1580296558005},{"_id":"themes/melody/languages/zh-Hans.yml","hash":"68c5794ec57227daec2e3afe2c5d502fa0a7092a","modified":1580296558005},{"_id":"themes/melody/languages/default.yml","hash":"2af19daf22ec99daf2482af9dac5c3ff641497c4","modified":1580296558005},{"_id":"themes/melody/layout/404.pug","hash":"0ad5d251ba70edad5c04a45d13ca6a8db3bf7b42","modified":1580296558006},{"_id":"themes/melody/layout/archive.pug","hash":"2133e9f369dac19b9f843fc956521f864ace7567","modified":1580310186000},{"_id":"themes/melody/layout/category.pug","hash":"ea5f82d69e586f293f428f3b237c17bf873b4f03","modified":1580296558006},{"_id":"themes/melody/layout/gallery.pug","hash":"c083a7bbf5f46305daed74632aef3403b7d94dc7","modified":1580296558006},{"_id":"themes/melody/layout/index.pug","hash":"5e969c09fa5902829ad0b14c0af8d432bd4c7078","modified":1580310186000},{"_id":"themes/melody/layout/page.pug","hash":"64f1a6564f674a6bbc9dbcb371ae6e23c1335221","modified":1580296558011},{"_id":"themes/melody/layout/post.pug","hash":"949550f3b7195124b2ca5f34e3bdab6fd08de0d4","modified":1580362934000},{"_id":"themes/melody/layout/slides.pug","hash":"1e84a92d5b854dd233e0b511d59c1cd7c8d647a1","modified":1580296558012},{"_id":"themes/melody/layout/tag.pug","hash":"ca333911bc97bc9d3eba6e1bc05e96b209ecedfb","modified":1580296558012},{"_id":"themes/melody/scripts/gallery-tag.js","hash":"74e2e95f8daec619578f4b7dd1ed77cd5907f37e","modified":1580296558012},{"_id":"themes/melody/scripts/replace-config.js","hash":"7476015a4e091203c3048c5377ec5d67439520fa","modified":1580296558013},{"_id":"themes/melody/source/melody-favicon.ico","hash":"e33c804e570eb238fe095ed28346dd1b3a0666ae","modified":1580296558027},{"_id":"themes/melody/source/js/hexo-theme-melody.js","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1580296558018},{"_id":"themes/melody/layout/includes/additional-js.pug","hash":"c4ca62466684758d5a26e5866f9ed87b5c9401b8","modified":1580296558007},{"_id":"themes/melody/layout/includes/config.pug","hash":"b55265d49832decb34d57f222deb64f04cc9aa12","modified":1580296558007},{"_id":"themes/melody/layout/includes/footer.pug","hash":"1ad8d015d75b5f2b098a332c1c6195e6935d9f33","modified":1580464278000},{"_id":"themes/melody/layout/includes/head.pug","hash":"cdabb5841dc42a58b6e06df9bc4f5acf90bc8419","modified":1580296558008},{"_id":"themes/melody/layout/includes/header.pug","hash":"006f86f19256eecc05c6cc6e66d5c0c79ddfcc63","modified":1580395295285},{"_id":"themes/melody/layout/includes/layout.pug","hash":"58856b5048fb64e7dab75a6ae32cc2a0ad94de4f","modified":1584956181338},{"_id":"themes/melody/layout/includes/nav.pug","hash":"3f1fe059784df45f923587b81cc972659ed22e01","modified":1580362934000},{"_id":"themes/melody/layout/includes/pagination.pug","hash":"fe33a94d90836b767c42654ccc4c4de7d7f227fc","modified":1580296558009},{"_id":"themes/melody/layout/includes/recent-posts.pug","hash":"128c448f5bab71f59912516edff9d476ff6b8afe","modified":1580362934000},{"_id":"themes/melody/layout/includes/sidebar.pug","hash":"211b8ecfdb7b5dd836c87436def410a52dfa5ecd","modified":1580296558010},{"_id":"themes/melody/source/css/404.styl","hash":"b7a0f8b23cb137b1a6c4fa0f9a35e06e93065b2c","modified":1580296558013},{"_id":"themes/melody/source/css/index.styl","hash":"2053ba56db707e7a03796ba59f77103765b02353","modified":1580296558016},{"_id":"themes/melody/source/css/var.styl","hash":"259feee66bf9c326e781bb63a177627dbe3eb539","modified":1580362934000},{"_id":"themes/melody/source/img/algolia.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1580296558017},{"_id":"themes/melody/source/img/avatar.png","hash":"a44601fac9a81dd7e392d05ea5ddc65c96b051df","modified":1580296558017},{"_id":"themes/melody/source/js/copy.js","hash":"ce7f8601c7c75ced79e2e9851beec37299d49fd1","modified":1580296558018},{"_id":"themes/melody/source/js/fancybox.js","hash":"2d3eaa654b2524c41dc5aba1d5e2e7cc9aaefd26","modified":1580296558018},{"_id":"themes/melody/source/js/fireworks.js","hash":"8691ab09c6a77d2e8e0d7ef9ca079f573e981de5","modified":1580464684000},{"_id":"themes/melody/source/js/head.js","hash":"555e9caa046d5a174af8d20c75e9e89c25aabb6c","modified":1580296558018},{"_id":"themes/melody/source/js/katex.js","hash":"a5a999b357c0fd9aeacae721bf121f30d40d6726","modified":1580296558018},{"_id":"themes/melody/source/js/scroll.js","hash":"467f883ca2ace0c0fb46ae24919223560a6fb72c","modified":1580296558019},{"_id":"themes/melody/source/js/sidebar.js","hash":"a42109c5a69dedc87e1aaf8cb2383fd43069677e","modified":1580296558019},{"_id":"themes/melody/source/js/transition.js","hash":"11c3b82a5e9ef2bf7bd712b6c211d86426f9a23e","modified":1580296558026},{"_id":"themes/melody/source/js/utils.js","hash":"f514662ad80803e1bb5f6bc653c4b9ad06ea4932","modified":1580296558026},{"_id":"themes/melody/layout/includes/gallery/script.pug","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1580296558008},{"_id":"themes/melody/layout/includes/404/404-nav.pug","hash":"4cd894857bb90fe44b55e852864692ed06588b8e","modified":1580296558006},{"_id":"themes/melody/layout/includes/404/layout.pug","hash":"9c7cdf16a9b9b4aa251dba9378a0f00d985101de","modified":1580296558006},{"_id":"themes/melody/layout/includes/comments/disqus.pug","hash":"e62b73df92566806bfb170f204295cffd7074215","modified":1580296558007},{"_id":"themes/melody/layout/includes/comments/gitalk.pug","hash":"86bdbc4a52024c3573bea27817394dd118b70a26","modified":1580401468107},{"_id":"themes/melody/layout/includes/comments/gitment.pug","hash":"0b7cd8b0b114876238ca022abda4c1fcdfaee12f","modified":1580296558007},{"_id":"themes/melody/layout/includes/comments/laibili.pug","hash":"97de1d1fb0459e7a2394ac2f5e449adf9b6986cb","modified":1580296558007},{"_id":"themes/melody/layout/includes/comments/index.pug","hash":"6c16214e5945142e5f3b58e7694397e26f28849d","modified":1580296558007},{"_id":"themes/melody/layout/includes/comments/valine.pug","hash":"9115ffd74549d356c18d4e2ad0a85d7b320b8c6e","modified":1580296558007},{"_id":"themes/melody/layout/includes/count/busuanzi.pug","hash":"4df5e63ab0113efb93f05ef781b2a7e3f34ba753","modified":1580296558008},{"_id":"themes/melody/layout/includes/gallery/layout.pug","hash":"8ff96c4f9afb416c5fc586c9585ae51cb6129529","modified":1580296558008},{"_id":"themes/melody/layout/includes/mixins/article-sort.pug","hash":"297b098dc6bba73b76bac4cf6bcd0c29d5dcb2ed","modified":1580296558009},{"_id":"themes/melody/layout/includes/mixins/slide.pug","hash":"91975f700b20131ab4df4d2ea3e1acc8bf2d3eef","modified":1580296558009},{"_id":"themes/melody/layout/includes/search/algolia.pug","hash":"44d5a061df53a276d22b3855652645d90117d0b6","modified":1580296558009},{"_id":"themes/melody/layout/includes/search/index.pug","hash":"b01828b37d789797aeb5433f1705cff3c540a4d5","modified":1580296558009},{"_id":"themes/melody/layout/includes/search/local-search.pug","hash":"f88070a84379bc06fb385e1193448fae6a8a54e1","modified":1580296558009},{"_id":"themes/melody/layout/includes/share/add-this.pug","hash":"17a11c1c36c9078639c2a82628ce5fc6584daffb","modified":1580296558010},{"_id":"themes/melody/layout/includes/share/index.pug","hash":"a2ec6da33cf5fa0ba6c8c38ec3841a0b0003ce98","modified":1580296558010},{"_id":"themes/melody/layout/includes/share/share-js.pug","hash":"e612725ba48711fc119f91c6196287ad13f5a2ba","modified":1580296558010},{"_id":"themes/melody/layout/includes/slide/layout.pug","hash":"f90bfc1cbe21e799a8784129e1a34bd59404e3df","modified":1580296558010},{"_id":"themes/melody/layout/includes/slide/script.pug","hash":"940c000ececf7f7596bf8c452dda9b92a5df7710","modified":1580296558010},{"_id":"themes/melody/layout/includes/third-party/canvas-ribbon.pug","hash":"39a03f188ac415642766b062a80b1b710f3ea609","modified":1580296558011},{"_id":"themes/melody/layout/includes/third-party/katex.pug","hash":"79b2336ad8d921907a5b1badc10ba1651c92843b","modified":1580296558011},{"_id":"themes/melody/layout/includes/third-party/mathjax.pug","hash":"33b350f9826795cd59d9e277a24accc8a9bc9076","modified":1580296558011},{"_id":"themes/melody/source/css/_global/index.styl","hash":"2a6195ce7e822362633ebf403c9438b42fa126bb","modified":1580362934000},{"_id":"themes/melody/source/css/_highlight/diff.styl","hash":"ffdfbf088da7bf33899557395abcac0d2bffd67d","modified":1580296558014},{"_id":"themes/melody/source/css/_highlight/highlight.styl","hash":"016c800bf7a0ef6d520e135ab69ef072760483cb","modified":1580296558014},{"_id":"themes/melody/source/css/_highlight/theme.styl","hash":"7d85860927afa1d93b4a39febff3d95a73de4c36","modified":1580296558014},{"_id":"themes/melody/source/css/_layout/comments.styl","hash":"e58602aad6792f1a5dbda0677ecb04d21ac10e97","modified":1580296558014},{"_id":"themes/melody/source/css/_layout/footer.styl","hash":"ca8c816bdb144503bec7e755344fb0e4e370a7bf","modified":1580362934000},{"_id":"themes/melody/source/css/_layout/head.styl","hash":"73488de3f36369c29ecd5e0be9661bb2b508548c","modified":1580362934000},{"_id":"themes/melody/source/css/_layout/page.styl","hash":"d2f6050bf6ef80523ed9a5a0f058fa5dbaf72ea8","modified":1580296558015},{"_id":"themes/melody/source/css/_layout/pagination.styl","hash":"a3f52d1f7ff1eaead8df016b2a4def6f7b4e9559","modified":1580296558015},{"_id":"themes/melody/source/css/_layout/post.styl","hash":"9fd88cc878a156e8b275c8dcb95717ca5ceea83a","modified":1580296558015},{"_id":"themes/melody/source/css/_layout/sidebar.styl","hash":"e8315401a6c791d00617c031be01f45df70fe7fd","modified":1580296558015},{"_id":"themes/melody/source/css/_search/algolia.styl","hash":"534e5641e3efe2452db95cc25ec8da0111ceadcf","modified":1580296558015},{"_id":"themes/melody/source/css/_search/index.styl","hash":"63cae4465ac54b71361c1795206534c7f2e6e5b1","modified":1580296558016},{"_id":"themes/melody/source/css/_search/local-search.styl","hash":"d7970b385265fef782cdcaaf4fe68a2217625467","modified":1580296558016},{"_id":"themes/melody/source/css/_third-party/jquery.fancybox.min.css","hash":"f9c94ec04062a1bfe1ef894c49e6ec33fa121778","modified":1580296558016},{"_id":"themes/melody/source/css/_third-party/normalize.min.css","hash":"e12eef6d6811c132f4f2fcf6c936be384191bcaf","modified":1580296558016},{"_id":"themes/melody/source/js/search/algolia.js","hash":"8d2cc7ac4a015563344a3981c3040d308489935c","modified":1580296558019},{"_id":"themes/melody/source/js/search/local-search.js","hash":"b7e77c27097d9d3ced13618912069d1ddf1cd64a","modified":1580296558019},{"_id":"themes/melody/source/js/third-party/canvas-ribbon.js","hash":"8fd084e962fb2028be9f748b5cb5f53d030d1d03","modified":1580296558020},{"_id":"themes/melody/source/js/third-party/anime.min.js","hash":"3c46c9597c721644a515c1c54ab13f46406657f7","modified":1580296558020},{"_id":"themes/melody/source/js/third-party/jquery.fancybox.min.js","hash":"2ec3ef6c31b971ba5e58eb4a0c5ede902bbdd4af","modified":1580296558020},{"_id":"themes/melody/source/js/third-party/velocity.min.js","hash":"69c85b9d6a931a7d3a5b0657e60112c31fb3b286","modified":1580296558026},{"_id":"themes/melody/source/js/third-party/velocity.ui.min.js","hash":"d8124c091d19fa4072616a44a8897fabc6599fce","modified":1580296558026},{"_id":"themes/melody/source/js/third-party/jquery.min.js","hash":"1055018c28ab41087ef9ccefe411606893dabea2","modified":1580296558021},{"_id":"themes/melody/source/js/third-party/reveal/markdown.min.js","hash":"859d70cd7c459819b90fe27afb940d16ecff6614","modified":1580296558025},{"_id":"themes/melody/source/js/third-party/reveal/marked.min.js","hash":"37f3186f93ec854f56bf745a5988a89225e8da6c","modified":1580296558025},{"_id":"themes/melody/source/js/third-party/reveal/math.min.js","hash":"779c98dbd83a528f27ea4b9f2d420c957c0939ba","modified":1580296558025},{"_id":"themes/melody/source/js/third-party/reveal/notes.min.js","hash":"4bb2925b111467791fdef3c4e4b41993d59ce90f","modified":1580296558025},{"_id":"themes/melody/source/js/third-party/reveal/zoom.min.js","hash":"aca47bf417d451c4d364c6eb287a230e4b462b17","modified":1580296558026},{"_id":"themes/melody/source/js/third-party/reveal/head.min.js","hash":"8c9495c76d5aa00d3dfb88653c362fba9f10cbb2","modified":1580296558021},{"_id":"themes/melody/source/js/third-party/reveal/reveal.min.js","hash":"d8377a86451712488dea87caf5acbf8e97aa991f","modified":1580296558025},{"_id":"themes/melody/source/js/third-party/reveal/highlight.min.js","hash":"10dd530e712a67f25cf27845213c0f28d2fe9e4d","modified":1580296558024},{"_id":"public/archives/index.html","hash":"877ff41a2a8e4bbec47d9b604e88a6f7a651c3eb","modified":1580467956809},{"_id":"public/2020/01/29/hello-world/index.html","hash":"1d1270b908194b39f1ec7c010ca6a3f4706509e6","modified":1580297527307},{"_id":"public/archives/2020/index.html","hash":"745a1e88ba165f264b558dc63c2a93090aad95b0","modified":1580467956809},{"_id":"public/archives/2020/01/index.html","hash":"ff127667ada9bec54ae4eead22379de315d4808c","modified":1580467956809},{"_id":"public/index.html","hash":"48aa9e0e5cada5661f0935fcf31f45b2880658a2","modified":1580467956809},{"_id":"public/melody-favicon.ico","hash":"e33c804e570eb238fe095ed28346dd1b3a0666ae","modified":1580467956809},{"_id":"public/img/algolia.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1580467956809},{"_id":"public/img/avatar.png","hash":"a44601fac9a81dd7e392d05ea5ddc65c96b051df","modified":1580467956809},{"_id":"public/js/hexo-theme-melody.js","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1580467956809},{"_id":"public/css/404.css","hash":"712ecbf4ac203ab5f1ea92989c0f0062a3d0aca9","modified":1580467956809},{"_id":"public/js/fancybox.js","hash":"2d3eaa654b2524c41dc5aba1d5e2e7cc9aaefd26","modified":1580467956809},{"_id":"public/js/copy.js","hash":"ce7f8601c7c75ced79e2e9851beec37299d49fd1","modified":1580467956809},{"_id":"public/js/fireworks.js","hash":"17d5770d46d9b531b675b129835561146290af83","modified":1580467956809},{"_id":"public/js/katex.js","hash":"a5a999b357c0fd9aeacae721bf121f30d40d6726","modified":1580467956809},{"_id":"public/js/head.js","hash":"555e9caa046d5a174af8d20c75e9e89c25aabb6c","modified":1580467956809},{"_id":"public/js/sidebar.js","hash":"a42109c5a69dedc87e1aaf8cb2383fd43069677e","modified":1580467956809},{"_id":"public/js/scroll.js","hash":"467f883ca2ace0c0fb46ae24919223560a6fb72c","modified":1580467956809},{"_id":"public/js/transition.js","hash":"11c3b82a5e9ef2bf7bd712b6c211d86426f9a23e","modified":1580467956809},{"_id":"public/js/utils.js","hash":"f514662ad80803e1bb5f6bc653c4b9ad06ea4932","modified":1580467956809},{"_id":"public/js/third-party/canvas-ribbon.js","hash":"8fd084e962fb2028be9f748b5cb5f53d030d1d03","modified":1580467956809},{"_id":"public/js/search/algolia.js","hash":"8d2cc7ac4a015563344a3981c3040d308489935c","modified":1580467956809},{"_id":"public/js/search/local-search.js","hash":"b7e77c27097d9d3ced13618912069d1ddf1cd64a","modified":1580467956809},{"_id":"public/js/third-party/reveal/markdown.min.js","hash":"859d70cd7c459819b90fe27afb940d16ecff6614","modified":1580467956809},{"_id":"public/js/third-party/reveal/math.min.js","hash":"779c98dbd83a528f27ea4b9f2d420c957c0939ba","modified":1580467956809},{"_id":"public/js/third-party/reveal/notes.min.js","hash":"4bb2925b111467791fdef3c4e4b41993d59ce90f","modified":1580467956809},{"_id":"public/js/third-party/reveal/zoom.min.js","hash":"aca47bf417d451c4d364c6eb287a230e4b462b17","modified":1580467956809},{"_id":"public/css/index.css","hash":"bd71b0d6f19306a75c67b13de03650dc317c8ede","modified":1580467956809},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1580467956809},{"_id":"public/js/third-party/anime.min.js","hash":"3c46c9597c721644a515c1c54ab13f46406657f7","modified":1580467956809},{"_id":"public/js/third-party/velocity.ui.min.js","hash":"d8124c091d19fa4072616a44a8897fabc6599fce","modified":1580467956809},{"_id":"public/js/third-party/reveal/head.min.js","hash":"95c9de30444117adbbb3218070fda00af187a76a","modified":1580467956809},{"_id":"public/js/third-party/reveal/marked.min.js","hash":"37f3186f93ec854f56bf745a5988a89225e8da6c","modified":1580467956809},{"_id":"public/js/third-party/velocity.min.js","hash":"69c85b9d6a931a7d3a5b0657e60112c31fb3b286","modified":1580467956809},{"_id":"public/js/third-party/jquery.fancybox.min.js","hash":"2ec3ef6c31b971ba5e58eb4a0c5ede902bbdd4af","modified":1580467956809},{"_id":"public/js/third-party/reveal/reveal.min.js","hash":"d8377a86451712488dea87caf5acbf8e97aa991f","modified":1580467956809},{"_id":"public/js/third-party/jquery.min.js","hash":"1055018c28ab41087ef9ccefe411606893dabea2","modified":1580467956809},{"_id":"public/js/third-party/reveal/highlight.min.js","hash":"10dd530e712a67f25cf27845213c0f28d2fe9e4d","modified":1580467956809},{"_id":"source/.DS_Store","hash":"df87615cedd0e0af69fc907a2db927e48cd75dcb","modified":1584670158639},{"_id":"source/images/AH.png","hash":"b2814aa4750f99dbebb875fa33df38749c8e10e9","modified":1580314367089},{"_id":"public/2020/01/30/hello-world/index.html","hash":"a0c25d84cde10e82933cbe45762191e9f36b2be4","modified":1580314551294},{"_id":"public/images/AH.png","hash":"b2814aa4750f99dbebb875fa33df38749c8e10e9","modified":1580467956809},{"_id":"source/images/.DS_Store","hash":"89237aef95b6f44f3357509d97a4e53cf3292423","modified":1580316685217},{"_id":"source/categories/index.md","hash":"9dafb1ddccaeb1d5d4625520e0285096ad411a04","modified":1581925828766},{"_id":"source/tags/index.md","hash":"79ed645d5d3ff28fa67a70d7567404d9938fe848","modified":1580555329413},{"_id":"source/about/index.md","hash":"ecb01a265549511e79ca826ea87a8b21fda8be12","modified":1581926237364},{"_id":"themes/melody/.DS_Store","hash":"862bf792e92c1da22d13358333991b58bb412395","modified":1580396665336},{"_id":"themes/melody/source/srq.jpg","hash":"ce8cfdedd8661ba607399e20c5534365b81c0df9","modified":1570970855000},{"_id":"themes/melody/source/.DS_Store","hash":"1b45643263c8577832c23672cbddf5b4dbd436b2","modified":1580457363420},{"_id":"themes/melody/source/kelo.JPG","hash":"266841291aba6600add12b73a00797288f615243","modified":1580404863000},{"_id":"themes/melody/source/land.jpg","hash":"e3ba16c4bcbd1e687b4e4f64618c87ec3261051e","modified":1565764131000},{"_id":"themes/melody/source/js/background.js","hash":"b95aee68529f6451f2f5029568879bff47488836","modified":1580464708062},{"_id":"public/search.xml","hash":"5de5abc4d545ea0c39e55fbe63d3a9bfbde93d0e","modified":1580467956809},{"_id":"public/categories/index.html","hash":"c20914050c25a9adbad1bff8c6b92181b743bed9","modified":1580467956809},{"_id":"public/tags/index.html","hash":"3faf292c6a43c0bebf09a7915bd6948c8839784f","modified":1580467956809},{"_id":"public/about/index.html","hash":"0f78de8bfddf7ea49bb322d3b06a9950619ac4c7","modified":1580467956809},{"_id":"public/2020/01/31/hello-world/index.html","hash":"e359872402f2dc7556d6bc75ecb0e69d3e39bdc0","modified":1580467956809},{"_id":"public/categories/begin/index.html","hash":"1e09b4839dc42a52be4304d4658bd354b22f4ef6","modified":1580467956809},{"_id":"public/categories/begin/end/index.html","hash":"b9e2f58f68ab70861a20da9e81d3c8bcc941ae5f","modified":1580467956809},{"_id":"public/tags/begin/index.html","hash":"3db7a059bf2d32a6428adc14873248477b5f4da4","modified":1580467956809},{"_id":"public/kelo.JPG","hash":"266841291aba6600add12b73a00797288f615243","modified":1580467956809},{"_id":"public/assets/algolia/algoliasearchLite.min.js","hash":"284416885e4e80e27fa4eae6fc305f4de15b914c","modified":1580467956809},{"_id":"public/assets/algolia/algoliasearch.min.js","hash":"a3b131a9a47ccc16f4dd8988fabb6d306548db2f","modified":1580467956809},{"_id":"public/assets/algolia/algoliasearchLite.js","hash":"e56ad6b82caf69066de545201014291fc961635e","modified":1580467956809},{"_id":"public/js/background.js","hash":"b95aee68529f6451f2f5029568879bff47488836","modified":1580467956809},{"_id":"public/assets/algolia/algoliasearch.js","hash":"6948fcdf071e4983e784e8c458cf201536f77792","modified":1580467956809},{"_id":"public/land.jpg","hash":"e3ba16c4bcbd1e687b4e4f64618c87ec3261051e","modified":1580467956809},{"_id":"themes/melody/source/js/canvas_t.js","hash":"50b499a54faa16784d41ef4ec384f7433531c75e","modified":1580475272940},{"_id":"themes/melody/source/whale.ico","hash":"1e444d651e25b92e8facaa1baba6d6269fd00bec","modified":1580481347807},{"_id":"themes/melody/melody.","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1580314514000},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1580311542000},{"_id":"source/_posts/Dengmengda.md","hash":"122c465e0404c928cbc24054666f98a7ae1abe7f","modified":1580372248000},{"_id":"source/_posts/demoBlog.md","hash":"00a60e12758142e299fbdc64254f3409d8419789","modified":1580297472000},{"_id":"source/about/me.md","hash":"3e1602025e582f7ff133a63ddefb299ffb1f868c","modified":1580296050000},{"_id":"themes/melody/source/rushroom.jpg","hash":"290e5c050369a6a14e5fef4565f8b3efeeec1946","modified":1580555791101},{"_id":"themes/melody/source/12345.jpg","hash":"2aa1b8c3af18c136057b24a6653c56956f280d60","modified":1572262006000},{"_id":"themes/melody/source/dog2.ico","hash":"0db5bdaddf4083a62c8579a720073f1ba098fbbe","modified":1580555718515},{"_id":"themes/melody/source/123.jpg","hash":"b64a917945359665e649bff15ed5c440c62f9e34","modified":1541241502000},{"_id":"themes/melody/source/1234.jpg","hash":"8f93b4b2588cfed7ba941ee11e8e958a70640703","modified":1580313824000},{"_id":"themes/melody/source/lightInDark.jpg","hash":"bd262a67a67bf67e9b5aac3295b52859f5455095","modified":1580365308000},{"_id":"source/_posts/blog搭建以及服务器初试.md","hash":"f0c05cf84437e7e00d3e5e7a4d3d0db4010c2d8e","modified":1585321757000},{"_id":"source/_posts/Git 自学（三）标签管理.md","hash":"37024f0abf391f52048a769f686a840b87d183c7","modified":1585099239000},{"_id":"source/_posts/Git 自学（二）远程仓库与分支管理.md","hash":"4c3e64d30b14b9f370522e82d39feb2abce6ecdc","modified":1585099232000},{"_id":"source/_posts/Git 自学（一）Git 简介以及时间穿梭.md","hash":"14cf2e73b5ee48bff4dbc3b19e5c4bd3d4f89fdc","modified":1585099282000},{"_id":"source/_posts/操作系统-课堂笔记.md","hash":"5921c80dbeb84c969688734b8beb901d663bb34d","modified":1586305929000},{"_id":"source/_posts/基础知识积累（持续更新）.md","hash":"29df612485b63fc1c092e6f2c1bb5d03dda03a2b","modified":1583211969436},{"_id":"source/_posts/Unity.md","hash":"eadfca81f6a98eae393faf48a0cab98928e1da81","modified":1585100313000},{"_id":"source/_posts/kelo算法课堂.md","hash":"bee3a7aba1584423dc9c639a088660f28cc5d505","modified":1584026373220},{"_id":"source/_posts/程序员的自我修养（二）静态链接，装载，动态链接与Linux共享文件.md","hash":"80cfd89743c63663dbf08143794233d1017ca515","modified":1585099164000},{"_id":"source/_posts/程序员的自我修养（三）内存分布，运行库与系统调用.md","hash":"945d2258acaa700ce8067d1f5fbf354baa87b23e","modified":1585099164000},{"_id":"source/_posts/程序员的自我修养（一）操作系统、编译器、目标文件、链接器.md","hash":"ffdac6def983d73efe32b22041f501ee66178ac6","modified":1585100241000},{"_id":"source/_posts/数字娱乐架构上课笔记.md","hash":"3fe0d8b5d6a2387ee4baee2c584d8ee1df4b7bb2","modified":1585100308000},{"_id":"source/_posts/自顶向下的计算机网络.md","hash":"00bebd20e560a02c970a3143adcb8acfe43bac45","modified":1584950943978},{"_id":"source/_posts/计算机网络.md","hash":"fb75e7aff82b8f3559c9469fb601dbe743660f12","modified":1582117034153},{"_id":"themes/melody/source/IMG_8764.jpeg","hash":"6ca8ee8b21bd0d8a82afaad5275f34a1c3c62b72","modified":1581341474548},{"_id":"source/_posts/nginx&apache.md","hash":"f93335e81dc29cbbcb9f232eb9df764b0867d7a2","modified":1585321479000},{"_id":"source/_posts/DevelopForIos(1).md","hash":"3ce9b54bb1b6328121fbed61b688b015cb41f6bb","modified":1586665515000},{"_id":"source/_posts/图形学-上课笔记.md","hash":"149b9734281f451e90a9ddf8ff883c11a43a366d","modified":1585281759000},{"_id":"source/_posts/屠龙之技二（持续更新）.md","hash":"56235ec1f84c52100146c56be289667117a87442","modified":1585106634000},{"_id":"source/_posts/自顶向下的计算机网络3 运输层.md","hash":"d1c5bba694b5e1c652d376e638a8f0cf8283d9e7","modified":1585826153000},{"_id":"source/_posts/操作系統-4-存儲器管理.md","hash":"ff536b5fc17acbaee767d953d450729ce5af7051","modified":1586446571000},{"_id":"source/_posts/屠龙之技一.md","hash":"0dbfd99785e4c6853767226a4b79f31dcae5a38f","modified":1585099399000},{"_id":"source/_posts/自顶向下的计算机网络4 网络层.md","hash":"2a3e5cde95bb8b4398b8da17b6f2e96999af25ea","modified":1586493109000},{"_id":"themes/melody/source/pinkcat.ico","hash":"3b2bbe44e530a294d153a5c440b9f1f3f85b1bc2","modified":1585293901000}],"Category":[{"name":"begin","_id":"ck611a7cy0000udux6lr09s1w"},{"name":"begin end","_id":"ck611aqll0002udux4ys9fsv7"},{"name":"end","parent":"ck611a7cy0000udux6lr09s1w","_id":"ck611dkdi0005udux8pebcof2"},{"name":"操作系统","_id":"ck849avae0002thesc8lk2a0b"},{"name":"base","_id":"ck849avao0007thes4r58aukg"},{"name":"gameAndGraphics","_id":"ck849avaq000cthes9je13x6f"},{"name":"算法","_id":"ck849avax000jthesbnv93gdh"},{"name":"计算机网络","_id":"ck985a77m0002slqg6zy68nez"},{"name":"development","_id":"ck985a7850008slqghfi06l40"},{"name":"游戏及图形学","_id":"ck985a788000cslqgda3hcylx"},{"name":"屠龙之技","_id":"ck985a78f000gslqgfkqi5xp5"},{"name":"nginx & apache","parent":"ck985a77m0002slqg6zy68nez","_id":"ck985a78h000kslqg2px17xy2"},{"name":"自顶向下的计算机网络","parent":"ck985a77m0002slqg6zy68nez","_id":"ck985a78i000oslqg0r6bgpja"},{"name":"ios","parent":"ck985a7850008slqghfi06l40","_id":"ck985a78i000qslqgdxl2f1ul"},{"name":"图形学","parent":"ck985a788000cslqgda3hcylx","_id":"ck985a78j000sslqg7krlaqqc"},{"name":"运输层","parent":"ck985a78i000oslqg0r6bgpja","_id":"ck985a78k000uslqg1lgc6t6m"},{"name":"github","_id":"ck985a86k0014slqg30j6col1"},{"name":"blog搭建（hexo","parent":"ck985a77m0002slqg6zy68nez","_id":"ck985a86p0019slqg4rhfgftk"},{"name":"网络层","parent":"ck985a78i000oslqg0r6bgpja","_id":"ck985a86u001bslqgegpkdhrh"},{"name":"数字媒体架构上课笔记","parent":"ck985a788000cslqgda3hcylx","_id":"ck985a86x001eslqghbchaz8r"},{"name":"上课笔记","parent":"ck849avae0002thesc8lk2a0b","_id":"ck985a86z001islqg66c38e4l"},{"name":"程序员的自我修养","parent":"ck849avae0002thesc8lk2a0b","_id":"ck985a873001lslqg68uq7grp"},{"name":"unity","parent":"ck985a788000cslqgda3hcylx","_id":"ck985a8hb001yslqg9tveeojk"}],"Data":[],"Page":[{"title":"tags","date":"2020-02-01T11:06:40.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2020-02-01 19:06:40\ntype: \"tags\"\n---\n","updated":"2020-02-01T11:08:49.413Z","path":"tags/index.html","_id":"ck60gs7y600012xux3pjb5xe4","comments":1,"layout":"page","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"About me","date":"2020-01-29T11:07:30.000Z","_content":"","source":"about/me.md","raw":"---\ntitle: About me\ndate: 2020-01-29 19:07:30\n---\n","updated":"2020-01-29T11:07:30.000Z","path":"about/me.html","comments":1,"layout":"page","_id":"ck63irvjk0001xnmx4y7dc1ab","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"about","date":"2020-02-17T07:56:51.000Z","type":"about","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2020-02-17 15:56:51\ntype: \"about\"\n---\n","updated":"2020-02-17T07:57:17.364Z","path":"about/index.html","comments":1,"layout":"page","_id":"ck849avf40025thesfpa3ak4s","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"categories","date":"2020-02-17T07:49:47.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2020-02-17 15:49:47\ntype: \"categories\"\n---\n","updated":"2020-02-17T07:50:28.766Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ck849avf70026thesftm1c260","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"date":"2020-01-30T16:00:00.000Z","_content":"# 概览\n\n一. 标签管理\n\n1. 创建标签\n2. 操作标签\n\n二. github\n\n1. 使用码云 \n\n<!-- more -->\n\n# 标签管理\n\n标签（tag）是版本库的一个快照，相当于绑定某个commit的指针，拥有一个比commit id 更加简洁的名字。\n\n## 创建标签\n\n命令git tag <tagname>用于新建一个标签，默认为HEAD，也可以指定一个commit id；\n\n命令git tag -a <tagname> -m \"blablabla…\"可以指定标签信息；\n\n命令git tag可以查看所有标签。\n\n1. 切换至目标分支\n\n```\n$ git branch\n* dev\n  master\n$ git checkout master\nSwitched to branch 'master'\n```\n\n2. **git tag <name>**创建标签\n\n```\n$ git tag v1.0\n```\n\n3. **git tag**查看所有标签\n\n```\n$ git tag\nv1.0    \n```\n\n可通过commit id给版本打标签\n\n```\n$ git log --pretty=oneline --abbrev-commit\n12a631b (HEAD -> master, tag: v1.0, origin/master) merged bug fix 101\n4c805e2 fix bug 101\ne1e9c68 merge with no-ff\nf52c633 add merge\ncf810e4 conflict fixed\n5dc6824 & simple\n14096d0 AND simple\nb17d20e branch test\nd46f35e remove test.txt\nb84166e add test.txt\n519219b git tracks changes\ne43a48b understand how stage works\n1094adb append GPL\ne475afc add distributed\neaadf4e wrote a readme file\n```\n\n比方说要对add merge这次提交打标签，它对应的commit id是f52c633，敲入命令：\n\n```\n$ git tag v0.9 f52c633\n$ git tag\nv 0.9\nv 1.0\n```\n\n用git show <tagname>查看tag信息\n\n```\n$ git show v0.9\ncommit f52c63349bc3c1593499807e5c8e972b82c8f286 (tag: v0.9)\nAuthor: Michael Liao <askxuefeng@gmail.com>\nDate:   Fri May 18 21:56:54 2018 +0800\n\n    add merge\n\ndiff --git a/readme.txt b/readme.txt\n...\n```\n\n可以绑定有说明的tag: git tag -a <tagname> -m “”\n\n```\n$ git tag -a v0.1 -m \"version 0.1 released\" 1094adb\n$ git show v0.1\ntag v0.1\nTagger: Michael Liao <askxuefeng@gmail.com>\nDate:   Fri May 18 22:48:43 2018 +0800\n\nversion 0.1 released\n\ncommit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (tag: v0.1)\nAuthor: Michael Liao <askxuefeng@gmail.com>\nDate:   Fri May 18 21:06:15 2018 +0800\n\n    append GPL\n\ndiff --git a/readme.txt b/readme.txt\n...\n```\n\n标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。\n\n## 操作标签\n\n命令git push origin <tagname>可以推送一个本地标签；\n\n命令git push origin --tags可以推送全部未推送过的本地标签；\n\n命令git tag -d <tagname>可以删除一个本地标签；\n\n命令git push origin :refs/tags/<tagname>可以删除一个远程标签。\n\ntag打错了，git tag -d <tagname>可以删除。\n\n```\n$ git tag -d v0.1\nDeleted tag 'v0.1' (was f15b0dd)\n```\n\n推送特定tag到远程**git push origin <tagname>**：\n\n```\n$ git push origin v1.0\nTotal 0 (delta 0), reused 0 (delta 0)\nTo github.com:michaelliao/learngit.git\n * [new tag]         v1.0 -> v1.0\n```\n\n一次性推送全部tag到远程：\n\n```\n$ git push origin --tags\nTotal 0 (delta 0), reused 0 (delta 0)\nTo github.com:michaelliao/learngit.git\n * [new tag]         v0.9 -> v0.9\n```\n\n删除远程标签：\n首先删除本地标签：\n\n```\n$ git tag -d v0.9\nDeleted tag 'v0.9' (was f52c633)\n```\n\n其次从远程删除：**$ git push origin :refs/tags/<tagname>**\n\n```\n$ git push origin :refs/tags/v0.9\nTo github.com:michaelliao/learngit.git\n - [deleted]         v0.9\n```\n\n# use Github\n\n首先，在某个你想要参与修改的库中fork,相当于在自己的github账号底下克隆了一个远程库，这样的话，我们就可以对我们自己的远程库进行修改，最后将这个修改pull request给库主人，交给他审核即可。\n\n对自己的库修改：\n\n1. clone\n\n```\ngit clone git@github.com:Unalian/learngit-1.git\n```\n\n2. change\n\n```\nvim Unalian.txt\n//change the name:mv Unalian.txt una.txt\n```\n\n3. add una.txt\n\n```\ncommit -m \"add una.txt to master\"\n```\n\n注意，以上是将本地进行了修改。\n\n```\ngit push origin master\n```\n\n我们的远程库learngit-1修改好了，之后就可以pull request了。\n\n## 使用码云\n\n当github速度慢的时候可以进行操作\n\n[http://git-scm.com](http://git-scm.com/) （指令总结）","source":"_posts/Git 自学（三）标签管理.md","raw":"---\ndate: 2020/1/31\ntags:\n- git\n- 自学笔记\ncategories:\n- github\n---\n# 概览\n\n一. 标签管理\n\n1. 创建标签\n2. 操作标签\n\n二. github\n\n1. 使用码云 \n\n<!-- more -->\n\n# 标签管理\n\n标签（tag）是版本库的一个快照，相当于绑定某个commit的指针，拥有一个比commit id 更加简洁的名字。\n\n## 创建标签\n\n命令git tag <tagname>用于新建一个标签，默认为HEAD，也可以指定一个commit id；\n\n命令git tag -a <tagname> -m \"blablabla…\"可以指定标签信息；\n\n命令git tag可以查看所有标签。\n\n1. 切换至目标分支\n\n```\n$ git branch\n* dev\n  master\n$ git checkout master\nSwitched to branch 'master'\n```\n\n2. **git tag <name>**创建标签\n\n```\n$ git tag v1.0\n```\n\n3. **git tag**查看所有标签\n\n```\n$ git tag\nv1.0    \n```\n\n可通过commit id给版本打标签\n\n```\n$ git log --pretty=oneline --abbrev-commit\n12a631b (HEAD -> master, tag: v1.0, origin/master) merged bug fix 101\n4c805e2 fix bug 101\ne1e9c68 merge with no-ff\nf52c633 add merge\ncf810e4 conflict fixed\n5dc6824 & simple\n14096d0 AND simple\nb17d20e branch test\nd46f35e remove test.txt\nb84166e add test.txt\n519219b git tracks changes\ne43a48b understand how stage works\n1094adb append GPL\ne475afc add distributed\neaadf4e wrote a readme file\n```\n\n比方说要对add merge这次提交打标签，它对应的commit id是f52c633，敲入命令：\n\n```\n$ git tag v0.9 f52c633\n$ git tag\nv 0.9\nv 1.0\n```\n\n用git show <tagname>查看tag信息\n\n```\n$ git show v0.9\ncommit f52c63349bc3c1593499807e5c8e972b82c8f286 (tag: v0.9)\nAuthor: Michael Liao <askxuefeng@gmail.com>\nDate:   Fri May 18 21:56:54 2018 +0800\n\n    add merge\n\ndiff --git a/readme.txt b/readme.txt\n...\n```\n\n可以绑定有说明的tag: git tag -a <tagname> -m “”\n\n```\n$ git tag -a v0.1 -m \"version 0.1 released\" 1094adb\n$ git show v0.1\ntag v0.1\nTagger: Michael Liao <askxuefeng@gmail.com>\nDate:   Fri May 18 22:48:43 2018 +0800\n\nversion 0.1 released\n\ncommit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (tag: v0.1)\nAuthor: Michael Liao <askxuefeng@gmail.com>\nDate:   Fri May 18 21:06:15 2018 +0800\n\n    append GPL\n\ndiff --git a/readme.txt b/readme.txt\n...\n```\n\n标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。\n\n## 操作标签\n\n命令git push origin <tagname>可以推送一个本地标签；\n\n命令git push origin --tags可以推送全部未推送过的本地标签；\n\n命令git tag -d <tagname>可以删除一个本地标签；\n\n命令git push origin :refs/tags/<tagname>可以删除一个远程标签。\n\ntag打错了，git tag -d <tagname>可以删除。\n\n```\n$ git tag -d v0.1\nDeleted tag 'v0.1' (was f15b0dd)\n```\n\n推送特定tag到远程**git push origin <tagname>**：\n\n```\n$ git push origin v1.0\nTotal 0 (delta 0), reused 0 (delta 0)\nTo github.com:michaelliao/learngit.git\n * [new tag]         v1.0 -> v1.0\n```\n\n一次性推送全部tag到远程：\n\n```\n$ git push origin --tags\nTotal 0 (delta 0), reused 0 (delta 0)\nTo github.com:michaelliao/learngit.git\n * [new tag]         v0.9 -> v0.9\n```\n\n删除远程标签：\n首先删除本地标签：\n\n```\n$ git tag -d v0.9\nDeleted tag 'v0.9' (was f52c633)\n```\n\n其次从远程删除：**$ git push origin :refs/tags/<tagname>**\n\n```\n$ git push origin :refs/tags/v0.9\nTo github.com:michaelliao/learngit.git\n - [deleted]         v0.9\n```\n\n# use Github\n\n首先，在某个你想要参与修改的库中fork,相当于在自己的github账号底下克隆了一个远程库，这样的话，我们就可以对我们自己的远程库进行修改，最后将这个修改pull request给库主人，交给他审核即可。\n\n对自己的库修改：\n\n1. clone\n\n```\ngit clone git@github.com:Unalian/learngit-1.git\n```\n\n2. change\n\n```\nvim Unalian.txt\n//change the name:mv Unalian.txt una.txt\n```\n\n3. add una.txt\n\n```\ncommit -m \"add una.txt to master\"\n```\n\n注意，以上是将本地进行了修改。\n\n```\ngit push origin master\n```\n\n我们的远程库learngit-1修改好了，之后就可以pull request了。\n\n## 使用码云\n\n当github速度慢的时候可以进行操作\n\n[http://git-scm.com](http://git-scm.com/) （指令总结）","slug":"Git-自学（三）标签管理","published":1,"updated":"2020-03-25T01:20:39.000Z","title":"Git-自学（三）标签管理","_id":"ck67gmur30000o3mx3quwfqq0","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"概览\"><a href=\"#概览\" class=\"headerlink\" title=\"概览\"></a>概览</h1><p>一. 标签管理</p>\n<ol>\n<li>创建标签</li>\n<li>操作标签</li>\n</ol>\n<p>二. github</p>\n<ol>\n<li>使用码云 </li>\n</ol>\n<a id=\"more\"></a>\n\n<h1 id=\"标签管理\"><a href=\"#标签管理\" class=\"headerlink\" title=\"标签管理\"></a>标签管理</h1><p>标签（tag）是版本库的一个快照，相当于绑定某个commit的指针，拥有一个比commit id 更加简洁的名字。</p>\n<h2 id=\"创建标签\"><a href=\"#创建标签\" class=\"headerlink\" title=\"创建标签\"></a>创建标签</h2><p>命令git tag <tagname>用于新建一个标签，默认为HEAD，也可以指定一个commit id；</p>\n<p>命令git tag -a <tagname> -m “blablabla…”可以指定标签信息；</p>\n<p>命令git tag可以查看所有标签。</p>\n<ol>\n<li>切换至目标分支</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch</span><br><span class=\"line\">* dev</span><br><span class=\"line\">  master</span><br><span class=\"line\">$ git checkout master</span><br><span class=\"line\">Switched to branch &#39;master&#39;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>git tag <name></strong>创建标签</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git tag v1.0</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><strong>git tag</strong>查看所有标签</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git tag</span><br><span class=\"line\">v1.0</span><br></pre></td></tr></table></figure>\n\n<p>可通过commit id给版本打标签</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git log --pretty&#x3D;oneline --abbrev-commit</span><br><span class=\"line\">12a631b (HEAD -&gt; master, tag: v1.0, origin&#x2F;master) merged bug fix 101</span><br><span class=\"line\">4c805e2 fix bug 101</span><br><span class=\"line\">e1e9c68 merge with no-ff</span><br><span class=\"line\">f52c633 add merge</span><br><span class=\"line\">cf810e4 conflict fixed</span><br><span class=\"line\">5dc6824 &amp; simple</span><br><span class=\"line\">14096d0 AND simple</span><br><span class=\"line\">b17d20e branch test</span><br><span class=\"line\">d46f35e remove test.txt</span><br><span class=\"line\">b84166e add test.txt</span><br><span class=\"line\">519219b git tracks changes</span><br><span class=\"line\">e43a48b understand how stage works</span><br><span class=\"line\">1094adb append GPL</span><br><span class=\"line\">e475afc add distributed</span><br><span class=\"line\">eaadf4e wrote a readme file</span><br></pre></td></tr></table></figure>\n\n<p>比方说要对add merge这次提交打标签，它对应的commit id是f52c633，敲入命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git tag v0.9 f52c633</span><br><span class=\"line\">$ git tag</span><br><span class=\"line\">v 0.9</span><br><span class=\"line\">v 1.0</span><br></pre></td></tr></table></figure>\n\n<p>用git show <tagname>查看tag信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git show v0.9</span><br><span class=\"line\">commit f52c63349bc3c1593499807e5c8e972b82c8f286 (tag: v0.9)</span><br><span class=\"line\">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class=\"line\">Date:   Fri May 18 21:56:54 2018 +0800</span><br><span class=\"line\"></span><br><span class=\"line\">    add merge</span><br><span class=\"line\"></span><br><span class=\"line\">diff --git a&#x2F;readme.txt b&#x2F;readme.txt</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>可以绑定有说明的tag: git tag -a <tagname> -m “”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb</span><br><span class=\"line\">$ git show v0.1</span><br><span class=\"line\">tag v0.1</span><br><span class=\"line\">Tagger: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class=\"line\">Date:   Fri May 18 22:48:43 2018 +0800</span><br><span class=\"line\"></span><br><span class=\"line\">version 0.1 released</span><br><span class=\"line\"></span><br><span class=\"line\">commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (tag: v0.1)</span><br><span class=\"line\">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class=\"line\">Date:   Fri May 18 21:06:15 2018 +0800</span><br><span class=\"line\"></span><br><span class=\"line\">    append GPL</span><br><span class=\"line\"></span><br><span class=\"line\">diff --git a&#x2F;readme.txt b&#x2F;readme.txt</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。</p>\n<h2 id=\"操作标签\"><a href=\"#操作标签\" class=\"headerlink\" title=\"操作标签\"></a>操作标签</h2><p>命令git push origin <tagname>可以推送一个本地标签；</p>\n<p>命令git push origin –tags可以推送全部未推送过的本地标签；</p>\n<p>命令git tag -d <tagname>可以删除一个本地标签；</p>\n<p>命令git push origin :refs/tags/<tagname>可以删除一个远程标签。</p>\n<p>tag打错了，git tag -d <tagname>可以删除。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git tag -d v0.1</span><br><span class=\"line\">Deleted tag &#39;v0.1&#39; (was f15b0dd)</span><br></pre></td></tr></table></figure>\n\n<p>推送特定tag到远程<strong>git push origin <tagname></strong>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push origin v1.0</span><br><span class=\"line\">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class=\"line\">To github.com:michaelliao&#x2F;learngit.git</span><br><span class=\"line\"> * [new tag]         v1.0 -&gt; v1.0</span><br></pre></td></tr></table></figure>\n\n<p>一次性推送全部tag到远程：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push origin --tags</span><br><span class=\"line\">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class=\"line\">To github.com:michaelliao&#x2F;learngit.git</span><br><span class=\"line\"> * [new tag]         v0.9 -&gt; v0.9</span><br></pre></td></tr></table></figure>\n\n<p>删除远程标签：<br>首先删除本地标签：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git tag -d v0.9</span><br><span class=\"line\">Deleted tag &#39;v0.9&#39; (was f52c633)</span><br></pre></td></tr></table></figure>\n\n<p>其次从远程删除：<strong>$ git push origin :refs/tags/<tagname></strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push origin :refs&#x2F;tags&#x2F;v0.9</span><br><span class=\"line\">To github.com:michaelliao&#x2F;learngit.git</span><br><span class=\"line\"> - [deleted]         v0.9</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"use-Github\"><a href=\"#use-Github\" class=\"headerlink\" title=\"use Github\"></a>use Github</h1><p>首先，在某个你想要参与修改的库中fork,相当于在自己的github账号底下克隆了一个远程库，这样的话，我们就可以对我们自己的远程库进行修改，最后将这个修改pull request给库主人，交给他审核即可。</p>\n<p>对自己的库修改：</p>\n<ol>\n<li>clone</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone git@github.com:Unalian&#x2F;learngit-1.git</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>change</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim Unalian.txt</span><br><span class=\"line\">&#x2F;&#x2F;change the name:mv Unalian.txt una.txt</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>add una.txt</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">commit -m &quot;add una.txt to master&quot;</span><br></pre></td></tr></table></figure>\n\n<p>注意，以上是将本地进行了修改。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin master</span><br></pre></td></tr></table></figure>\n\n<p>我们的远程库learngit-1修改好了，之后就可以pull request了。</p>\n<h2 id=\"使用码云\"><a href=\"#使用码云\" class=\"headerlink\" title=\"使用码云\"></a>使用码云</h2><p>当github速度慢的时候可以进行操作</p>\n<p><a href=\"http://git-scm.com/\" target=\"_blank\" rel=\"noopener\">http://git-scm.com</a> （指令总结）</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"概览\"><a href=\"#概览\" class=\"headerlink\" title=\"概览\"></a>概览</h1><p>一. 标签管理</p>\n<ol>\n<li>创建标签</li>\n<li>操作标签</li>\n</ol>\n<p>二. github</p>\n<ol>\n<li>使用码云 </li>\n</ol>","more":"<h1 id=\"标签管理\"><a href=\"#标签管理\" class=\"headerlink\" title=\"标签管理\"></a>标签管理</h1><p>标签（tag）是版本库的一个快照，相当于绑定某个commit的指针，拥有一个比commit id 更加简洁的名字。</p>\n<h2 id=\"创建标签\"><a href=\"#创建标签\" class=\"headerlink\" title=\"创建标签\"></a>创建标签</h2><p>命令git tag <tagname>用于新建一个标签，默认为HEAD，也可以指定一个commit id；</p>\n<p>命令git tag -a <tagname> -m “blablabla…”可以指定标签信息；</p>\n<p>命令git tag可以查看所有标签。</p>\n<ol>\n<li>切换至目标分支</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch</span><br><span class=\"line\">* dev</span><br><span class=\"line\">  master</span><br><span class=\"line\">$ git checkout master</span><br><span class=\"line\">Switched to branch &#39;master&#39;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>git tag <name></strong>创建标签</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git tag v1.0</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><strong>git tag</strong>查看所有标签</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git tag</span><br><span class=\"line\">v1.0</span><br></pre></td></tr></table></figure>\n\n<p>可通过commit id给版本打标签</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git log --pretty&#x3D;oneline --abbrev-commit</span><br><span class=\"line\">12a631b (HEAD -&gt; master, tag: v1.0, origin&#x2F;master) merged bug fix 101</span><br><span class=\"line\">4c805e2 fix bug 101</span><br><span class=\"line\">e1e9c68 merge with no-ff</span><br><span class=\"line\">f52c633 add merge</span><br><span class=\"line\">cf810e4 conflict fixed</span><br><span class=\"line\">5dc6824 &amp; simple</span><br><span class=\"line\">14096d0 AND simple</span><br><span class=\"line\">b17d20e branch test</span><br><span class=\"line\">d46f35e remove test.txt</span><br><span class=\"line\">b84166e add test.txt</span><br><span class=\"line\">519219b git tracks changes</span><br><span class=\"line\">e43a48b understand how stage works</span><br><span class=\"line\">1094adb append GPL</span><br><span class=\"line\">e475afc add distributed</span><br><span class=\"line\">eaadf4e wrote a readme file</span><br></pre></td></tr></table></figure>\n\n<p>比方说要对add merge这次提交打标签，它对应的commit id是f52c633，敲入命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git tag v0.9 f52c633</span><br><span class=\"line\">$ git tag</span><br><span class=\"line\">v 0.9</span><br><span class=\"line\">v 1.0</span><br></pre></td></tr></table></figure>\n\n<p>用git show <tagname>查看tag信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git show v0.9</span><br><span class=\"line\">commit f52c63349bc3c1593499807e5c8e972b82c8f286 (tag: v0.9)</span><br><span class=\"line\">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class=\"line\">Date:   Fri May 18 21:56:54 2018 +0800</span><br><span class=\"line\"></span><br><span class=\"line\">    add merge</span><br><span class=\"line\"></span><br><span class=\"line\">diff --git a&#x2F;readme.txt b&#x2F;readme.txt</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>可以绑定有说明的tag: git tag -a <tagname> -m “”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb</span><br><span class=\"line\">$ git show v0.1</span><br><span class=\"line\">tag v0.1</span><br><span class=\"line\">Tagger: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class=\"line\">Date:   Fri May 18 22:48:43 2018 +0800</span><br><span class=\"line\"></span><br><span class=\"line\">version 0.1 released</span><br><span class=\"line\"></span><br><span class=\"line\">commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (tag: v0.1)</span><br><span class=\"line\">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class=\"line\">Date:   Fri May 18 21:06:15 2018 +0800</span><br><span class=\"line\"></span><br><span class=\"line\">    append GPL</span><br><span class=\"line\"></span><br><span class=\"line\">diff --git a&#x2F;readme.txt b&#x2F;readme.txt</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。</p>\n<h2 id=\"操作标签\"><a href=\"#操作标签\" class=\"headerlink\" title=\"操作标签\"></a>操作标签</h2><p>命令git push origin <tagname>可以推送一个本地标签；</p>\n<p>命令git push origin –tags可以推送全部未推送过的本地标签；</p>\n<p>命令git tag -d <tagname>可以删除一个本地标签；</p>\n<p>命令git push origin :refs/tags/<tagname>可以删除一个远程标签。</p>\n<p>tag打错了，git tag -d <tagname>可以删除。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git tag -d v0.1</span><br><span class=\"line\">Deleted tag &#39;v0.1&#39; (was f15b0dd)</span><br></pre></td></tr></table></figure>\n\n<p>推送特定tag到远程<strong>git push origin <tagname></strong>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push origin v1.0</span><br><span class=\"line\">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class=\"line\">To github.com:michaelliao&#x2F;learngit.git</span><br><span class=\"line\"> * [new tag]         v1.0 -&gt; v1.0</span><br></pre></td></tr></table></figure>\n\n<p>一次性推送全部tag到远程：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push origin --tags</span><br><span class=\"line\">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class=\"line\">To github.com:michaelliao&#x2F;learngit.git</span><br><span class=\"line\"> * [new tag]         v0.9 -&gt; v0.9</span><br></pre></td></tr></table></figure>\n\n<p>删除远程标签：<br>首先删除本地标签：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git tag -d v0.9</span><br><span class=\"line\">Deleted tag &#39;v0.9&#39; (was f52c633)</span><br></pre></td></tr></table></figure>\n\n<p>其次从远程删除：<strong>$ git push origin :refs/tags/<tagname></strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push origin :refs&#x2F;tags&#x2F;v0.9</span><br><span class=\"line\">To github.com:michaelliao&#x2F;learngit.git</span><br><span class=\"line\"> - [deleted]         v0.9</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"use-Github\"><a href=\"#use-Github\" class=\"headerlink\" title=\"use Github\"></a>use Github</h1><p>首先，在某个你想要参与修改的库中fork,相当于在自己的github账号底下克隆了一个远程库，这样的话，我们就可以对我们自己的远程库进行修改，最后将这个修改pull request给库主人，交给他审核即可。</p>\n<p>对自己的库修改：</p>\n<ol>\n<li>clone</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone git@github.com:Unalian&#x2F;learngit-1.git</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>change</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim Unalian.txt</span><br><span class=\"line\">&#x2F;&#x2F;change the name:mv Unalian.txt una.txt</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>add una.txt</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">commit -m &quot;add una.txt to master&quot;</span><br></pre></td></tr></table></figure>\n\n<p>注意，以上是将本地进行了修改。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin master</span><br></pre></td></tr></table></figure>\n\n<p>我们的远程库learngit-1修改好了，之后就可以pull request了。</p>\n<h2 id=\"使用码云\"><a href=\"#使用码云\" class=\"headerlink\" title=\"使用码云\"></a>使用码云</h2><p>当github速度慢的时候可以进行操作</p>\n<p><a href=\"http://git-scm.com/\" target=\"_blank\" rel=\"noopener\">http://git-scm.com</a> （指令总结）</p>"},{"date":"2020-02-01T16:00:00.000Z","password":6235283,"abstract":"This is pricate passage, please enter the passpord.","message":"This is pricate passage, please enter the passpord.","_content":"# 基于hexo的配置\n## 基本结构\n\nhexo的下载和配置参见[官网](https://hexo.io)，有详细的下载，配置，模板信息。并且介绍了文件的结构，对于学习前端知识有很大的帮助。\n\n如下是下载后的文件夹内部结构。其中，source是根目录，_posts存放单个post，格式是.md。\n\n_config.yml存放一些结构文件，其中常修改的是title, author, language\n\n<!-- more -->\n\n```\n`.├── _config.yml├── package.json├── scaffolds├── source|   ├── _drafts|   └── _posts└── themes`\n```\n\n##  _post\n\n(1) _posts存放单个post，格式是.md。\n\n(2) quote：(修改_posts)\n\n```yaml\n`{% blockquote %}Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem.{% endblockquote %}`\n```\n\n(3) Categories & Tags（修改_posts）\n\n```yaml\ncategories:\n- Sports\n- Baseball\ntags:\n- Injury\n- Fight\n- Shocking\n```\n\n## page\n\n建立新的导航菜单项：\n\n* 前往你的Hexo博客的根目录\n\n* 输入`hexo new page tags`\n\n* 找到`source/tags/index.md`这个文件\n\n* 修改这个文件：\n\n  ```yaml\n  ---\n  title: 标签\n  date: 2018-01-05 00:00:00\n  type: \"tags\"\n  ---\n  ```\n\ntype必须是`tags`，增加`categories`页面的话也是一样的。\n\n* 然后配置melody.yml（即./themes/melody/_config.yml)\n\n  ```yaml\n  menu:\n    Home: /\n    Archives: /archives\n    Tags: /tags\n    Categories: /categories\n  ```\n\n## 节选\n\n<!-- more -->之前的内容将在主页显示\n\n# themes\n\n## 修改主题\n\n主题的配置选用了[melogy](https://molunerfinn.com/hexo-theme-melody-doc/zh-Hans) \n\n* 在github中下载后，自动配置入themes文件夹中，并为git文件夹（这可能是造成整个blog文件无法push的原因，但是还不确定在一个本地仓库中还有一个仓库是否会影响git push，现状是最后本地可运行的blog文件无法被git push）。\n\n* 配置blog文件中的_config.yml，将themes改为melogy\n\n## 配置_config.yml(./themes/melody/ _config.yml)\n\ntheme_color: (修改主题色)\n\nmenu：(1.3 修改导航菜单)\n\nfavicon: /dog2.ico （修改网站图标 .ico格式）\n\nhighlight_theme: light （代码高亮模式 其他模式还有pale night, dark, ocean）\n\nfireworks: true （点击特效，在./themes/melody/source/js/firework.js中可修改特效）\n\nsocial:github fa: [https://github.com/Unalian]()  (社交网站图标，点击可关联社交媒体。设置详细方法参见主题配置说明网站)\n\navatar: /rushroom.jpg （头像）\n\ntop_img: /lightInDark.jpg # false or url of img\n\ntop_img_height: 80 # best range: 60 - 100（顶图设置）\n\nfooter_custom_text: to be or not to be （底字）\n\n## layout\n\n.pug格式：所谓的pug就是jade,也就是一种通过缩进的方式来编写代码的过程，在编译的过程中，我们不需要考虑标签是否闭合的问题。此外，用这种编译方式，加快了我们写代码的速度，也为代码复用提供了便捷。\n\n可用以修改网页内容，对这一部分的修改并不多。\n\n# 服务器的建立与使用\n\n## 租用服务器\n\n在k的引导下，租用了阿里云的服务器（轻量级应用服务器）。（云翼计划，学生每月9.8）\n\n设置为系统镜像，系统为CentOS。在terminal访问时的指令是：\n\n```\nssh root@47.***.***.155\n```\n\nk解析到了ip.***.monster 上，并且设置了数字签名，让登录更加方便了呢。()\n\n## 修改blog内容:**Rsync**\n\n```\nrsync  -av  /test/  /backup --本机上的同步，把/test目录下的内容同步到/backup目录下(包括隐藏文件)\n\nrsync  -av  192.168.1.20:/backup/  /backup/   --把远端192.168.1.20的/backup目录下的内容同步到本地的/backup目录\n\n（注意：路径写法的区别！原目录后面加不加/也影响你的同步目录；没加/，就是将目录本身同步过去；目录加/，就是将目录里的内容同步过去！）\n\nrsync  -av  /home  --exclude=abc  /backup    --将/home目录下除了abc其他内容都同步到/backup目录下\n\nrsync  -a  --delete  /backup/  /test/                 --如果同步后，源主机中有文件删除了，这时要想目标主机与源主机的内容保持一致，可以使用--delete参数进行同步\n```\n\n在本机blog文件外 \n\n```\n#  rsync  -av  /test/  192.168.1.20:/backup          --把本地的/test目录内容，同步到远端191.168.1.10的/backup目录下\n```\n\n# exp\n\n* 最大的教训就是要做好版本控制，在过程中出现了好几次以外的错误，却不知道是哪里出了错，因此以后应该利用git做好版本控制，减少工作清零的风险。\n* 这次反复出现的一个问题是系统强制改了一个关键文件，我一直没发现这个问题，最后一次经过对报错的分析终于找到了这个问题。\n\n\n\n# v2ray \n\n![见文档](https://www.v2ray.com/chapter_00/install.html)\n\n\n\n最简单的 单也算是自己成功了\n\n\n\n![](https://img.cetacis.dev/uploads/big/622e953653dd2222979f2e7ceb8020ec.jpg)","source":"_posts/blog搭建以及服务器初试.md","raw":"---\ndate: 2020/2/2\ntags:\n- blog\n- 服务器\n- hexo\n- 自学笔记\ncategories:\n- 计算机网络\n- blog搭建（hexo\npassword: 6235283\nabstract: This is pricate passage, please enter the passpord.\nmessage: This is pricate passage, please enter the passpord.\n---\n# 基于hexo的配置\n## 基本结构\n\nhexo的下载和配置参见[官网](https://hexo.io)，有详细的下载，配置，模板信息。并且介绍了文件的结构，对于学习前端知识有很大的帮助。\n\n如下是下载后的文件夹内部结构。其中，source是根目录，_posts存放单个post，格式是.md。\n\n_config.yml存放一些结构文件，其中常修改的是title, author, language\n\n<!-- more -->\n\n```\n`.├── _config.yml├── package.json├── scaffolds├── source|   ├── _drafts|   └── _posts└── themes`\n```\n\n##  _post\n\n(1) _posts存放单个post，格式是.md。\n\n(2) quote：(修改_posts)\n\n```yaml\n`{% blockquote %}Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem.{% endblockquote %}`\n```\n\n(3) Categories & Tags（修改_posts）\n\n```yaml\ncategories:\n- Sports\n- Baseball\ntags:\n- Injury\n- Fight\n- Shocking\n```\n\n## page\n\n建立新的导航菜单项：\n\n* 前往你的Hexo博客的根目录\n\n* 输入`hexo new page tags`\n\n* 找到`source/tags/index.md`这个文件\n\n* 修改这个文件：\n\n  ```yaml\n  ---\n  title: 标签\n  date: 2018-01-05 00:00:00\n  type: \"tags\"\n  ---\n  ```\n\ntype必须是`tags`，增加`categories`页面的话也是一样的。\n\n* 然后配置melody.yml（即./themes/melody/_config.yml)\n\n  ```yaml\n  menu:\n    Home: /\n    Archives: /archives\n    Tags: /tags\n    Categories: /categories\n  ```\n\n## 节选\n\n<!-- more -->之前的内容将在主页显示\n\n# themes\n\n## 修改主题\n\n主题的配置选用了[melogy](https://molunerfinn.com/hexo-theme-melody-doc/zh-Hans) \n\n* 在github中下载后，自动配置入themes文件夹中，并为git文件夹（这可能是造成整个blog文件无法push的原因，但是还不确定在一个本地仓库中还有一个仓库是否会影响git push，现状是最后本地可运行的blog文件无法被git push）。\n\n* 配置blog文件中的_config.yml，将themes改为melogy\n\n## 配置_config.yml(./themes/melody/ _config.yml)\n\ntheme_color: (修改主题色)\n\nmenu：(1.3 修改导航菜单)\n\nfavicon: /dog2.ico （修改网站图标 .ico格式）\n\nhighlight_theme: light （代码高亮模式 其他模式还有pale night, dark, ocean）\n\nfireworks: true （点击特效，在./themes/melody/source/js/firework.js中可修改特效）\n\nsocial:github fa: [https://github.com/Unalian]()  (社交网站图标，点击可关联社交媒体。设置详细方法参见主题配置说明网站)\n\navatar: /rushroom.jpg （头像）\n\ntop_img: /lightInDark.jpg # false or url of img\n\ntop_img_height: 80 # best range: 60 - 100（顶图设置）\n\nfooter_custom_text: to be or not to be （底字）\n\n## layout\n\n.pug格式：所谓的pug就是jade,也就是一种通过缩进的方式来编写代码的过程，在编译的过程中，我们不需要考虑标签是否闭合的问题。此外，用这种编译方式，加快了我们写代码的速度，也为代码复用提供了便捷。\n\n可用以修改网页内容，对这一部分的修改并不多。\n\n# 服务器的建立与使用\n\n## 租用服务器\n\n在k的引导下，租用了阿里云的服务器（轻量级应用服务器）。（云翼计划，学生每月9.8）\n\n设置为系统镜像，系统为CentOS。在terminal访问时的指令是：\n\n```\nssh root@47.***.***.155\n```\n\nk解析到了ip.***.monster 上，并且设置了数字签名，让登录更加方便了呢。()\n\n## 修改blog内容:**Rsync**\n\n```\nrsync  -av  /test/  /backup --本机上的同步，把/test目录下的内容同步到/backup目录下(包括隐藏文件)\n\nrsync  -av  192.168.1.20:/backup/  /backup/   --把远端192.168.1.20的/backup目录下的内容同步到本地的/backup目录\n\n（注意：路径写法的区别！原目录后面加不加/也影响你的同步目录；没加/，就是将目录本身同步过去；目录加/，就是将目录里的内容同步过去！）\n\nrsync  -av  /home  --exclude=abc  /backup    --将/home目录下除了abc其他内容都同步到/backup目录下\n\nrsync  -a  --delete  /backup/  /test/                 --如果同步后，源主机中有文件删除了，这时要想目标主机与源主机的内容保持一致，可以使用--delete参数进行同步\n```\n\n在本机blog文件外 \n\n```\n#  rsync  -av  /test/  192.168.1.20:/backup          --把本地的/test目录内容，同步到远端191.168.1.10的/backup目录下\n```\n\n# exp\n\n* 最大的教训就是要做好版本控制，在过程中出现了好几次以外的错误，却不知道是哪里出了错，因此以后应该利用git做好版本控制，减少工作清零的风险。\n* 这次反复出现的一个问题是系统强制改了一个关键文件，我一直没发现这个问题，最后一次经过对报错的分析终于找到了这个问题。\n\n\n\n# v2ray \n\n![见文档](https://www.v2ray.com/chapter_00/install.html)\n\n\n\n最简单的 单也算是自己成功了\n\n\n\n![](https://img.cetacis.dev/uploads/big/622e953653dd2222979f2e7ceb8020ec.jpg)","slug":"blog搭建以及服务器初试","published":1,"updated":"2020-03-27T15:09:17.000Z","title":"blog搭建以及服务器初试","_id":"ck67gmur70001o3mxb5gugexw","comments":1,"layout":"post","photos":[],"link":"","content":"<div id=\"hexo-blog-encrypt\" data-wpm=\"Oh, this is an invalid password. Check and try again, please.\" data-whm=\"OOPS, these decrypted content may changed, but you can still have a look.\">\n  <div class=\"hbe-input-container\">\n  <input type=\"password\" id=\"hbePass\" placeholder=\"\" />\n    <label for=\"hbePass\">This is pricate passage, please enter the passpord.</label>\n    <div class=\"bottom-line\"></div>\n  </div>\n  <script id=\"hbeData\" type=\"hbeData\" data-hmacdigest=\"5d589f06e6ee71b4b3d4e6b556704094e27e756c4d37b490d13bde56c9cf4d4b\">380efbcb598b2f98e7ee074936afab27ea6737ba43731f0a74132b9232d62933f556e713f4d20f10f99b7d0c565835035c1d25b19a3a0e7eabd35f7a4070ed87d494cfa5d9a68b8a92b95fd4aef5a6f22aa687031c0a1be87e54fa3ea7e93c69c5d9fb27d873e4e86015045a642c853e3e835888fc3339dae14b4fbe3b97b35fc3f1b434cc97016141737b3b6ccac85ee01b438ad41f4375067bed25cc67ca8725f58dfd458156d6356de3305b37c0df2a584d43d4166c3ea7382264f02f6473c73ef2d68fba36a106e77b29c4d872c4896c38c58aae099bb972defec5b38916581b7a114ad740a334447b5cc40c5d0629a8217cc583542fe5135d17c95991b8989ef2864669c343660d142447318a7e48cc784b0aa366afbbc3b13447b40d64dd51d19e56e7b6fa7d2ff2bf1c2f0474d2a587da54f94b7cab9aec2a4ca9a8fd9ef5f68a7b293c238fd8a4e445eca2d6581b82e3e2696b1e15bf6f737501926c73fde04fbb72ce97296b32a6c69318f77f893ebf56710ae105e514fc8e55f55b63199ccc58140276042c60fc47d8a2868b27892f4569c6edddb2d8382baa1b99e8f85f71d3e8c2073373599416f85a88045e7917b2221a042bf2caa4f5cd4bfe68a494d9f739f7603257c75e7d14bc5bffa34c2543717f9413bd72f41399459eecf896174888c2dd4ac8cd1e16cc3be7c24424be686a919bd688375948889ff71cd2d1f436643c6b75da71b4f1c98c9e9d465760632fc7ed5463e58dd3bd4c3aad1a1331ae02204ba91a40274a377df9576873b0e4c823487ac159cb8faa08fd3665e5de9ecdcaad5c3b1c74f4f0b952a2b2ed2b2addccad52864c720a655457e74625ec1d771afc42343bcf11824e7bf4fd4e8422192d886dea96302f23fb1b15998f20624c47c9ef10e0eec995042ffee2c42c0e1c5fc9c8f9f80fb491b22b7e12cfd91abf867316dad49e75e695a19114b6463f8f4e963dcaef3758913d80e47f5a634d1e63207fcf73aeb5f4c46c5f34d68088ed57d0d4ee5312edca521673512f4cba79e9516fd868ffc9f88af784141892ded29fdb248ca5e11a6e78a2d4a4350cdee5fe01aca43478505948cc2350ad641c96be2c96ea8df31588538691302dddbaecbb6ef437a10e508fe4e0d36e4e427380f74958ab82ec558ec13cf501536d05744e227846ec142d1918336160e8d4f4ef2b24a41e3a5879d5d9317e2f1f705707998db8aebabe8ef560a8a9fbc4b0e9b4d742ad9cb385eb16f3129a6e25cf95213d8d28634c0d907e4b1903caf36c8ae7f0b621fb6e434e1561805ef039d96c115e9542165c06840c8cdfb24af631738785bd3d0120da9fe97a652c9cefbc4861d5b22b27fa11c2d3f411ef058e6fb90e8edc0bfb682af39f4f6745f5716f710002b2d6dd43b7e00d112a0437a51ee532be1dd6efd091f04e28e0f50e038f2d9cd6e4756cde2f1237a02c3ce1987f6b5ef1bc5943f0889d13640c8641ce2230b1585dabb4cd640ef10e587850ea384857eaf7f0b114e6e48721cf43051e8f979cdf8f54348deff3ce5ffc568f780896081119e8296e9161df96c53dec25cfa34736af0efddab35f6ae1f28ed11f1115bedc6b3bb0404badb18461d7884616db04ec1d4ef44877fa27bf0ec5ae270936c4339a22f8a36ce6bcddd30e42ff8af1035b142dd773e0ac271c2aa7e437baf14d9ef1cec7bce34a945554fdce5bad69a8cdc5128d336f247814d7904aea2671d90eba35731f7469e9474afe06fcd3071b03e99e7ae3fcba754d3bdeb639dac273108760dc33d114e1e3ba2bceeb8210fa36246e3a07a45a23556df1bfd8fb7fd0ac17383eff088725edbc869159a219f2523a994b2f8d979bf546f611bdb0df6d1e6eef741ac135a077bdb934fe0266ea2514ceef31cb0eb0e74b1d805555870760a72fabd3790cbdc98aaa679dda4b0e3bcf932835e8195a0ad526a17bc071b3622ebe9f7d5867e82da13a345839eb64354cbb7c7a49cb06f98d7e8be7cf8bc14508f760fd84f53b21f94f5fdc3cbbeba8cce0c47b4e8979ab3ab40e1ea001814acd1e5a6c2a324e78a810ca3e4cbe84842a1403c4c385baf1f4081c34292a71b47fd2ff83e605fcb8303465e833f1504b0870cf0b140a57176a0ff0386d0ebbeb6cdb795cce9f47e0da9df79038428d7024c4d9ac0ebdc7e8dae78cc573c57cf4541fb1eff717410becb73d0ea5dbdda842f0dabfa50d5a039baef6ceff215df6cd829eac97b01646f2cfa94aa435e9469273448ad41ac0b385143da4333cba760a44b2571fbcf47495da6c6a846ef5fc1baaa8e4855e772629e7a88bc1e6af786b348a479c1282e489e18a479794a33f8a5fa37b2d7deeceb5e7a771bf44490b7055b5a663885b7ae74584517e54bdf669783d0a79272f52b74a829e40818f7eedaa8d7b6f7971b6e2ef76b0118ad80e9b462b65af4219e9213fe4dab4e201adec16938592e17198961741ff9bd378f0ccdcb45c2de3a017bb241ee8e1c374c0b3fba5605399ba6a1601da413a207542337a215906c585b80bcc44251f82b3aea7b41b91bf26a31621eee4dbc5825da53fa9d8cbb35273a6da6afe7ab22570344b859b55475dab64b44f6a745e1d9a12fc0bf28683b1c0efdd77f5e76c4366d24eeba43350a0025fae233f84ee401910914925b9fc761b2c6d2fe50098f9b9066a7045256481f5deed70318656ed4b8163ab06f4539f0da07478d30bc2958e733149be5cd26cbd51da7d0f601942006138224baa5398e6983b64d46c329d745c191ce5848237d0569d487c75e63569de0617ab38c3c16d936a3a62ff1b331cb50b123dd91a3df64dbc379a492ca1e99d737556caec1dedb3f2cacea6107e7b0187425caf5a65d0be9347b5ad45e97dce3cb6d8103f0379602d84bfb26398c14eb5c65d284d13f7770fc2d4e539454afd775d453731ee76ad2c8b20386cc39c6a50efcb7299f39bbeb189b48beb03d0b2ae0f400ff49ccb054797397d0a86dcbb79723930a26216151da29b22f329e4edf161ebba87b25e3d18c2f6f53d27779bdbed26ba34430443ed04c026c66b2fc4f6728499028ffad68cdd9d8bd9f349733fdc08664cd15690d65e96e5021ede7a70ea3a2ee3bc9b82421cc0499d183e1933955fbde890c267f5088590918c109d321304fe3b0a9f3a91226c6d69fe0a74be6c4bbe0bcbdf2e00cd8d75032c0aaeed17ed15bbca3346359bd6c60fac3debdb205e122868445fb6a01c4f1de62d447ba45b4d43c217afda34fb190c53436140cd4c33f053ed1b558de8fa214d59586f720bd5c165265206008b01db2d1a7f7893335fa9ac097e82f48888be1dd3d3331f6414daead152b34dfd5fda23d784c07656ee3b0a13cece12375423e62c1ed4e79c468cd4f5ee634e5df3b0cce7d0fb593db04a221a1a367ebd1fe9d1ed5f05338fbfda4fbddda1f159e9682e9f13300070f4c9e376fe84284dfa8bff67208a4da893587c41073330d75b1afce44240f0415208fb5e5206571fcd9f132bd553bb52d16fafad5d5e62e59534e0028c2b4eccbe9d428ae52fcaba0173e754a37f512bec2ad560e05662d1669ac1515a147bf26ec1f5b4ff86a61fc63ccbcb8b2a038774f00d82ab88f42b34404ed50ecbe654fcba6955bf42dd982e1962c940d4d841fd0faf28f6b43cc2f20de5344c4d0fcc8168e83861be1997cbaef10b9f17f09c55e5e40dd3ecc3673dff98e2109db213dc057f12dd9a9519af1db8a5ee295c3b0875efca82d5e815c9e5de9834b84ccfc333e1363a893042300f88ea83b185df7dc899f827806becfc9683015f1dd4e589464bbed307142685b94fd862d3cc58e7d76eb3c0972b97ae335893da814992283d54d2304fc717d2ef8a8b57c328d5818090ea056a754d5e973bf4cd23e0052ba9643850c746fb08affc6ebad10b50621399cd9a678efb66856a72a60ec432709d6c701577d3c13a68529b3573f9bb1dad035008ebf827aa369de8842ed779338111ca40beb5e58440a986eb7b36abad530bb5de9280027c661fc5ac324074614496b55faf92876150d3324ef45e34dc87f78ab8b48468d2e7250106b0670002e75a3124482da52fae2e2e80a18c6e80d4cf7f06a557e03d091610e506bf9bf50d0ec258bd9b29a9c8b7790b993178aa92cb37a9dc404e6d5c796cb6d91edddabdbf9630462a90c29e742908a37121912a8567db99ed42e68e21488ed919db724882e792e6752e0f2c48b50d32b918d57e266cf45fd67f0d13f789a50916dff57d7e0ab3063934c25f257cf87c26c0d23259b588995540c9c5b42a4dafd355c31f4db1bf15efb6eb93fb603004373ad4fb3d7a07ecf36f1464e846959ff4539bcbf0a90b78398f06e7100819454df36ec9b88bedef12ab9e37cc0f2d93fc9c06bff040b762f00df1c2d08a5cfd11a21d2e7be6d97c431240f0f4ad904180dd91dbca325446f061aa0c2731112ac84639a650eb8230304919ceae6098cda98fefedab7027936d89af090a37a1d5297dac8bc6fa241dda504f75060df69907c01a41f3c8d13923010163086415380ecc0bf4a507c8bd98fc437e235b2696b87f738be12665eb5db90ae3dd7df4588932113ec3c7651a113fca1c64946b3d2cc3e17b4f2ad6e4a80dba08658327aed32141e7263f2d395486a3277cad4c8cf489539c14dbeeeed62390a6272a6563f3bca6e591583885f9f189a47c184f463f12bc6d27220d2f5621cd58d7ce9a5db86d44dae076fd51196458a2b167c28857598366b9742984afeee981700b293b0a8e8afaece92ac1aa7c06175123c36113ccd6b52f7936f2300df90c8d9014252503ae8be99d124caea44ae9faf04d43e47396b19ee2f935aba04e50b83a65535fe122d0bd412dcb797992606aeda91bcbeaced583ce3a03f204245bbe9887cc297e5d1448c79c4a8719d2dd31ba18b9749a239a7a8e3892a9d478727db6c95d85e7c070d47e8dc895a8da9e01064fd267a9b91b096db154b229b817fb982ca272eb894921b1ed7f8323ad1d2b4e9145a28b8e2d18ff110c2674512119c0529cff381b0086dbbd8bd4b82f43fe02e6b0d5270066f1a9c215440be6f81598359f63a75891cd7fb84ecf2c0b4205438256347becbc4d9c7ffb39782d498d8c2aafcb299bba1e354159c1ae8471c7a8875e111d321179b1e6cea0a38d0ec2e657f9a2e19a594232e32dde7a7cda1e98221559c010f57b4245cd5b80562502565779ba64e5f7c11057a6d9940922d8f2ce08c16ff0d13eae758c2ac8f2d92d76cabc3923f60649b181ee5da8977ab4ea8a02c746d5c9273a5cb7845991fb781a9e27e87ec27a05db0b2c8e6c5b6be2c39daf486feda45aa12d3ad40d21a1a893d4e7730c358761358d38d9ad1a385111414ff135efc4a8505c2f10a1006282e89b6b36cfd60e6e592575acb8dbacfa5bfb2c4c6c4bfa98c0da3f799cb0badd91d984ad14e1db96b18c44cd7b39322ae1274a4f6f0f69e9bca7282a56fec62386459f9d37a952138286c0020b4bcc4d36a2fe9e4cb428333fb0cc2c0949c36a6652e87a1647336701a54e63b5714ef5a70e5516a3fc10d98943431fab0091a7bd34cf751e44d4e2ef95102e803924b35267f8fdf095b5dbad4f31a7f89a0bdc9dc4aae223f160bdd14e2eb96073aabc350282bb8e2c4afc14ce6c6325fb9cc2330d15b32c0de12f0fc12ed461ca6f8170fb0c0b2d77c08e369ae6eb69975cd40f7b718dd7be14a9a04eacbaae05527affb139d6b7ac3c96d7ae72ebb0dfaf818689cd3fcd45a509a3ba026ce4c91ea27ded0dc88a61a9d8ca51ee1af417e543a3d0ff715e0bce7e83128f02db4daaeca87a5bd21639a46b31aff523b519332b5113c24d5286b97e7a31e76e1c84c2fc5d90f6d79b71ec09ee075aeb5c045c1658f8fe2c03ab23ef9f662e2ec894e01b5624ca3b57ee3f0b266b3124d44d2b42fd0d245248978f2bbdf5aa0353d8ffb1e1f59749c87f91901aac3004f92e57058240bd357f68b7eee55929c9d7af8c6606f1ded950852ba21066b672400528c0110b6c85c00c0d9fb89f34535408803041beee05dedcf8d6ed41361df05cffc555637089fd7c54ed870f5d1c475d53787c3ebd9789365899f8009136f2c38c62eed0c0a35be353f6ee2a19da7ac73a4e5d5d393e6c5084be11ecfee19e418ac5a2a065dd154165d36fb7de48dbef6dae64e6d0ddf50908dec0c770d8dac6888a4697d398d9d03ba6fb1b9bf842b94a67ea866971d76759a2cc5c2a47757c5a646edf3c7e934e9fcdf4654fe71249b173939406ed5fae3dfa906d62ce37afe8b5e62178c30147b5045b96265d7540fc6fab1837e8665a44fa86fc277263df146203d9254f8143392e63a9ee9c6db2030f1143408c9a644fa2fdbe1c7fde788b0480db898d2fe2a08dc34137455a6f48fcf22a48c57f3a97e69e4d68c386c635cb17470f556e5146f69daa283964ecffcbd71e180d54befb576dd38ac4132a9578f0c92b93d0bac4f9ea974e9919d01bf377b04d087c149ef47d895b47ba02f5f7b72cfc694bb10367b434a01e046e624750f52dc1b5f14f5e6530e404c50918e5eeaeb17943032170bd8d2536d20a64f08f030a59c31975a4ac363bfd958f41f4331dac16476ce51be54bcfc01a93009de026b48dbaaa0565419a6aa6d6af457217800da94fc6765c3de3cd003405b6a68d49a3bce56189a655c35d14ed30fedb5e138a3758ceb91fe158997ed3e4941ff4d3d6ed3045db70c733492584105cd3e7b1cd482510c74bf64611bbcd70c9da0444ace4a180354d8479a4610bde9ed13b6b24c604cb707363849c4aa287c2a1f73377c1bfab716b502c77eb4841ec2795e607e6d7dec706afb0c21c0cbfb2a57b638441c967387337f6efa1cae682582575e2643aa66ba9346492e11d11d0f3161686559f3d2403eb162666bad9ebdf5114122b636f835fcaf1530cc5e6847d95c3a5fa2b4e103e03b836d7f5a84666b5271cc01ad745267c897fcafa3c3818a049cf033252840bd10bfb4f5f2fe98107bd583642aac3041b456917d9fcbdf48acd5ef41f981562fc63da8013405fb7ff3510380c85b3ba0d7a78d3df69ba288bbf1f33083c90b2bb119f04cf49b505b78c11ea7f57ce4fcab49716cd0021ad072e69d7ff3230f21d8313ac3ad2ac44faecbdb53163fe1f1fb346693e60b69cc4ff61bc62b607da985c799bc6bd021c756c09aa1b5c1bfd7de7be6a0ce189665d4bdedcfee13c04d03fb1297f3fd4ae12dbdec4cd907e9941e26171705d0ac822483b7c1adf71b43f8811892149ffd7d8067b3b459480015c7c05e04aa8fe6cf2351293caf0cb4f6bfe5a807586a3e431c868bd03ac41651021e861fa0c3bd7a2e562c8de56e4f51de2bfcba2df3f702fba63cdf90027bc546e41289244069518f39a0f960c483e763b64ad6e91b5769bed26b40ab5403d7223558cb9099e700a3498176a2b230cf65b9d57374a3089cb134d4c5bae0ff22d362c1345612e8c85c3406166dedda6c87a5cb92026d0bac061940e9616d1f80ae21ac9c0e327ae2bf18c8978ae458bddf05d12da7cc935f3376b18285b69e6f66809c98192b7e53b524e7c10fd76a430c56185f432202678aa323bafd70479d290b4e0f0116af38daf6d318069912f0d1d64655c5060e37b46e53bc015c0f864bd16c80ae32bd80de34baa8fecbad3ac23e08b0129cc0d59ca807cf98b14dcf13b8989e03441cba5216f637e179ffe14a0872bc252ad2e8dffbd69a7c0533374b0b0af05e490915c99ba125e0806c50b15afd94d9757f042631655f03b0e108f1a8283d2488db5ee3c0c4843a37dd0ad20ebb2019e1e56596f5927f493063378f1b68fe8a51a09cbcb71c832be92d1a074df68ddcd4758f31dc77b35fe91da86dbf8adcc72ff603f44156809f73a43093050a6e22c657c46d40d3cf38733535508578f876fe1291991bac9ac9de0f6dca065c55ae8cd17cc474557e44735d66a4c92a492a8552e5f9cca3c3e36175896f435d8256860056ac4199f9cb6d5bb6faf78334e9066a037d71eda9f6958d25fe17f69fa23e815b06dc92f7ac9796fe36f7298aa1b0b903e0543f43fbbac9e06a89b856143faa28b0e721ac6931b8665912d83271f256db17269d18bcde9f98014a4174ab5052d3dac31be66f233ab9889e6d974dbb092e9cd03ed5bb41b85905e0122e142ca6797201ad3026b6bc53c36e317c88dc3f36cddd9faaba8183f4a743acfbcac5954964d77acf7d1f21723ea5f715640c1104d37a25d2a8c44908412ff6bc2949cf8c9ca66f77465aabebed0b2e0a6a5d87302f44d57373e104fb52510bf3cfc9900512591a7dd6fa9638b41f694012205a47f11fb70ff80ead6d99cbe0ede548db665dd482a32ab756d93e36ed17dc22033eb6797f405f14fbd6beaeb93209fb1e8fa95f0960d8804c8a383ccf9c0751395aa9a03ec9234b9bb981f9277e2999c30b8d44c07c719cfda1d6fb39ab0415ed3cb942699077b29ad94eb0b57dd1fedae434f233f2b7a20f2a8b595832249788eabbf945e26b7e4e5b1b02c76e68d996a26d708884d0ea9428d5c534de0cf931758d413f98d918e906cfe729ef9e6b39b41cb0cfdf51cf9235e5997e93e8aea9755600534ccc32768769ed67a7bceb6cdb7e4ee124c5f00af7069ec53dcd2000292ac53aadc44da16084cbef32233dd2a63b6ae6710b794451be47517fbfc68fd1f096a4726847e654ed195a47cd3ed7e845091d251f66383151a70a4a19f7cc2d85a556ac151c7b0b875ec5ed3517dc6b7bcf1345fb80d1355b1550c83ccbf3861c0b7997513a183d893b20de4032d4e33b402e8e7e8362640b8acc98bc8d7bf34171ba35d7e6010d85484017dd961b8c334eca2837c79b569ee503c6bd5eb05070cd029a4604f7b4a44c530a91658791611e9df83ba518a32de4586e8151efb52946b01871ef821bc22954afa27f67d414d3fc3fd62817bb225cf703cdfe68c4228b8f367b3dc1ae4acd0909c99b8fdfee3e576b01c900b54fcb305bf272a3f94dfc804945036ec513a8c2cb14e7cde514ce234fc80d181f8512325e2e1b687b163ebcb6235fa48c5900323dcba75e67d7b7bd8ed51607d5958493f6104037dee8e7672d4496725c56ee868cf8fce6b2d169956dc70bd0edbcc19003fb7654b5540ac447841c21e9847bb01a369c6bb817947c12282002795a6e6bf522e92067f2dd2d91ff346882954bbcd5658e2ab406cd3fd441e803938bb2a146eb2c2dce7eac2e03d74cc7130507b01d4f8c19e3778f6976b8df24836e837ee16b2d7e52d71e0ff3c8a7f5503991219b8449a006881e5157dabe247b9c237b9d07408438c6e48641e097c449afaeb4575d0d8a33e7515130049ff1789f15bc0f90fda5a36eef6839b45728f3de02e591cb9869f9173bca33c1f7b657472c9c941b65d41c003e1ec2022c0cc5c35ab69dd22321bf92701a41881558a6499a82e64c9a0d57c9a941d45f5712c6bc58b2160af3d4ada3960b9ca57b7f785df425c928b0e3a1b105fb64cb63338c8b511121c96fda155293b6c451b9baa530318eaa89154a0d047ca48c38a8b1b726893f3c71caa9a30852874b10f5b1e4b0cd46a044c2bc850ccf6f3d7b5d8acf57fc5a8d27f6120a76926baceebd2b107967b193d42a8c69495d55acc1058a321dd6d75ba2463f4a95dbd93cbd5190d426922b1d91fb09530405519b0f18a9cc9a038a330746c384199624d7dc3353b36943684b4b10687eff3188834ca7afd2d1bd0a532cfdf1fd2ced47bcdb005c78a227c7aea1a2223ef5a5b6e87a1f90b3fd3acbeab961566b443ce42b4a3cab7a5badcf99777c99091dc5079c6d6f29b902bc9860d1a172e895b1d22a2b7e294bc503f64b216c3f9daabbae1da2f40199611a97e6d3a8720aaa167a3b26851481554771bceaee3981ba300b80f7447c7c48655f154499bbcd8fd556e4889e189560586275ae3191e5c838b5952aa785240dac56488f4996c23b82686a338775012c4a9d8074bda6ef5099ed9cdd73e0d3a25ba02aedbdfe5d4844740ac7060eedb090e32f572920dfc39659640b1f0021ab46e1db9474408a9cd13de68c514707ed17b22bb7b29ff0769f7196d6774295d8b010a3e85ae15bf7d0957ade848802393beebca64c823a31a8240d13eea18e4389d00deed46df94f54ede44b90b33bfe30ed8011ad570e3ef1519e57832876f45f6a3b5e69e52f4d7a805cace55d9617ab1e747ad93bb9e6dcdb57c51ad3486ad09da028f613d03be661bafaad547c28febf04119c2a5b6f64afacc3924f5cef3a8decb12987d55450b93900ed2ca57a902e6b40a0ee2e5526c622eb1a6b48cc5e785211b2f58dee209f235405ebec319bd3bb6f51a24aa6fef469f2fd6fba545c107b215b249cb3e645223ba64926aef5dbc72ab66c1e089596033d72cd53dde1767a9155766dcc094f8c21e1a26135df74ade4d2255bd6e98458bbe9f76aed8109b08f44d901ebfb735ff8a565b31f727b619d6943b14cdbff5014821e754c7fa67e755847acd19b05db7d7ec968fa3f90ed3127299e0d151c6504438a700dd5c6afce0b31985d8d4197855aa4a927efcf41e1369c8f603d02af27c55cca440b914c179448e5fe2a9bedf2e05395980560a6bd40a4d531ee98d69fa7a1234083f353dbda58a0045e97d5e32df74b217549e059cf54ca5d10026376ab5f57ee488f6352b3f7c14a0ce6a5008a10fe22ca865ee0e8878b5c694ad369c4e75c6444681dd1deccfdd96f1aba4828d19b2e8b1d635865f6b301010f1dbd3f68de5e0baedc63756b25c005767c88697f62caea0a10aa4ca0cbd8d6875246b981b6a5c6ab13255535e411a8e11635fbd765a754ffaddcb5db82ed76d5d4f644d105be7cfe1d17e80ff1bcb6f4962ae615b021f8f33724f223d68948b50137d71de92e7bf1ebb678b68dd507a35bbd66eeafc2a819529f0a125b65c9de1354a1e5b60a839d6bb96ab3997ba9db312709bdfbcbd49c81dfdc7c8b0af2e1410e502dd9d6540dc2b0c7c20b2a8327a149a077274b24db0aa85ac2b651c4bd30b2c6d74a5240c1deffb263980010ceaf402dc9f09378b73b6f224d08917670ba37bf4fcaf5008ab99b85e1f42c4b07f7d7ce40972e7188b3f9297ef53ac595c08b8c22c64b8b67e0cc194dad2c59aa84311f70bb9393c2a357f08fb14d8145989845a11f00c4127a3392ae3765aa1ccbab31e7ebf0b9f3b4bc176aeaa9e4ecb31ce5837a93896051ad6a6075d51a9338efd7d909edae02c22d06d19e228e0babfa8d3134d238cf481ba76361ec434674a965c085bc14e270ccc6e0397a80564e4ae1923da849853ef748d6dceeceb2943ffeb78a883bf48ecc83bca89f44e78a10d9ec88a34d2f0d84f081e8ffbbe3f52ee611ae987849dee7e79a8dafb389a072f21c9aebbdaec12b1203fd462280c858f1a958dca278b8279270d0b71e4af807cbe6e838b1f1205bfc16c6a58d987072a075ffbc1394b101c4976411ac5a374cf60a399b27227b32c42384ebc4eb4047e4b21e89f1d38d72e973240b19c1d811b426cdfb374fbdc2ec73b8c6701289b072a72248faeb8af5ae49bccc0de357e18312fb19301b17ae72a8f11fa7be27ddccc76c697742803d6b5c0ec86f9297e7018db207a3bb8f160c09f5dd7c63f62201d2754ed68d3e0c2afd56a2ccc17dec19e19e3b5818b4d69d6a37289333950f467e3a74739b56ba12dbe3cb46194a1c6845e0491452a0ee282623f60d1730c85d8a8185e24720a6da9ddfa56a7924a4c1960683a88a38a4c0398ba948fef0a7f042afac2127b0aedab31b4a9f378f20160f74413b95187329584314af5864ce6e1b009b64c363c3ea7780a1adf092558bc932cd637e9346ad25eb164eb721bda74230f22026bb1d50488b725ee9b5209a9bd30ac9dc74f1a742180b50e72755d3c108c3d5f93c0c1e47e84656893050d8b11c359d7e303546e310cdfbb88dd2e3d39dd1fd523fe1bd1d3c85b06878c730845866173538ec35cc84c407e17a37a8826a900bfc54b045e16c6efa98c9cbbf8ccd8d329b5240cca367821657fffbe029498ef62d0f312df4241cde3c53d1bbd3c2a07f5511ca35b30051e5ceb4e05a36b1c7ed294e1f01d33080ca193792ef3c5fe93c8395971cc97502c0a12d9945b973eb1f667c7e213ab95e23cb8fa3c4a1e761ae07bbce3e9ff36f834a1c1f0b9fe94e3b68a3dc33030c4d3252c5179987e1547e4dde38f43b017d6e03fe242fda9ce3be6c99a35a4ab768547ad2b28182a7d24392afc90299cea7f5d339ece9fb5f6ece5ff18e6cc70440fb4ade3aa55ea275fc1c10bc1599b225436d743b39d9d4380552c305e608563e79326566d98175107f63830ef8dcf34b78cc788f93c2ae116833f686cefa4bc1713b79805acefba59bc582ee5ce69eb8fb2dd377b0be107b54e5103faef6571f2cd46bf5f1d3ba791f822f2e44e4817678944de07ec4e1cc2fed4450d07d1ce9caa779af1ab93f293458275110060505be4fa74b4b8daafbbf6d69f747faf7ff6696bc0b0db01c9e1afef056fa29fb6568008db22b7c376f16bab2e9ac5808c9a798142cdc7f96b348146d25adc9e2cf425940387dcdc289bd10d3e5c1b2f3df39bfa07238ccdc8419db7e71eb43073188028ad2983dfd32efa31349f5b3d9db67826c9be506aaf9d7ae6e44b4e8fc9747321ce1ed463aba72d9f2bb36c4c01b4180ec8c84ffb3a7ef0dc3a714ffe0f005a0fa816f443af01895b6c0b13d929e2f05b192a9a02db9fa2e069637ee057cd5446384d5ccd60ee816fa3d88939441973c0586b89ba317cd9e9baac37c234e23a9cc32b33526c1146d5e7006c257cef5f6c20fe70233c54fb9510c594909589b06126f32834ea881b8e18086db44f43f47a5c8b0ed5568b3c2f174de134bb8d314ce66aaa48423dc1ae91f8616241958934063efd0cf876446e0d50038292d843a0d66460e7639e451c1bb1fb5d4a474b20d7fee574223e06c1f26d14166fb46381ce6cf9d93d9f6f5422812ef105cf834cbf38eb67bfe94695b36d86662345eefd5fb426286199fe080a96540cafc147c849eb6533d43b53828666cef287574ae9c7149a414cc950aa7f91ad1c26e14dfce7503202b09d03b3797dea7174d7eb2b3507dce5670aadbc677b9e33ac7ac13a24f0b707180fbc6d75c70e09407aa17ec45906b31043857c876c47f4f7e7b445e8ea310bcd22bc9edf3f11dda8fc05fb2d81e6644f56880f391ff7021ee9ab1d1052ff4c30f6cde7c40dfb199b7ebc48dc34c2561df2c71408e6ce806e1e6df3de213dfaa406931133ebfc1c98e7deba31ccba7ddc329f4e2dc1ec8ceaf489120b84144dab4301e464541d8c6a4f5dffdabc47704ef962ce68027623aa064e932e392d81bfd894a44d0810bf0a59babc01aaafc3056325463246417ddc86cf6ca8016cf4b195da30d32b9754ebc790aff9adf6e1245b1dbd042b487160f315bc41b594d2b47850c2c986bf4b8796db8283065899716d932ed16253d29c1c73135031e42f9636f79285371c1514bf75e7480773afb146c0dbbfdf1b6dc0790f47d41b03ed08dc1e4d370db7cfdc971716757636fdacb0d24f7ba4a6600f22d249f80817e709cb280678b0d05ddd184c87975080e4457c571f73a3daa4fd2f5b305502014a00f7f04d0806bcd8d66a4fcb9511ae8e2bfa3c024e2ee4cc55f4f11583dcaa8a9ef23138b9fa58c9f5acc71900094573576e12491b17526a3bde6dd1f0ffc5168099b0ef82c48f414a28bd776360963b06e9fca1d62fcff4ff4f1d47472dc92e1f40a39d6bdc4f9e5369fb040f3119c09c7378b59352820015643529be417cfcd8ca1bfed66bb8e937df9620dbc744478773532fa5a0fe549eadfcc444af27536e91b0120281cf1cc6c9e423dc8d9e3c7ebb7206640646f95308674dad9916c1dcb10fa7ef3a2793f899aa1caa9ddc93ed266bdc8778463ace732cfb486691b7990624d09111c49ed28575e86104966d05f02bdd209688bc8e2f08cc5574a0ba4bd0325169d40d922cbdbefa601a54b6d316f7fe9d629b595ecb2bf5ed4ca9f31ad3716f99b42483e2c940f990d256be1034818bf610ca75f5270c58a638e335bb836ff8b27103d13640e2d842c12052c7b9a48e8a2a3c89f4e8f99768b796b24e3af77debf513a9697446dcbfdca131cd79701053b20ddb33c12eb53af78578d08a54a0ff704e1cddecfe3425e684ebdabb1864e2298c5aea26953968ae1f9d0c65565d7e4c82da16e94bf76afbc8944cd663bd7025297cee2709e8294b4b8db57ca6bc36465e3e6b02d905eab808f574430a35fccf09ef97a0009a45bc0ea4c407bac33ec8959eac984d4428b10e33380cdefc5ab4b50633809c268512cfd622219df843c5fc918a0ae78e88b3cdeb43f1f30b2c58316fd659b3405c3a2242004dd1bf5c9bc6e3627ee7efab1832fea1ffe5c8dcb807cb5c7fdd984790f9f027b3da5a8e727d32c129643e5451ebd1933602316b003cd5883209b5f84d3872336c99061b87bc0f8aad6bf32bbebdf1aa7a1afb0a44ac33978259e476c2934dc607616f7c243c3c953346ce0eb4d201360de7357a44212b0dc681f31c7614177a88785cdf1997f91876f67b2c872fac809aa42c1143ff08a9bbbac92b901f8202467b04f56d4837ec19c94d33d3f166d3f7256d1657ea210de0f592981446e089a208e5d303debfbe7f29a420ae2b259803170e65cd8962cecb8c15062780a30942c6767c29b1c028522f428df6b13600ecf0157d6eb15892851e6699e97bb1bb7da421142c00910111b5dfa6ba3ed71b717d54c709f9bc84ceefeb13ce62fe118ee16155e6c1901b13525bb3b5c2a3bd27265e28885137a2ccdc37fff1c210085c3dcfa3224a1334508c8685b476e475ff99be7f4436ab4dbff308211b8da6a3c624595a53ab8344a034e48851a290332982d10a7378f2f00b5f885b59132fd456b6fb9577d9784c76ba738ece0dc036fe092f8f8ae8208c70f61234572820c3172343f2175186f3dac7c3bc2fb4886b7ab356ce50b9a275030355bdb15ebef125cdd2b90dd9bfce766531f90f47a4173291b090261b8f7f64879645557851ec6c74da753062c5dfe33f8069cb0ca85b01e3544df4bd520b206a388adca2e4f18bf74c5290d7f250043ddd5e8c53b257f912b7c7e04296283678de7407be1dda10668dade8998e526b469c61498be637784f9112a5086d4e5b14e9bf57108c469ecf923ee5484833d9a9d76848a322e0934295441f70f38c7dbafb89d674db2fc5250e1e9df9df8958c212c2502aa6afe9177e9042aed4a392762ceb9f96f496aef5185615aeb102a1450745ffb26289142e4d33ee9050d3fae1392bb136c30f3cf7bb1e02b5b191450e3fb88af22096bc426f31486efe57958286e2334414fe61d75b02cc131a1e3cb15f646c5a153d4d25f2fa857eb01da9fe0855513da8d4b13f24e92c1316dbcfb27ae5033440c2a3f90181b6987ed0e2041f0ed9b820ccc94a2359e5fc7a91056a1ada7270dc06ea5a30d7858f39275e1a2a9ae429a46876c893824f2647dcfdbdc8c50ebdcd2e010b2a9b2adc085c0049438ef4905461bf94ff9fd7ec6b72b57d5e4b0edaa49f7cee2e2184798b7ce89d8796bd8ee1e2274f0402eba5ada1153dd7b5f7f8d795732852a29d57af1c916090b46eb17a13fefeb7076b6ea67be9c85efe8e0195af403e2a47210dfa57379b91e5234784272ebf737f04d0f28f9a9ede88daa839ca3f424629816ebf5185518b40bf97386c5800f040f29b537b6d0ff93532f2d607ba2e8827ff4d47261b11aa6ea191b1b292060825f08d9ea7c442fb68c720f863fc7ea94b6ca9d810ab28606ba531be5a33815d83a6e1055f29418e806b9aee50730167de97d0b0c4aeeba43613557bf1942a15ad91009d215b981a215a7334f2b78d8ec37daaa540ff7ab74685a00e380991942a3439f5de91eb959bde9a6352a1a3310b51c3fc0ec3f4f631faf196b7509da2b8a6f28043fc1967c62c64f1602a70b8a46ec1ef26d3dfafd8ec83de5c3706c7f749a688019a48a233bd7281402f967d147665a800115e9e368d1660bee0a9a6573c6d7a0564bc367162c86018553f915a1d362971a1849313b78db9eb9a4da92e09b09a242e2fbe1d7ea8b6422561d5da5c0942cec4acdead9bea0ae79fd99f62ad70e852dce9c89d4f27781fac423d119fc2f26cba8240a0bfa98804e460ad24c9d938bfee4b5ba84456c2a34a2129759ac6ed666c35bf7a995ac2b2c6e578cdd2b61c251e5ed1bbb23d61a42556611f8194b8db3fa842320acbf83e1f326cebe08521601fb9ccffdd006f71e77d6c2f8af8742cb1d4374f5a80744ea2a182bb1e946871eecd2f5ccc8adac50bb701df2b4e2ecdf42aca7f3d3f2b7947afcf995507525b04669fb0c910ac29d442f5915cd922fabaa46a6402f28ca994e2fdd05a24c5cdcdb830f6fefe651c12fa2f652a8c5bc15892a43b5b983789084b3ffbe1dc2ae20183a431ad3adc2fea2627c2bf5bbc69ff98f8361ec39d5b2dfd</script>\n</div>\n<script src=\"/lib/blog-encrypt.js\"></script><link href=\"/css/blog-encrypt.css\" rel=\"stylesheet\" type=\"text/css\">","site":{"data":{}},"excerpt":"This is pricate passage, please enter the passpord.","more":"This is pricate passage, please enter the passpord.","origin":"<h1 id=\"基于hexo的配置\"><a href=\"#基于hexo的配置\" class=\"headerlink\" title=\"基于hexo的配置\"></a>基于hexo的配置</h1><h2 id=\"基本结构\"><a href=\"#基本结构\" class=\"headerlink\" title=\"基本结构\"></a>基本结构</h2><p>hexo的下载和配置参见<a href=\"https://hexo.io\" target=\"_blank\" rel=\"noopener\">官网</a>，有详细的下载，配置，模板信息。并且介绍了文件的结构，对于学习前端知识有很大的帮助。</p>\n<p>如下是下载后的文件夹内部结构。其中，source是根目录，_posts存放单个post，格式是.md。</p>\n<p>_config.yml存放一些结构文件，其中常修改的是title, author, language</p>\n<a id=\"more\"></a>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#96;.├── _config.yml├── package.json├── scaffolds├── source|   ├── _drafts|   └── _posts└── themes&#96;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"post\"><a href=\"#post\" class=\"headerlink\" title=\"_post\"></a>_post</h2><p>(1) _posts存放单个post，格式是.md。</p>\n<p>(2) quote：(修改_posts)</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">`&#123;%</span> <span class=\"string\">blockquote</span> <span class=\"string\">%&#125;Lorem</span> <span class=\"string\">ipsum</span> <span class=\"string\">dolor</span> <span class=\"string\">sit</span> <span class=\"string\">amet,</span> <span class=\"string\">consectetur</span> <span class=\"string\">adipiscing</span> <span class=\"string\">elit.</span> <span class=\"string\">Pellentesque</span> <span class=\"string\">hendrerit</span> <span class=\"string\">lacus</span> <span class=\"string\">ut</span> <span class=\"string\">purus</span> <span class=\"string\">iaculis</span> <span class=\"string\">feugiat.</span> <span class=\"string\">Sed</span> <span class=\"string\">nec</span> <span class=\"string\">tempor</span> <span class=\"string\">elit,</span> <span class=\"string\">quis</span> <span class=\"string\">aliquam</span> <span class=\"string\">neque.</span> <span class=\"string\">Curabitur</span> <span class=\"string\">sed</span> <span class=\"string\">diam</span> <span class=\"string\">eget</span> <span class=\"string\">dolor</span> <span class=\"string\">fermentum</span> <span class=\"string\">semper</span> <span class=\"string\">at</span> <span class=\"string\">eu</span> <span class=\"string\">lorem.&#123;%</span> <span class=\"string\">endblockquote</span> <span class=\"string\">%&#125;`</span></span><br></pre></td></tr></table></figure>\n\n<p>(3) Categories &amp; Tags（修改_posts）</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">categories:</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">Sports</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">Baseball</span></span><br><span class=\"line\"><span class=\"attr\">tags:</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">Injury</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">Fight</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">Shocking</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"page\"><a href=\"#page\" class=\"headerlink\" title=\"page\"></a>page</h2><p>建立新的导航菜单项：</p>\n<ul>\n<li><p>前往你的Hexo博客的根目录</p>\n</li>\n<li><p>输入<code>hexo new page tags</code></p>\n</li>\n<li><p>找到<code>source/tags/index.md</code>这个文件</p>\n</li>\n<li><p>修改这个文件：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">title:</span> <span class=\"string\">标签</span></span><br><span class=\"line\"><span class=\"attr\">date:</span> <span class=\"number\">2018</span><span class=\"number\">-01</span><span class=\"number\">-05</span> <span class=\"number\">00</span><span class=\"string\">:00:00</span></span><br><span class=\"line\"><span class=\"attr\">type:</span> <span class=\"string\">\"tags\"</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>type必须是<code>tags</code>，增加<code>categories</code>页面的话也是一样的。</p>\n<ul>\n<li><p>然后配置melody.yml（即./themes/melody/_config.yml)</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">menu:</span></span><br><span class=\"line\">  <span class=\"attr\">Home:</span> <span class=\"string\">/</span></span><br><span class=\"line\">  <span class=\"attr\">Archives:</span> <span class=\"string\">/archives</span></span><br><span class=\"line\">  <span class=\"attr\">Tags:</span> <span class=\"string\">/tags</span></span><br><span class=\"line\">  <span class=\"attr\">Categories:</span> <span class=\"string\">/categories</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"节选\"><a href=\"#节选\" class=\"headerlink\" title=\"节选\"></a>节选</h2><!-- more -->之前的内容将在主页显示\n\n<h1 id=\"themes\"><a href=\"#themes\" class=\"headerlink\" title=\"themes\"></a>themes</h1><h2 id=\"修改主题\"><a href=\"#修改主题\" class=\"headerlink\" title=\"修改主题\"></a>修改主题</h2><p>主题的配置选用了<a href=\"https://molunerfinn.com/hexo-theme-melody-doc/zh-Hans\" target=\"_blank\" rel=\"noopener\">melogy</a> </p>\n<ul>\n<li><p>在github中下载后，自动配置入themes文件夹中，并为git文件夹（这可能是造成整个blog文件无法push的原因，但是还不确定在一个本地仓库中还有一个仓库是否会影响git push，现状是最后本地可运行的blog文件无法被git push）。</p>\n</li>\n<li><p>配置blog文件中的_config.yml，将themes改为melogy</p>\n</li>\n</ul>\n<h2 id=\"配置-config-yml-themes-melody-config-yml\"><a href=\"#配置-config-yml-themes-melody-config-yml\" class=\"headerlink\" title=\"配置_config.yml(./themes/melody/ _config.yml)\"></a>配置_config.yml(./themes/melody/ _config.yml)</h2><p>theme_color: (修改主题色)</p>\n<p>menu：(1.3 修改导航菜单)</p>\n<p>favicon: /dog2.ico （修改网站图标 .ico格式）</p>\n<p>highlight_theme: light （代码高亮模式 其他模式还有pale night, dark, ocean）</p>\n<p>fireworks: true （点击特效，在./themes/melody/source/js/firework.js中可修改特效）</p>\n<p>social:github fa: <a href=\"\">https://github.com/Unalian</a>  (社交网站图标，点击可关联社交媒体。设置详细方法参见主题配置说明网站)</p>\n<p>avatar: /rushroom.jpg （头像）</p>\n<p>top_img: /lightInDark.jpg # false or url of img</p>\n<p>top_img_height: 80 # best range: 60 - 100（顶图设置）</p>\n<p>footer_custom_text: to be or not to be （底字）</p>\n<h2 id=\"layout\"><a href=\"#layout\" class=\"headerlink\" title=\"layout\"></a>layout</h2><p>.pug格式：所谓的pug就是jade,也就是一种通过缩进的方式来编写代码的过程，在编译的过程中，我们不需要考虑标签是否闭合的问题。此外，用这种编译方式，加快了我们写代码的速度，也为代码复用提供了便捷。</p>\n<p>可用以修改网页内容，对这一部分的修改并不多。</p>\n<h1 id=\"服务器的建立与使用\"><a href=\"#服务器的建立与使用\" class=\"headerlink\" title=\"服务器的建立与使用\"></a>服务器的建立与使用</h1><h2 id=\"租用服务器\"><a href=\"#租用服务器\" class=\"headerlink\" title=\"租用服务器\"></a>租用服务器</h2><p>在k的引导下，租用了阿里云的服务器（轻量级应用服务器）。（云翼计划，学生每月9.8）</p>\n<p>设置为系统镜像，系统为CentOS。在terminal访问时的指令是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh root@47.***.***.155</span><br></pre></td></tr></table></figure>\n\n<p>k解析到了ip.***.monster 上，并且设置了数字签名，让登录更加方便了呢。()</p>\n<h2 id=\"修改blog内容-Rsync\"><a href=\"#修改blog内容-Rsync\" class=\"headerlink\" title=\"修改blog内容:Rsync\"></a>修改blog内容:<strong>Rsync</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rsync  -av  &#x2F;test&#x2F;  &#x2F;backup --本机上的同步，把&#x2F;test目录下的内容同步到&#x2F;backup目录下(包括隐藏文件)</span><br><span class=\"line\"></span><br><span class=\"line\">rsync  -av  192.168.1.20:&#x2F;backup&#x2F;  &#x2F;backup&#x2F;   --把远端192.168.1.20的&#x2F;backup目录下的内容同步到本地的&#x2F;backup目录</span><br><span class=\"line\"></span><br><span class=\"line\">（注意：路径写法的区别！原目录后面加不加&#x2F;也影响你的同步目录；没加&#x2F;，就是将目录本身同步过去；目录加&#x2F;，就是将目录里的内容同步过去！）</span><br><span class=\"line\"></span><br><span class=\"line\">rsync  -av  &#x2F;home  --exclude&#x3D;abc  &#x2F;backup    --将&#x2F;home目录下除了abc其他内容都同步到&#x2F;backup目录下</span><br><span class=\"line\"></span><br><span class=\"line\">rsync  -a  --delete  &#x2F;backup&#x2F;  &#x2F;test&#x2F;                 --如果同步后，源主机中有文件删除了，这时要想目标主机与源主机的内容保持一致，可以使用--delete参数进行同步</span><br></pre></td></tr></table></figure>\n\n<p>在本机blog文件外 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#  rsync  -av  &#x2F;test&#x2F;  192.168.1.20:&#x2F;backup          --把本地的&#x2F;test目录内容，同步到远端191.168.1.10的&#x2F;backup目录下</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"exp\"><a href=\"#exp\" class=\"headerlink\" title=\"exp\"></a>exp</h1><ul>\n<li>最大的教训就是要做好版本控制，在过程中出现了好几次以外的错误，却不知道是哪里出了错，因此以后应该利用git做好版本控制，减少工作清零的风险。</li>\n<li>这次反复出现的一个问题是系统强制改了一个关键文件，我一直没发现这个问题，最后一次经过对报错的分析终于找到了这个问题。</li>\n</ul>\n<h1 id=\"v2ray\"><a href=\"#v2ray\" class=\"headerlink\" title=\"v2ray\"></a>v2ray</h1><p><img src=\"https://www.v2ray.com/chapter_00/install.html\" alt=\"见文档\"></p>\n<p>最简单的 单也算是自己成功了</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/622e953653dd2222979f2e7ceb8020ec.jpg\" alt=\"\"></p>\n","encrypt":true},{"date":"2020-01-19T16:00:00.000Z","_content":"# 概览\n\n一. 简介\n\n​\t1. 创建版本库\n\n​\t2. 把文件添加到文本库\n\n二. 时间穿梭\n\n1. 观察状态以及变化\n2. 版本回退\n  3. 工作区与暂存区\n  4. 撤销修改\n  5. 删除文件\n\n<!-- more -->\n\n# 简介\n\n## 创建版本库\n\n1.首先，选择一个合适的地方，创建一个空目录：\n\n```\n$ mkdir learngit\n$ cd learngit\n$ pwd\n/Users/michael/learngit\n```\n\n**pwd**命令用于显示当前目录。\n\n2.通过git init命令把这个目录变成Git可以管理的仓库：\n\n```\n$ git init\nInitialized empty Git repository in /Users/michael/learngit/.git/\n```\n\n如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。\n\n## 把文件添加到文本库\n\n用终端建立文件：\n1.vim 路径/***.txt\n2.i\n3.录入内容\n4.esc\n5.：wq\n\n本实例中，把readme.txt放在之前建立的/Users/michael/learngit/下\n\n内容是：\n\n“Git is a version control system.\nGit is free software.”\n\n1.用命令git add告诉Git，把文件添加到仓库：\n\n```\n$ git add readme.txt\n```\n\n2.用命令git commit告诉Git，把文件提交到仓库：\n\n```\n$ git commit -m \"wrote a readme file\"\n[master (root-commit) eaadf4e] wrote a readme file\n 1 file changed, 2 insertions(+)\n create mode 100644 readme.txt\n```\n\ngit commit命令:-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。\n\ngit commit命令执行成功后会告诉你，1 file changed：1个文件被改动（我们新添加的readme.txt文件）；2 insertions：插入了两行内容（readme.txt有两行内容）。\n\n因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如：\n\n```\n$ git add file1.txt\n$ git add file2.txt file3.txt\n$ git commit -m \"add 3 files.\"\n```\n\n# 时间穿梭\n\n## 观察状态以及变化\n\n将之前的readme.txt 改成：\n\n“Git is a distributed version control system.\nGit is free software.”\n\n运行**git status**命令看看结果：\n\n```\n$ git status\nOn branch master\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n\tmodified:   readme.txt\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n```\n\ngit status命令可以让我们时刻掌握仓库当前的状态，上面的命令输出告诉我们，readme.txt被修改过了，但还没有准备提交的修改。\n\n具体修改了什么内容，需要用**git diff**这个命令看看：\n\n```\n$ git diff readme.txt \ndiff --git a/readme.txt b/readme.txt\nindex 46d49bf..9247db6 100644\n--- a/readme.txt\n+++ b/readme.txt\n@@ -1,2 +1,2 @@\n-Git is a version control system.\n+Git is a distributed version control system.\n Git is free software.\n```\n\n可以从上面的命令输出看到，我们在第一行添加了一个distributed单词。\n\n要将修改过的txt提交到版本库，还是需要git add和git commit.\n\n```\n$ git add readme.txt\n```\n\n在git commit之前用git status查看状态\n\n```\n$ git status\nOn branch master\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\nmodified: readme.txt\n```\n\n从 modified: readme.txt 可以看出readme.txt发生了变化但是还没有commit\n\n```\n$ git commit -m \"add distributed\"\n[master e475afc] add distributed\n 1 file changed, 1 insertion(+), 1 deletion(-)\n```\n\n提交后，查看状态\n\n```\n$ git status\nOn branch master\nnothing to commit, working tree clean\n```\n\n## 版本回退\n\n再次修改文件，改成：\n\n“Git is a distributed version control system.\nGit is free software distributed under the GPL.”\n\n```\n$ git add readme.txt\n$ git commit -m \"append GPL\"\n[master 1094adb] append GPL\n 1 file changed, 1 insertion(+), 1 deletion(-)\n```\n\n回顾一下：\n版本1：wrote a readme file\nGit is a version control system.\nGit is free software.\n\n版本2：add distributed\nGit is a distributed version control system.\nGit is free software.\n\n版本3：append GPL\nGit is a distributed version control system.\nGit is free software distributed under the GPL.\n\n可以将**git log**命令查看已有版本:\n\n```\n$ git log\ncommit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -> master)\nAuthor: Michael Liao <askxuefeng@gmail.com>\nDate:   Fri May 18 21:06:15 2018 +0800\n\n    append GPL\n\ncommit e475afc93c209a690c39c13a46716e8fa000c366\nAuthor: Michael Liao <askxuefeng@gmail.com>\nDate:   Fri May 18 21:03:36 2018 +0800\n\n    add distributed\n\ncommit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0\nAuthor: Michael Liao <askxuefeng@gmail.com>\nDate:   Fri May 18 20:59:18 2018 +0800\n\n    wrote a readme file\n```\n\n如果过于复杂，可用**git log --pretty=oneline**查看commit id和commit说明\n\n```\n$ git log --pretty=oneline\n1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -> master) append GPL\ne475afc93c209a690c39c13a46716e8fa000c366 add distributed\neaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme file\n```\n\n当前版本是append GPL,要回溯到add distributed时,就可以使用**git reset**命令：：\n\n首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交append GPL，上一个版本就是HEAD，上上一个版本就是HEAD，当然往上100个版本写100个比较容易数不过来，所以写成HEAD~100。\n\n```\n$ git reset --hard HEAD^\nHEAD is now at e475afc add distributed\n```\n\n这时查看内容：\n\n```\n$ cat readme.txt\nGit is a distributed version control system.\nGit is free software.\n```\n\n这个时候如果查看版本库：\n\n```\n$ git log\ncommit e475afc93c209a690c39c13a46716e8fa000c366 (HEAD -> master)\nAuthor: Michael Liao <askxuefeng@gmail.com>\nDate:   Fri May 18 21:03:36 2018 +0800\n\n    add distributed\n\ncommit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0\nAuthor: Michael Liao <askxuefeng@gmail.com>\nDate:   Fri May 18 20:59:18 2018 +0800\n\n    wrote a readme file\n```\n\nappend GPL的版本已经没有了。\n\n找回方法：\n\n1. **git reset --hard** – 查找版本号\n\n```\n$ git reset --hard 1094a\n```\n\n2. **git reflog** – 看之前的指令确定版本号\n\n```\n$ git reflog\ne475afc HEAD@{1}: reset: moving to HEAD^\n1094adb (HEAD -> master) HEAD@{2}: commit: append GPL\ne475afc HEAD@{3}: commit: add distributed\neaadf4e HEAD@{4}: commit (initial): wrote a readme file\n```\n\n## 工作区与暂存区\n\ngit工作分为工作区（可见）与版本库（隐藏目录），在版本库里有暂存区（stage）和分支（master），git add相当于将工作区里被修改的文件加入stage，git commit相当于将stage里的文件一次性提交到master里。\n\n几种状态：\n\n1. \n\n```\n$ git status\nOn branch master\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n\tmodified:   readme.txt\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\n\tLICENSE\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n```\n\nmodified:readme.txt和no changes added to commit可以看出，readme.txt修改了还没有add。\nuntracked files:LICENSE和no changes added to commit可以看出，LICENSE从来没有添加过。\n\n2. \n\n```\n$ git status\nOn branch master\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\n\n\tnew file:   LICENSE\n\tmodified:   readme.txt\n```\n\nchanges to be committed可以看出，这两个文件add后还没有commit。\n\n3. \n\n```\n$ git status\nOn branch master\nnothing to commit, working tree clean\n```\n\n提交以后，工作树就是干净的了。\n\n查看工作区与版本库的区别：**git diff HEAD – readme.txt**\n\n```\n$ git diff HEAD -- readme.txt \ndiff --git a/readme.txt b/readme.txt\nindex 76d770f..a9c5755 100644\n--- a/readme.txt\n+++ b/readme.txt\n@@ -1,4 +1,4 @@\n Git is a distributed version control system.\n Git is free software distributed under the GPL.\n Git has a mutable index called stage.\n-Git tracks changes.\n+Git tracks changes of files.\n```\n\n## 撤销修改\n\n1. 只是在工作区写错，将工作区的修改丢弃\n   **git checkout - - <file>** 将工作区的改变撤销（恢复到最近的add/commit状态）\n2. add后发现错误,将暂存区的修改回退到工作区\n   **git reset HEAD <file>**\n\n```\n$ git reset HEAD readme.txt\nUnstaged changes after reset:\nM\treadme.txt\n```\n\n3. commit后发现写错，直接回退版本。\n   见版本回退\n\n## 删除文件\n\n工作区：直接从资源管理器里删除/rm <file>\n\n```\n    $ rm test.txt\n```\n\n此时git status可知，删除后还未添加到.git目录\n\n```\n$ git status\nOn branch master\nChanges not staged for commit:\n  (use \"git add/rm <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n\tdeleted:    test.txt\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n```\n\n之后git rm, git commit:\n\n```\n$ git rm test.txt\nrm 'test.txt'\n\n$ git commit -m \"remove test.txt\"\n[master d46f35e] remove test.txt\n 1 file changed, 1 deletion(-)\n delete mode 100644 test.txt\n```\n\n现在就把文件从版本库中被删除了。\n\n删错时，可用$ git checkout - - <file>\n**git checkout**其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。","source":"_posts/Git 自学（一）Git 简介以及时间穿梭.md","raw":"---\ndate: 2020/1/20\ntags:\n- git\n- 自学笔记\ncategories:\n- github\n\n---\n# 概览\n\n一. 简介\n\n​\t1. 创建版本库\n\n​\t2. 把文件添加到文本库\n\n二. 时间穿梭\n\n1. 观察状态以及变化\n2. 版本回退\n  3. 工作区与暂存区\n  4. 撤销修改\n  5. 删除文件\n\n<!-- more -->\n\n# 简介\n\n## 创建版本库\n\n1.首先，选择一个合适的地方，创建一个空目录：\n\n```\n$ mkdir learngit\n$ cd learngit\n$ pwd\n/Users/michael/learngit\n```\n\n**pwd**命令用于显示当前目录。\n\n2.通过git init命令把这个目录变成Git可以管理的仓库：\n\n```\n$ git init\nInitialized empty Git repository in /Users/michael/learngit/.git/\n```\n\n如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。\n\n## 把文件添加到文本库\n\n用终端建立文件：\n1.vim 路径/***.txt\n2.i\n3.录入内容\n4.esc\n5.：wq\n\n本实例中，把readme.txt放在之前建立的/Users/michael/learngit/下\n\n内容是：\n\n“Git is a version control system.\nGit is free software.”\n\n1.用命令git add告诉Git，把文件添加到仓库：\n\n```\n$ git add readme.txt\n```\n\n2.用命令git commit告诉Git，把文件提交到仓库：\n\n```\n$ git commit -m \"wrote a readme file\"\n[master (root-commit) eaadf4e] wrote a readme file\n 1 file changed, 2 insertions(+)\n create mode 100644 readme.txt\n```\n\ngit commit命令:-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。\n\ngit commit命令执行成功后会告诉你，1 file changed：1个文件被改动（我们新添加的readme.txt文件）；2 insertions：插入了两行内容（readme.txt有两行内容）。\n\n因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如：\n\n```\n$ git add file1.txt\n$ git add file2.txt file3.txt\n$ git commit -m \"add 3 files.\"\n```\n\n# 时间穿梭\n\n## 观察状态以及变化\n\n将之前的readme.txt 改成：\n\n“Git is a distributed version control system.\nGit is free software.”\n\n运行**git status**命令看看结果：\n\n```\n$ git status\nOn branch master\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n\tmodified:   readme.txt\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n```\n\ngit status命令可以让我们时刻掌握仓库当前的状态，上面的命令输出告诉我们，readme.txt被修改过了，但还没有准备提交的修改。\n\n具体修改了什么内容，需要用**git diff**这个命令看看：\n\n```\n$ git diff readme.txt \ndiff --git a/readme.txt b/readme.txt\nindex 46d49bf..9247db6 100644\n--- a/readme.txt\n+++ b/readme.txt\n@@ -1,2 +1,2 @@\n-Git is a version control system.\n+Git is a distributed version control system.\n Git is free software.\n```\n\n可以从上面的命令输出看到，我们在第一行添加了一个distributed单词。\n\n要将修改过的txt提交到版本库，还是需要git add和git commit.\n\n```\n$ git add readme.txt\n```\n\n在git commit之前用git status查看状态\n\n```\n$ git status\nOn branch master\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\nmodified: readme.txt\n```\n\n从 modified: readme.txt 可以看出readme.txt发生了变化但是还没有commit\n\n```\n$ git commit -m \"add distributed\"\n[master e475afc] add distributed\n 1 file changed, 1 insertion(+), 1 deletion(-)\n```\n\n提交后，查看状态\n\n```\n$ git status\nOn branch master\nnothing to commit, working tree clean\n```\n\n## 版本回退\n\n再次修改文件，改成：\n\n“Git is a distributed version control system.\nGit is free software distributed under the GPL.”\n\n```\n$ git add readme.txt\n$ git commit -m \"append GPL\"\n[master 1094adb] append GPL\n 1 file changed, 1 insertion(+), 1 deletion(-)\n```\n\n回顾一下：\n版本1：wrote a readme file\nGit is a version control system.\nGit is free software.\n\n版本2：add distributed\nGit is a distributed version control system.\nGit is free software.\n\n版本3：append GPL\nGit is a distributed version control system.\nGit is free software distributed under the GPL.\n\n可以将**git log**命令查看已有版本:\n\n```\n$ git log\ncommit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -> master)\nAuthor: Michael Liao <askxuefeng@gmail.com>\nDate:   Fri May 18 21:06:15 2018 +0800\n\n    append GPL\n\ncommit e475afc93c209a690c39c13a46716e8fa000c366\nAuthor: Michael Liao <askxuefeng@gmail.com>\nDate:   Fri May 18 21:03:36 2018 +0800\n\n    add distributed\n\ncommit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0\nAuthor: Michael Liao <askxuefeng@gmail.com>\nDate:   Fri May 18 20:59:18 2018 +0800\n\n    wrote a readme file\n```\n\n如果过于复杂，可用**git log --pretty=oneline**查看commit id和commit说明\n\n```\n$ git log --pretty=oneline\n1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -> master) append GPL\ne475afc93c209a690c39c13a46716e8fa000c366 add distributed\neaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme file\n```\n\n当前版本是append GPL,要回溯到add distributed时,就可以使用**git reset**命令：：\n\n首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交append GPL，上一个版本就是HEAD，上上一个版本就是HEAD，当然往上100个版本写100个比较容易数不过来，所以写成HEAD~100。\n\n```\n$ git reset --hard HEAD^\nHEAD is now at e475afc add distributed\n```\n\n这时查看内容：\n\n```\n$ cat readme.txt\nGit is a distributed version control system.\nGit is free software.\n```\n\n这个时候如果查看版本库：\n\n```\n$ git log\ncommit e475afc93c209a690c39c13a46716e8fa000c366 (HEAD -> master)\nAuthor: Michael Liao <askxuefeng@gmail.com>\nDate:   Fri May 18 21:03:36 2018 +0800\n\n    add distributed\n\ncommit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0\nAuthor: Michael Liao <askxuefeng@gmail.com>\nDate:   Fri May 18 20:59:18 2018 +0800\n\n    wrote a readme file\n```\n\nappend GPL的版本已经没有了。\n\n找回方法：\n\n1. **git reset --hard** – 查找版本号\n\n```\n$ git reset --hard 1094a\n```\n\n2. **git reflog** – 看之前的指令确定版本号\n\n```\n$ git reflog\ne475afc HEAD@{1}: reset: moving to HEAD^\n1094adb (HEAD -> master) HEAD@{2}: commit: append GPL\ne475afc HEAD@{3}: commit: add distributed\neaadf4e HEAD@{4}: commit (initial): wrote a readme file\n```\n\n## 工作区与暂存区\n\ngit工作分为工作区（可见）与版本库（隐藏目录），在版本库里有暂存区（stage）和分支（master），git add相当于将工作区里被修改的文件加入stage，git commit相当于将stage里的文件一次性提交到master里。\n\n几种状态：\n\n1. \n\n```\n$ git status\nOn branch master\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n\tmodified:   readme.txt\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\n\tLICENSE\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n```\n\nmodified:readme.txt和no changes added to commit可以看出，readme.txt修改了还没有add。\nuntracked files:LICENSE和no changes added to commit可以看出，LICENSE从来没有添加过。\n\n2. \n\n```\n$ git status\nOn branch master\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\n\n\tnew file:   LICENSE\n\tmodified:   readme.txt\n```\n\nchanges to be committed可以看出，这两个文件add后还没有commit。\n\n3. \n\n```\n$ git status\nOn branch master\nnothing to commit, working tree clean\n```\n\n提交以后，工作树就是干净的了。\n\n查看工作区与版本库的区别：**git diff HEAD – readme.txt**\n\n```\n$ git diff HEAD -- readme.txt \ndiff --git a/readme.txt b/readme.txt\nindex 76d770f..a9c5755 100644\n--- a/readme.txt\n+++ b/readme.txt\n@@ -1,4 +1,4 @@\n Git is a distributed version control system.\n Git is free software distributed under the GPL.\n Git has a mutable index called stage.\n-Git tracks changes.\n+Git tracks changes of files.\n```\n\n## 撤销修改\n\n1. 只是在工作区写错，将工作区的修改丢弃\n   **git checkout - - <file>** 将工作区的改变撤销（恢复到最近的add/commit状态）\n2. add后发现错误,将暂存区的修改回退到工作区\n   **git reset HEAD <file>**\n\n```\n$ git reset HEAD readme.txt\nUnstaged changes after reset:\nM\treadme.txt\n```\n\n3. commit后发现写错，直接回退版本。\n   见版本回退\n\n## 删除文件\n\n工作区：直接从资源管理器里删除/rm <file>\n\n```\n    $ rm test.txt\n```\n\n此时git status可知，删除后还未添加到.git目录\n\n```\n$ git status\nOn branch master\nChanges not staged for commit:\n  (use \"git add/rm <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n\tdeleted:    test.txt\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n```\n\n之后git rm, git commit:\n\n```\n$ git rm test.txt\nrm 'test.txt'\n\n$ git commit -m \"remove test.txt\"\n[master d46f35e] remove test.txt\n 1 file changed, 1 deletion(-)\n delete mode 100644 test.txt\n```\n\n现在就把文件从版本库中被删除了。\n\n删错时，可用$ git checkout - - <file>\n**git checkout**其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。","slug":"Git-自学（一）Git-简介以及时间穿梭","published":1,"updated":"2020-03-25T01:21:22.000Z","title":"Git-自学（一）Git-简介以及时间穿梭","_id":"ck67gmura0003o3mx7jiyb4wo","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"概览\"><a href=\"#概览\" class=\"headerlink\" title=\"概览\"></a>概览</h1><p>一. 简介</p>\n<p>​    1. 创建版本库</p>\n<p>​    2. 把文件添加到文本库</p>\n<p>二. 时间穿梭</p>\n<ol>\n<li>观察状态以及变化</li>\n<li>版本回退<ol start=\"3\">\n<li>工作区与暂存区</li>\n<li>撤销修改</li>\n<li>删除文件</li>\n</ol>\n</li>\n</ol>\n<a id=\"more\"></a>\n\n<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><h2 id=\"创建版本库\"><a href=\"#创建版本库\" class=\"headerlink\" title=\"创建版本库\"></a>创建版本库</h2><p>1.首先，选择一个合适的地方，创建一个空目录：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mkdir learngit</span><br><span class=\"line\">$ cd learngit</span><br><span class=\"line\">$ pwd</span><br><span class=\"line\">&#x2F;Users&#x2F;michael&#x2F;learngit</span><br></pre></td></tr></table></figure>\n\n<p><strong>pwd</strong>命令用于显示当前目录。</p>\n<p>2.通过git init命令把这个目录变成Git可以管理的仓库：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git init</span><br><span class=\"line\">Initialized empty Git repository in &#x2F;Users&#x2F;michael&#x2F;learngit&#x2F;.git&#x2F;</span><br></pre></td></tr></table></figure>\n\n<p>如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。</p>\n<h2 id=\"把文件添加到文本库\"><a href=\"#把文件添加到文本库\" class=\"headerlink\" title=\"把文件添加到文本库\"></a>把文件添加到文本库</h2><p>用终端建立文件：<br>1.vim 路径/***.txt<br>2.i<br>3.录入内容<br>4.esc<br>5.：wq</p>\n<p>本实例中，把readme.txt放在之前建立的/Users/michael/learngit/下</p>\n<p>内容是：</p>\n<p>“Git is a version control system.<br>Git is free software.”</p>\n<p>1.用命令git add告诉Git，把文件添加到仓库：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add readme.txt</span><br></pre></td></tr></table></figure>\n\n<p>2.用命令git commit告诉Git，把文件提交到仓库：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git commit -m &quot;wrote a readme file&quot;</span><br><span class=\"line\">[master (root-commit) eaadf4e] wrote a readme file</span><br><span class=\"line\"> 1 file changed, 2 insertions(+)</span><br><span class=\"line\"> create mode 100644 readme.txt</span><br></pre></td></tr></table></figure>\n\n<p>git commit命令:-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</p>\n<p>git commit命令执行成功后会告诉你，1 file changed：1个文件被改动（我们新添加的readme.txt文件）；2 insertions：插入了两行内容（readme.txt有两行内容）。</p>\n<p>因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add file1.txt</span><br><span class=\"line\">$ git add file2.txt file3.txt</span><br><span class=\"line\">$ git commit -m &quot;add 3 files.&quot;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"时间穿梭\"><a href=\"#时间穿梭\" class=\"headerlink\" title=\"时间穿梭\"></a>时间穿梭</h1><h2 id=\"观察状态以及变化\"><a href=\"#观察状态以及变化\" class=\"headerlink\" title=\"观察状态以及变化\"></a>观察状态以及变化</h2><p>将之前的readme.txt 改成：</p>\n<p>“Git is a distributed version control system.<br>Git is free software.”</p>\n<p>运行<strong>git status</strong>命令看看结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git status</span><br><span class=\"line\">On branch master</span><br><span class=\"line\">Changes not staged for commit:</span><br><span class=\"line\">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class=\"line\">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class=\"line\"></span><br><span class=\"line\">\tmodified:   readme.txt</span><br><span class=\"line\"></span><br><span class=\"line\">no changes added to commit (use &quot;git add&quot; and&#x2F;or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure>\n\n<p>git status命令可以让我们时刻掌握仓库当前的状态，上面的命令输出告诉我们，readme.txt被修改过了，但还没有准备提交的修改。</p>\n<p>具体修改了什么内容，需要用<strong>git diff</strong>这个命令看看：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git diff readme.txt </span><br><span class=\"line\">diff --git a&#x2F;readme.txt b&#x2F;readme.txt</span><br><span class=\"line\">index 46d49bf..9247db6 100644</span><br><span class=\"line\">--- a&#x2F;readme.txt</span><br><span class=\"line\">+++ b&#x2F;readme.txt</span><br><span class=\"line\">@@ -1,2 +1,2 @@</span><br><span class=\"line\">-Git is a version control system.</span><br><span class=\"line\">+Git is a distributed version control system.</span><br><span class=\"line\"> Git is free software.</span><br></pre></td></tr></table></figure>\n\n<p>可以从上面的命令输出看到，我们在第一行添加了一个distributed单词。</p>\n<p>要将修改过的txt提交到版本库，还是需要git add和git commit.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add readme.txt</span><br></pre></td></tr></table></figure>\n\n<p>在git commit之前用git status查看状态</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git status</span><br><span class=\"line\">On branch master</span><br><span class=\"line\">Changes to be committed:</span><br><span class=\"line\">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class=\"line\">modified: readme.txt</span><br></pre></td></tr></table></figure>\n\n<p>从 modified: readme.txt 可以看出readme.txt发生了变化但是还没有commit</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git commit -m &quot;add distributed&quot;</span><br><span class=\"line\">[master e475afc] add distributed</span><br><span class=\"line\"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>\n\n<p>提交后，查看状态</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git status</span><br><span class=\"line\">On branch master</span><br><span class=\"line\">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"版本回退\"><a href=\"#版本回退\" class=\"headerlink\" title=\"版本回退\"></a>版本回退</h2><p>再次修改文件，改成：</p>\n<p>“Git is a distributed version control system.<br>Git is free software distributed under the GPL.”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add readme.txt</span><br><span class=\"line\">$ git commit -m &quot;append GPL&quot;</span><br><span class=\"line\">[master 1094adb] append GPL</span><br><span class=\"line\"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>\n\n<p>回顾一下：<br>版本1：wrote a readme file<br>Git is a version control system.<br>Git is free software.</p>\n<p>版本2：add distributed<br>Git is a distributed version control system.<br>Git is free software.</p>\n<p>版本3：append GPL<br>Git is a distributed version control system.<br>Git is free software distributed under the GPL.</p>\n<p>可以将<strong>git log</strong>命令查看已有版本:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git log</span><br><span class=\"line\">commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master)</span><br><span class=\"line\">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class=\"line\">Date:   Fri May 18 21:06:15 2018 +0800</span><br><span class=\"line\"></span><br><span class=\"line\">    append GPL</span><br><span class=\"line\"></span><br><span class=\"line\">commit e475afc93c209a690c39c13a46716e8fa000c366</span><br><span class=\"line\">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class=\"line\">Date:   Fri May 18 21:03:36 2018 +0800</span><br><span class=\"line\"></span><br><span class=\"line\">    add distributed</span><br><span class=\"line\"></span><br><span class=\"line\">commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0</span><br><span class=\"line\">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class=\"line\">Date:   Fri May 18 20:59:18 2018 +0800</span><br><span class=\"line\"></span><br><span class=\"line\">    wrote a readme file</span><br></pre></td></tr></table></figure>\n\n<p>如果过于复杂，可用<strong>git log –pretty=oneline</strong>查看commit id和commit说明</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git log --pretty&#x3D;oneline</span><br><span class=\"line\">1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master) append GPL</span><br><span class=\"line\">e475afc93c209a690c39c13a46716e8fa000c366 add distributed</span><br><span class=\"line\">eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme file</span><br></pre></td></tr></table></figure>\n\n<p>当前版本是append GPL,要回溯到add distributed时,就可以使用<strong>git reset</strong>命令：：</p>\n<p>首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交append GPL，上一个版本就是HEAD，上上一个版本就是HEAD，当然往上100个版本写100个比较容易数不过来，所以写成HEAD~100。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git reset --hard HEAD^</span><br><span class=\"line\">HEAD is now at e475afc add distributed</span><br></pre></td></tr></table></figure>\n\n<p>这时查看内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cat readme.txt</span><br><span class=\"line\">Git is a distributed version control system.</span><br><span class=\"line\">Git is free software.</span><br></pre></td></tr></table></figure>\n\n<p>这个时候如果查看版本库：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git log</span><br><span class=\"line\">commit e475afc93c209a690c39c13a46716e8fa000c366 (HEAD -&gt; master)</span><br><span class=\"line\">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class=\"line\">Date:   Fri May 18 21:03:36 2018 +0800</span><br><span class=\"line\"></span><br><span class=\"line\">    add distributed</span><br><span class=\"line\"></span><br><span class=\"line\">commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0</span><br><span class=\"line\">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class=\"line\">Date:   Fri May 18 20:59:18 2018 +0800</span><br><span class=\"line\"></span><br><span class=\"line\">    wrote a readme file</span><br></pre></td></tr></table></figure>\n\n<p>append GPL的版本已经没有了。</p>\n<p>找回方法：</p>\n<ol>\n<li><strong>git reset –hard</strong> – 查找版本号</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git reset --hard 1094a</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>git reflog</strong> – 看之前的指令确定版本号</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git reflog</span><br><span class=\"line\">e475afc HEAD@&#123;1&#125;: reset: moving to HEAD^</span><br><span class=\"line\">1094adb (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: append GPL</span><br><span class=\"line\">e475afc HEAD@&#123;3&#125;: commit: add distributed</span><br><span class=\"line\">eaadf4e HEAD@&#123;4&#125;: commit (initial): wrote a readme file</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"工作区与暂存区\"><a href=\"#工作区与暂存区\" class=\"headerlink\" title=\"工作区与暂存区\"></a>工作区与暂存区</h2><p>git工作分为工作区（可见）与版本库（隐藏目录），在版本库里有暂存区（stage）和分支（master），git add相当于将工作区里被修改的文件加入stage，git commit相当于将stage里的文件一次性提交到master里。</p>\n<p>几种状态：</p>\n<ol>\n<li><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git status</span><br><span class=\"line\">On branch master</span><br><span class=\"line\">Changes not staged for commit:</span><br><span class=\"line\">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class=\"line\">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class=\"line\"></span><br><span class=\"line\">\tmodified:   readme.txt</span><br><span class=\"line\"></span><br><span class=\"line\">Untracked files:</span><br><span class=\"line\">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class=\"line\"></span><br><span class=\"line\">\tLICENSE</span><br><span class=\"line\"></span><br><span class=\"line\">no changes added to commit (use &quot;git add&quot; and&#x2F;or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>modified:readme.txt和no changes added to commit可以看出，readme.txt修改了还没有add。<br>untracked files:LICENSE和no changes added to commit可以看出，LICENSE从来没有添加过。</p>\n<ol start=\"2\">\n<li><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git status</span><br><span class=\"line\">On branch master</span><br><span class=\"line\">Changes to be committed:</span><br><span class=\"line\">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class=\"line\"></span><br><span class=\"line\">\tnew file:   LICENSE</span><br><span class=\"line\">\tmodified:   readme.txt</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>changes to be committed可以看出，这两个文件add后还没有commit。</p>\n<ol start=\"3\">\n<li><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git status</span><br><span class=\"line\">On branch master</span><br><span class=\"line\">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>提交以后，工作树就是干净的了。</p>\n<p>查看工作区与版本库的区别：<strong>git diff HEAD – readme.txt</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git diff HEAD -- readme.txt </span><br><span class=\"line\">diff --git a&#x2F;readme.txt b&#x2F;readme.txt</span><br><span class=\"line\">index 76d770f..a9c5755 100644</span><br><span class=\"line\">--- a&#x2F;readme.txt</span><br><span class=\"line\">+++ b&#x2F;readme.txt</span><br><span class=\"line\">@@ -1,4 +1,4 @@</span><br><span class=\"line\"> Git is a distributed version control system.</span><br><span class=\"line\"> Git is free software distributed under the GPL.</span><br><span class=\"line\"> Git has a mutable index called stage.</span><br><span class=\"line\">-Git tracks changes.</span><br><span class=\"line\">+Git tracks changes of files.</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"撤销修改\"><a href=\"#撤销修改\" class=\"headerlink\" title=\"撤销修改\"></a>撤销修改</h2><ol>\n<li>只是在工作区写错，将工作区的修改丢弃<br><strong>git checkout - - <file></strong> 将工作区的改变撤销（恢复到最近的add/commit状态）</li>\n<li>add后发现错误,将暂存区的修改回退到工作区<br><strong>git reset HEAD <file></strong></li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git reset HEAD readme.txt</span><br><span class=\"line\">Unstaged changes after reset:</span><br><span class=\"line\">M\treadme.txt</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>commit后发现写错，直接回退版本。<br>见版本回退</li>\n</ol>\n<h2 id=\"删除文件\"><a href=\"#删除文件\" class=\"headerlink\" title=\"删除文件\"></a>删除文件</h2><p>工作区：直接从资源管理器里删除/rm <file></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ rm test.txt</span><br></pre></td></tr></table></figure>\n\n<p>此时git status可知，删除后还未添加到.git目录</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git status</span><br><span class=\"line\">On branch master</span><br><span class=\"line\">Changes not staged for commit:</span><br><span class=\"line\">  (use &quot;git add&#x2F;rm &lt;file&gt;...&quot; to update what will be committed)</span><br><span class=\"line\">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class=\"line\"></span><br><span class=\"line\">\tdeleted:    test.txt</span><br><span class=\"line\"></span><br><span class=\"line\">no changes added to commit (use &quot;git add&quot; and&#x2F;or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure>\n\n<p>之后git rm, git commit:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git rm test.txt</span><br><span class=\"line\">rm &#39;test.txt&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">$ git commit -m &quot;remove test.txt&quot;</span><br><span class=\"line\">[master d46f35e] remove test.txt</span><br><span class=\"line\"> 1 file changed, 1 deletion(-)</span><br><span class=\"line\"> delete mode 100644 test.txt</span><br></pre></td></tr></table></figure>\n\n<p>现在就把文件从版本库中被删除了。</p>\n<p>删错时，可用$ git checkout - - <file><br><strong>git checkout</strong>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"概览\"><a href=\"#概览\" class=\"headerlink\" title=\"概览\"></a>概览</h1><p>一. 简介</p>\n<p>​    1. 创建版本库</p>\n<p>​    2. 把文件添加到文本库</p>\n<p>二. 时间穿梭</p>\n<ol>\n<li>观察状态以及变化</li>\n<li>版本回退<ol start=\"3\">\n<li>工作区与暂存区</li>\n<li>撤销修改</li>\n<li>删除文件</li>\n</ol>\n</li>\n</ol>","more":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><h2 id=\"创建版本库\"><a href=\"#创建版本库\" class=\"headerlink\" title=\"创建版本库\"></a>创建版本库</h2><p>1.首先，选择一个合适的地方，创建一个空目录：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mkdir learngit</span><br><span class=\"line\">$ cd learngit</span><br><span class=\"line\">$ pwd</span><br><span class=\"line\">&#x2F;Users&#x2F;michael&#x2F;learngit</span><br></pre></td></tr></table></figure>\n\n<p><strong>pwd</strong>命令用于显示当前目录。</p>\n<p>2.通过git init命令把这个目录变成Git可以管理的仓库：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git init</span><br><span class=\"line\">Initialized empty Git repository in &#x2F;Users&#x2F;michael&#x2F;learngit&#x2F;.git&#x2F;</span><br></pre></td></tr></table></figure>\n\n<p>如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。</p>\n<h2 id=\"把文件添加到文本库\"><a href=\"#把文件添加到文本库\" class=\"headerlink\" title=\"把文件添加到文本库\"></a>把文件添加到文本库</h2><p>用终端建立文件：<br>1.vim 路径/***.txt<br>2.i<br>3.录入内容<br>4.esc<br>5.：wq</p>\n<p>本实例中，把readme.txt放在之前建立的/Users/michael/learngit/下</p>\n<p>内容是：</p>\n<p>“Git is a version control system.<br>Git is free software.”</p>\n<p>1.用命令git add告诉Git，把文件添加到仓库：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add readme.txt</span><br></pre></td></tr></table></figure>\n\n<p>2.用命令git commit告诉Git，把文件提交到仓库：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git commit -m &quot;wrote a readme file&quot;</span><br><span class=\"line\">[master (root-commit) eaadf4e] wrote a readme file</span><br><span class=\"line\"> 1 file changed, 2 insertions(+)</span><br><span class=\"line\"> create mode 100644 readme.txt</span><br></pre></td></tr></table></figure>\n\n<p>git commit命令:-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</p>\n<p>git commit命令执行成功后会告诉你，1 file changed：1个文件被改动（我们新添加的readme.txt文件）；2 insertions：插入了两行内容（readme.txt有两行内容）。</p>\n<p>因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add file1.txt</span><br><span class=\"line\">$ git add file2.txt file3.txt</span><br><span class=\"line\">$ git commit -m &quot;add 3 files.&quot;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"时间穿梭\"><a href=\"#时间穿梭\" class=\"headerlink\" title=\"时间穿梭\"></a>时间穿梭</h1><h2 id=\"观察状态以及变化\"><a href=\"#观察状态以及变化\" class=\"headerlink\" title=\"观察状态以及变化\"></a>观察状态以及变化</h2><p>将之前的readme.txt 改成：</p>\n<p>“Git is a distributed version control system.<br>Git is free software.”</p>\n<p>运行<strong>git status</strong>命令看看结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git status</span><br><span class=\"line\">On branch master</span><br><span class=\"line\">Changes not staged for commit:</span><br><span class=\"line\">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class=\"line\">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class=\"line\"></span><br><span class=\"line\">\tmodified:   readme.txt</span><br><span class=\"line\"></span><br><span class=\"line\">no changes added to commit (use &quot;git add&quot; and&#x2F;or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure>\n\n<p>git status命令可以让我们时刻掌握仓库当前的状态，上面的命令输出告诉我们，readme.txt被修改过了，但还没有准备提交的修改。</p>\n<p>具体修改了什么内容，需要用<strong>git diff</strong>这个命令看看：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git diff readme.txt </span><br><span class=\"line\">diff --git a&#x2F;readme.txt b&#x2F;readme.txt</span><br><span class=\"line\">index 46d49bf..9247db6 100644</span><br><span class=\"line\">--- a&#x2F;readme.txt</span><br><span class=\"line\">+++ b&#x2F;readme.txt</span><br><span class=\"line\">@@ -1,2 +1,2 @@</span><br><span class=\"line\">-Git is a version control system.</span><br><span class=\"line\">+Git is a distributed version control system.</span><br><span class=\"line\"> Git is free software.</span><br></pre></td></tr></table></figure>\n\n<p>可以从上面的命令输出看到，我们在第一行添加了一个distributed单词。</p>\n<p>要将修改过的txt提交到版本库，还是需要git add和git commit.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add readme.txt</span><br></pre></td></tr></table></figure>\n\n<p>在git commit之前用git status查看状态</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git status</span><br><span class=\"line\">On branch master</span><br><span class=\"line\">Changes to be committed:</span><br><span class=\"line\">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class=\"line\">modified: readme.txt</span><br></pre></td></tr></table></figure>\n\n<p>从 modified: readme.txt 可以看出readme.txt发生了变化但是还没有commit</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git commit -m &quot;add distributed&quot;</span><br><span class=\"line\">[master e475afc] add distributed</span><br><span class=\"line\"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>\n\n<p>提交后，查看状态</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git status</span><br><span class=\"line\">On branch master</span><br><span class=\"line\">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"版本回退\"><a href=\"#版本回退\" class=\"headerlink\" title=\"版本回退\"></a>版本回退</h2><p>再次修改文件，改成：</p>\n<p>“Git is a distributed version control system.<br>Git is free software distributed under the GPL.”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add readme.txt</span><br><span class=\"line\">$ git commit -m &quot;append GPL&quot;</span><br><span class=\"line\">[master 1094adb] append GPL</span><br><span class=\"line\"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>\n\n<p>回顾一下：<br>版本1：wrote a readme file<br>Git is a version control system.<br>Git is free software.</p>\n<p>版本2：add distributed<br>Git is a distributed version control system.<br>Git is free software.</p>\n<p>版本3：append GPL<br>Git is a distributed version control system.<br>Git is free software distributed under the GPL.</p>\n<p>可以将<strong>git log</strong>命令查看已有版本:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git log</span><br><span class=\"line\">commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master)</span><br><span class=\"line\">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class=\"line\">Date:   Fri May 18 21:06:15 2018 +0800</span><br><span class=\"line\"></span><br><span class=\"line\">    append GPL</span><br><span class=\"line\"></span><br><span class=\"line\">commit e475afc93c209a690c39c13a46716e8fa000c366</span><br><span class=\"line\">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class=\"line\">Date:   Fri May 18 21:03:36 2018 +0800</span><br><span class=\"line\"></span><br><span class=\"line\">    add distributed</span><br><span class=\"line\"></span><br><span class=\"line\">commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0</span><br><span class=\"line\">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class=\"line\">Date:   Fri May 18 20:59:18 2018 +0800</span><br><span class=\"line\"></span><br><span class=\"line\">    wrote a readme file</span><br></pre></td></tr></table></figure>\n\n<p>如果过于复杂，可用<strong>git log –pretty=oneline</strong>查看commit id和commit说明</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git log --pretty&#x3D;oneline</span><br><span class=\"line\">1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master) append GPL</span><br><span class=\"line\">e475afc93c209a690c39c13a46716e8fa000c366 add distributed</span><br><span class=\"line\">eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme file</span><br></pre></td></tr></table></figure>\n\n<p>当前版本是append GPL,要回溯到add distributed时,就可以使用<strong>git reset</strong>命令：：</p>\n<p>首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交append GPL，上一个版本就是HEAD，上上一个版本就是HEAD，当然往上100个版本写100个比较容易数不过来，所以写成HEAD~100。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git reset --hard HEAD^</span><br><span class=\"line\">HEAD is now at e475afc add distributed</span><br></pre></td></tr></table></figure>\n\n<p>这时查看内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cat readme.txt</span><br><span class=\"line\">Git is a distributed version control system.</span><br><span class=\"line\">Git is free software.</span><br></pre></td></tr></table></figure>\n\n<p>这个时候如果查看版本库：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git log</span><br><span class=\"line\">commit e475afc93c209a690c39c13a46716e8fa000c366 (HEAD -&gt; master)</span><br><span class=\"line\">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class=\"line\">Date:   Fri May 18 21:03:36 2018 +0800</span><br><span class=\"line\"></span><br><span class=\"line\">    add distributed</span><br><span class=\"line\"></span><br><span class=\"line\">commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0</span><br><span class=\"line\">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class=\"line\">Date:   Fri May 18 20:59:18 2018 +0800</span><br><span class=\"line\"></span><br><span class=\"line\">    wrote a readme file</span><br></pre></td></tr></table></figure>\n\n<p>append GPL的版本已经没有了。</p>\n<p>找回方法：</p>\n<ol>\n<li><strong>git reset –hard</strong> – 查找版本号</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git reset --hard 1094a</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>git reflog</strong> – 看之前的指令确定版本号</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git reflog</span><br><span class=\"line\">e475afc HEAD@&#123;1&#125;: reset: moving to HEAD^</span><br><span class=\"line\">1094adb (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: append GPL</span><br><span class=\"line\">e475afc HEAD@&#123;3&#125;: commit: add distributed</span><br><span class=\"line\">eaadf4e HEAD@&#123;4&#125;: commit (initial): wrote a readme file</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"工作区与暂存区\"><a href=\"#工作区与暂存区\" class=\"headerlink\" title=\"工作区与暂存区\"></a>工作区与暂存区</h2><p>git工作分为工作区（可见）与版本库（隐藏目录），在版本库里有暂存区（stage）和分支（master），git add相当于将工作区里被修改的文件加入stage，git commit相当于将stage里的文件一次性提交到master里。</p>\n<p>几种状态：</p>\n<ol>\n<li><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git status</span><br><span class=\"line\">On branch master</span><br><span class=\"line\">Changes not staged for commit:</span><br><span class=\"line\">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class=\"line\">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class=\"line\"></span><br><span class=\"line\">\tmodified:   readme.txt</span><br><span class=\"line\"></span><br><span class=\"line\">Untracked files:</span><br><span class=\"line\">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class=\"line\"></span><br><span class=\"line\">\tLICENSE</span><br><span class=\"line\"></span><br><span class=\"line\">no changes added to commit (use &quot;git add&quot; and&#x2F;or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>modified:readme.txt和no changes added to commit可以看出，readme.txt修改了还没有add。<br>untracked files:LICENSE和no changes added to commit可以看出，LICENSE从来没有添加过。</p>\n<ol start=\"2\">\n<li><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git status</span><br><span class=\"line\">On branch master</span><br><span class=\"line\">Changes to be committed:</span><br><span class=\"line\">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class=\"line\"></span><br><span class=\"line\">\tnew file:   LICENSE</span><br><span class=\"line\">\tmodified:   readme.txt</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>changes to be committed可以看出，这两个文件add后还没有commit。</p>\n<ol start=\"3\">\n<li><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git status</span><br><span class=\"line\">On branch master</span><br><span class=\"line\">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>提交以后，工作树就是干净的了。</p>\n<p>查看工作区与版本库的区别：<strong>git diff HEAD – readme.txt</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git diff HEAD -- readme.txt </span><br><span class=\"line\">diff --git a&#x2F;readme.txt b&#x2F;readme.txt</span><br><span class=\"line\">index 76d770f..a9c5755 100644</span><br><span class=\"line\">--- a&#x2F;readme.txt</span><br><span class=\"line\">+++ b&#x2F;readme.txt</span><br><span class=\"line\">@@ -1,4 +1,4 @@</span><br><span class=\"line\"> Git is a distributed version control system.</span><br><span class=\"line\"> Git is free software distributed under the GPL.</span><br><span class=\"line\"> Git has a mutable index called stage.</span><br><span class=\"line\">-Git tracks changes.</span><br><span class=\"line\">+Git tracks changes of files.</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"撤销修改\"><a href=\"#撤销修改\" class=\"headerlink\" title=\"撤销修改\"></a>撤销修改</h2><ol>\n<li>只是在工作区写错，将工作区的修改丢弃<br><strong>git checkout - - <file></strong> 将工作区的改变撤销（恢复到最近的add/commit状态）</li>\n<li>add后发现错误,将暂存区的修改回退到工作区<br><strong>git reset HEAD <file></strong></li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git reset HEAD readme.txt</span><br><span class=\"line\">Unstaged changes after reset:</span><br><span class=\"line\">M\treadme.txt</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>commit后发现写错，直接回退版本。<br>见版本回退</li>\n</ol>\n<h2 id=\"删除文件\"><a href=\"#删除文件\" class=\"headerlink\" title=\"删除文件\"></a>删除文件</h2><p>工作区：直接从资源管理器里删除/rm <file></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ rm test.txt</span><br></pre></td></tr></table></figure>\n\n<p>此时git status可知，删除后还未添加到.git目录</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git status</span><br><span class=\"line\">On branch master</span><br><span class=\"line\">Changes not staged for commit:</span><br><span class=\"line\">  (use &quot;git add&#x2F;rm &lt;file&gt;...&quot; to update what will be committed)</span><br><span class=\"line\">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class=\"line\"></span><br><span class=\"line\">\tdeleted:    test.txt</span><br><span class=\"line\"></span><br><span class=\"line\">no changes added to commit (use &quot;git add&quot; and&#x2F;or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure>\n\n<p>之后git rm, git commit:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git rm test.txt</span><br><span class=\"line\">rm &#39;test.txt&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">$ git commit -m &quot;remove test.txt&quot;</span><br><span class=\"line\">[master d46f35e] remove test.txt</span><br><span class=\"line\"> 1 file changed, 1 deletion(-)</span><br><span class=\"line\"> delete mode 100644 test.txt</span><br></pre></td></tr></table></figure>\n\n<p>现在就把文件从版本库中被删除了。</p>\n<p>删错时，可用$ git checkout - - <file><br><strong>git checkout</strong>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p>"},{"date":"2020-01-27T16:00:00.000Z","_content":"# 概览\n\n一. 远程仓库\n\n1. 创建SSH密钥\n2. 创建远程库\n3. 从远程库克隆\n\n二. 分支管理\n\n1. 创建与合并分支\n\n2. 解决冲突\n\n3. 分支管理策略\n\n4. Bug分支\n\n5. feature分支\n\n6. 多人协作\n\n7. rebase\n\n   <!-- more -->\n\n## 远程仓库\n\n## 创建SSH密钥\n\ngithub提供远程仓库，本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，需要设置：\n\n创建SSH key\n\n```\n$ ssh-keygen -t rsa -C \"Dengmengda@Gmail.com\"\n```\n\n一路回车\n\n如果一切顺利的话，可以在用户主目(cd ~)(ls)录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。\n\n查看：(cat)\n\n```\nadeMacBook-Air:.ssh una$ cat ~/.ssh/id_rsa.pub\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQD2WRdPq72pjh5ZiG7fzhFwHsZtQ7KbWA4ZF0G6LoFmh4JTSkGOTBaixu8+NNmRksxYKVenYwqFPT2meWocDm19Lly6wN6+rxdf9pmiRRv+5zJb4XkGi2j4+foPt1XPYc1FZM6lzeyh127W5+2VPZDG7hKatzh9OEsiKXHI5OaANPpW+diPs/kAEMsrMMuzMOUTJFhbqaS48Pv1aZaSBotI2YbHjOEGA2KAXH1dEepLM17fpVvFV3eVi5k+erTOj38yxiW598x+ZBrig5Jwf+6X1LJiB7VFW1QEqCcQxf1aEgErhRmrxEp+YWnJQCJHvWjp8N7f+txYFkoBkJfoq4zD Dengmengda@Gmail.com\n```\n\n之后，登录github，在settings->SSH key添加SSHkey(id_rsa.pub公钥)\n\n## 创建远程库\n\n在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，让这两个仓库进行远程同步。So,GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作\n\n在github里creat a new repository\n\n在GitHub上的这个learngit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。\n\n根据提示\n\n```\ngit remote add origin https://github.com/Unalian/learngit.git\ngit push -u origin master\n```\n\n由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。\n\n之后就可以在github的页面里看见了。\n以后修改就可以\n\n```\n$ git push origin master\n```\n\n将修改推至远程版本库了，这样就真正拥有了一个分布式版本库。\n\n在过程中会有SSH警告，yes即可。\n\n## 从远程库克隆\n\n在github上建立一个新的库，勾选**Initialize this repository with a README**，这样系统会自动建立一个README.md的文件。这样远程库就准备好了。\n\n下一步是用命令git clone克隆一个本地库：\n\n```\n$ git clone git@github.com:Unalian/gitskills.git\nCloning into 'gitskills'...\nremote: Counting objects: 3, done.\nremote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 3\nReceiving objects: 100% (3/3), done.\n```\n\nGit支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。\n\n# 分支管理\n\n分支：\n分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。\n现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。\n\n## 创建与合并分支\n\n创建dev分支\n\n```\n$ git branch dev\n```\n\n切换到dev分支\n\n```\n$ git checkout dev\nSwitched to branch 'dev'\n```\n\n将两个指令综合起来就是\n\n```\n$ git checkout -b dev\nSwitched to a new branch 'dev'\n```\n\n查看所有分支（当前分支前有*）\n\n```\n$ git branch\n* dev\n  master\n```\n\n然后在dev分支上正常提交，比如在readme.txt上进行修改\n加上一行\nCreating a new branch is quick.\n\n提交：\n\n```\n$ git add readme.txt \n$ git commit -m \"branch test\"\n[dev b17d20e] branch test\n 1 file changed, 1 insertion(+)\n```\n\ndev分支搞定，现在切回master分支：\n\n```\n$ git checkout master\nSwitched to branch 'master'\n```\n\n如果此时查看readme.txt，就会发现还是没有改变。因此，需要合并branch到master上。\n\n```\n$ git merge dev\nUpdating d46f35e..b17d20e\nFast-forward\n readme.txt | 1 +\n 1 file changed, 1 insertion(+)\n```\n\n这里提到，本次合并是Fast-forward，因此，是直接将master指向dev的当前提交，合并速度快，但是也有其他的合并方式。\n\n通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。\n\n如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。\n\n合并完成后，就可以删除dev分支。\n\n```\n$ git branch -d dev\nDeleted branch dev (was b17d20e).\n```\n\n总结：\n\n```\n查看分支：git branch\n\n创建分支：git branch <name>\n\n切换分支：git checkout <name>\n\n创建+切换分支：git checkout -b <name>\n\n合并某分支到当前分支：git merge <name>\n\n删除分支：git branch -d <name>\n```\n\n## 解决冲突\n\n创建feature1分支，然后在master，feature1都进行修改，在尝试快速合并时会出现冲突。\n\n```\n$ git merge feature1\nAuto-merging readme.txt\nCONFLICT (content): Merge conflict in readme.txt\nAutomatic merge failed; fix conflicts and then commit the result.\n```\n\n这个时候查看状态：\n\n```\n$ git status\nOn branch master\nYour branch is ahead of 'origin/master' by 2 commits.\n  (use \"git push\" to publish your local commits)\n\nYou have unmerged paths.\n  (fix conflicts and run \"git commit\")\n  (use \"git merge --abort\" to abort the merge)\n\nUnmerged paths:\n  (use \"git add <file>...\" to mark resolution)\n\n\tboth modified:   readme.txt\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n```\n\n这个时候查看readme.txt的内容：\n\n```\nGit is a distributed version control system.\nGit is free software distributed under the GPL.\nGit has a mutable index called stage.\nGit tracks changes of files.\n<<<<<<< HEAD\nCreating a new branch is quick & simple.\n=======\nCreating a new branch is quick AND simple.\n>>>>>>> feature1\n```\n\n可清晰看出不同分支的区别，这个时候就可以手动修改文件，解决冲突。\n\ngit log也可以查看分支合并情况。\n\n最后，删除feature1就可以了：\n\n```\n$git branch -d feature1\n```\n\n## 分支管理策略\n\n1. fast-forward\n2. `--no-ff` (强制禁用fast-forward)\n\n```\n$ git merge --no-ff -m \"merge with no-ff\" dev\nMerge made by the 'recursive' strategy.\n readme.txt | 1 +\n 1 file changed, 1 insertion(+)\n```\n\n因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。\n合并分支时，加上–no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。\n\n```\n$ git log --graph --pretty=oneline --abbrev-commit\n*   e1e9c68 (HEAD -> master) merge with no-ff\n|\\  \n| * f52c633 (dev) add merge\n|/  \n*   cf810e4 conflict fixed\n```\n\n## Bug分支\n\n修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；\n\n当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场；\n\n在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick <commit>命令，把bug提交的修改“复制”到当前分支，避免重复劳动。\n\n比如此刻在dev工作，但是master出现了bug，要切换到master然后开一个BUG分支。这就要求dev分支commit。但是，dev的工作还没有做完，不想将它commit，因此用git stash将工作区封存。\n\n```\n$ git stash\nSaved working directory and index state WIP on dev: f52c633 add merge\n```\n\n将dev工作区封存，此时可以开始修改bug\n\n```\n$ git checkout master\nSwitched to branch 'master'\nYour branch is ahead of 'origin/master' by 6 commits.\n  (use \"git push\" to publish your local commits)\n\n$ git checkout -b issue-101\nSwitched to a new branch 'issue-101'\n\n$ git add readme.txt \n$ git commit -m \"fix bug 101\"\n[issue-101 4c805e2] fix bug 101\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n$ git checkout master\nSwitched to branch 'master'\nYour branch is ahead of 'origin/master' by 6 commits.\n  (use \"git push\" to publish your local commits)\n\n$ git merge --no-ff -m \"merged bug fix 101\" issue-101\nMerge made by the 'recursive' strategy.\n readme.txt | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n \n $ git branch -d issue-101\nDeleted branch issue-101 (was b17d20e).\n```\n\n将bug修改完毕以后可以开始重回dev工作。第一件事就是找回封存区的文件：\n\n```\n$ git stash list\nstash@{0}: WIP on dev: f52c633 add merge\n```\n\n发现文件被存在某个地方，第二件事就是恢复文件。\n\n一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；\n\n```\n$ git stash apply stash@{0}\n$ git stash drop stash@{0}\n```\n\n另一种方式是用git stash pop，恢复的同时把stash内容也删了：\n\n```\n$ git stash pop\nOn branch dev\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\n\n\tnew file:   hello.py\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n\tmodified:   readme.txt\n\nDropped refs/stash@{0} (5d677e2ee266f39ea296182fb2354265b91b3b2a)\n```\n\n再用git stash list康，发现stash已经空了。\n\n这个时候dev可以继续工作了。但是我们想要将我们在master上做的bug修改复制到dev上。当然，我们可以重复操作，不过没必要。同样的bug，要在dev上修复，我们只需要把4c805e2 fix bug 101这个提交所做的修改“复制”到dev分支。\n\n注意：我们只想复制4c805e2 fix bug 101这个提交所做的修改，并不是把整个master分支merge过来。\n\n为了方便操作，Git专门提供了一个**cherry-pick**命令，让我们能复制一个特定的提交到当前分支：\n\n```\n$ git branch\n* dev\n  master\n$ git cherry-pick 4c805e2\n[master 1d4b803] fix bug 101\n 1 file changed, 1 insertion(+), 1 deletion(-)\n```\n\n## feature分支\n\n一个新功能，最好用feature分支实验，如果实验失败，可以直接删除。\n这个时候，因为分支没有合并，所以需要强行删除：\n\n```\n$ git branch -D feature-vulcan\nDeleted branch feature-vulcan (was 287773e).\n```\n\n## 多人协作\n\n多人协作的工作模式通常是这样：\n\n1. 试图用git push origin <branch-name>推送自己的修改；\n2. 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；\n3. 如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to <branch-name> origin/<branch-name>。\n4. 如果合并有冲突，则解决冲突，并在本地提交；\n5. 没有冲突或者解决掉冲突后，再用git push origin <branch-name>推送就能成功！\n\n基本指令：\n\n1. 查看远程库信息，使用git remote -v；\n2. 本地新建的分支如果不推送到远程，对其他人就是不可见的；\n3. 从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；\n4. 在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；\n5. 建立本地分支和远程分支的关联，使用git branch --set-upstream branch-name origin/branch-name；\n6. 从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。\n\n<1>查看远程库\n查看远程库信息：\n\n```\n$ git remote\norigin\n```\n\n查看远程库详细信息：\n\n```\n$ git remote -v\norigin  git@github.com:michaelliao/learngit.git (fetch)\norigin  git@github.com:michaelliao/learngit.git (push)\n```\n\n如果没有推送权限，就看不见push地址\n\n<2>推送分支\n推送本地master到远程库\n\n```\n$ git push origin master\n```\n\n推送本地dev到远程库\n\n```\n$ git push origin dev\n```\n\n- master分支是主分支，因此要时刻与远程同步；\n- dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；\n- bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；\n- feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。\n\n<3>抓取分支\n\n将远程库克隆：\n\n```\ngit clone git@github.com:Unalian/learngit.git\n$ git branch\n* master\n```\n\n此时只有master。（git branch q 退出）\n\n要在dev分支上开发，就必须创建远程origin的dev分支到本地：\n\n```\n$ git checkout -b dev origin/dev\n```\n\n现在，他就可以在dev上继续修改，然后，时不时地把dev分支push到远程：\n\n```\n$ git commit -m \"add env\"\n[dev 7a5e5dd] add env\n 1 file changed, 1 insertion(+)\n create mode 100644 env.txt\n\n$ git push origin dev\nCounting objects: 3, done.\nDelta compression using up to 4 threads.\nCompressing objects: 100% (2/2), done.\nWriting objects: 100% (3/3), 308 bytes | 308.00 KiB/s, done.\nTotal 3 (delta 0), reused 0 (delta 0)\nTo github.com:michaelliao/learngit.git\n   f52c633..7a5e5dd  dev -> dev\n```\n\n这个push的时候，如果发现有一个人也同时将自己的更改push了，此时，就会发生冲突。因此，我们需要pull最新版本的提交，并与我将要push的版本进行冲突处理，最后再进行push。\n\n将最新的提交从origin/dev上抓取下来：\n\n```\n$ git pull\nThere is no tracking information for the current branch.\nPlease specify which branch you want to merge with.\nSee git-pull(1) for details.\n\n    git pull <remote> <branch>\n\nIf you wish to set tracking information for this branch you can do so with:\n\n    git branch --set-upstream-to=origin/<branch> dev\n```\n\n这里显示抓取失败，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接：\n\n```\n$ git branch --set-upstream-to=origin/dev dev\nBranch 'dev' set up to track remote branch 'dev' from 'origin'.\n```\n\n再pull：\n\n```\n$ git pull\nAuto-merging env.txt\nCONFLICT (add/add): Merge conflict in env.txt\nAutomatic merge failed; fix conflicts and then commit the result.\n```\n\npull成功但是合并出现冲突,手动处理冲突，再次push。（pull的同时会发生合并）\n\n```\n$ git commit -m \"fix env conflict\"\n[dev 57c53ab] fix env conflict\n\n$ git push origin dev\nCounting objects: 6, done.\nDelta compression using up to 4 threads.\nCompressing objects: 100% (4/4), done.\nWriting objects: 100% (6/6), 621 bytes | 621.00 KiB/s, done.\nTotal 6 (delta 0), reused 0 (delta 0)\nTo github.com:michaelliao/learngit.git\n   7a5e5dd..57c53ab  dev -> dev\n```\n\n## rebase\n\nrebase操作可以把本地未push的分叉提交历史整理成直线；\n\nrebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。\n\n在上一节我们看到了，多人在同一个分支上协作时，很容易出现冲突。即使没有冲突，后push的童鞋不得不先pull，在本地合并，然后才能push成功。\n\n每次合并再push后，分支变成了这样：\n\n```\n$ git log --graph --pretty=oneline --abbrev-commit\n* d1be385 (HEAD -> master, origin/master) init hello\n*   e5e69f1 Merge branch 'dev'\n|\\  \n| *   57c53ab (origin/dev, dev) fix env conflict\n| |\\  \n| | * 7a5e5dd add env\n| * | 7bd91f1 add new env\n| |/  \n* |   12a631b merged bug fix 101\n|\\ \\  \n| * | 4c805e2 fix bug 101\n|/ /  \n* |   e1e9c68 merge with no-ff\n|\\ \\  \n| |/  \n| * f52c633 add merge\n|/  \n*   cf810e4 conflict fixed\n```\n\n注意到Git用(HEAD -> master)和(origin/master)标识出当前分支的HEAD和远程origin的位置分别是582d922 add author和d1be385 init hello，本地分支比远程分支快两个提交。\n\n现在我们尝试推送本地分支：\n\n```\n$ git push origin master\nTo github.com:michaelliao/learngit.git\n ! [rejected]        master -> master (fetch first)\nerror: failed to push some refs to 'git@github.com:michaelliao/learngit.git'\nhint: Updates were rejected because the remote contains work that you do\nhint: not have locally. This is usually caused by another repository pushing\nhint: to the same ref. You may want to first integrate the remote changes\nhint: (e.g., 'git pull ...') before pushing again.\nhint: See the 'Note about fast-forwards' in 'git push --help' for details.\n```\n\n很不幸，失败了，这说明有人先于我们推送了远程分支。按照经验，先pull一下：\n\n```\n$ git pull\nremote: Counting objects: 3, done.\nremote: Compressing objects: 100% (1/1), done.\nremote: Total 3 (delta 1), reused 3 (delta 1), pack-reused 0\nUnpacking objects: 100% (3/3), done.\nFrom github.com:michaelliao/learngit\n   d1be385..f005ed4  master     -> origin/master\n * [new tag]         v1.0       -> v1.0\nAuto-merging hello.py\nMerge made by the 'recursive' strategy.\n hello.py | 1 +\n 1 file changed, 1 insertion(+)\n```\n\n再用git status看看状态：\n\n```\n$ git status\nOn branch master\nYour branch is ahead of 'origin/master' by 3 commits.\n  (use \"git push\" to publish your local commits)\n\nnothing to commit, working tree clean\n```\n\n加上刚才合并的提交，现在我们本地分支比远程分支超前3个提交。\n\n用git log看看：\n\n```\n$ git log --graph --pretty=oneline --abbrev-commit\n*   e0ea545 (HEAD -> master) Merge branch 'master' of github.com:michaelliao/learngit\n|\\  \n| * f005ed4 (origin/master) set exit=1\n* | 582d922 add author\n* | 8875536 add comment\n|/  \n* d1be385 init hello\n...\n```\n\n提交历史分叉就很不方便了，我们想把这些化成一条直线。\n输入命令**git rebase**\n\n```\n$ git rebase\nFirst, rewinding head to replay your work on top of it...\nApplying: add comment\nUsing index info to reconstruct a base tree...\nM\thello.py\nFalling back to patching base and 3-way merge...\nAuto-merging hello.py\nApplying: add author\nUsing index info to reconstruct a base tree...\nM\thello.py\nFalling back to patching base and 3-way merge...\nAuto-merging hello.py\n```\n\n再git log\n\n```\n$ git log --graph --pretty=oneline --abbrev-commit\n* 7e61ed4 (HEAD -> master) add author\n* 3611cfe add comment\n* f005ed4 (origin/master) set exit=1\n* d1be385 init hello\n...\n```\n\n这就是rebase操作的特点：把分叉的提交历史“整理”成一条直线，看上去更直观。缺点是本地的分叉提交已经被修改过了。\n\n最后，通过push操作把本地分支推送到远程：\n\n```\nMac:~/learngit michael$ git push origin master\nCounting objects: 6, done.\nDelta compression using up to 4 threads.\nCompressing objects: 100% (5/5), done.\nWriting objects: 100% (6/6), 576 bytes | 576.00 KiB/s, done.\nTotal 6 (delta 2), reused 0 (delta 0)\nremote: Resolving deltas: 100% (2/2), completed with 1 local object.\nTo github.com:michaelliao/learngit.git\n   f005ed4..7e61ed4  master -> master\n```","source":"_posts/Git 自学（二）远程仓库与分支管理.md","raw":"---\ndate: 2020/1/28\ntags:\n- git\n- 自学笔记\ncategories:\n- github\n---\n# 概览\n\n一. 远程仓库\n\n1. 创建SSH密钥\n2. 创建远程库\n3. 从远程库克隆\n\n二. 分支管理\n\n1. 创建与合并分支\n\n2. 解决冲突\n\n3. 分支管理策略\n\n4. Bug分支\n\n5. feature分支\n\n6. 多人协作\n\n7. rebase\n\n   <!-- more -->\n\n## 远程仓库\n\n## 创建SSH密钥\n\ngithub提供远程仓库，本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，需要设置：\n\n创建SSH key\n\n```\n$ ssh-keygen -t rsa -C \"Dengmengda@Gmail.com\"\n```\n\n一路回车\n\n如果一切顺利的话，可以在用户主目(cd ~)(ls)录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。\n\n查看：(cat)\n\n```\nadeMacBook-Air:.ssh una$ cat ~/.ssh/id_rsa.pub\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQD2WRdPq72pjh5ZiG7fzhFwHsZtQ7KbWA4ZF0G6LoFmh4JTSkGOTBaixu8+NNmRksxYKVenYwqFPT2meWocDm19Lly6wN6+rxdf9pmiRRv+5zJb4XkGi2j4+foPt1XPYc1FZM6lzeyh127W5+2VPZDG7hKatzh9OEsiKXHI5OaANPpW+diPs/kAEMsrMMuzMOUTJFhbqaS48Pv1aZaSBotI2YbHjOEGA2KAXH1dEepLM17fpVvFV3eVi5k+erTOj38yxiW598x+ZBrig5Jwf+6X1LJiB7VFW1QEqCcQxf1aEgErhRmrxEp+YWnJQCJHvWjp8N7f+txYFkoBkJfoq4zD Dengmengda@Gmail.com\n```\n\n之后，登录github，在settings->SSH key添加SSHkey(id_rsa.pub公钥)\n\n## 创建远程库\n\n在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，让这两个仓库进行远程同步。So,GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作\n\n在github里creat a new repository\n\n在GitHub上的这个learngit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。\n\n根据提示\n\n```\ngit remote add origin https://github.com/Unalian/learngit.git\ngit push -u origin master\n```\n\n由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。\n\n之后就可以在github的页面里看见了。\n以后修改就可以\n\n```\n$ git push origin master\n```\n\n将修改推至远程版本库了，这样就真正拥有了一个分布式版本库。\n\n在过程中会有SSH警告，yes即可。\n\n## 从远程库克隆\n\n在github上建立一个新的库，勾选**Initialize this repository with a README**，这样系统会自动建立一个README.md的文件。这样远程库就准备好了。\n\n下一步是用命令git clone克隆一个本地库：\n\n```\n$ git clone git@github.com:Unalian/gitskills.git\nCloning into 'gitskills'...\nremote: Counting objects: 3, done.\nremote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 3\nReceiving objects: 100% (3/3), done.\n```\n\nGit支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。\n\n# 分支管理\n\n分支：\n分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。\n现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。\n\n## 创建与合并分支\n\n创建dev分支\n\n```\n$ git branch dev\n```\n\n切换到dev分支\n\n```\n$ git checkout dev\nSwitched to branch 'dev'\n```\n\n将两个指令综合起来就是\n\n```\n$ git checkout -b dev\nSwitched to a new branch 'dev'\n```\n\n查看所有分支（当前分支前有*）\n\n```\n$ git branch\n* dev\n  master\n```\n\n然后在dev分支上正常提交，比如在readme.txt上进行修改\n加上一行\nCreating a new branch is quick.\n\n提交：\n\n```\n$ git add readme.txt \n$ git commit -m \"branch test\"\n[dev b17d20e] branch test\n 1 file changed, 1 insertion(+)\n```\n\ndev分支搞定，现在切回master分支：\n\n```\n$ git checkout master\nSwitched to branch 'master'\n```\n\n如果此时查看readme.txt，就会发现还是没有改变。因此，需要合并branch到master上。\n\n```\n$ git merge dev\nUpdating d46f35e..b17d20e\nFast-forward\n readme.txt | 1 +\n 1 file changed, 1 insertion(+)\n```\n\n这里提到，本次合并是Fast-forward，因此，是直接将master指向dev的当前提交，合并速度快，但是也有其他的合并方式。\n\n通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。\n\n如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。\n\n合并完成后，就可以删除dev分支。\n\n```\n$ git branch -d dev\nDeleted branch dev (was b17d20e).\n```\n\n总结：\n\n```\n查看分支：git branch\n\n创建分支：git branch <name>\n\n切换分支：git checkout <name>\n\n创建+切换分支：git checkout -b <name>\n\n合并某分支到当前分支：git merge <name>\n\n删除分支：git branch -d <name>\n```\n\n## 解决冲突\n\n创建feature1分支，然后在master，feature1都进行修改，在尝试快速合并时会出现冲突。\n\n```\n$ git merge feature1\nAuto-merging readme.txt\nCONFLICT (content): Merge conflict in readme.txt\nAutomatic merge failed; fix conflicts and then commit the result.\n```\n\n这个时候查看状态：\n\n```\n$ git status\nOn branch master\nYour branch is ahead of 'origin/master' by 2 commits.\n  (use \"git push\" to publish your local commits)\n\nYou have unmerged paths.\n  (fix conflicts and run \"git commit\")\n  (use \"git merge --abort\" to abort the merge)\n\nUnmerged paths:\n  (use \"git add <file>...\" to mark resolution)\n\n\tboth modified:   readme.txt\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n```\n\n这个时候查看readme.txt的内容：\n\n```\nGit is a distributed version control system.\nGit is free software distributed under the GPL.\nGit has a mutable index called stage.\nGit tracks changes of files.\n<<<<<<< HEAD\nCreating a new branch is quick & simple.\n=======\nCreating a new branch is quick AND simple.\n>>>>>>> feature1\n```\n\n可清晰看出不同分支的区别，这个时候就可以手动修改文件，解决冲突。\n\ngit log也可以查看分支合并情况。\n\n最后，删除feature1就可以了：\n\n```\n$git branch -d feature1\n```\n\n## 分支管理策略\n\n1. fast-forward\n2. `--no-ff` (强制禁用fast-forward)\n\n```\n$ git merge --no-ff -m \"merge with no-ff\" dev\nMerge made by the 'recursive' strategy.\n readme.txt | 1 +\n 1 file changed, 1 insertion(+)\n```\n\n因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。\n合并分支时，加上–no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。\n\n```\n$ git log --graph --pretty=oneline --abbrev-commit\n*   e1e9c68 (HEAD -> master) merge with no-ff\n|\\  \n| * f52c633 (dev) add merge\n|/  \n*   cf810e4 conflict fixed\n```\n\n## Bug分支\n\n修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；\n\n当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场；\n\n在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick <commit>命令，把bug提交的修改“复制”到当前分支，避免重复劳动。\n\n比如此刻在dev工作，但是master出现了bug，要切换到master然后开一个BUG分支。这就要求dev分支commit。但是，dev的工作还没有做完，不想将它commit，因此用git stash将工作区封存。\n\n```\n$ git stash\nSaved working directory and index state WIP on dev: f52c633 add merge\n```\n\n将dev工作区封存，此时可以开始修改bug\n\n```\n$ git checkout master\nSwitched to branch 'master'\nYour branch is ahead of 'origin/master' by 6 commits.\n  (use \"git push\" to publish your local commits)\n\n$ git checkout -b issue-101\nSwitched to a new branch 'issue-101'\n\n$ git add readme.txt \n$ git commit -m \"fix bug 101\"\n[issue-101 4c805e2] fix bug 101\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n$ git checkout master\nSwitched to branch 'master'\nYour branch is ahead of 'origin/master' by 6 commits.\n  (use \"git push\" to publish your local commits)\n\n$ git merge --no-ff -m \"merged bug fix 101\" issue-101\nMerge made by the 'recursive' strategy.\n readme.txt | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n \n $ git branch -d issue-101\nDeleted branch issue-101 (was b17d20e).\n```\n\n将bug修改完毕以后可以开始重回dev工作。第一件事就是找回封存区的文件：\n\n```\n$ git stash list\nstash@{0}: WIP on dev: f52c633 add merge\n```\n\n发现文件被存在某个地方，第二件事就是恢复文件。\n\n一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；\n\n```\n$ git stash apply stash@{0}\n$ git stash drop stash@{0}\n```\n\n另一种方式是用git stash pop，恢复的同时把stash内容也删了：\n\n```\n$ git stash pop\nOn branch dev\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\n\n\tnew file:   hello.py\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n\tmodified:   readme.txt\n\nDropped refs/stash@{0} (5d677e2ee266f39ea296182fb2354265b91b3b2a)\n```\n\n再用git stash list康，发现stash已经空了。\n\n这个时候dev可以继续工作了。但是我们想要将我们在master上做的bug修改复制到dev上。当然，我们可以重复操作，不过没必要。同样的bug，要在dev上修复，我们只需要把4c805e2 fix bug 101这个提交所做的修改“复制”到dev分支。\n\n注意：我们只想复制4c805e2 fix bug 101这个提交所做的修改，并不是把整个master分支merge过来。\n\n为了方便操作，Git专门提供了一个**cherry-pick**命令，让我们能复制一个特定的提交到当前分支：\n\n```\n$ git branch\n* dev\n  master\n$ git cherry-pick 4c805e2\n[master 1d4b803] fix bug 101\n 1 file changed, 1 insertion(+), 1 deletion(-)\n```\n\n## feature分支\n\n一个新功能，最好用feature分支实验，如果实验失败，可以直接删除。\n这个时候，因为分支没有合并，所以需要强行删除：\n\n```\n$ git branch -D feature-vulcan\nDeleted branch feature-vulcan (was 287773e).\n```\n\n## 多人协作\n\n多人协作的工作模式通常是这样：\n\n1. 试图用git push origin <branch-name>推送自己的修改；\n2. 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；\n3. 如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to <branch-name> origin/<branch-name>。\n4. 如果合并有冲突，则解决冲突，并在本地提交；\n5. 没有冲突或者解决掉冲突后，再用git push origin <branch-name>推送就能成功！\n\n基本指令：\n\n1. 查看远程库信息，使用git remote -v；\n2. 本地新建的分支如果不推送到远程，对其他人就是不可见的；\n3. 从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；\n4. 在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；\n5. 建立本地分支和远程分支的关联，使用git branch --set-upstream branch-name origin/branch-name；\n6. 从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。\n\n<1>查看远程库\n查看远程库信息：\n\n```\n$ git remote\norigin\n```\n\n查看远程库详细信息：\n\n```\n$ git remote -v\norigin  git@github.com:michaelliao/learngit.git (fetch)\norigin  git@github.com:michaelliao/learngit.git (push)\n```\n\n如果没有推送权限，就看不见push地址\n\n<2>推送分支\n推送本地master到远程库\n\n```\n$ git push origin master\n```\n\n推送本地dev到远程库\n\n```\n$ git push origin dev\n```\n\n- master分支是主分支，因此要时刻与远程同步；\n- dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；\n- bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；\n- feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。\n\n<3>抓取分支\n\n将远程库克隆：\n\n```\ngit clone git@github.com:Unalian/learngit.git\n$ git branch\n* master\n```\n\n此时只有master。（git branch q 退出）\n\n要在dev分支上开发，就必须创建远程origin的dev分支到本地：\n\n```\n$ git checkout -b dev origin/dev\n```\n\n现在，他就可以在dev上继续修改，然后，时不时地把dev分支push到远程：\n\n```\n$ git commit -m \"add env\"\n[dev 7a5e5dd] add env\n 1 file changed, 1 insertion(+)\n create mode 100644 env.txt\n\n$ git push origin dev\nCounting objects: 3, done.\nDelta compression using up to 4 threads.\nCompressing objects: 100% (2/2), done.\nWriting objects: 100% (3/3), 308 bytes | 308.00 KiB/s, done.\nTotal 3 (delta 0), reused 0 (delta 0)\nTo github.com:michaelliao/learngit.git\n   f52c633..7a5e5dd  dev -> dev\n```\n\n这个push的时候，如果发现有一个人也同时将自己的更改push了，此时，就会发生冲突。因此，我们需要pull最新版本的提交，并与我将要push的版本进行冲突处理，最后再进行push。\n\n将最新的提交从origin/dev上抓取下来：\n\n```\n$ git pull\nThere is no tracking information for the current branch.\nPlease specify which branch you want to merge with.\nSee git-pull(1) for details.\n\n    git pull <remote> <branch>\n\nIf you wish to set tracking information for this branch you can do so with:\n\n    git branch --set-upstream-to=origin/<branch> dev\n```\n\n这里显示抓取失败，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接：\n\n```\n$ git branch --set-upstream-to=origin/dev dev\nBranch 'dev' set up to track remote branch 'dev' from 'origin'.\n```\n\n再pull：\n\n```\n$ git pull\nAuto-merging env.txt\nCONFLICT (add/add): Merge conflict in env.txt\nAutomatic merge failed; fix conflicts and then commit the result.\n```\n\npull成功但是合并出现冲突,手动处理冲突，再次push。（pull的同时会发生合并）\n\n```\n$ git commit -m \"fix env conflict\"\n[dev 57c53ab] fix env conflict\n\n$ git push origin dev\nCounting objects: 6, done.\nDelta compression using up to 4 threads.\nCompressing objects: 100% (4/4), done.\nWriting objects: 100% (6/6), 621 bytes | 621.00 KiB/s, done.\nTotal 6 (delta 0), reused 0 (delta 0)\nTo github.com:michaelliao/learngit.git\n   7a5e5dd..57c53ab  dev -> dev\n```\n\n## rebase\n\nrebase操作可以把本地未push的分叉提交历史整理成直线；\n\nrebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。\n\n在上一节我们看到了，多人在同一个分支上协作时，很容易出现冲突。即使没有冲突，后push的童鞋不得不先pull，在本地合并，然后才能push成功。\n\n每次合并再push后，分支变成了这样：\n\n```\n$ git log --graph --pretty=oneline --abbrev-commit\n* d1be385 (HEAD -> master, origin/master) init hello\n*   e5e69f1 Merge branch 'dev'\n|\\  \n| *   57c53ab (origin/dev, dev) fix env conflict\n| |\\  \n| | * 7a5e5dd add env\n| * | 7bd91f1 add new env\n| |/  \n* |   12a631b merged bug fix 101\n|\\ \\  \n| * | 4c805e2 fix bug 101\n|/ /  \n* |   e1e9c68 merge with no-ff\n|\\ \\  \n| |/  \n| * f52c633 add merge\n|/  \n*   cf810e4 conflict fixed\n```\n\n注意到Git用(HEAD -> master)和(origin/master)标识出当前分支的HEAD和远程origin的位置分别是582d922 add author和d1be385 init hello，本地分支比远程分支快两个提交。\n\n现在我们尝试推送本地分支：\n\n```\n$ git push origin master\nTo github.com:michaelliao/learngit.git\n ! [rejected]        master -> master (fetch first)\nerror: failed to push some refs to 'git@github.com:michaelliao/learngit.git'\nhint: Updates were rejected because the remote contains work that you do\nhint: not have locally. This is usually caused by another repository pushing\nhint: to the same ref. You may want to first integrate the remote changes\nhint: (e.g., 'git pull ...') before pushing again.\nhint: See the 'Note about fast-forwards' in 'git push --help' for details.\n```\n\n很不幸，失败了，这说明有人先于我们推送了远程分支。按照经验，先pull一下：\n\n```\n$ git pull\nremote: Counting objects: 3, done.\nremote: Compressing objects: 100% (1/1), done.\nremote: Total 3 (delta 1), reused 3 (delta 1), pack-reused 0\nUnpacking objects: 100% (3/3), done.\nFrom github.com:michaelliao/learngit\n   d1be385..f005ed4  master     -> origin/master\n * [new tag]         v1.0       -> v1.0\nAuto-merging hello.py\nMerge made by the 'recursive' strategy.\n hello.py | 1 +\n 1 file changed, 1 insertion(+)\n```\n\n再用git status看看状态：\n\n```\n$ git status\nOn branch master\nYour branch is ahead of 'origin/master' by 3 commits.\n  (use \"git push\" to publish your local commits)\n\nnothing to commit, working tree clean\n```\n\n加上刚才合并的提交，现在我们本地分支比远程分支超前3个提交。\n\n用git log看看：\n\n```\n$ git log --graph --pretty=oneline --abbrev-commit\n*   e0ea545 (HEAD -> master) Merge branch 'master' of github.com:michaelliao/learngit\n|\\  \n| * f005ed4 (origin/master) set exit=1\n* | 582d922 add author\n* | 8875536 add comment\n|/  \n* d1be385 init hello\n...\n```\n\n提交历史分叉就很不方便了，我们想把这些化成一条直线。\n输入命令**git rebase**\n\n```\n$ git rebase\nFirst, rewinding head to replay your work on top of it...\nApplying: add comment\nUsing index info to reconstruct a base tree...\nM\thello.py\nFalling back to patching base and 3-way merge...\nAuto-merging hello.py\nApplying: add author\nUsing index info to reconstruct a base tree...\nM\thello.py\nFalling back to patching base and 3-way merge...\nAuto-merging hello.py\n```\n\n再git log\n\n```\n$ git log --graph --pretty=oneline --abbrev-commit\n* 7e61ed4 (HEAD -> master) add author\n* 3611cfe add comment\n* f005ed4 (origin/master) set exit=1\n* d1be385 init hello\n...\n```\n\n这就是rebase操作的特点：把分叉的提交历史“整理”成一条直线，看上去更直观。缺点是本地的分叉提交已经被修改过了。\n\n最后，通过push操作把本地分支推送到远程：\n\n```\nMac:~/learngit michael$ git push origin master\nCounting objects: 6, done.\nDelta compression using up to 4 threads.\nCompressing objects: 100% (5/5), done.\nWriting objects: 100% (6/6), 576 bytes | 576.00 KiB/s, done.\nTotal 6 (delta 2), reused 0 (delta 0)\nremote: Resolving deltas: 100% (2/2), completed with 1 local object.\nTo github.com:michaelliao/learngit.git\n   f005ed4..7e61ed4  master -> master\n```","slug":"Git-自学（二）远程仓库与分支管理","published":1,"updated":"2020-03-25T01:20:32.000Z","title":"Git-自学（二）远程仓库与分支管理","_id":"ck67gmurb0004o3mxeyimhkvr","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"概览\"><a href=\"#概览\" class=\"headerlink\" title=\"概览\"></a>概览</h1><p>一. 远程仓库</p>\n<ol>\n<li>创建SSH密钥</li>\n<li>创建远程库</li>\n<li>从远程库克隆</li>\n</ol>\n<p>二. 分支管理</p>\n<ol>\n<li><p>创建与合并分支</p>\n</li>\n<li><p>解决冲突</p>\n</li>\n<li><p>分支管理策略</p>\n</li>\n<li><p>Bug分支</p>\n</li>\n<li><p>feature分支</p>\n</li>\n<li><p>多人协作</p>\n</li>\n<li><p>rebase</p>\n<a id=\"more\"></a>\n\n</li>\n</ol>\n<h2 id=\"远程仓库\"><a href=\"#远程仓库\" class=\"headerlink\" title=\"远程仓库\"></a>远程仓库</h2><h2 id=\"创建SSH密钥\"><a href=\"#创建SSH密钥\" class=\"headerlink\" title=\"创建SSH密钥\"></a>创建SSH密钥</h2><p>github提供远程仓库，本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，需要设置：</p>\n<p>创建SSH key</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh-keygen -t rsa -C &quot;Dengmengda@Gmail.com&quot;</span><br></pre></td></tr></table></figure>\n\n<p>一路回车</p>\n<p>如果一切顺利的话，可以在用户主目(cd ~)(ls)录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。</p>\n<p>查看：(cat)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adeMacBook-Air:.ssh una$ cat ~&#x2F;.ssh&#x2F;id_rsa.pub</span><br><span class=\"line\">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQD2WRdPq72pjh5ZiG7fzhFwHsZtQ7KbWA4ZF0G6LoFmh4JTSkGOTBaixu8+NNmRksxYKVenYwqFPT2meWocDm19Lly6wN6+rxdf9pmiRRv+5zJb4XkGi2j4+foPt1XPYc1FZM6lzeyh127W5+2VPZDG7hKatzh9OEsiKXHI5OaANPpW+diPs&#x2F;kAEMsrMMuzMOUTJFhbqaS48Pv1aZaSBotI2YbHjOEGA2KAXH1dEepLM17fpVvFV3eVi5k+erTOj38yxiW598x+ZBrig5Jwf+6X1LJiB7VFW1QEqCcQxf1aEgErhRmrxEp+YWnJQCJHvWjp8N7f+txYFkoBkJfoq4zD Dengmengda@Gmail.com</span><br></pre></td></tr></table></figure>\n\n<p>之后，登录github，在settings-&gt;SSH key添加SSHkey(id_rsa.pub公钥)</p>\n<h2 id=\"创建远程库\"><a href=\"#创建远程库\" class=\"headerlink\" title=\"创建远程库\"></a>创建远程库</h2><p>在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，让这两个仓库进行远程同步。So,GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作</p>\n<p>在github里creat a new repository</p>\n<p>在GitHub上的这个learngit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。</p>\n<p>根据提示</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add origin https:&#x2F;&#x2F;github.com&#x2F;Unalian&#x2F;learngit.git</span><br><span class=\"line\">git push -u origin master</span><br></pre></td></tr></table></figure>\n\n<p>由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。</p>\n<p>之后就可以在github的页面里看见了。<br>以后修改就可以</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push origin master</span><br></pre></td></tr></table></figure>\n\n<p>将修改推至远程版本库了，这样就真正拥有了一个分布式版本库。</p>\n<p>在过程中会有SSH警告，yes即可。</p>\n<h2 id=\"从远程库克隆\"><a href=\"#从远程库克隆\" class=\"headerlink\" title=\"从远程库克隆\"></a>从远程库克隆</h2><p>在github上建立一个新的库，勾选<strong>Initialize this repository with a README</strong>，这样系统会自动建立一个README.md的文件。这样远程库就准备好了。</p>\n<p>下一步是用命令git clone克隆一个本地库：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git clone git@github.com:Unalian&#x2F;gitskills.git</span><br><span class=\"line\">Cloning into &#39;gitskills&#39;...</span><br><span class=\"line\">remote: Counting objects: 3, done.</span><br><span class=\"line\">remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 3</span><br><span class=\"line\">Receiving objects: 100% (3&#x2F;3), done.</span><br></pre></td></tr></table></figure>\n\n<p>Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。</p>\n<h1 id=\"分支管理\"><a href=\"#分支管理\" class=\"headerlink\" title=\"分支管理\"></a>分支管理</h1><p>分支：<br>分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。<br>现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。</p>\n<h2 id=\"创建与合并分支\"><a href=\"#创建与合并分支\" class=\"headerlink\" title=\"创建与合并分支\"></a>创建与合并分支</h2><p>创建dev分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch dev</span><br></pre></td></tr></table></figure>\n\n<p>切换到dev分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout dev</span><br><span class=\"line\">Switched to branch &#39;dev&#39;</span><br></pre></td></tr></table></figure>\n\n<p>将两个指令综合起来就是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout -b dev</span><br><span class=\"line\">Switched to a new branch &#39;dev&#39;</span><br></pre></td></tr></table></figure>\n\n<p>查看所有分支（当前分支前有*）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch</span><br><span class=\"line\">* dev</span><br><span class=\"line\">  master</span><br></pre></td></tr></table></figure>\n\n<p>然后在dev分支上正常提交，比如在readme.txt上进行修改<br>加上一行<br>Creating a new branch is quick.</p>\n<p>提交：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add readme.txt </span><br><span class=\"line\">$ git commit -m &quot;branch test&quot;</span><br><span class=\"line\">[dev b17d20e] branch test</span><br><span class=\"line\"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>\n\n<p>dev分支搞定，现在切回master分支：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout master</span><br><span class=\"line\">Switched to branch &#39;master&#39;</span><br></pre></td></tr></table></figure>\n\n<p>如果此时查看readme.txt，就会发现还是没有改变。因此，需要合并branch到master上。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git merge dev</span><br><span class=\"line\">Updating d46f35e..b17d20e</span><br><span class=\"line\">Fast-forward</span><br><span class=\"line\"> readme.txt | 1 +</span><br><span class=\"line\"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>\n\n<p>这里提到，本次合并是Fast-forward，因此，是直接将master指向dev的当前提交，合并速度快，但是也有其他的合并方式。</p>\n<p>通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。</p>\n<p>如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p>\n<p>合并完成后，就可以删除dev分支。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch -d dev</span><br><span class=\"line\">Deleted branch dev (was b17d20e).</span><br></pre></td></tr></table></figure>\n\n<p>总结：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">查看分支：git branch</span><br><span class=\"line\"></span><br><span class=\"line\">创建分支：git branch &lt;name&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">切换分支：git checkout &lt;name&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">创建+切换分支：git checkout -b &lt;name&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">合并某分支到当前分支：git merge &lt;name&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">删除分支：git branch -d &lt;name&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"解决冲突\"><a href=\"#解决冲突\" class=\"headerlink\" title=\"解决冲突\"></a>解决冲突</h2><p>创建feature1分支，然后在master，feature1都进行修改，在尝试快速合并时会出现冲突。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git merge feature1</span><br><span class=\"line\">Auto-merging readme.txt</span><br><span class=\"line\">CONFLICT (content): Merge conflict in readme.txt</span><br><span class=\"line\">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure>\n\n<p>这个时候查看状态：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git status</span><br><span class=\"line\">On branch master</span><br><span class=\"line\">Your branch is ahead of &#39;origin&#x2F;master&#39; by 2 commits.</span><br><span class=\"line\">  (use &quot;git push&quot; to publish your local commits)</span><br><span class=\"line\"></span><br><span class=\"line\">You have unmerged paths.</span><br><span class=\"line\">  (fix conflicts and run &quot;git commit&quot;)</span><br><span class=\"line\">  (use &quot;git merge --abort&quot; to abort the merge)</span><br><span class=\"line\"></span><br><span class=\"line\">Unmerged paths:</span><br><span class=\"line\">  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)</span><br><span class=\"line\"></span><br><span class=\"line\">\tboth modified:   readme.txt</span><br><span class=\"line\"></span><br><span class=\"line\">no changes added to commit (use &quot;git add&quot; and&#x2F;or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure>\n\n<p>这个时候查看readme.txt的内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Git is a distributed version control system.</span><br><span class=\"line\">Git is free software distributed under the GPL.</span><br><span class=\"line\">Git has a mutable index called stage.</span><br><span class=\"line\">Git tracks changes of files.</span><br><span class=\"line\">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class=\"line\">Creating a new branch is quick &amp; simple.</span><br><span class=\"line\">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class=\"line\">Creating a new branch is quick AND simple.</span><br><span class=\"line\">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</span><br></pre></td></tr></table></figure>\n\n<p>可清晰看出不同分支的区别，这个时候就可以手动修改文件，解决冲突。</p>\n<p>git log也可以查看分支合并情况。</p>\n<p>最后，删除feature1就可以了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$git branch -d feature1</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"分支管理策略\"><a href=\"#分支管理策略\" class=\"headerlink\" title=\"分支管理策略\"></a>分支管理策略</h2><ol>\n<li>fast-forward</li>\n<li><code>--no-ff</code> (强制禁用fast-forward)</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git merge --no-ff -m &quot;merge with no-ff&quot; dev</span><br><span class=\"line\">Merge made by the &#39;recursive&#39; strategy.</span><br><span class=\"line\"> readme.txt | 1 +</span><br><span class=\"line\"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>\n\n<p>因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。<br>合并分支时，加上–no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git log --graph --pretty&#x3D;oneline --abbrev-commit</span><br><span class=\"line\">*   e1e9c68 (HEAD -&gt; master) merge with no-ff</span><br><span class=\"line\">|\\  </span><br><span class=\"line\">| * f52c633 (dev) add merge</span><br><span class=\"line\">|&#x2F;  </span><br><span class=\"line\">*   cf810e4 conflict fixed</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Bug分支\"><a href=\"#Bug分支\" class=\"headerlink\" title=\"Bug分支\"></a>Bug分支</h2><p>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</p>\n<p>当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场；</p>\n<p>在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick <commit>命令，把bug提交的修改“复制”到当前分支，避免重复劳动。</p>\n<p>比如此刻在dev工作，但是master出现了bug，要切换到master然后开一个BUG分支。这就要求dev分支commit。但是，dev的工作还没有做完，不想将它commit，因此用git stash将工作区封存。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git stash</span><br><span class=\"line\">Saved working directory and index state WIP on dev: f52c633 add merge</span><br></pre></td></tr></table></figure>\n\n<p>将dev工作区封存，此时可以开始修改bug</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout master</span><br><span class=\"line\">Switched to branch &#39;master&#39;</span><br><span class=\"line\">Your branch is ahead of &#39;origin&#x2F;master&#39; by 6 commits.</span><br><span class=\"line\">  (use &quot;git push&quot; to publish your local commits)</span><br><span class=\"line\"></span><br><span class=\"line\">$ git checkout -b issue-101</span><br><span class=\"line\">Switched to a new branch &#39;issue-101&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">$ git add readme.txt </span><br><span class=\"line\">$ git commit -m &quot;fix bug 101&quot;</span><br><span class=\"line\">[issue-101 4c805e2] fix bug 101</span><br><span class=\"line\"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br><span class=\"line\"></span><br><span class=\"line\">$ git checkout master</span><br><span class=\"line\">Switched to branch &#39;master&#39;</span><br><span class=\"line\">Your branch is ahead of &#39;origin&#x2F;master&#39; by 6 commits.</span><br><span class=\"line\">  (use &quot;git push&quot; to publish your local commits)</span><br><span class=\"line\"></span><br><span class=\"line\">$ git merge --no-ff -m &quot;merged bug fix 101&quot; issue-101</span><br><span class=\"line\">Merge made by the &#39;recursive&#39; strategy.</span><br><span class=\"line\"> readme.txt | 2 +-</span><br><span class=\"line\"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br><span class=\"line\"> </span><br><span class=\"line\"> $ git branch -d issue-101</span><br><span class=\"line\">Deleted branch issue-101 (was b17d20e).</span><br></pre></td></tr></table></figure>\n\n<p>将bug修改完毕以后可以开始重回dev工作。第一件事就是找回封存区的文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git stash list</span><br><span class=\"line\">stash@&#123;0&#125;: WIP on dev: f52c633 add merge</span><br></pre></td></tr></table></figure>\n\n<p>发现文件被存在某个地方，第二件事就是恢复文件。</p>\n<p>一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git stash apply stash@&#123;0&#125;</span><br><span class=\"line\">$ git stash drop stash@&#123;0&#125;</span><br></pre></td></tr></table></figure>\n\n<p>另一种方式是用git stash pop，恢复的同时把stash内容也删了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git stash pop</span><br><span class=\"line\">On branch dev</span><br><span class=\"line\">Changes to be committed:</span><br><span class=\"line\">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class=\"line\"></span><br><span class=\"line\">\tnew file:   hello.py</span><br><span class=\"line\"></span><br><span class=\"line\">Changes not staged for commit:</span><br><span class=\"line\">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class=\"line\">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class=\"line\"></span><br><span class=\"line\">\tmodified:   readme.txt</span><br><span class=\"line\"></span><br><span class=\"line\">Dropped refs&#x2F;stash@&#123;0&#125; (5d677e2ee266f39ea296182fb2354265b91b3b2a)</span><br></pre></td></tr></table></figure>\n\n<p>再用git stash list康，发现stash已经空了。</p>\n<p>这个时候dev可以继续工作了。但是我们想要将我们在master上做的bug修改复制到dev上。当然，我们可以重复操作，不过没必要。同样的bug，要在dev上修复，我们只需要把4c805e2 fix bug 101这个提交所做的修改“复制”到dev分支。</p>\n<p>注意：我们只想复制4c805e2 fix bug 101这个提交所做的修改，并不是把整个master分支merge过来。</p>\n<p>为了方便操作，Git专门提供了一个<strong>cherry-pick</strong>命令，让我们能复制一个特定的提交到当前分支：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch</span><br><span class=\"line\">* dev</span><br><span class=\"line\">  master</span><br><span class=\"line\">$ git cherry-pick 4c805e2</span><br><span class=\"line\">[master 1d4b803] fix bug 101</span><br><span class=\"line\"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"feature分支\"><a href=\"#feature分支\" class=\"headerlink\" title=\"feature分支\"></a>feature分支</h2><p>一个新功能，最好用feature分支实验，如果实验失败，可以直接删除。<br>这个时候，因为分支没有合并，所以需要强行删除：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch -D feature-vulcan</span><br><span class=\"line\">Deleted branch feature-vulcan (was 287773e).</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"多人协作\"><a href=\"#多人协作\" class=\"headerlink\" title=\"多人协作\"></a>多人协作</h2><p>多人协作的工作模式通常是这样：</p>\n<ol>\n<li>试图用git push origin <branch-name>推送自己的修改；</li>\n<li>如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；</li>\n<li>如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream-to <branch-name> origin/<branch-name>。</li>\n<li>如果合并有冲突，则解决冲突，并在本地提交；</li>\n<li>没有冲突或者解决掉冲突后，再用git push origin <branch-name>推送就能成功！</li>\n</ol>\n<p>基本指令：</p>\n<ol>\n<li>查看远程库信息，使用git remote -v；</li>\n<li>本地新建的分支如果不推送到远程，对其他人就是不可见的；</li>\n<li>从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；</li>\n<li>在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；</li>\n<li>建立本地分支和远程分支的关联，使用git branch –set-upstream branch-name origin/branch-name；</li>\n<li>从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。</li>\n</ol>\n<p>&lt;1&gt;查看远程库<br>查看远程库信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git remote</span><br><span class=\"line\">origin</span><br></pre></td></tr></table></figure>\n\n<p>查看远程库详细信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git remote -v</span><br><span class=\"line\">origin  git@github.com:michaelliao&#x2F;learngit.git (fetch)</span><br><span class=\"line\">origin  git@github.com:michaelliao&#x2F;learngit.git (push)</span><br></pre></td></tr></table></figure>\n\n<p>如果没有推送权限，就看不见push地址</p>\n<p>&lt;2&gt;推送分支<br>推送本地master到远程库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push origin master</span><br></pre></td></tr></table></figure>\n\n<p>推送本地dev到远程库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push origin dev</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>master分支是主分支，因此要时刻与远程同步；</li>\n<li>dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</li>\n<li>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</li>\n<li>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</li>\n</ul>\n<p>&lt;3&gt;抓取分支</p>\n<p>将远程库克隆：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone git@github.com:Unalian&#x2F;learngit.git</span><br><span class=\"line\">$ git branch</span><br><span class=\"line\">* master</span><br></pre></td></tr></table></figure>\n\n<p>此时只有master。（git branch q 退出）</p>\n<p>要在dev分支上开发，就必须创建远程origin的dev分支到本地：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout -b dev origin&#x2F;dev</span><br></pre></td></tr></table></figure>\n\n<p>现在，他就可以在dev上继续修改，然后，时不时地把dev分支push到远程：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git commit -m &quot;add env&quot;</span><br><span class=\"line\">[dev 7a5e5dd] add env</span><br><span class=\"line\"> 1 file changed, 1 insertion(+)</span><br><span class=\"line\"> create mode 100644 env.txt</span><br><span class=\"line\"></span><br><span class=\"line\">$ git push origin dev</span><br><span class=\"line\">Counting objects: 3, done.</span><br><span class=\"line\">Delta compression using up to 4 threads.</span><br><span class=\"line\">Compressing objects: 100% (2&#x2F;2), done.</span><br><span class=\"line\">Writing objects: 100% (3&#x2F;3), 308 bytes | 308.00 KiB&#x2F;s, done.</span><br><span class=\"line\">Total 3 (delta 0), reused 0 (delta 0)</span><br><span class=\"line\">To github.com:michaelliao&#x2F;learngit.git</span><br><span class=\"line\">   f52c633..7a5e5dd  dev -&gt; dev</span><br></pre></td></tr></table></figure>\n\n<p>这个push的时候，如果发现有一个人也同时将自己的更改push了，此时，就会发生冲突。因此，我们需要pull最新版本的提交，并与我将要push的版本进行冲突处理，最后再进行push。</p>\n<p>将最新的提交从origin/dev上抓取下来：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git pull</span><br><span class=\"line\">There is no tracking information for the current branch.</span><br><span class=\"line\">Please specify which branch you want to merge with.</span><br><span class=\"line\">See git-pull(1) for details.</span><br><span class=\"line\"></span><br><span class=\"line\">    git pull &lt;remote&gt; &lt;branch&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">If you wish to set tracking information for this branch you can do so with:</span><br><span class=\"line\"></span><br><span class=\"line\">    git branch --set-upstream-to&#x3D;origin&#x2F;&lt;branch&gt; dev</span><br></pre></td></tr></table></figure>\n\n<p>这里显示抓取失败，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch --set-upstream-to&#x3D;origin&#x2F;dev dev</span><br><span class=\"line\">Branch &#39;dev&#39; set up to track remote branch &#39;dev&#39; from &#39;origin&#39;.</span><br></pre></td></tr></table></figure>\n\n<p>再pull：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git pull</span><br><span class=\"line\">Auto-merging env.txt</span><br><span class=\"line\">CONFLICT (add&#x2F;add): Merge conflict in env.txt</span><br><span class=\"line\">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure>\n\n<p>pull成功但是合并出现冲突,手动处理冲突，再次push。（pull的同时会发生合并）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git commit -m &quot;fix env conflict&quot;</span><br><span class=\"line\">[dev 57c53ab] fix env conflict</span><br><span class=\"line\"></span><br><span class=\"line\">$ git push origin dev</span><br><span class=\"line\">Counting objects: 6, done.</span><br><span class=\"line\">Delta compression using up to 4 threads.</span><br><span class=\"line\">Compressing objects: 100% (4&#x2F;4), done.</span><br><span class=\"line\">Writing objects: 100% (6&#x2F;6), 621 bytes | 621.00 KiB&#x2F;s, done.</span><br><span class=\"line\">Total 6 (delta 0), reused 0 (delta 0)</span><br><span class=\"line\">To github.com:michaelliao&#x2F;learngit.git</span><br><span class=\"line\">   7a5e5dd..57c53ab  dev -&gt; dev</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"rebase\"><a href=\"#rebase\" class=\"headerlink\" title=\"rebase\"></a>rebase</h2><p>rebase操作可以把本地未push的分叉提交历史整理成直线；</p>\n<p>rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</p>\n<p>在上一节我们看到了，多人在同一个分支上协作时，很容易出现冲突。即使没有冲突，后push的童鞋不得不先pull，在本地合并，然后才能push成功。</p>\n<p>每次合并再push后，分支变成了这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git log --graph --pretty&#x3D;oneline --abbrev-commit</span><br><span class=\"line\">* d1be385 (HEAD -&gt; master, origin&#x2F;master) init hello</span><br><span class=\"line\">*   e5e69f1 Merge branch &#39;dev&#39;</span><br><span class=\"line\">|\\  </span><br><span class=\"line\">| *   57c53ab (origin&#x2F;dev, dev) fix env conflict</span><br><span class=\"line\">| |\\  </span><br><span class=\"line\">| | * 7a5e5dd add env</span><br><span class=\"line\">| * | 7bd91f1 add new env</span><br><span class=\"line\">| |&#x2F;  </span><br><span class=\"line\">* |   12a631b merged bug fix 101</span><br><span class=\"line\">|\\ \\  </span><br><span class=\"line\">| * | 4c805e2 fix bug 101</span><br><span class=\"line\">|&#x2F; &#x2F;  </span><br><span class=\"line\">* |   e1e9c68 merge with no-ff</span><br><span class=\"line\">|\\ \\  </span><br><span class=\"line\">| |&#x2F;  </span><br><span class=\"line\">| * f52c633 add merge</span><br><span class=\"line\">|&#x2F;  </span><br><span class=\"line\">*   cf810e4 conflict fixed</span><br></pre></td></tr></table></figure>\n\n<p>注意到Git用(HEAD -&gt; master)和(origin/master)标识出当前分支的HEAD和远程origin的位置分别是582d922 add author和d1be385 init hello，本地分支比远程分支快两个提交。</p>\n<p>现在我们尝试推送本地分支：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push origin master</span><br><span class=\"line\">To github.com:michaelliao&#x2F;learngit.git</span><br><span class=\"line\"> ! [rejected]        master -&gt; master (fetch first)</span><br><span class=\"line\">error: failed to push some refs to &#39;git@github.com:michaelliao&#x2F;learngit.git&#39;</span><br><span class=\"line\">hint: Updates were rejected because the remote contains work that you do</span><br><span class=\"line\">hint: not have locally. This is usually caused by another repository pushing</span><br><span class=\"line\">hint: to the same ref. You may want to first integrate the remote changes</span><br><span class=\"line\">hint: (e.g., &#39;git pull ...&#39;) before pushing again.</span><br><span class=\"line\">hint: See the &#39;Note about fast-forwards&#39; in &#39;git push --help&#39; for details.</span><br></pre></td></tr></table></figure>\n\n<p>很不幸，失败了，这说明有人先于我们推送了远程分支。按照经验，先pull一下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git pull</span><br><span class=\"line\">remote: Counting objects: 3, done.</span><br><span class=\"line\">remote: Compressing objects: 100% (1&#x2F;1), done.</span><br><span class=\"line\">remote: Total 3 (delta 1), reused 3 (delta 1), pack-reused 0</span><br><span class=\"line\">Unpacking objects: 100% (3&#x2F;3), done.</span><br><span class=\"line\">From github.com:michaelliao&#x2F;learngit</span><br><span class=\"line\">   d1be385..f005ed4  master     -&gt; origin&#x2F;master</span><br><span class=\"line\"> * [new tag]         v1.0       -&gt; v1.0</span><br><span class=\"line\">Auto-merging hello.py</span><br><span class=\"line\">Merge made by the &#39;recursive&#39; strategy.</span><br><span class=\"line\"> hello.py | 1 +</span><br><span class=\"line\"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>\n\n<p>再用git status看看状态：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git status</span><br><span class=\"line\">On branch master</span><br><span class=\"line\">Your branch is ahead of &#39;origin&#x2F;master&#39; by 3 commits.</span><br><span class=\"line\">  (use &quot;git push&quot; to publish your local commits)</span><br><span class=\"line\"></span><br><span class=\"line\">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>\n\n<p>加上刚才合并的提交，现在我们本地分支比远程分支超前3个提交。</p>\n<p>用git log看看：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git log --graph --pretty&#x3D;oneline --abbrev-commit</span><br><span class=\"line\">*   e0ea545 (HEAD -&gt; master) Merge branch &#39;master&#39; of github.com:michaelliao&#x2F;learngit</span><br><span class=\"line\">|\\  </span><br><span class=\"line\">| * f005ed4 (origin&#x2F;master) set exit&#x3D;1</span><br><span class=\"line\">* | 582d922 add author</span><br><span class=\"line\">* | 8875536 add comment</span><br><span class=\"line\">|&#x2F;  </span><br><span class=\"line\">* d1be385 init hello</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>提交历史分叉就很不方便了，我们想把这些化成一条直线。<br>输入命令<strong>git rebase</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git rebase</span><br><span class=\"line\">First, rewinding head to replay your work on top of it...</span><br><span class=\"line\">Applying: add comment</span><br><span class=\"line\">Using index info to reconstruct a base tree...</span><br><span class=\"line\">M\thello.py</span><br><span class=\"line\">Falling back to patching base and 3-way merge...</span><br><span class=\"line\">Auto-merging hello.py</span><br><span class=\"line\">Applying: add author</span><br><span class=\"line\">Using index info to reconstruct a base tree...</span><br><span class=\"line\">M\thello.py</span><br><span class=\"line\">Falling back to patching base and 3-way merge...</span><br><span class=\"line\">Auto-merging hello.py</span><br></pre></td></tr></table></figure>\n\n<p>再git log</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git log --graph --pretty&#x3D;oneline --abbrev-commit</span><br><span class=\"line\">* 7e61ed4 (HEAD -&gt; master) add author</span><br><span class=\"line\">* 3611cfe add comment</span><br><span class=\"line\">* f005ed4 (origin&#x2F;master) set exit&#x3D;1</span><br><span class=\"line\">* d1be385 init hello</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>这就是rebase操作的特点：把分叉的提交历史“整理”成一条直线，看上去更直观。缺点是本地的分叉提交已经被修改过了。</p>\n<p>最后，通过push操作把本地分支推送到远程：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Mac:~&#x2F;learngit michael$ git push origin master</span><br><span class=\"line\">Counting objects: 6, done.</span><br><span class=\"line\">Delta compression using up to 4 threads.</span><br><span class=\"line\">Compressing objects: 100% (5&#x2F;5), done.</span><br><span class=\"line\">Writing objects: 100% (6&#x2F;6), 576 bytes | 576.00 KiB&#x2F;s, done.</span><br><span class=\"line\">Total 6 (delta 2), reused 0 (delta 0)</span><br><span class=\"line\">remote: Resolving deltas: 100% (2&#x2F;2), completed with 1 local object.</span><br><span class=\"line\">To github.com:michaelliao&#x2F;learngit.git</span><br><span class=\"line\">   f005ed4..7e61ed4  master -&gt; master</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h1 id=\"概览\"><a href=\"#概览\" class=\"headerlink\" title=\"概览\"></a>概览</h1><p>一. 远程仓库</p>\n<ol>\n<li>创建SSH密钥</li>\n<li>创建远程库</li>\n<li>从远程库克隆</li>\n</ol>\n<p>二. 分支管理</p>\n<ol>\n<li><p>创建与合并分支</p>\n</li>\n<li><p>解决冲突</p>\n</li>\n<li><p>分支管理策略</p>\n</li>\n<li><p>Bug分支</p>\n</li>\n<li><p>feature分支</p>\n</li>\n<li><p>多人协作</p>\n</li>\n<li><p>rebase</p>","more":"</li>\n</ol>\n<h2 id=\"远程仓库\"><a href=\"#远程仓库\" class=\"headerlink\" title=\"远程仓库\"></a>远程仓库</h2><h2 id=\"创建SSH密钥\"><a href=\"#创建SSH密钥\" class=\"headerlink\" title=\"创建SSH密钥\"></a>创建SSH密钥</h2><p>github提供远程仓库，本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，需要设置：</p>\n<p>创建SSH key</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh-keygen -t rsa -C &quot;Dengmengda@Gmail.com&quot;</span><br></pre></td></tr></table></figure>\n\n<p>一路回车</p>\n<p>如果一切顺利的话，可以在用户主目(cd ~)(ls)录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。</p>\n<p>查看：(cat)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adeMacBook-Air:.ssh una$ cat ~&#x2F;.ssh&#x2F;id_rsa.pub</span><br><span class=\"line\">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQD2WRdPq72pjh5ZiG7fzhFwHsZtQ7KbWA4ZF0G6LoFmh4JTSkGOTBaixu8+NNmRksxYKVenYwqFPT2meWocDm19Lly6wN6+rxdf9pmiRRv+5zJb4XkGi2j4+foPt1XPYc1FZM6lzeyh127W5+2VPZDG7hKatzh9OEsiKXHI5OaANPpW+diPs&#x2F;kAEMsrMMuzMOUTJFhbqaS48Pv1aZaSBotI2YbHjOEGA2KAXH1dEepLM17fpVvFV3eVi5k+erTOj38yxiW598x+ZBrig5Jwf+6X1LJiB7VFW1QEqCcQxf1aEgErhRmrxEp+YWnJQCJHvWjp8N7f+txYFkoBkJfoq4zD Dengmengda@Gmail.com</span><br></pre></td></tr></table></figure>\n\n<p>之后，登录github，在settings-&gt;SSH key添加SSHkey(id_rsa.pub公钥)</p>\n<h2 id=\"创建远程库\"><a href=\"#创建远程库\" class=\"headerlink\" title=\"创建远程库\"></a>创建远程库</h2><p>在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，让这两个仓库进行远程同步。So,GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作</p>\n<p>在github里creat a new repository</p>\n<p>在GitHub上的这个learngit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。</p>\n<p>根据提示</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add origin https:&#x2F;&#x2F;github.com&#x2F;Unalian&#x2F;learngit.git</span><br><span class=\"line\">git push -u origin master</span><br></pre></td></tr></table></figure>\n\n<p>由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。</p>\n<p>之后就可以在github的页面里看见了。<br>以后修改就可以</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push origin master</span><br></pre></td></tr></table></figure>\n\n<p>将修改推至远程版本库了，这样就真正拥有了一个分布式版本库。</p>\n<p>在过程中会有SSH警告，yes即可。</p>\n<h2 id=\"从远程库克隆\"><a href=\"#从远程库克隆\" class=\"headerlink\" title=\"从远程库克隆\"></a>从远程库克隆</h2><p>在github上建立一个新的库，勾选<strong>Initialize this repository with a README</strong>，这样系统会自动建立一个README.md的文件。这样远程库就准备好了。</p>\n<p>下一步是用命令git clone克隆一个本地库：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git clone git@github.com:Unalian&#x2F;gitskills.git</span><br><span class=\"line\">Cloning into &#39;gitskills&#39;...</span><br><span class=\"line\">remote: Counting objects: 3, done.</span><br><span class=\"line\">remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 3</span><br><span class=\"line\">Receiving objects: 100% (3&#x2F;3), done.</span><br></pre></td></tr></table></figure>\n\n<p>Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。</p>\n<h1 id=\"分支管理\"><a href=\"#分支管理\" class=\"headerlink\" title=\"分支管理\"></a>分支管理</h1><p>分支：<br>分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。<br>现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。</p>\n<h2 id=\"创建与合并分支\"><a href=\"#创建与合并分支\" class=\"headerlink\" title=\"创建与合并分支\"></a>创建与合并分支</h2><p>创建dev分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch dev</span><br></pre></td></tr></table></figure>\n\n<p>切换到dev分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout dev</span><br><span class=\"line\">Switched to branch &#39;dev&#39;</span><br></pre></td></tr></table></figure>\n\n<p>将两个指令综合起来就是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout -b dev</span><br><span class=\"line\">Switched to a new branch &#39;dev&#39;</span><br></pre></td></tr></table></figure>\n\n<p>查看所有分支（当前分支前有*）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch</span><br><span class=\"line\">* dev</span><br><span class=\"line\">  master</span><br></pre></td></tr></table></figure>\n\n<p>然后在dev分支上正常提交，比如在readme.txt上进行修改<br>加上一行<br>Creating a new branch is quick.</p>\n<p>提交：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add readme.txt </span><br><span class=\"line\">$ git commit -m &quot;branch test&quot;</span><br><span class=\"line\">[dev b17d20e] branch test</span><br><span class=\"line\"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>\n\n<p>dev分支搞定，现在切回master分支：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout master</span><br><span class=\"line\">Switched to branch &#39;master&#39;</span><br></pre></td></tr></table></figure>\n\n<p>如果此时查看readme.txt，就会发现还是没有改变。因此，需要合并branch到master上。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git merge dev</span><br><span class=\"line\">Updating d46f35e..b17d20e</span><br><span class=\"line\">Fast-forward</span><br><span class=\"line\"> readme.txt | 1 +</span><br><span class=\"line\"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>\n\n<p>这里提到，本次合并是Fast-forward，因此，是直接将master指向dev的当前提交，合并速度快，但是也有其他的合并方式。</p>\n<p>通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。</p>\n<p>如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p>\n<p>合并完成后，就可以删除dev分支。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch -d dev</span><br><span class=\"line\">Deleted branch dev (was b17d20e).</span><br></pre></td></tr></table></figure>\n\n<p>总结：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">查看分支：git branch</span><br><span class=\"line\"></span><br><span class=\"line\">创建分支：git branch &lt;name&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">切换分支：git checkout &lt;name&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">创建+切换分支：git checkout -b &lt;name&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">合并某分支到当前分支：git merge &lt;name&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">删除分支：git branch -d &lt;name&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"解决冲突\"><a href=\"#解决冲突\" class=\"headerlink\" title=\"解决冲突\"></a>解决冲突</h2><p>创建feature1分支，然后在master，feature1都进行修改，在尝试快速合并时会出现冲突。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git merge feature1</span><br><span class=\"line\">Auto-merging readme.txt</span><br><span class=\"line\">CONFLICT (content): Merge conflict in readme.txt</span><br><span class=\"line\">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure>\n\n<p>这个时候查看状态：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git status</span><br><span class=\"line\">On branch master</span><br><span class=\"line\">Your branch is ahead of &#39;origin&#x2F;master&#39; by 2 commits.</span><br><span class=\"line\">  (use &quot;git push&quot; to publish your local commits)</span><br><span class=\"line\"></span><br><span class=\"line\">You have unmerged paths.</span><br><span class=\"line\">  (fix conflicts and run &quot;git commit&quot;)</span><br><span class=\"line\">  (use &quot;git merge --abort&quot; to abort the merge)</span><br><span class=\"line\"></span><br><span class=\"line\">Unmerged paths:</span><br><span class=\"line\">  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)</span><br><span class=\"line\"></span><br><span class=\"line\">\tboth modified:   readme.txt</span><br><span class=\"line\"></span><br><span class=\"line\">no changes added to commit (use &quot;git add&quot; and&#x2F;or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure>\n\n<p>这个时候查看readme.txt的内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Git is a distributed version control system.</span><br><span class=\"line\">Git is free software distributed under the GPL.</span><br><span class=\"line\">Git has a mutable index called stage.</span><br><span class=\"line\">Git tracks changes of files.</span><br><span class=\"line\">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class=\"line\">Creating a new branch is quick &amp; simple.</span><br><span class=\"line\">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class=\"line\">Creating a new branch is quick AND simple.</span><br><span class=\"line\">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</span><br></pre></td></tr></table></figure>\n\n<p>可清晰看出不同分支的区别，这个时候就可以手动修改文件，解决冲突。</p>\n<p>git log也可以查看分支合并情况。</p>\n<p>最后，删除feature1就可以了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$git branch -d feature1</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"分支管理策略\"><a href=\"#分支管理策略\" class=\"headerlink\" title=\"分支管理策略\"></a>分支管理策略</h2><ol>\n<li>fast-forward</li>\n<li><code>--no-ff</code> (强制禁用fast-forward)</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git merge --no-ff -m &quot;merge with no-ff&quot; dev</span><br><span class=\"line\">Merge made by the &#39;recursive&#39; strategy.</span><br><span class=\"line\"> readme.txt | 1 +</span><br><span class=\"line\"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>\n\n<p>因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。<br>合并分支时，加上–no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git log --graph --pretty&#x3D;oneline --abbrev-commit</span><br><span class=\"line\">*   e1e9c68 (HEAD -&gt; master) merge with no-ff</span><br><span class=\"line\">|\\  </span><br><span class=\"line\">| * f52c633 (dev) add merge</span><br><span class=\"line\">|&#x2F;  </span><br><span class=\"line\">*   cf810e4 conflict fixed</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Bug分支\"><a href=\"#Bug分支\" class=\"headerlink\" title=\"Bug分支\"></a>Bug分支</h2><p>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</p>\n<p>当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场；</p>\n<p>在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick <commit>命令，把bug提交的修改“复制”到当前分支，避免重复劳动。</p>\n<p>比如此刻在dev工作，但是master出现了bug，要切换到master然后开一个BUG分支。这就要求dev分支commit。但是，dev的工作还没有做完，不想将它commit，因此用git stash将工作区封存。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git stash</span><br><span class=\"line\">Saved working directory and index state WIP on dev: f52c633 add merge</span><br></pre></td></tr></table></figure>\n\n<p>将dev工作区封存，此时可以开始修改bug</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout master</span><br><span class=\"line\">Switched to branch &#39;master&#39;</span><br><span class=\"line\">Your branch is ahead of &#39;origin&#x2F;master&#39; by 6 commits.</span><br><span class=\"line\">  (use &quot;git push&quot; to publish your local commits)</span><br><span class=\"line\"></span><br><span class=\"line\">$ git checkout -b issue-101</span><br><span class=\"line\">Switched to a new branch &#39;issue-101&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">$ git add readme.txt </span><br><span class=\"line\">$ git commit -m &quot;fix bug 101&quot;</span><br><span class=\"line\">[issue-101 4c805e2] fix bug 101</span><br><span class=\"line\"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br><span class=\"line\"></span><br><span class=\"line\">$ git checkout master</span><br><span class=\"line\">Switched to branch &#39;master&#39;</span><br><span class=\"line\">Your branch is ahead of &#39;origin&#x2F;master&#39; by 6 commits.</span><br><span class=\"line\">  (use &quot;git push&quot; to publish your local commits)</span><br><span class=\"line\"></span><br><span class=\"line\">$ git merge --no-ff -m &quot;merged bug fix 101&quot; issue-101</span><br><span class=\"line\">Merge made by the &#39;recursive&#39; strategy.</span><br><span class=\"line\"> readme.txt | 2 +-</span><br><span class=\"line\"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br><span class=\"line\"> </span><br><span class=\"line\"> $ git branch -d issue-101</span><br><span class=\"line\">Deleted branch issue-101 (was b17d20e).</span><br></pre></td></tr></table></figure>\n\n<p>将bug修改完毕以后可以开始重回dev工作。第一件事就是找回封存区的文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git stash list</span><br><span class=\"line\">stash@&#123;0&#125;: WIP on dev: f52c633 add merge</span><br></pre></td></tr></table></figure>\n\n<p>发现文件被存在某个地方，第二件事就是恢复文件。</p>\n<p>一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git stash apply stash@&#123;0&#125;</span><br><span class=\"line\">$ git stash drop stash@&#123;0&#125;</span><br></pre></td></tr></table></figure>\n\n<p>另一种方式是用git stash pop，恢复的同时把stash内容也删了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git stash pop</span><br><span class=\"line\">On branch dev</span><br><span class=\"line\">Changes to be committed:</span><br><span class=\"line\">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class=\"line\"></span><br><span class=\"line\">\tnew file:   hello.py</span><br><span class=\"line\"></span><br><span class=\"line\">Changes not staged for commit:</span><br><span class=\"line\">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class=\"line\">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class=\"line\"></span><br><span class=\"line\">\tmodified:   readme.txt</span><br><span class=\"line\"></span><br><span class=\"line\">Dropped refs&#x2F;stash@&#123;0&#125; (5d677e2ee266f39ea296182fb2354265b91b3b2a)</span><br></pre></td></tr></table></figure>\n\n<p>再用git stash list康，发现stash已经空了。</p>\n<p>这个时候dev可以继续工作了。但是我们想要将我们在master上做的bug修改复制到dev上。当然，我们可以重复操作，不过没必要。同样的bug，要在dev上修复，我们只需要把4c805e2 fix bug 101这个提交所做的修改“复制”到dev分支。</p>\n<p>注意：我们只想复制4c805e2 fix bug 101这个提交所做的修改，并不是把整个master分支merge过来。</p>\n<p>为了方便操作，Git专门提供了一个<strong>cherry-pick</strong>命令，让我们能复制一个特定的提交到当前分支：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch</span><br><span class=\"line\">* dev</span><br><span class=\"line\">  master</span><br><span class=\"line\">$ git cherry-pick 4c805e2</span><br><span class=\"line\">[master 1d4b803] fix bug 101</span><br><span class=\"line\"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"feature分支\"><a href=\"#feature分支\" class=\"headerlink\" title=\"feature分支\"></a>feature分支</h2><p>一个新功能，最好用feature分支实验，如果实验失败，可以直接删除。<br>这个时候，因为分支没有合并，所以需要强行删除：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch -D feature-vulcan</span><br><span class=\"line\">Deleted branch feature-vulcan (was 287773e).</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"多人协作\"><a href=\"#多人协作\" class=\"headerlink\" title=\"多人协作\"></a>多人协作</h2><p>多人协作的工作模式通常是这样：</p>\n<ol>\n<li>试图用git push origin <branch-name>推送自己的修改；</li>\n<li>如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；</li>\n<li>如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream-to <branch-name> origin/<branch-name>。</li>\n<li>如果合并有冲突，则解决冲突，并在本地提交；</li>\n<li>没有冲突或者解决掉冲突后，再用git push origin <branch-name>推送就能成功！</li>\n</ol>\n<p>基本指令：</p>\n<ol>\n<li>查看远程库信息，使用git remote -v；</li>\n<li>本地新建的分支如果不推送到远程，对其他人就是不可见的；</li>\n<li>从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；</li>\n<li>在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；</li>\n<li>建立本地分支和远程分支的关联，使用git branch –set-upstream branch-name origin/branch-name；</li>\n<li>从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。</li>\n</ol>\n<p>&lt;1&gt;查看远程库<br>查看远程库信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git remote</span><br><span class=\"line\">origin</span><br></pre></td></tr></table></figure>\n\n<p>查看远程库详细信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git remote -v</span><br><span class=\"line\">origin  git@github.com:michaelliao&#x2F;learngit.git (fetch)</span><br><span class=\"line\">origin  git@github.com:michaelliao&#x2F;learngit.git (push)</span><br></pre></td></tr></table></figure>\n\n<p>如果没有推送权限，就看不见push地址</p>\n<p>&lt;2&gt;推送分支<br>推送本地master到远程库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push origin master</span><br></pre></td></tr></table></figure>\n\n<p>推送本地dev到远程库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push origin dev</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>master分支是主分支，因此要时刻与远程同步；</li>\n<li>dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</li>\n<li>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</li>\n<li>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</li>\n</ul>\n<p>&lt;3&gt;抓取分支</p>\n<p>将远程库克隆：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone git@github.com:Unalian&#x2F;learngit.git</span><br><span class=\"line\">$ git branch</span><br><span class=\"line\">* master</span><br></pre></td></tr></table></figure>\n\n<p>此时只有master。（git branch q 退出）</p>\n<p>要在dev分支上开发，就必须创建远程origin的dev分支到本地：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout -b dev origin&#x2F;dev</span><br></pre></td></tr></table></figure>\n\n<p>现在，他就可以在dev上继续修改，然后，时不时地把dev分支push到远程：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git commit -m &quot;add env&quot;</span><br><span class=\"line\">[dev 7a5e5dd] add env</span><br><span class=\"line\"> 1 file changed, 1 insertion(+)</span><br><span class=\"line\"> create mode 100644 env.txt</span><br><span class=\"line\"></span><br><span class=\"line\">$ git push origin dev</span><br><span class=\"line\">Counting objects: 3, done.</span><br><span class=\"line\">Delta compression using up to 4 threads.</span><br><span class=\"line\">Compressing objects: 100% (2&#x2F;2), done.</span><br><span class=\"line\">Writing objects: 100% (3&#x2F;3), 308 bytes | 308.00 KiB&#x2F;s, done.</span><br><span class=\"line\">Total 3 (delta 0), reused 0 (delta 0)</span><br><span class=\"line\">To github.com:michaelliao&#x2F;learngit.git</span><br><span class=\"line\">   f52c633..7a5e5dd  dev -&gt; dev</span><br></pre></td></tr></table></figure>\n\n<p>这个push的时候，如果发现有一个人也同时将自己的更改push了，此时，就会发生冲突。因此，我们需要pull最新版本的提交，并与我将要push的版本进行冲突处理，最后再进行push。</p>\n<p>将最新的提交从origin/dev上抓取下来：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git pull</span><br><span class=\"line\">There is no tracking information for the current branch.</span><br><span class=\"line\">Please specify which branch you want to merge with.</span><br><span class=\"line\">See git-pull(1) for details.</span><br><span class=\"line\"></span><br><span class=\"line\">    git pull &lt;remote&gt; &lt;branch&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">If you wish to set tracking information for this branch you can do so with:</span><br><span class=\"line\"></span><br><span class=\"line\">    git branch --set-upstream-to&#x3D;origin&#x2F;&lt;branch&gt; dev</span><br></pre></td></tr></table></figure>\n\n<p>这里显示抓取失败，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch --set-upstream-to&#x3D;origin&#x2F;dev dev</span><br><span class=\"line\">Branch &#39;dev&#39; set up to track remote branch &#39;dev&#39; from &#39;origin&#39;.</span><br></pre></td></tr></table></figure>\n\n<p>再pull：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git pull</span><br><span class=\"line\">Auto-merging env.txt</span><br><span class=\"line\">CONFLICT (add&#x2F;add): Merge conflict in env.txt</span><br><span class=\"line\">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure>\n\n<p>pull成功但是合并出现冲突,手动处理冲突，再次push。（pull的同时会发生合并）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git commit -m &quot;fix env conflict&quot;</span><br><span class=\"line\">[dev 57c53ab] fix env conflict</span><br><span class=\"line\"></span><br><span class=\"line\">$ git push origin dev</span><br><span class=\"line\">Counting objects: 6, done.</span><br><span class=\"line\">Delta compression using up to 4 threads.</span><br><span class=\"line\">Compressing objects: 100% (4&#x2F;4), done.</span><br><span class=\"line\">Writing objects: 100% (6&#x2F;6), 621 bytes | 621.00 KiB&#x2F;s, done.</span><br><span class=\"line\">Total 6 (delta 0), reused 0 (delta 0)</span><br><span class=\"line\">To github.com:michaelliao&#x2F;learngit.git</span><br><span class=\"line\">   7a5e5dd..57c53ab  dev -&gt; dev</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"rebase\"><a href=\"#rebase\" class=\"headerlink\" title=\"rebase\"></a>rebase</h2><p>rebase操作可以把本地未push的分叉提交历史整理成直线；</p>\n<p>rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</p>\n<p>在上一节我们看到了，多人在同一个分支上协作时，很容易出现冲突。即使没有冲突，后push的童鞋不得不先pull，在本地合并，然后才能push成功。</p>\n<p>每次合并再push后，分支变成了这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git log --graph --pretty&#x3D;oneline --abbrev-commit</span><br><span class=\"line\">* d1be385 (HEAD -&gt; master, origin&#x2F;master) init hello</span><br><span class=\"line\">*   e5e69f1 Merge branch &#39;dev&#39;</span><br><span class=\"line\">|\\  </span><br><span class=\"line\">| *   57c53ab (origin&#x2F;dev, dev) fix env conflict</span><br><span class=\"line\">| |\\  </span><br><span class=\"line\">| | * 7a5e5dd add env</span><br><span class=\"line\">| * | 7bd91f1 add new env</span><br><span class=\"line\">| |&#x2F;  </span><br><span class=\"line\">* |   12a631b merged bug fix 101</span><br><span class=\"line\">|\\ \\  </span><br><span class=\"line\">| * | 4c805e2 fix bug 101</span><br><span class=\"line\">|&#x2F; &#x2F;  </span><br><span class=\"line\">* |   e1e9c68 merge with no-ff</span><br><span class=\"line\">|\\ \\  </span><br><span class=\"line\">| |&#x2F;  </span><br><span class=\"line\">| * f52c633 add merge</span><br><span class=\"line\">|&#x2F;  </span><br><span class=\"line\">*   cf810e4 conflict fixed</span><br></pre></td></tr></table></figure>\n\n<p>注意到Git用(HEAD -&gt; master)和(origin/master)标识出当前分支的HEAD和远程origin的位置分别是582d922 add author和d1be385 init hello，本地分支比远程分支快两个提交。</p>\n<p>现在我们尝试推送本地分支：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push origin master</span><br><span class=\"line\">To github.com:michaelliao&#x2F;learngit.git</span><br><span class=\"line\"> ! [rejected]        master -&gt; master (fetch first)</span><br><span class=\"line\">error: failed to push some refs to &#39;git@github.com:michaelliao&#x2F;learngit.git&#39;</span><br><span class=\"line\">hint: Updates were rejected because the remote contains work that you do</span><br><span class=\"line\">hint: not have locally. This is usually caused by another repository pushing</span><br><span class=\"line\">hint: to the same ref. You may want to first integrate the remote changes</span><br><span class=\"line\">hint: (e.g., &#39;git pull ...&#39;) before pushing again.</span><br><span class=\"line\">hint: See the &#39;Note about fast-forwards&#39; in &#39;git push --help&#39; for details.</span><br></pre></td></tr></table></figure>\n\n<p>很不幸，失败了，这说明有人先于我们推送了远程分支。按照经验，先pull一下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git pull</span><br><span class=\"line\">remote: Counting objects: 3, done.</span><br><span class=\"line\">remote: Compressing objects: 100% (1&#x2F;1), done.</span><br><span class=\"line\">remote: Total 3 (delta 1), reused 3 (delta 1), pack-reused 0</span><br><span class=\"line\">Unpacking objects: 100% (3&#x2F;3), done.</span><br><span class=\"line\">From github.com:michaelliao&#x2F;learngit</span><br><span class=\"line\">   d1be385..f005ed4  master     -&gt; origin&#x2F;master</span><br><span class=\"line\"> * [new tag]         v1.0       -&gt; v1.0</span><br><span class=\"line\">Auto-merging hello.py</span><br><span class=\"line\">Merge made by the &#39;recursive&#39; strategy.</span><br><span class=\"line\"> hello.py | 1 +</span><br><span class=\"line\"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>\n\n<p>再用git status看看状态：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git status</span><br><span class=\"line\">On branch master</span><br><span class=\"line\">Your branch is ahead of &#39;origin&#x2F;master&#39; by 3 commits.</span><br><span class=\"line\">  (use &quot;git push&quot; to publish your local commits)</span><br><span class=\"line\"></span><br><span class=\"line\">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>\n\n<p>加上刚才合并的提交，现在我们本地分支比远程分支超前3个提交。</p>\n<p>用git log看看：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git log --graph --pretty&#x3D;oneline --abbrev-commit</span><br><span class=\"line\">*   e0ea545 (HEAD -&gt; master) Merge branch &#39;master&#39; of github.com:michaelliao&#x2F;learngit</span><br><span class=\"line\">|\\  </span><br><span class=\"line\">| * f005ed4 (origin&#x2F;master) set exit&#x3D;1</span><br><span class=\"line\">* | 582d922 add author</span><br><span class=\"line\">* | 8875536 add comment</span><br><span class=\"line\">|&#x2F;  </span><br><span class=\"line\">* d1be385 init hello</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>提交历史分叉就很不方便了，我们想把这些化成一条直线。<br>输入命令<strong>git rebase</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git rebase</span><br><span class=\"line\">First, rewinding head to replay your work on top of it...</span><br><span class=\"line\">Applying: add comment</span><br><span class=\"line\">Using index info to reconstruct a base tree...</span><br><span class=\"line\">M\thello.py</span><br><span class=\"line\">Falling back to patching base and 3-way merge...</span><br><span class=\"line\">Auto-merging hello.py</span><br><span class=\"line\">Applying: add author</span><br><span class=\"line\">Using index info to reconstruct a base tree...</span><br><span class=\"line\">M\thello.py</span><br><span class=\"line\">Falling back to patching base and 3-way merge...</span><br><span class=\"line\">Auto-merging hello.py</span><br></pre></td></tr></table></figure>\n\n<p>再git log</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git log --graph --pretty&#x3D;oneline --abbrev-commit</span><br><span class=\"line\">* 7e61ed4 (HEAD -&gt; master) add author</span><br><span class=\"line\">* 3611cfe add comment</span><br><span class=\"line\">* f005ed4 (origin&#x2F;master) set exit&#x3D;1</span><br><span class=\"line\">* d1be385 init hello</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>这就是rebase操作的特点：把分叉的提交历史“整理”成一条直线，看上去更直观。缺点是本地的分叉提交已经被修改过了。</p>\n<p>最后，通过push操作把本地分支推送到远程：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Mac:~&#x2F;learngit michael$ git push origin master</span><br><span class=\"line\">Counting objects: 6, done.</span><br><span class=\"line\">Delta compression using up to 4 threads.</span><br><span class=\"line\">Compressing objects: 100% (5&#x2F;5), done.</span><br><span class=\"line\">Writing objects: 100% (6&#x2F;6), 576 bytes | 576.00 KiB&#x2F;s, done.</span><br><span class=\"line\">Total 6 (delta 2), reused 0 (delta 0)</span><br><span class=\"line\">remote: Resolving deltas: 100% (2&#x2F;2), completed with 1 local object.</span><br><span class=\"line\">To github.com:michaelliao&#x2F;learngit.git</span><br><span class=\"line\">   f005ed4..7e61ed4  master -&gt; master</span><br></pre></td></tr></table></figure>"},{"date":"2020-03-29T16:00:00.000Z","_content":"## 2.5 经典进程同步问题\n\n### 2.5.1 生产者消费者问题\n\n<!-- more -->\n**1. 概念**\n\n* 代表一类具有相同属性的进程。\n\n* 共享一个大小固定的缓冲区，一个或多个生产者生产数\n\n  据，并将生产的数据存入缓冲区，并有一个消费者从缓冲区中取数据。\n\n* 例如， 在输入时，输入进程是生产者，计算进程是消费者;而在输出时，则计 算进程是生产者，而打印进程是消费者。\n\n分别设置两个指针in和out:\n– in指向生产者将存放数据的存储单元 – out指向消费者将取数据的存储单元\n\n*如果不控制生产者与消费者：生产者和消费者可能同时进入缓冲区，甚至可能同时读/写一个存储单**元，将导致执行结果不确定。*\n\n**2. 解决方法1：信号量**\n\n互斥信号量mutex:实现诸进程对缓冲池的互斥使用; \n\n资源信号量empty:表示缓冲池中空缓冲区的数量;初始值定义为1\n\n资源信号量full:表示满缓冲区的数量; 初始值定义为0\n\n只要缓冲池未满，生产者便可将消息送入缓冲池;只要缓冲池未空，消费者便可从缓冲池中取走一个消息。\n\n生产者\n\n```\nvar mutex，empty，full:semaphore:=1，n，0; \n\tbuffer:array[0，...，n-1]of item; \n\tin，out:integer:=0，0;\n\tbegin\n\t\tparbegin \n\t\t\tproceducer:begin\n\t\t\t\trepeat\n\t\t\t\t...\n\t\t\t\tproducer an item nextp;\n\t\t\t\t...\n\t\t\t\twait(empty);\t当empty == 1：1-1=0 \n\t\t\t\t\t\t\t\t\t\t\t当empty == 0 说明缓冲区不空\n\t\t\t\twait(mutex);  \n\t\t\t\tbuffer(in):=nextp; \n\t\t\t\tin:=(in+1)mod n; \n\t\t\t\tsignal(mutex);释放缓冲区 \n\t\t\t\tsignal(full); full代表数据个数\nuntil false; end\n \n```\n\n消费者\n\n```\n consumer :begin \n \t\t\t\t\t\trepeat\n\t\t\t\t\t\twait (full); \n\t\t\t\t\t\twait(mutex); 缓冲区是否有其他进程\n\t\t\t\t\t\tnextc :=buffer(out); \n\t\t\t\t\t\tout:= (out+1)mod n;\n\t\t\t\t\t\tsignal(mutex); \n\t\t\t\t\t\tsignal(empty);\n\t\t\t\t\t\tconsumer the item in nextc;\n\t\t\t\t\tuntil false; \n\t\t\t\tend\n\t\t\tparend \n\t\tend\n```\n\n**3. 注意**\n\n* 先申请资源信号量，再申请互斥信号量\n\n  *资源信号量相当于你吃饭先预定个桌子如果你不预定 直接去吃饭 没桌子了你只好一直在那等了 别人吃完了桌子留给了预定的人 你没预定就得一直在那等 就是死锁了*\n\n  *如两个进程都反过来操作，先互斥了，但是没有得到临界资源，发生死锁*\n\n* 对任何信号量的wait与signal操作必须配对。同一进程中的多对wait与signal语句只能嵌套，不能交叉。\n\n* 对同一个资源信号量的wait与signal可以不在同一个进程中。\n\n  – 例如，wait(empty)在计算进程中，而signal(empty)则在打印进程中，计 算进程若因执行wait(empty)而阻塞， 则以后将由打印进程将它唤醒\n\n* wait与signal语句不能颠倒顺序，wait语句一定先于signal语句，否则可能 引起进程死锁。\n\n**4. 解决方法2：and信号量**\n\n![and信号量（合并互斥和资源信号量）](https://img.cetacis.dev/uploads/big/25e90fb77f0065bee3136b76517b5f2b.png)\n\n### 2.5.2 读者和写者问题\n\n**1. 概念**\n\n读者：只读不取\n\n读读不互斥，读写互斥，写写互斥。\n\n**2. 解决方法1：读者优先**\n\n**读者优先**：一旦有读者正在读数据，允许多个读者同时进入读数据，只有 当全部读者退出，才允许写者进入写数据。\n\n可能问题：读者不断进入，写者长时间等待（饥饿）\n\n```\nVar rmutex, wmutex:semaphore∶ =1,1;/* 互斥信号量，初始化为1 */\n\tReadcount:integer∶ =0;; /* 统计读者个数 */ \n\tbegin\n\tparbegin\n\tReader:begin \n\t\trepeat\n\t\twait(rmutex);# 共享变量，保证互斥\n\t\tif readcount=0 then wait(wmutex); # readcount == 0 在此之前没有读者 \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t# 需要判断是否有写进程 如果有，则需要等待写进程\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t# wmutex：用于写进程互斥\n\t\t\tReadcount∶ =Readcount+1;   # 读者进程的共享变量\n\t\tsignal(rmutex);\n...\nperform read operation;\n...\n\t\twait(rmutex); \n\t\t\treadcount∶ =readcount-1;\n\t\t\tif readcount=0 then signal(wmutex); # 最后一个读进程，有可能有进程在等，\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t# 判断是否需要唤醒\n\t\t\tsignal(rmutex);\n\t\t\tuntil false;\n     end\n \n```\n\n**2. 解决方法2：信号量集**\n\n写者\n\n```\nvar RN integer;/* 控制读者上限RN*/ \n\tL, mx:semaphore∶ =RN,1;\n\tbegin\n  \tparbegin\n\t\t\treader:begin \n\t\t\t\trepeat\n\t\t\t\t\tswait(L,1,1);\n\t\t\t\t\t/* 每进入一个读者，L减一，控制总数RN个*/ \n\t\t\t\t\tswait(mx,1,0);\n\t\t\t\t\t/* 开关，mx=1标识无writer进程写*/\n...\n\t\t\t\t\tperform read operation; \n\t\t\t\t\t...\n\n```\n\n![](https://img.cetacis.dev/uploads/big/7710f66ad00fa7588b9bc758f3803f08.png)\n\n### 2.5.3 哲学家就餐问题\n\n**1. 问题描述**\n\n![哲学家问题](https://img.cetacis.dev/uploads/big/7e7c738894e76900b2d180fcf1e9e43b.png)\n\n经分析可知，放在桌子上的筷子是临界资源，在一段时间内只允许一位哲学 家使用。为了实现对筷子的互斥使用，可以用一个信号量表示一只筷子，由\n\n这五个信号量构成信号量数组。其描述如下: • Var chopstick: array[0, ..., 4] of semaphore;\n\n**2. 解决方式1：信号量**\n\n* 每个筷子一个初值为1的信号量 \n* 每个哲学家是一个进程\n\n```\nVar Chopstick;array [0,4]of semaphore; \n 第i个进程描述为(i=0,... ,4)\nrepeat\n\twait(chopstick[i]);取左筷子; \n\twait(chopstick[(i+1)mod 5]);取右筷子; \n\teat;\n\tsignal(chopstick[i]);放左筷子\n\tsignal (Chopstick[(i+1)mod 5];放右筷子; \n\tthink;\nuntil false;\n(这可能导致死锁：只要相邻的两个人同时拿起左筷子就会发生死锁\n```\n\n*对wait/signal的理解*\n\n*wait ：在取用一个资源时是否需要wait*\n\n*signal： 在放置一个资源时，设置此资源可获取*\n\n**3. 解决方式2：and信号量（解决死锁**\n\n```\nVar chopsiick array [0, ..., 4] of semaphore∶ =(1,1,1,1,1); \n\tprocessi\n\t\trepeat\n\t\t\tthink;\n\t\t\tsswait(chopstick[(i+1) mod 5], chopstick [i]); \n\t\t\teat;\n\t\t\tssignat(chopstick [(i+1) mod 5], chopstick [i]);\n\t\tuntil false;\n```\n\n### 2.5.4 互斥与同步解决方法之四 : 管程\n\n**1. 概念**\n\n* 出现原因：每个要访问临界资源的进程都必须自备**同步操作**wait(S)和signal(s)。这就使大量的同步操作分散在各个进程中。这不仅给系统的管理带来了麻烦，而且还会因同步操作的使用不当而导致系统死锁。\n\n* 定义：将资源访问的同步，资源本身进行封装为一个“class”。同时，只能有一个“class”访问这个数据。Hansan为管程所下的定义是:“一个管程定义了一个数据结构和能为并发进程所执行(在该数据结构上)的一组操作，这组操作能同步进程和改变管程 中的数据”。\n\n* 互斥保证：操作系统- 任何时刻，只能有一个进程在管程中运行\n\n* 组成：1 局部于管程的共享变量说明;\n\n  ​\t\t\t2 对该数据结构进行操作的一组过程\n\n  ​\t\t\t3 对局部于管程的数据设置初始值的语句。 \n\n  ​\t\t\t4 管程的名称\n\n**2. 对生产者消费者问题的解决**\n\n在利用管程方法来解决生产者-消费者问题时， 首先便是为它们建立一个管程，并命名为Proclucer-Consumer, 或简称为PC。其中包括两个过程: \n\n(1)put(item)过程。 生产者利用该过程将自己生产的产品投放到缓冲池中，\n\n并用整型变量count来表示在缓冲池中已有的产品数目，当count≥n时，表示 缓冲池已满，生产者须等待。\n(2) get(item)过程。消费者利用该过程从缓冲池中取出一个产品，当count≤0 时，表示缓冲池中已无可取用的产品， 消费者应等待。\n\n```\nproducer:begin \n\trepeat\n\t\tproduce an item in nextp;\n\t\tPC.put(item); \n\t\tuntil false;\n\tend # 生产者进程\nconsumer:begin\n\trepeat\n\t\tPC.get(item);\n\t\tconsume the item in nextc;\n\t\tuntil false; \n\tend # 消费者进程\n```\n\n将所有功能封装在**PC**这个“类”中，直接调用。\n\n## 2.6 进程通信\n\n**概念：**当进程进行通信合作时，各个进程之间需要建立连接，进程通信需要同步和协调。\n\n通讯类型：控制信息（低级）数据（高级）\n\n进程之间同步与互斥是一种低级通信,用来控制进程执行速度。\n\n– 效率低\n– 通信对用户不透明\n\n### 通信机制1 基于共享存储区方式\n\n1. 通过程序设计来实现。程序员设计程序时，利用程序指令设置共享数据结构， 并处理通信进程之间的同步等问题，操作系统只需提供共享存储区。\n\n2. 由操作系统在内存中划分出一块区域作为共享存储区。\n\n– 进程在通信前向系统申请共享存储区中的一个分区。\n\n– 然后，申请进程把获得的共享存储分区连接到本进程上，此后便可象读/写 普通存储器一样地读/写共享存储分区。\n\n– 该方式下，通信进程之间的同步与互斥访问共享存储区可以由操作系统实 现。\n\n### 通信机制2 管道通信\n\n- 所谓“管道”，是指用于连接一个读进程和一个写进程以实现他们之间通信 的一个共享文件，又名pipe文件。\n- 向管道(共享文件)提供输入的发送进程(即写进程)， 以字符流形式将大量的数 据送入管道;\n- 而接受管道输出的接收进程(即读进程)，则从管道中接收(读)数据。由于发送 进程和接收进程是利用管道进行通信的，故又称为管道通信。\n- 这种方式首创于UNIX系统，由于它能有效地传送大量数据，因而又被引入到 许多其它操作系统中。\n\n**有名管道  **：通过文件的读写（遵循FIFO原则\n\n**无名管道**：内存\n\n### 通信机制3 信息传递方式\n\n比如网络信息的传递，本机的进程与远端服务器链接并且传递。\n\n进程间的数据交换，是以格式化的消息(message)为单位的(计算机网络称为报文)\n\n## 2.7 线程\n\n线程是一种比进程更小的独立运行单位：线程（threads） 可以比进程更好地提高程序的并行执行程度，并且提高系统的吞吐量。\n\n### 2.7.1 线程的引入\n\n进程特点：\n\n* 资源所有权:一个进程包括一个保存进程映像的虚地址空间，并且随时分配对。资源的的控制或所有权，包括内存、I/O通道、I/O设备、文件等。\n\n  资源：处理机，io\n\n* 调度/执行:进程是被操作系统调度的实体。\n\n为区分这两个特点，调度并分派的部分通常称为线程或轻便进程(lightweight process)，而资源所有权的部分通常称为进程。\n\n#### 线程的属性：\n\n(1) 线程是一个被调度和分派的基本单位，并可独立运行的实体。大多数与 执行相关的信息可以保存在线程级的数据结构中;\n\n(2)线程是可以并发执行; (3)共享进程资源。\n\n(4)线程是轻型实体，在切换时只需保存少量寄存器的内容，不涉及存储器的 管理等，因此系统开销小。\n\n(5)进程中的所有线程共享同一个地址空间，挂起进程则会挂起进程中的所有 线程。类似地，进程的终止会导致进程中所有线程的终止。\n\n#### 线程优点\n\n1. 在一个已有进程中创建一个新线程比创建一个全新进程所需的时间少。 \n2. 终止一个线程比终止一个进程花费的时间少。 \n3. 线程间切换比进程间切换花费的时间少。\n4. 线程提高了不同的执行程序间通信的效率。同一个进程中的线程共享存储空 间和文件，它们无需调用内核就可以互相通信。\n\n### 2.7.2 线程进程比较\n\n1、调度的基本单位 2、并发性 3、拥有资源 4、独立性 5、系统开销 6、支持多处理机\n\n### 线程状态和线程控制块\n\n**线程的状态有: **\n\n运行状态、就绪状态、阻塞状态等。\n\n**在线程切换时保存的线程信息:**\n\n1 一个执行栈。\n2 每个线程静态存储局部变量。 3对存储器和其进程资源的访问，并与该进程中的其他线程共享这些资源。如:寄存器状态、堆栈、线程运行状态、 优先级、线程专有存储器、信 号屏蔽等\n\n#### 线程状态变化的4种基本操作\n\n1派生(Spawn):当产生一个新进程时，同时也为该进程派生了一个“初始化 线程”，随后，可以在同一个进程中派生另一个线程，新线程被放置在就绪队列中。\n\n2阻塞(Block):当线程需要等待一个事件时，它将阻塞，此时处理器转而执 行另一个就绪线程。\n\n3解除阻塞(Unblock):当阻塞一个线程的事件发生时，该线程被转移到就绪 队列中。\n\n4结束(Finish):当一个线程完成时，其寄存器的信息和栈都被释放。\n\n### 2.6.3 线程的分类\n\n1. 内核\n2. 用户空间 （同时，用户层也可有资源所有权，线程在此层对进程直接进行调度\n\n\n\n\n\n# 第三章 处理机与死锁\n\n多到程序环境进程数目多于处理机数，处理机是十分重要的资源，如何分配尤为重要，它是由调度程序完成的，需要优秀的调度方法。\n\n调度需要解决的问题：1. 调度算法 2. 何时分配 3. 调度过程及其进程 的上下文切换\n\n## 3.1 处理机调度的层次和调度算法目标\n\n调度对象\n\n- 作业（job） 程序、数据、作业说明书\n\n### 3.1.1 处理机调度的层次\n\n1. 高级调度 \n\n   作业调度或长程调度:用于决定把外存上处于后备队列中的哪些作业调入内存，并为它们创建进程、分配必要的资源，然后，再将新创建的进程排在就 绪队列上，准备执行 。\n\n2. 低级调度\n\n   进程调度或短程调度:用来决定就绪队列中的哪个进程(或内核级线程) 应获得处理机，然后再由分派程序把处理机分配给该进程的具体操作。\n\n3. 中级调度\n\n   目的：提高内存利用率和系统吞吐量。就绪状态--挂起状态 当系统负载过重，*将进程挂起到外存的专*用*区域*\n\n#### 1. 高级调度\n\n作业调度或长程调度:用于决定把外存上处于后备队列中的哪些作业调入内存，并为它们创建进程、分配必要的资源，然后，再将新创建的进程排在就 绪队列上，准备执行 。\n\n* 接受作业数量：取决于多到程序度允许多少作业同时在内存运行\n* 接纳那些作业：取决于调度算法 （先入先出、短作业优先、基于作业优先权、相应比高者优先\n\n**阶段与状态：**\n\n收容运行段（后备状态）\n\n运行阶段（运行状态）\n\n完成阶段（完成状态）\n\n#### 2. 低级调度\n\n**进程调度的主要任务**\n\n– 保存处理机的现场信息到进程PCB中，如:程序计数器、通用寄存器等 \n– 按某种算法选取进程，如优先级算法、轮转法等\n– 由分派程序(Dispatcher)把处理器分配给进程，恢复进程处理机现场\n\n**进程调度机制的三个部分**\n\n– 排队器 对首进程即将要被调用的进程\n\n– 分派器 (分派程序) 将cpu分配\n\n– 上下文切换器 (两对)\n\n当前进程->分派程序->新进程\n\n**调度方式**\n\n* 非抢占式\n\n  1. 正在执行的进程执行完毕，或因发生某事件而不能再继续执(包括:当前执行进程被中断、挂起自己、退出等)\n\n  2. 执行中的进程因提出I/O请求而暂停执行;\n\n  3. 在进程通信或同步过程中执行了某种原语操作，如P操作原语，Block原语， Wakeup原语等。\n\n* 抢占式\n\n  抢占原则： 优先权原则。短作业(进程)优先原则。时间片原则。\n\n  优缺点：优点 满足对响应时间严格的实时任务 缺点 调度开销大\n\n#### 3. 中级调度\n\n目的：提高内存利用率和系统吞吐量。\n\n**挂起状态：**使那些暂时不能运行的进程不再占用内存资源，而将它们调至外存上去等待。\n\n程序重又具备运行条件、且内存又稍有空闲时，由中级调度来决定把 外存上的哪些又具备运行条件的就绪进程，重新调入内存，并修改其状态为 就绪状态。\n\n#### 4. 调度队列模型和调度准则\n\n1. 仅有进程调度的调度队列模型\n\n![](https://img.cetacis.dev/uploads/big/a2f70281a16a73945aab3c237bd18ec3.png)\n\n2. 有高级和低级调度的调度队列模型\n\n![](https://img.cetacis.dev/uploads/big/9c92d3574c203412fcf950aa64936c72.png)\n\n3. 同时具有三级调度的调度队列模型\n\n![](https://img.cetacis.dev/uploads/big/b626a71c9dbaecdccd485b19c9fe8cb6.png)\n\n### 3.1.2 处理机调度算法目标\n\n#### 1. 共同目标\n\n**资源利用率** 最重要\n\n**公平性** 合理cpu时间 合理不仅仅在于先入先出，而在于很多原则，比如优先权原则，短进程原则。\n\n**平衡性** 保持各种cpu的系统资源使用平衡性\n\n策略强制执行\n\n#### 2. 批处理系统目标\n\n![](https://img.cetacis.dev/uploads/big/47dcfdb60f8ab8ca9616e37659a6b8a2.png)\n\n平均周转时间求和即全部的周转时间\n\n平均带权周转时间求和是 周转时间/服务时间\n\n#### 3. 分时系统目标\n\n1. 响应时间快 用户体验好\n\n2. 均衡性 系统响应时间快慢与用户所请求服务的复杂性相适应\n\n#### 4. 实时系统的目标\n\n1. **截止时间的保证** 截止时间指任务必须开始执行或者必须完成的时间。实时系统调度算法的一个重要目标是保证实时任务对截止时间的要求。\n2. 可预测性\n\n## 3.3 调度算法\n\n调度算法：根据系统的资源分配策略所规定的资源分配算法。对于不同 的系统目标，通常采用不同的调度算法。\n\n1.先来先服务(FCFS) 2.短作业(短进程)优先(SJF) 3.时间片轮转(RR) 4.基于优先级的调度算法 5.剩余时间最短者优先 6.高响应比优先调度算法 7.多级反馈队列调度法\n\n*有利于否在于带权周转时间的长短*\n\n周转时间 = 完成时间 - 到达时间\n\n带权周转时间 = 周转时间 / 服务时间\n\n### 3.3.1先来先服务\n\n有利于长作业不利于短作业（短作业可能会等待较长时间才能得到短时服务）\n\n非抢占式调度（批处理\n\n### 3.3.2 短作业优先（短作业即服务时间短）\n\n首先从就绪队列调度估计时间最短的作业 \n\n有利于短作业不利于长作业（所有短作业完成以后长作业才可能开始，甚至可能导致长作业长期不被调度）\n\n非抢占式调度（批处理\n\n缺点：1. 有利于短作业不利于长作业 2. 非抢占式调度 3. 对于长短估计不一定准确，不能选到最短的\n\n### 3.3.3 基于优先级的调度算法\n\n把处理机分配给就绪队列中优先级最高的进程\n\n**两种类型**：非抢占式优先权算法   抢占式优先权调度算法\n\n#### 1. 非抢占优先权算法\n\n系统一旦把处理机分配给就绪队列中优先权最高的进程后， 该进程便一直执行下去，直至完成;或因发生某事件使该进程放弃处理机时， 系统方可再将处理机重新分配给另一优先权最高的进程。\n\n#### 2. 抢占式优先权调度算法\n\n 在其执行期间，只要又出现了另一个其优先权更高的进程，进程调度程序就 立即停止当前进程的执行，重新将处理机分配给新到的优先权最高的进程。\n\n**特点**：能更好地满足紧迫作业的要求，故而常用于要求比较严格的实时系统中，以及对性能要求较高的批处理和分时系统中。\n\n#### 3. 优先权的类型\n\n**静态优先权**：在创建进程时确定的，且在进程的整个运行期间保持不变。\n\n**动态优先权**：在创建进程时所赋予的优先权，是可以随进程的推进或随 其等待时间的增加而改变的，以便获得更好的调度性能。\n\n**确定进程优先权的依据有三个方面**：\n\n(1)进程类型。\n– 系统进程的优先权高于一般用户进程的优先权。\n\n(2)进程对资源的需求。\n– 对执行时间和内存要求少的进程应赋予较高的优先权。\n\n(3)用户要求。\n– 按照各进程的执行流程和进程的紧迫程度来指定进程的优先权。\n\n#### 4. 高响应比 优先 调度算法\n\n响应比 Rp = 1 + 等待时间/要求服务时间 = 响应时间 / 要求服务时间 = （等待时间+要求服务时间）/要求服务时间\n\n即：要求服务时间越短，等待时间越长，响应比越大。\n\n分析：\n\n（1）时间同，越短优先权越高，**有利于短作业**\n\n（2）实现的是先来先服务\n\n（3）对于长作业，也可以由等待时间的增加而提高，防止长作业无法被调度。\n\n* 优点 ： 该算法既照顾了短作业，又考虑了作业到达的先后次序，同时不会使 长作业长期得不到服务。\n\n* 缺点： 利用该算法时，每次调度之前，都须先做响应比的计算，会增加系统 开销。\n\n### 3.3.4 时间片轮转调度费RR\n\n#### 1. RR\n\n系统将所有的就绪进程按先来先服务的原则，排成一个 队列，每次调度时，把CPU分配给队首进程，并令执行一个时间片。当执行的时间片用完时，由一个计时器发出时钟中断请求， 调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾;\n\n切换情况： 时间片用完；时间片没有用完，但是进程执行错误/错误。\n\n特点：系统能在给定的时间内，响应所有用户的请求。\n\n时间片大小会影响计算机性能：短时间片有利于短作业，使其较快完成，但会频繁发生中断、进程上下文切换，增加系统开销;\n\n对于短的、计算型进程比较有利，因为该进程充分利用时间片，而I/O型进程 却不利，因为在两次I/O之间仅需很少的CPU时间，却需要等待一个时间片。\n\n常用于分时系统及事务处理系统。\n\n#### 2. 多级反馈队列调度法（抢占式调度算法\n\n* 设置多个继续队列，每个队列有不同的优先级。赋予不用队列的时间片的大小也各不相同。优先级高，时间片小。优先级低，时间片大。第一个队列往后，优先级逐渐降低。\n\n* 当一个新进程进入内存后，首先将它放入第一队列的末尾，按FCFS原则排 队等待调度。\n\n  – 当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统;\n  – 如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的\n\n  末尾，再同样地按FCFS原则等待调度执行;\n  – 如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队\n\n  列，......\n  – 当进程最后被降到第n队列后，在第n队列中按RR方式调度\n\n* 当第一队列空闲，才调度第二队列中的进程运行。当1-（i-1）空闲，i队列才会运行。\n\n  当新进程进入后，会抢占二/三队列的cpu。将正在运行的进程放回i队列末尾。\n\n性能：\n\n(1)终端型作业用户。\n\n能在第一队列所规定的时间片内完成，可使终端型作业用户都感到满意。\n\n(2)对短作业用户有利。\n\n(3)长批处理作业用户。对于长作业，它将依次在第1，2,...，n个队列中运行， 然后再按轮转方式运行，用户不必担心其作业长期得不到处理。\n\n## 3.4 实时系统与实时任务调度\n\n由于在实时系统中都存在着若干个实时进程或任务，\n– 实时进程通常带有某种程度的紧迫性\n– 需要引入一种新的调度解决实时进程的调度，即实时调度。\n\n### 3.4.1 实现实时调度系统的基本条件\n\n#### 1. 提供必要的信息\n(1)就绪时间。 (2)开始截止时间或完成截止时间。 (3)处理时间。\n\n(4)资源要求。 (5)优先级。\n\n#### 2. 系统处理能力强\n\n在实时系统中，通常都有着多个实时任务。若处理机的处理能力不够强，则有 可能因处理机忙不过来而使某些实时任务不能得到及时处理。\n\n解决的方法是提高系统的处理能力，其途径有:\n\n* 对单处理机系统，增强其处理能力，以此显著地减少对每一个任务的处理时间;\n*  其二是采用多处理机系统。\n\n#### 3. 采用抢占式调动机制\n\n在含有硬实时任务的实时系统中，广泛采用抢占机制。当一个优先权更高 的任务到达时，允许暂停当前任务，而令高优先权任务立即投入运行，这 样便可满足该硬实时任务对截止时间的要求。\n\n#### 4. 具有快速切换机制\n\n（1）对外部中断的快速响应能力。\n\n（2）快速的任务分派能力。\n\n### 3.4.2 实时调度算法的分类\n\n![实时调度算法的分类](https://img.cetacis.dev/uploads/big/04eae4dfeee38b3ff3a71670585f7df6.png)\n\n### 3.4.3 常用的几种实时调度算法\n\n#### 1. 最早截止时间优先算法(EDF)\n\n* 按照截止时间排序\n* 如果新进程截止时间早于当前进程截止时间，则进行抢占。\n\n#### 2. 最低松弛度优先算法(LLF) \n\n松弛度=完成截至时间–剩余运行时间–当前时间\n\n略\n\n## 3.5 死锁概述\n\n**死锁(Deadlock)**：是指多个进程在运行过程中因争夺资源而造成的一 种僵局。必须由外力解决。\n\n### 3.5.1 死锁原因\n\n（1）资源竞争\n\n（2）进程间推进顺序非法\n\n#### 1.  竞争资源\n\n1) 可剥夺和非剥夺性资源\n\n- 可剥夺性资源: 是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺。如:处理机、内存等\n- 非剥夺性资源: 当系统把这类资源分配给某进程后，再不能强行收回，只能 在进程用完后自行释放。如打印机等\n\n2) 竞争非剥夺性资源\n\n* 在系统中所配置的非剥夺性资源，由于它们的数量不能满足诸进程运行的 需要，会使进程在运行过程中，因争夺这些资源而陷入僵局。 \n\n* 例如，系统中只有一台打印机R1和一台磁带机R2，可供进程P1和P2共享。 处理不好，在P1与P2之间会形成僵局，引起死锁。 P1先R1后R2，P2先R2后R1，可能会死锁。\n\n3)竞争临时性资源\n\n• 临时性资源，可以创造(生产)和撤消(消耗)的资源，也称之为消耗性资源，它也可能引起死锁。 \n\n• 如信号量、消息、buffer中的数据等资源。 \n\n• 例如:S1、S2和S3是临时性资源，是由进程P1、P2和P3产生的消息。如果 消息通信处理顺序不当也会发生死锁。 \n\n#### 2. 进程推进顺序不当引起死锁\n\n### 3.5.2 死锁必要条件\n\n(1)互斥条件 : 指进程对所分配到的资源进行排它性使用 。\n\n(2)请求和保持条件 : 指进程已经保持了至少一个资源，但又提出了新的资源 请求 。\n\n(3)不剥夺条件 : 指进程已获得的资源，在未使用完之前，不能被剥夺，只能 在使用完时由自己释放。\n\n(4)环路等待条件 : 指在发生死锁时，必然存在一个进程——资源的环形链 。\n\n### 3.5.3 解决死锁概述\n\n(1)预防死锁:是通过设置某些限制条件，去破坏产生死锁的四个必要条件中 的一个或几个条件，来预防发生死锁。\n\n(2)避免死锁:是在资源的动态分配过程中，用某种方法去防止系统进入不安 全状态，从而避免发生死锁。\n\n(3)检测死锁:通过系统所设置的检测机构，及时地检测出死锁的发生，并精 确地确定与死锁有关的进程和资源;\n\n(4)解除死锁:当检测到系统中已发生死锁时，须将进程从死锁状态中解脱出 来。常用的实施方法是撤消或挂起一些进程。\n\n## 3.6 预防死锁\n\n#### 1. 破坏“请求保持”条件\n\n系统规定所有进程在开始运行之前，都必须一次性地申请其在整个运行过程 所需的全部资源。\n\n从而进程在整个运行期间，便不会再提出资源要求，从而摒弃了请求和保持 条件，由此可以避免发生死锁。\n\n 优点:简单、易于实现且很安全。\n 缺点:资源被严重浪费，进程经常会发生饥饿现象。\n\n#### 2. 摒弃“不剥夺”条件\n\n当一个已经保持了某些资源的进程，再提出新的资源请求而不能立即得到满 足时，必须释放它已经保持了的所有资源。待以后需要时再重新申请。从而 摒弃了“不剥夺”条件。\n\n**缺点**:实现起来比较复杂且要付出很大代价。\n\n* 一个资源在使用一段时间后，它的被迫释放可能会造成前段工作的失效。 – 会使进程前后两次运行的信息不连续。\n* 因反复地申请和释放资源，致使进程执行被无限推迟，延长进程周转时 间、增加系统开销、降低吞吐量\n\n#### 3. 摒弃”环路等待“条件\n\n这种方法中规定，系统将所有资源按类型进行线性排队，并赋予不同的序号。 所有进程对资源的请求必须严格按照资源序号递增的次序提出，这样，在所 形成的资源分配图中，不可能再出现环路，因而摒弃了“环路等待”条件。\n\n**缺点：**\n\n1. 为系统中各类资源分配的序号必须相对稳定，这就限制了新设备类型的\n\n   增加;\n\n2. 经常发生作业使用资源的顺序与系统规定资源使用顺序不同的情况，造成资源浪费;\n\n3. 增加了程序设计难度。\n\n## 3.7 避免死锁\n\n### 3.7.1 安全状态\n\n- 所谓安全状态，是指系统能按某种进程顺序，如<P1，P2，...，Pn>，依次为n 个进程分配其所需资源，直至其最大需求，使每个进程都可顺利地完成，称 系统处于安全状态。\n- 称〈P1，P2，...，Pn〉序列为安全序列。否则，如果系统无法找到这样一个安 全序列，则称系统处于不安全状态。\n\n### 3.7.2 银行家算法\n\n避免死锁的关键在于如何准确的预测是否会出现死锁，从而避免死锁。最有 代表性的避免死锁的算法是Dijkstra的银行家算法。\n\n#### 1. 银行家算法数据结构\n\n(1)可利用资源向量Available:这是一个含有m个元素的数组，其中的每一个 元素代表一类可利用的资源数目。其数值随该类资源的分配和回收而动态地 改变。 Available[j]=k,表示系统中现有Rj类资源k个。\n\n(2)最大需求矩阵Max。这是一个n × m的矩阵，它定义了n个进程中每一个进 程对m类资源的最大需求。Max[i,j]=K，表示进程Pi需要Rj类资源的最大数目 为K。\n\n(3)分配矩阵Allocation是一个nxm矩阵，定义了系统中每一类资源当前已分配给每一进程的资源数。Allocation[i,j]=K，表示进程Pi当前已分 得Rj类资源的数目为K。\n\n(4)需求矩阵Need。这也是一个n×m的矩阵，用以表示每一个进程尚需的各 类资源数。Need[i,j]=K，表示进程Pi还需要Rj类资源K个，方能完成其任务。\n\n• 上述三个矩阵的关系:Need[i,j]=Max[i,j] - Allocation[i,j]\n\n#### 2. 银行家算法\n\n设Requesti，是进程Pi的请求向量，当Pi发出资源请求后，系统按下述步骤进行 检查:\n\n(1)如果Requesti[j]≤Need[i,j],便转向步骤2;否则认为出错，因为它所需要的 资源数已超过它所声明的最大值。\n\n(2)如果Requesti[j]≤Available[j]，便转向步(3)，否则，表示尚无足够资源， Pi须阻塞等待。\n\n(3)系统试探着把资源分配给进程Pi ，并修改下面数据结构中的数值: \n\nAvailable[j]:= Available[j] - Requesti[j]; Allocation[i,j] : = Allocation[i,j] + Requesti[j]; Need[i,j]: =Need[i,j] - Requesti[j]; \n\n(4)系统执行安全性算法，检查此次资源分配后，系统是否处于安全状态。若 安全，才正式将资源分配给进程Pi ，以完成本次分配;否则，将本次的试探 分配作废，恢复原来的资源分配状态，让进程Pi等待。 \n\n#### 3. 安全性算法\n\n系统所执行的安全性算法可描述如下:\n\n (1)设置两个向量:\n\n1工作向量Work: 它表示系统可提供给进程继续运行所需的各类资源数目，初始值Work:=Available\n\n2设置数组Finish[n]:初始值Finish[i]:=false; 当Finish[i]:=true时，进程Pi可获得其所需的全部资源，从而顺利执行完成。\n\n(2)从进程集合中找到一个能满足下述条件的进程Pi : \n\n1Finish[i]=false;  2 Need[i,j]≤work; **寻找未完成的进程，它的所需资源量小于系统可用资源量**\n\n若找到，执行步骤(3),否则，执行步骤(4)。 \n\n(3)当进程Pi获得资源后，顺利执行直至完成，并释放出分配给它的资源，故应 执行: \n\nWork:= Work+Allocation[i,j]; Finish[i] :=true;  go to step 2; \n\n(4)如果所有进程的Finish[i]=true都满足，则表示系统处于安全状态;否则， 系统处于不安全状态。 \n\n**大题出现 ppt例子**\n\n## 3.8 死锁的检测与解除\n\n### 3.8.1 死锁的检验\n\n#### 1. 死锁检测\n\n如果系统不愿意附加太多约束条件预防死锁，也不希望系统额外开销预测并避 免死锁，那么，只能允许死锁出现，然后，再解除它。\n\n• 因此，系统需要利用某种方法来检测死锁\n\n• 资源分配图 该图是由一组结点N和一组边E所组成的一个对偶G=(N,E)\n\n其中:\n\n(1)把N分为两个互斥的子集，即一组进程结点P={P1,P2，...，Pn)和一组资 源结点R={R1, R2 ，...， Rn}，N=PUR。 \n\n(2)凡属于E中的一个边e∈ E都连接着P中的一个结点和R中的一个结点 – e={Pi,Rj} \n\n它表示进程Pi请求一个单位的rj资源。 – e={Rj，Pi} \n\n它表示把一个单位的资源Rj分配给进程Pi 。 \n\n#### 2. 死锁定理\n\n![](https://img.cetacis.dev/uploads/big/a4ed842da08a8e4aa93af662aa37612d.png)\n\n#### 3. 死锁检测算法\n\n若能消去资源分配图中所有结点的连接边，使全部结点都成为孤立结点，则称 该图是可完全简化图;若不能使该图完全简化，则称该图是不可完全化简图。\n\n可以证明:当且仅当系统某状态S所对应的资源分配图是不可完全化简的，则S 是死锁状态。该充分条件称为死锁定理。\n\n#### 4.死锁检测中的数据结构 \n\n(1)可利用资源向量Available，它表示了m类资源中每一类资源的可用数目。\n\n (2)把不占用资源的进程(Allocation:=0)记入L表中，即Li U L\n\n (3)从进程集合中找到一个Requesti≤work的进程，做如下处理:\n\n1. Work:=work十Allocationi，\n\n2. 将它记入L表中。\n\n(4)若不能把所有进程都记入L表中，便表明系统状态S的资源分配图是不可 完全简化的。因此，该系统状态将发生死锁。\n\n```\n Work:= Available; \n \tL:={Li|Allocationi=0∩Requesti=0} \n \tfor all Li∈L do\n\t\tbegin\n\t\tfor all Requesti≤Work do\n\t\t\tbegin \n\t\t\t\tWork:=Work十Allocationi;\n        Li∪L;\n\t\t\tend \n\t\tend\n\tdeadlock:= (L={P1，P2，.... ，Pn});\n```\n\n### 3.8.2 死锁的解除\n\n当发现有进程死锁时，常采用的两种方法是解除死锁:\n\n (1)剥夺资源。从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态。\n\n(2)撤消进程。最简单的撤消进程的方法，是使全部死锁进程都夭折掉;或者 按照某种顺序逐个地撤消进程，直至有足够的资源可用，使死锁状态消除为\n\n止。\n\n按照解除死锁复杂度递增的顺序列出解除死锁的方法:\n1. 撤消死锁进程。该方法是目前操作系统中解除死锁的常用方法。\n2. 把死锁进程恢复到前一个检查点，重新执行每个进程。\n3. 按照某种原则逐个选择死锁进程进行撤消，直到解除系统死锁。\n4. 按照某种原则逐个剥夺进程资源，直到解除死锁。\n\n**最小代价原则**\n\n第三种和第四种方法需要选择系统付出代价最小的进程，最小代价原则: \n\n– 到目前为止，花费处理机的时间最少的进程;\n\n– 到目前为止，产生输出最少的进程;\n\n– 估计未执行部分最多的进程;\n\n– 到目前为止，已获得资源量最少的进程; – 优先级最低的进程。\n\n\n\n","source":"_posts/操作系统-课堂笔记.md","raw":"---\ndate: 2020/3/30\ntags:\n- 上课笔记\n- 进程\ncategories:\n- 操作系统\n- 上课笔记\n---\n## 2.5 经典进程同步问题\n\n### 2.5.1 生产者消费者问题\n\n<!-- more -->\n**1. 概念**\n\n* 代表一类具有相同属性的进程。\n\n* 共享一个大小固定的缓冲区，一个或多个生产者生产数\n\n  据，并将生产的数据存入缓冲区，并有一个消费者从缓冲区中取数据。\n\n* 例如， 在输入时，输入进程是生产者，计算进程是消费者;而在输出时，则计 算进程是生产者，而打印进程是消费者。\n\n分别设置两个指针in和out:\n– in指向生产者将存放数据的存储单元 – out指向消费者将取数据的存储单元\n\n*如果不控制生产者与消费者：生产者和消费者可能同时进入缓冲区，甚至可能同时读/写一个存储单**元，将导致执行结果不确定。*\n\n**2. 解决方法1：信号量**\n\n互斥信号量mutex:实现诸进程对缓冲池的互斥使用; \n\n资源信号量empty:表示缓冲池中空缓冲区的数量;初始值定义为1\n\n资源信号量full:表示满缓冲区的数量; 初始值定义为0\n\n只要缓冲池未满，生产者便可将消息送入缓冲池;只要缓冲池未空，消费者便可从缓冲池中取走一个消息。\n\n生产者\n\n```\nvar mutex，empty，full:semaphore:=1，n，0; \n\tbuffer:array[0，...，n-1]of item; \n\tin，out:integer:=0，0;\n\tbegin\n\t\tparbegin \n\t\t\tproceducer:begin\n\t\t\t\trepeat\n\t\t\t\t...\n\t\t\t\tproducer an item nextp;\n\t\t\t\t...\n\t\t\t\twait(empty);\t当empty == 1：1-1=0 \n\t\t\t\t\t\t\t\t\t\t\t当empty == 0 说明缓冲区不空\n\t\t\t\twait(mutex);  \n\t\t\t\tbuffer(in):=nextp; \n\t\t\t\tin:=(in+1)mod n; \n\t\t\t\tsignal(mutex);释放缓冲区 \n\t\t\t\tsignal(full); full代表数据个数\nuntil false; end\n \n```\n\n消费者\n\n```\n consumer :begin \n \t\t\t\t\t\trepeat\n\t\t\t\t\t\twait (full); \n\t\t\t\t\t\twait(mutex); 缓冲区是否有其他进程\n\t\t\t\t\t\tnextc :=buffer(out); \n\t\t\t\t\t\tout:= (out+1)mod n;\n\t\t\t\t\t\tsignal(mutex); \n\t\t\t\t\t\tsignal(empty);\n\t\t\t\t\t\tconsumer the item in nextc;\n\t\t\t\t\tuntil false; \n\t\t\t\tend\n\t\t\tparend \n\t\tend\n```\n\n**3. 注意**\n\n* 先申请资源信号量，再申请互斥信号量\n\n  *资源信号量相当于你吃饭先预定个桌子如果你不预定 直接去吃饭 没桌子了你只好一直在那等了 别人吃完了桌子留给了预定的人 你没预定就得一直在那等 就是死锁了*\n\n  *如两个进程都反过来操作，先互斥了，但是没有得到临界资源，发生死锁*\n\n* 对任何信号量的wait与signal操作必须配对。同一进程中的多对wait与signal语句只能嵌套，不能交叉。\n\n* 对同一个资源信号量的wait与signal可以不在同一个进程中。\n\n  – 例如，wait(empty)在计算进程中，而signal(empty)则在打印进程中，计 算进程若因执行wait(empty)而阻塞， 则以后将由打印进程将它唤醒\n\n* wait与signal语句不能颠倒顺序，wait语句一定先于signal语句，否则可能 引起进程死锁。\n\n**4. 解决方法2：and信号量**\n\n![and信号量（合并互斥和资源信号量）](https://img.cetacis.dev/uploads/big/25e90fb77f0065bee3136b76517b5f2b.png)\n\n### 2.5.2 读者和写者问题\n\n**1. 概念**\n\n读者：只读不取\n\n读读不互斥，读写互斥，写写互斥。\n\n**2. 解决方法1：读者优先**\n\n**读者优先**：一旦有读者正在读数据，允许多个读者同时进入读数据，只有 当全部读者退出，才允许写者进入写数据。\n\n可能问题：读者不断进入，写者长时间等待（饥饿）\n\n```\nVar rmutex, wmutex:semaphore∶ =1,1;/* 互斥信号量，初始化为1 */\n\tReadcount:integer∶ =0;; /* 统计读者个数 */ \n\tbegin\n\tparbegin\n\tReader:begin \n\t\trepeat\n\t\twait(rmutex);# 共享变量，保证互斥\n\t\tif readcount=0 then wait(wmutex); # readcount == 0 在此之前没有读者 \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t# 需要判断是否有写进程 如果有，则需要等待写进程\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t# wmutex：用于写进程互斥\n\t\t\tReadcount∶ =Readcount+1;   # 读者进程的共享变量\n\t\tsignal(rmutex);\n...\nperform read operation;\n...\n\t\twait(rmutex); \n\t\t\treadcount∶ =readcount-1;\n\t\t\tif readcount=0 then signal(wmutex); # 最后一个读进程，有可能有进程在等，\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t# 判断是否需要唤醒\n\t\t\tsignal(rmutex);\n\t\t\tuntil false;\n     end\n \n```\n\n**2. 解决方法2：信号量集**\n\n写者\n\n```\nvar RN integer;/* 控制读者上限RN*/ \n\tL, mx:semaphore∶ =RN,1;\n\tbegin\n  \tparbegin\n\t\t\treader:begin \n\t\t\t\trepeat\n\t\t\t\t\tswait(L,1,1);\n\t\t\t\t\t/* 每进入一个读者，L减一，控制总数RN个*/ \n\t\t\t\t\tswait(mx,1,0);\n\t\t\t\t\t/* 开关，mx=1标识无writer进程写*/\n...\n\t\t\t\t\tperform read operation; \n\t\t\t\t\t...\n\n```\n\n![](https://img.cetacis.dev/uploads/big/7710f66ad00fa7588b9bc758f3803f08.png)\n\n### 2.5.3 哲学家就餐问题\n\n**1. 问题描述**\n\n![哲学家问题](https://img.cetacis.dev/uploads/big/7e7c738894e76900b2d180fcf1e9e43b.png)\n\n经分析可知，放在桌子上的筷子是临界资源，在一段时间内只允许一位哲学 家使用。为了实现对筷子的互斥使用，可以用一个信号量表示一只筷子，由\n\n这五个信号量构成信号量数组。其描述如下: • Var chopstick: array[0, ..., 4] of semaphore;\n\n**2. 解决方式1：信号量**\n\n* 每个筷子一个初值为1的信号量 \n* 每个哲学家是一个进程\n\n```\nVar Chopstick;array [0,4]of semaphore; \n 第i个进程描述为(i=0,... ,4)\nrepeat\n\twait(chopstick[i]);取左筷子; \n\twait(chopstick[(i+1)mod 5]);取右筷子; \n\teat;\n\tsignal(chopstick[i]);放左筷子\n\tsignal (Chopstick[(i+1)mod 5];放右筷子; \n\tthink;\nuntil false;\n(这可能导致死锁：只要相邻的两个人同时拿起左筷子就会发生死锁\n```\n\n*对wait/signal的理解*\n\n*wait ：在取用一个资源时是否需要wait*\n\n*signal： 在放置一个资源时，设置此资源可获取*\n\n**3. 解决方式2：and信号量（解决死锁**\n\n```\nVar chopsiick array [0, ..., 4] of semaphore∶ =(1,1,1,1,1); \n\tprocessi\n\t\trepeat\n\t\t\tthink;\n\t\t\tsswait(chopstick[(i+1) mod 5], chopstick [i]); \n\t\t\teat;\n\t\t\tssignat(chopstick [(i+1) mod 5], chopstick [i]);\n\t\tuntil false;\n```\n\n### 2.5.4 互斥与同步解决方法之四 : 管程\n\n**1. 概念**\n\n* 出现原因：每个要访问临界资源的进程都必须自备**同步操作**wait(S)和signal(s)。这就使大量的同步操作分散在各个进程中。这不仅给系统的管理带来了麻烦，而且还会因同步操作的使用不当而导致系统死锁。\n\n* 定义：将资源访问的同步，资源本身进行封装为一个“class”。同时，只能有一个“class”访问这个数据。Hansan为管程所下的定义是:“一个管程定义了一个数据结构和能为并发进程所执行(在该数据结构上)的一组操作，这组操作能同步进程和改变管程 中的数据”。\n\n* 互斥保证：操作系统- 任何时刻，只能有一个进程在管程中运行\n\n* 组成：1 局部于管程的共享变量说明;\n\n  ​\t\t\t2 对该数据结构进行操作的一组过程\n\n  ​\t\t\t3 对局部于管程的数据设置初始值的语句。 \n\n  ​\t\t\t4 管程的名称\n\n**2. 对生产者消费者问题的解决**\n\n在利用管程方法来解决生产者-消费者问题时， 首先便是为它们建立一个管程，并命名为Proclucer-Consumer, 或简称为PC。其中包括两个过程: \n\n(1)put(item)过程。 生产者利用该过程将自己生产的产品投放到缓冲池中，\n\n并用整型变量count来表示在缓冲池中已有的产品数目，当count≥n时，表示 缓冲池已满，生产者须等待。\n(2) get(item)过程。消费者利用该过程从缓冲池中取出一个产品，当count≤0 时，表示缓冲池中已无可取用的产品， 消费者应等待。\n\n```\nproducer:begin \n\trepeat\n\t\tproduce an item in nextp;\n\t\tPC.put(item); \n\t\tuntil false;\n\tend # 生产者进程\nconsumer:begin\n\trepeat\n\t\tPC.get(item);\n\t\tconsume the item in nextc;\n\t\tuntil false; \n\tend # 消费者进程\n```\n\n将所有功能封装在**PC**这个“类”中，直接调用。\n\n## 2.6 进程通信\n\n**概念：**当进程进行通信合作时，各个进程之间需要建立连接，进程通信需要同步和协调。\n\n通讯类型：控制信息（低级）数据（高级）\n\n进程之间同步与互斥是一种低级通信,用来控制进程执行速度。\n\n– 效率低\n– 通信对用户不透明\n\n### 通信机制1 基于共享存储区方式\n\n1. 通过程序设计来实现。程序员设计程序时，利用程序指令设置共享数据结构， 并处理通信进程之间的同步等问题，操作系统只需提供共享存储区。\n\n2. 由操作系统在内存中划分出一块区域作为共享存储区。\n\n– 进程在通信前向系统申请共享存储区中的一个分区。\n\n– 然后，申请进程把获得的共享存储分区连接到本进程上，此后便可象读/写 普通存储器一样地读/写共享存储分区。\n\n– 该方式下，通信进程之间的同步与互斥访问共享存储区可以由操作系统实 现。\n\n### 通信机制2 管道通信\n\n- 所谓“管道”，是指用于连接一个读进程和一个写进程以实现他们之间通信 的一个共享文件，又名pipe文件。\n- 向管道(共享文件)提供输入的发送进程(即写进程)， 以字符流形式将大量的数 据送入管道;\n- 而接受管道输出的接收进程(即读进程)，则从管道中接收(读)数据。由于发送 进程和接收进程是利用管道进行通信的，故又称为管道通信。\n- 这种方式首创于UNIX系统，由于它能有效地传送大量数据，因而又被引入到 许多其它操作系统中。\n\n**有名管道  **：通过文件的读写（遵循FIFO原则\n\n**无名管道**：内存\n\n### 通信机制3 信息传递方式\n\n比如网络信息的传递，本机的进程与远端服务器链接并且传递。\n\n进程间的数据交换，是以格式化的消息(message)为单位的(计算机网络称为报文)\n\n## 2.7 线程\n\n线程是一种比进程更小的独立运行单位：线程（threads） 可以比进程更好地提高程序的并行执行程度，并且提高系统的吞吐量。\n\n### 2.7.1 线程的引入\n\n进程特点：\n\n* 资源所有权:一个进程包括一个保存进程映像的虚地址空间，并且随时分配对。资源的的控制或所有权，包括内存、I/O通道、I/O设备、文件等。\n\n  资源：处理机，io\n\n* 调度/执行:进程是被操作系统调度的实体。\n\n为区分这两个特点，调度并分派的部分通常称为线程或轻便进程(lightweight process)，而资源所有权的部分通常称为进程。\n\n#### 线程的属性：\n\n(1) 线程是一个被调度和分派的基本单位，并可独立运行的实体。大多数与 执行相关的信息可以保存在线程级的数据结构中;\n\n(2)线程是可以并发执行; (3)共享进程资源。\n\n(4)线程是轻型实体，在切换时只需保存少量寄存器的内容，不涉及存储器的 管理等，因此系统开销小。\n\n(5)进程中的所有线程共享同一个地址空间，挂起进程则会挂起进程中的所有 线程。类似地，进程的终止会导致进程中所有线程的终止。\n\n#### 线程优点\n\n1. 在一个已有进程中创建一个新线程比创建一个全新进程所需的时间少。 \n2. 终止一个线程比终止一个进程花费的时间少。 \n3. 线程间切换比进程间切换花费的时间少。\n4. 线程提高了不同的执行程序间通信的效率。同一个进程中的线程共享存储空 间和文件，它们无需调用内核就可以互相通信。\n\n### 2.7.2 线程进程比较\n\n1、调度的基本单位 2、并发性 3、拥有资源 4、独立性 5、系统开销 6、支持多处理机\n\n### 线程状态和线程控制块\n\n**线程的状态有: **\n\n运行状态、就绪状态、阻塞状态等。\n\n**在线程切换时保存的线程信息:**\n\n1 一个执行栈。\n2 每个线程静态存储局部变量。 3对存储器和其进程资源的访问，并与该进程中的其他线程共享这些资源。如:寄存器状态、堆栈、线程运行状态、 优先级、线程专有存储器、信 号屏蔽等\n\n#### 线程状态变化的4种基本操作\n\n1派生(Spawn):当产生一个新进程时，同时也为该进程派生了一个“初始化 线程”，随后，可以在同一个进程中派生另一个线程，新线程被放置在就绪队列中。\n\n2阻塞(Block):当线程需要等待一个事件时，它将阻塞，此时处理器转而执 行另一个就绪线程。\n\n3解除阻塞(Unblock):当阻塞一个线程的事件发生时，该线程被转移到就绪 队列中。\n\n4结束(Finish):当一个线程完成时，其寄存器的信息和栈都被释放。\n\n### 2.6.3 线程的分类\n\n1. 内核\n2. 用户空间 （同时，用户层也可有资源所有权，线程在此层对进程直接进行调度\n\n\n\n\n\n# 第三章 处理机与死锁\n\n多到程序环境进程数目多于处理机数，处理机是十分重要的资源，如何分配尤为重要，它是由调度程序完成的，需要优秀的调度方法。\n\n调度需要解决的问题：1. 调度算法 2. 何时分配 3. 调度过程及其进程 的上下文切换\n\n## 3.1 处理机调度的层次和调度算法目标\n\n调度对象\n\n- 作业（job） 程序、数据、作业说明书\n\n### 3.1.1 处理机调度的层次\n\n1. 高级调度 \n\n   作业调度或长程调度:用于决定把外存上处于后备队列中的哪些作业调入内存，并为它们创建进程、分配必要的资源，然后，再将新创建的进程排在就 绪队列上，准备执行 。\n\n2. 低级调度\n\n   进程调度或短程调度:用来决定就绪队列中的哪个进程(或内核级线程) 应获得处理机，然后再由分派程序把处理机分配给该进程的具体操作。\n\n3. 中级调度\n\n   目的：提高内存利用率和系统吞吐量。就绪状态--挂起状态 当系统负载过重，*将进程挂起到外存的专*用*区域*\n\n#### 1. 高级调度\n\n作业调度或长程调度:用于决定把外存上处于后备队列中的哪些作业调入内存，并为它们创建进程、分配必要的资源，然后，再将新创建的进程排在就 绪队列上，准备执行 。\n\n* 接受作业数量：取决于多到程序度允许多少作业同时在内存运行\n* 接纳那些作业：取决于调度算法 （先入先出、短作业优先、基于作业优先权、相应比高者优先\n\n**阶段与状态：**\n\n收容运行段（后备状态）\n\n运行阶段（运行状态）\n\n完成阶段（完成状态）\n\n#### 2. 低级调度\n\n**进程调度的主要任务**\n\n– 保存处理机的现场信息到进程PCB中，如:程序计数器、通用寄存器等 \n– 按某种算法选取进程，如优先级算法、轮转法等\n– 由分派程序(Dispatcher)把处理器分配给进程，恢复进程处理机现场\n\n**进程调度机制的三个部分**\n\n– 排队器 对首进程即将要被调用的进程\n\n– 分派器 (分派程序) 将cpu分配\n\n– 上下文切换器 (两对)\n\n当前进程->分派程序->新进程\n\n**调度方式**\n\n* 非抢占式\n\n  1. 正在执行的进程执行完毕，或因发生某事件而不能再继续执(包括:当前执行进程被中断、挂起自己、退出等)\n\n  2. 执行中的进程因提出I/O请求而暂停执行;\n\n  3. 在进程通信或同步过程中执行了某种原语操作，如P操作原语，Block原语， Wakeup原语等。\n\n* 抢占式\n\n  抢占原则： 优先权原则。短作业(进程)优先原则。时间片原则。\n\n  优缺点：优点 满足对响应时间严格的实时任务 缺点 调度开销大\n\n#### 3. 中级调度\n\n目的：提高内存利用率和系统吞吐量。\n\n**挂起状态：**使那些暂时不能运行的进程不再占用内存资源，而将它们调至外存上去等待。\n\n程序重又具备运行条件、且内存又稍有空闲时，由中级调度来决定把 外存上的哪些又具备运行条件的就绪进程，重新调入内存，并修改其状态为 就绪状态。\n\n#### 4. 调度队列模型和调度准则\n\n1. 仅有进程调度的调度队列模型\n\n![](https://img.cetacis.dev/uploads/big/a2f70281a16a73945aab3c237bd18ec3.png)\n\n2. 有高级和低级调度的调度队列模型\n\n![](https://img.cetacis.dev/uploads/big/9c92d3574c203412fcf950aa64936c72.png)\n\n3. 同时具有三级调度的调度队列模型\n\n![](https://img.cetacis.dev/uploads/big/b626a71c9dbaecdccd485b19c9fe8cb6.png)\n\n### 3.1.2 处理机调度算法目标\n\n#### 1. 共同目标\n\n**资源利用率** 最重要\n\n**公平性** 合理cpu时间 合理不仅仅在于先入先出，而在于很多原则，比如优先权原则，短进程原则。\n\n**平衡性** 保持各种cpu的系统资源使用平衡性\n\n策略强制执行\n\n#### 2. 批处理系统目标\n\n![](https://img.cetacis.dev/uploads/big/47dcfdb60f8ab8ca9616e37659a6b8a2.png)\n\n平均周转时间求和即全部的周转时间\n\n平均带权周转时间求和是 周转时间/服务时间\n\n#### 3. 分时系统目标\n\n1. 响应时间快 用户体验好\n\n2. 均衡性 系统响应时间快慢与用户所请求服务的复杂性相适应\n\n#### 4. 实时系统的目标\n\n1. **截止时间的保证** 截止时间指任务必须开始执行或者必须完成的时间。实时系统调度算法的一个重要目标是保证实时任务对截止时间的要求。\n2. 可预测性\n\n## 3.3 调度算法\n\n调度算法：根据系统的资源分配策略所规定的资源分配算法。对于不同 的系统目标，通常采用不同的调度算法。\n\n1.先来先服务(FCFS) 2.短作业(短进程)优先(SJF) 3.时间片轮转(RR) 4.基于优先级的调度算法 5.剩余时间最短者优先 6.高响应比优先调度算法 7.多级反馈队列调度法\n\n*有利于否在于带权周转时间的长短*\n\n周转时间 = 完成时间 - 到达时间\n\n带权周转时间 = 周转时间 / 服务时间\n\n### 3.3.1先来先服务\n\n有利于长作业不利于短作业（短作业可能会等待较长时间才能得到短时服务）\n\n非抢占式调度（批处理\n\n### 3.3.2 短作业优先（短作业即服务时间短）\n\n首先从就绪队列调度估计时间最短的作业 \n\n有利于短作业不利于长作业（所有短作业完成以后长作业才可能开始，甚至可能导致长作业长期不被调度）\n\n非抢占式调度（批处理\n\n缺点：1. 有利于短作业不利于长作业 2. 非抢占式调度 3. 对于长短估计不一定准确，不能选到最短的\n\n### 3.3.3 基于优先级的调度算法\n\n把处理机分配给就绪队列中优先级最高的进程\n\n**两种类型**：非抢占式优先权算法   抢占式优先权调度算法\n\n#### 1. 非抢占优先权算法\n\n系统一旦把处理机分配给就绪队列中优先权最高的进程后， 该进程便一直执行下去，直至完成;或因发生某事件使该进程放弃处理机时， 系统方可再将处理机重新分配给另一优先权最高的进程。\n\n#### 2. 抢占式优先权调度算法\n\n 在其执行期间，只要又出现了另一个其优先权更高的进程，进程调度程序就 立即停止当前进程的执行，重新将处理机分配给新到的优先权最高的进程。\n\n**特点**：能更好地满足紧迫作业的要求，故而常用于要求比较严格的实时系统中，以及对性能要求较高的批处理和分时系统中。\n\n#### 3. 优先权的类型\n\n**静态优先权**：在创建进程时确定的，且在进程的整个运行期间保持不变。\n\n**动态优先权**：在创建进程时所赋予的优先权，是可以随进程的推进或随 其等待时间的增加而改变的，以便获得更好的调度性能。\n\n**确定进程优先权的依据有三个方面**：\n\n(1)进程类型。\n– 系统进程的优先权高于一般用户进程的优先权。\n\n(2)进程对资源的需求。\n– 对执行时间和内存要求少的进程应赋予较高的优先权。\n\n(3)用户要求。\n– 按照各进程的执行流程和进程的紧迫程度来指定进程的优先权。\n\n#### 4. 高响应比 优先 调度算法\n\n响应比 Rp = 1 + 等待时间/要求服务时间 = 响应时间 / 要求服务时间 = （等待时间+要求服务时间）/要求服务时间\n\n即：要求服务时间越短，等待时间越长，响应比越大。\n\n分析：\n\n（1）时间同，越短优先权越高，**有利于短作业**\n\n（2）实现的是先来先服务\n\n（3）对于长作业，也可以由等待时间的增加而提高，防止长作业无法被调度。\n\n* 优点 ： 该算法既照顾了短作业，又考虑了作业到达的先后次序，同时不会使 长作业长期得不到服务。\n\n* 缺点： 利用该算法时，每次调度之前，都须先做响应比的计算，会增加系统 开销。\n\n### 3.3.4 时间片轮转调度费RR\n\n#### 1. RR\n\n系统将所有的就绪进程按先来先服务的原则，排成一个 队列，每次调度时，把CPU分配给队首进程，并令执行一个时间片。当执行的时间片用完时，由一个计时器发出时钟中断请求， 调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾;\n\n切换情况： 时间片用完；时间片没有用完，但是进程执行错误/错误。\n\n特点：系统能在给定的时间内，响应所有用户的请求。\n\n时间片大小会影响计算机性能：短时间片有利于短作业，使其较快完成，但会频繁发生中断、进程上下文切换，增加系统开销;\n\n对于短的、计算型进程比较有利，因为该进程充分利用时间片，而I/O型进程 却不利，因为在两次I/O之间仅需很少的CPU时间，却需要等待一个时间片。\n\n常用于分时系统及事务处理系统。\n\n#### 2. 多级反馈队列调度法（抢占式调度算法\n\n* 设置多个继续队列，每个队列有不同的优先级。赋予不用队列的时间片的大小也各不相同。优先级高，时间片小。优先级低，时间片大。第一个队列往后，优先级逐渐降低。\n\n* 当一个新进程进入内存后，首先将它放入第一队列的末尾，按FCFS原则排 队等待调度。\n\n  – 当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统;\n  – 如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的\n\n  末尾，再同样地按FCFS原则等待调度执行;\n  – 如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队\n\n  列，......\n  – 当进程最后被降到第n队列后，在第n队列中按RR方式调度\n\n* 当第一队列空闲，才调度第二队列中的进程运行。当1-（i-1）空闲，i队列才会运行。\n\n  当新进程进入后，会抢占二/三队列的cpu。将正在运行的进程放回i队列末尾。\n\n性能：\n\n(1)终端型作业用户。\n\n能在第一队列所规定的时间片内完成，可使终端型作业用户都感到满意。\n\n(2)对短作业用户有利。\n\n(3)长批处理作业用户。对于长作业，它将依次在第1，2,...，n个队列中运行， 然后再按轮转方式运行，用户不必担心其作业长期得不到处理。\n\n## 3.4 实时系统与实时任务调度\n\n由于在实时系统中都存在着若干个实时进程或任务，\n– 实时进程通常带有某种程度的紧迫性\n– 需要引入一种新的调度解决实时进程的调度，即实时调度。\n\n### 3.4.1 实现实时调度系统的基本条件\n\n#### 1. 提供必要的信息\n(1)就绪时间。 (2)开始截止时间或完成截止时间。 (3)处理时间。\n\n(4)资源要求。 (5)优先级。\n\n#### 2. 系统处理能力强\n\n在实时系统中，通常都有着多个实时任务。若处理机的处理能力不够强，则有 可能因处理机忙不过来而使某些实时任务不能得到及时处理。\n\n解决的方法是提高系统的处理能力，其途径有:\n\n* 对单处理机系统，增强其处理能力，以此显著地减少对每一个任务的处理时间;\n*  其二是采用多处理机系统。\n\n#### 3. 采用抢占式调动机制\n\n在含有硬实时任务的实时系统中，广泛采用抢占机制。当一个优先权更高 的任务到达时，允许暂停当前任务，而令高优先权任务立即投入运行，这 样便可满足该硬实时任务对截止时间的要求。\n\n#### 4. 具有快速切换机制\n\n（1）对外部中断的快速响应能力。\n\n（2）快速的任务分派能力。\n\n### 3.4.2 实时调度算法的分类\n\n![实时调度算法的分类](https://img.cetacis.dev/uploads/big/04eae4dfeee38b3ff3a71670585f7df6.png)\n\n### 3.4.3 常用的几种实时调度算法\n\n#### 1. 最早截止时间优先算法(EDF)\n\n* 按照截止时间排序\n* 如果新进程截止时间早于当前进程截止时间，则进行抢占。\n\n#### 2. 最低松弛度优先算法(LLF) \n\n松弛度=完成截至时间–剩余运行时间–当前时间\n\n略\n\n## 3.5 死锁概述\n\n**死锁(Deadlock)**：是指多个进程在运行过程中因争夺资源而造成的一 种僵局。必须由外力解决。\n\n### 3.5.1 死锁原因\n\n（1）资源竞争\n\n（2）进程间推进顺序非法\n\n#### 1.  竞争资源\n\n1) 可剥夺和非剥夺性资源\n\n- 可剥夺性资源: 是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺。如:处理机、内存等\n- 非剥夺性资源: 当系统把这类资源分配给某进程后，再不能强行收回，只能 在进程用完后自行释放。如打印机等\n\n2) 竞争非剥夺性资源\n\n* 在系统中所配置的非剥夺性资源，由于它们的数量不能满足诸进程运行的 需要，会使进程在运行过程中，因争夺这些资源而陷入僵局。 \n\n* 例如，系统中只有一台打印机R1和一台磁带机R2，可供进程P1和P2共享。 处理不好，在P1与P2之间会形成僵局，引起死锁。 P1先R1后R2，P2先R2后R1，可能会死锁。\n\n3)竞争临时性资源\n\n• 临时性资源，可以创造(生产)和撤消(消耗)的资源，也称之为消耗性资源，它也可能引起死锁。 \n\n• 如信号量、消息、buffer中的数据等资源。 \n\n• 例如:S1、S2和S3是临时性资源，是由进程P1、P2和P3产生的消息。如果 消息通信处理顺序不当也会发生死锁。 \n\n#### 2. 进程推进顺序不当引起死锁\n\n### 3.5.2 死锁必要条件\n\n(1)互斥条件 : 指进程对所分配到的资源进行排它性使用 。\n\n(2)请求和保持条件 : 指进程已经保持了至少一个资源，但又提出了新的资源 请求 。\n\n(3)不剥夺条件 : 指进程已获得的资源，在未使用完之前，不能被剥夺，只能 在使用完时由自己释放。\n\n(4)环路等待条件 : 指在发生死锁时，必然存在一个进程——资源的环形链 。\n\n### 3.5.3 解决死锁概述\n\n(1)预防死锁:是通过设置某些限制条件，去破坏产生死锁的四个必要条件中 的一个或几个条件，来预防发生死锁。\n\n(2)避免死锁:是在资源的动态分配过程中，用某种方法去防止系统进入不安 全状态，从而避免发生死锁。\n\n(3)检测死锁:通过系统所设置的检测机构，及时地检测出死锁的发生，并精 确地确定与死锁有关的进程和资源;\n\n(4)解除死锁:当检测到系统中已发生死锁时，须将进程从死锁状态中解脱出 来。常用的实施方法是撤消或挂起一些进程。\n\n## 3.6 预防死锁\n\n#### 1. 破坏“请求保持”条件\n\n系统规定所有进程在开始运行之前，都必须一次性地申请其在整个运行过程 所需的全部资源。\n\n从而进程在整个运行期间，便不会再提出资源要求，从而摒弃了请求和保持 条件，由此可以避免发生死锁。\n\n 优点:简单、易于实现且很安全。\n 缺点:资源被严重浪费，进程经常会发生饥饿现象。\n\n#### 2. 摒弃“不剥夺”条件\n\n当一个已经保持了某些资源的进程，再提出新的资源请求而不能立即得到满 足时，必须释放它已经保持了的所有资源。待以后需要时再重新申请。从而 摒弃了“不剥夺”条件。\n\n**缺点**:实现起来比较复杂且要付出很大代价。\n\n* 一个资源在使用一段时间后，它的被迫释放可能会造成前段工作的失效。 – 会使进程前后两次运行的信息不连续。\n* 因反复地申请和释放资源，致使进程执行被无限推迟，延长进程周转时 间、增加系统开销、降低吞吐量\n\n#### 3. 摒弃”环路等待“条件\n\n这种方法中规定，系统将所有资源按类型进行线性排队，并赋予不同的序号。 所有进程对资源的请求必须严格按照资源序号递增的次序提出，这样，在所 形成的资源分配图中，不可能再出现环路，因而摒弃了“环路等待”条件。\n\n**缺点：**\n\n1. 为系统中各类资源分配的序号必须相对稳定，这就限制了新设备类型的\n\n   增加;\n\n2. 经常发生作业使用资源的顺序与系统规定资源使用顺序不同的情况，造成资源浪费;\n\n3. 增加了程序设计难度。\n\n## 3.7 避免死锁\n\n### 3.7.1 安全状态\n\n- 所谓安全状态，是指系统能按某种进程顺序，如<P1，P2，...，Pn>，依次为n 个进程分配其所需资源，直至其最大需求，使每个进程都可顺利地完成，称 系统处于安全状态。\n- 称〈P1，P2，...，Pn〉序列为安全序列。否则，如果系统无法找到这样一个安 全序列，则称系统处于不安全状态。\n\n### 3.7.2 银行家算法\n\n避免死锁的关键在于如何准确的预测是否会出现死锁，从而避免死锁。最有 代表性的避免死锁的算法是Dijkstra的银行家算法。\n\n#### 1. 银行家算法数据结构\n\n(1)可利用资源向量Available:这是一个含有m个元素的数组，其中的每一个 元素代表一类可利用的资源数目。其数值随该类资源的分配和回收而动态地 改变。 Available[j]=k,表示系统中现有Rj类资源k个。\n\n(2)最大需求矩阵Max。这是一个n × m的矩阵，它定义了n个进程中每一个进 程对m类资源的最大需求。Max[i,j]=K，表示进程Pi需要Rj类资源的最大数目 为K。\n\n(3)分配矩阵Allocation是一个nxm矩阵，定义了系统中每一类资源当前已分配给每一进程的资源数。Allocation[i,j]=K，表示进程Pi当前已分 得Rj类资源的数目为K。\n\n(4)需求矩阵Need。这也是一个n×m的矩阵，用以表示每一个进程尚需的各 类资源数。Need[i,j]=K，表示进程Pi还需要Rj类资源K个，方能完成其任务。\n\n• 上述三个矩阵的关系:Need[i,j]=Max[i,j] - Allocation[i,j]\n\n#### 2. 银行家算法\n\n设Requesti，是进程Pi的请求向量，当Pi发出资源请求后，系统按下述步骤进行 检查:\n\n(1)如果Requesti[j]≤Need[i,j],便转向步骤2;否则认为出错，因为它所需要的 资源数已超过它所声明的最大值。\n\n(2)如果Requesti[j]≤Available[j]，便转向步(3)，否则，表示尚无足够资源， Pi须阻塞等待。\n\n(3)系统试探着把资源分配给进程Pi ，并修改下面数据结构中的数值: \n\nAvailable[j]:= Available[j] - Requesti[j]; Allocation[i,j] : = Allocation[i,j] + Requesti[j]; Need[i,j]: =Need[i,j] - Requesti[j]; \n\n(4)系统执行安全性算法，检查此次资源分配后，系统是否处于安全状态。若 安全，才正式将资源分配给进程Pi ，以完成本次分配;否则，将本次的试探 分配作废，恢复原来的资源分配状态，让进程Pi等待。 \n\n#### 3. 安全性算法\n\n系统所执行的安全性算法可描述如下:\n\n (1)设置两个向量:\n\n1工作向量Work: 它表示系统可提供给进程继续运行所需的各类资源数目，初始值Work:=Available\n\n2设置数组Finish[n]:初始值Finish[i]:=false; 当Finish[i]:=true时，进程Pi可获得其所需的全部资源，从而顺利执行完成。\n\n(2)从进程集合中找到一个能满足下述条件的进程Pi : \n\n1Finish[i]=false;  2 Need[i,j]≤work; **寻找未完成的进程，它的所需资源量小于系统可用资源量**\n\n若找到，执行步骤(3),否则，执行步骤(4)。 \n\n(3)当进程Pi获得资源后，顺利执行直至完成，并释放出分配给它的资源，故应 执行: \n\nWork:= Work+Allocation[i,j]; Finish[i] :=true;  go to step 2; \n\n(4)如果所有进程的Finish[i]=true都满足，则表示系统处于安全状态;否则， 系统处于不安全状态。 \n\n**大题出现 ppt例子**\n\n## 3.8 死锁的检测与解除\n\n### 3.8.1 死锁的检验\n\n#### 1. 死锁检测\n\n如果系统不愿意附加太多约束条件预防死锁，也不希望系统额外开销预测并避 免死锁，那么，只能允许死锁出现，然后，再解除它。\n\n• 因此，系统需要利用某种方法来检测死锁\n\n• 资源分配图 该图是由一组结点N和一组边E所组成的一个对偶G=(N,E)\n\n其中:\n\n(1)把N分为两个互斥的子集，即一组进程结点P={P1,P2，...，Pn)和一组资 源结点R={R1, R2 ，...， Rn}，N=PUR。 \n\n(2)凡属于E中的一个边e∈ E都连接着P中的一个结点和R中的一个结点 – e={Pi,Rj} \n\n它表示进程Pi请求一个单位的rj资源。 – e={Rj，Pi} \n\n它表示把一个单位的资源Rj分配给进程Pi 。 \n\n#### 2. 死锁定理\n\n![](https://img.cetacis.dev/uploads/big/a4ed842da08a8e4aa93af662aa37612d.png)\n\n#### 3. 死锁检测算法\n\n若能消去资源分配图中所有结点的连接边，使全部结点都成为孤立结点，则称 该图是可完全简化图;若不能使该图完全简化，则称该图是不可完全化简图。\n\n可以证明:当且仅当系统某状态S所对应的资源分配图是不可完全化简的，则S 是死锁状态。该充分条件称为死锁定理。\n\n#### 4.死锁检测中的数据结构 \n\n(1)可利用资源向量Available，它表示了m类资源中每一类资源的可用数目。\n\n (2)把不占用资源的进程(Allocation:=0)记入L表中，即Li U L\n\n (3)从进程集合中找到一个Requesti≤work的进程，做如下处理:\n\n1. Work:=work十Allocationi，\n\n2. 将它记入L表中。\n\n(4)若不能把所有进程都记入L表中，便表明系统状态S的资源分配图是不可 完全简化的。因此，该系统状态将发生死锁。\n\n```\n Work:= Available; \n \tL:={Li|Allocationi=0∩Requesti=0} \n \tfor all Li∈L do\n\t\tbegin\n\t\tfor all Requesti≤Work do\n\t\t\tbegin \n\t\t\t\tWork:=Work十Allocationi;\n        Li∪L;\n\t\t\tend \n\t\tend\n\tdeadlock:= (L={P1，P2，.... ，Pn});\n```\n\n### 3.8.2 死锁的解除\n\n当发现有进程死锁时，常采用的两种方法是解除死锁:\n\n (1)剥夺资源。从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态。\n\n(2)撤消进程。最简单的撤消进程的方法，是使全部死锁进程都夭折掉;或者 按照某种顺序逐个地撤消进程，直至有足够的资源可用，使死锁状态消除为\n\n止。\n\n按照解除死锁复杂度递增的顺序列出解除死锁的方法:\n1. 撤消死锁进程。该方法是目前操作系统中解除死锁的常用方法。\n2. 把死锁进程恢复到前一个检查点，重新执行每个进程。\n3. 按照某种原则逐个选择死锁进程进行撤消，直到解除系统死锁。\n4. 按照某种原则逐个剥夺进程资源，直到解除死锁。\n\n**最小代价原则**\n\n第三种和第四种方法需要选择系统付出代价最小的进程，最小代价原则: \n\n– 到目前为止，花费处理机的时间最少的进程;\n\n– 到目前为止，产生输出最少的进程;\n\n– 估计未执行部分最多的进程;\n\n– 到目前为止，已获得资源量最少的进程; – 优先级最低的进程。\n\n\n\n","slug":"操作系统-课堂笔记","published":1,"updated":"2020-04-08T00:32:09.000Z","title":"操作系统-课堂笔记","_id":"ck849ava60000thes4u0if3ql","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"2-5-经典进程同步问题\"><a href=\"#2-5-经典进程同步问题\" class=\"headerlink\" title=\"2.5 经典进程同步问题\"></a>2.5 经典进程同步问题</h2><h3 id=\"2-5-1-生产者消费者问题\"><a href=\"#2-5-1-生产者消费者问题\" class=\"headerlink\" title=\"2.5.1 生产者消费者问题\"></a>2.5.1 生产者消费者问题</h3><a id=\"more\"></a>\n<p><strong>1. 概念</strong></p>\n<ul>\n<li><p>代表一类具有相同属性的进程。</p>\n</li>\n<li><p>共享一个大小固定的缓冲区，一个或多个生产者生产数</p>\n<p>据，并将生产的数据存入缓冲区，并有一个消费者从缓冲区中取数据。</p>\n</li>\n<li><p>例如， 在输入时，输入进程是生产者，计算进程是消费者;而在输出时，则计 算进程是生产者，而打印进程是消费者。</p>\n</li>\n</ul>\n<p>分别设置两个指针in和out:<br>– in指向生产者将存放数据的存储单元 – out指向消费者将取数据的存储单元</p>\n<p><em>如果不控制生产者与消费者：生产者和消费者可能同时进入缓冲区，甚至可能同时读/写一个存储单**元，将导致执行结果不确定。</em></p>\n<p><strong>2. 解决方法1：信号量</strong></p>\n<p>互斥信号量mutex:实现诸进程对缓冲池的互斥使用; </p>\n<p>资源信号量empty:表示缓冲池中空缓冲区的数量;初始值定义为1</p>\n<p>资源信号量full:表示满缓冲区的数量; 初始值定义为0</p>\n<p>只要缓冲池未满，生产者便可将消息送入缓冲池;只要缓冲池未空，消费者便可从缓冲池中取走一个消息。</p>\n<p>生产者</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var mutex，empty，full:semaphore:&#x3D;1，n，0; </span><br><span class=\"line\">\tbuffer:array[0，...，n-1]of item; </span><br><span class=\"line\">\tin，out:integer:&#x3D;0，0;</span><br><span class=\"line\">\tbegin</span><br><span class=\"line\">\t\tparbegin </span><br><span class=\"line\">\t\t\tproceducer:begin</span><br><span class=\"line\">\t\t\t\trepeat</span><br><span class=\"line\">\t\t\t\t...</span><br><span class=\"line\">\t\t\t\tproducer an item nextp;</span><br><span class=\"line\">\t\t\t\t...</span><br><span class=\"line\">\t\t\t\twait(empty);\t当empty &#x3D;&#x3D; 1：1-1&#x3D;0 </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t当empty &#x3D;&#x3D; 0 说明缓冲区不空</span><br><span class=\"line\">\t\t\t\twait(mutex);  </span><br><span class=\"line\">\t\t\t\tbuffer(in):&#x3D;nextp; </span><br><span class=\"line\">\t\t\t\tin:&#x3D;(in+1)mod n; </span><br><span class=\"line\">\t\t\t\tsignal(mutex);释放缓冲区 </span><br><span class=\"line\">\t\t\t\tsignal(full); full代表数据个数</span><br><span class=\"line\">until false; end</span><br></pre></td></tr></table></figure>\n\n<p>消费者</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">consumer :begin </span><br><span class=\"line\">\t\t\t\t\t\trepeat</span><br><span class=\"line\">\t\t\t\t\twait (full); </span><br><span class=\"line\">\t\t\t\t\twait(mutex); 缓冲区是否有其他进程</span><br><span class=\"line\">\t\t\t\t\tnextc :&#x3D;buffer(out); </span><br><span class=\"line\">\t\t\t\t\tout:&#x3D; (out+1)mod n;</span><br><span class=\"line\">\t\t\t\t\tsignal(mutex); </span><br><span class=\"line\">\t\t\t\t\tsignal(empty);</span><br><span class=\"line\">\t\t\t\t\tconsumer the item in nextc;</span><br><span class=\"line\">\t\t\t\tuntil false; </span><br><span class=\"line\">\t\t\tend</span><br><span class=\"line\">\t\tparend </span><br><span class=\"line\">\tend</span><br></pre></td></tr></table></figure>\n\n<p><strong>3. 注意</strong></p>\n<ul>\n<li><p>先申请资源信号量，再申请互斥信号量</p>\n<p><em>资源信号量相当于你吃饭先预定个桌子如果你不预定 直接去吃饭 没桌子了你只好一直在那等了 别人吃完了桌子留给了预定的人 你没预定就得一直在那等 就是死锁了</em></p>\n<p><em>如两个进程都反过来操作，先互斥了，但是没有得到临界资源，发生死锁</em></p>\n</li>\n<li><p>对任何信号量的wait与signal操作必须配对。同一进程中的多对wait与signal语句只能嵌套，不能交叉。</p>\n</li>\n<li><p>对同一个资源信号量的wait与signal可以不在同一个进程中。</p>\n<p>– 例如，wait(empty)在计算进程中，而signal(empty)则在打印进程中，计 算进程若因执行wait(empty)而阻塞， 则以后将由打印进程将它唤醒</p>\n</li>\n<li><p>wait与signal语句不能颠倒顺序，wait语句一定先于signal语句，否则可能 引起进程死锁。</p>\n</li>\n</ul>\n<p><strong>4. 解决方法2：and信号量</strong></p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/25e90fb77f0065bee3136b76517b5f2b.png\" alt=\"and信号量（合并互斥和资源信号量）\"></p>\n<h3 id=\"2-5-2-读者和写者问题\"><a href=\"#2-5-2-读者和写者问题\" class=\"headerlink\" title=\"2.5.2 读者和写者问题\"></a>2.5.2 读者和写者问题</h3><p><strong>1. 概念</strong></p>\n<p>读者：只读不取</p>\n<p>读读不互斥，读写互斥，写写互斥。</p>\n<p><strong>2. 解决方法1：读者优先</strong></p>\n<p><strong>读者优先</strong>：一旦有读者正在读数据，允许多个读者同时进入读数据，只有 当全部读者退出，才允许写者进入写数据。</p>\n<p>可能问题：读者不断进入，写者长时间等待（饥饿）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Var rmutex, wmutex:semaphore∶ &#x3D;1,1;&#x2F;* 互斥信号量，初始化为1 *&#x2F;</span><br><span class=\"line\">\tReadcount:integer∶ &#x3D;0;; &#x2F;* 统计读者个数 *&#x2F; </span><br><span class=\"line\">\tbegin</span><br><span class=\"line\">\tparbegin</span><br><span class=\"line\">\tReader:begin </span><br><span class=\"line\">\t\trepeat</span><br><span class=\"line\">\t\twait(rmutex);# 共享变量，保证互斥</span><br><span class=\"line\">\t\tif readcount&#x3D;0 then wait(wmutex); # readcount &#x3D;&#x3D; 0 在此之前没有读者 </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t# 需要判断是否有写进程 如果有，则需要等待写进程</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t# wmutex：用于写进程互斥</span><br><span class=\"line\">\t\t\tReadcount∶ &#x3D;Readcount+1;   # 读者进程的共享变量</span><br><span class=\"line\">\t\tsignal(rmutex);</span><br><span class=\"line\">...</span><br><span class=\"line\">perform read operation;</span><br><span class=\"line\">...</span><br><span class=\"line\">\t\twait(rmutex); </span><br><span class=\"line\">\t\t\treadcount∶ &#x3D;readcount-1;</span><br><span class=\"line\">\t\t\tif readcount&#x3D;0 then signal(wmutex); # 最后一个读进程，有可能有进程在等，</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t# 判断是否需要唤醒</span><br><span class=\"line\">\t\t\tsignal(rmutex);</span><br><span class=\"line\">\t\t\tuntil false;</span><br><span class=\"line\">     end</span><br></pre></td></tr></table></figure>\n\n<p><strong>2. 解决方法2：信号量集</strong></p>\n<p>写者</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var RN integer;&#x2F;* 控制读者上限RN*&#x2F; </span><br><span class=\"line\">\tL, mx:semaphore∶ &#x3D;RN,1;</span><br><span class=\"line\">\tbegin</span><br><span class=\"line\">  \tparbegin</span><br><span class=\"line\">\t\t\treader:begin </span><br><span class=\"line\">\t\t\t\trepeat</span><br><span class=\"line\">\t\t\t\t\tswait(L,1,1);</span><br><span class=\"line\">\t\t\t\t\t&#x2F;* 每进入一个读者，L减一，控制总数RN个*&#x2F; </span><br><span class=\"line\">\t\t\t\t\tswait(mx,1,0);</span><br><span class=\"line\">\t\t\t\t\t&#x2F;* 开关，mx&#x3D;1标识无writer进程写*&#x2F;</span><br><span class=\"line\">...</span><br><span class=\"line\">\t\t\t\t\tperform read operation; </span><br><span class=\"line\">\t\t\t\t\t...</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://img.cetacis.dev/uploads/big/7710f66ad00fa7588b9bc758f3803f08.png\" alt=\"\"></p>\n<h3 id=\"2-5-3-哲学家就餐问题\"><a href=\"#2-5-3-哲学家就餐问题\" class=\"headerlink\" title=\"2.5.3 哲学家就餐问题\"></a>2.5.3 哲学家就餐问题</h3><p><strong>1. 问题描述</strong></p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/7e7c738894e76900b2d180fcf1e9e43b.png\" alt=\"哲学家问题\"></p>\n<p>经分析可知，放在桌子上的筷子是临界资源，在一段时间内只允许一位哲学 家使用。为了实现对筷子的互斥使用，可以用一个信号量表示一只筷子，由</p>\n<p>这五个信号量构成信号量数组。其描述如下: • Var chopstick: array[0, …, 4] of semaphore;</p>\n<p><strong>2. 解决方式1：信号量</strong></p>\n<ul>\n<li>每个筷子一个初值为1的信号量 </li>\n<li>每个哲学家是一个进程</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Var Chopstick;array [0,4]of semaphore; </span><br><span class=\"line\"> 第i个进程描述为(i&#x3D;0,... ,4)</span><br><span class=\"line\">repeat</span><br><span class=\"line\">\twait(chopstick[i]);取左筷子; </span><br><span class=\"line\">\twait(chopstick[(i+1)mod 5]);取右筷子; </span><br><span class=\"line\">\teat;</span><br><span class=\"line\">\tsignal(chopstick[i]);放左筷子</span><br><span class=\"line\">\tsignal (Chopstick[(i+1)mod 5];放右筷子; </span><br><span class=\"line\">\tthink;</span><br><span class=\"line\">until false;</span><br><span class=\"line\">(这可能导致死锁：只要相邻的两个人同时拿起左筷子就会发生死锁</span><br></pre></td></tr></table></figure>\n\n<p><em>对wait/signal的理解</em></p>\n<p><em>wait ：在取用一个资源时是否需要wait</em></p>\n<p><em>signal： 在放置一个资源时，设置此资源可获取</em></p>\n<p><strong>3. 解决方式2：and信号量（解决死锁</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Var chopsiick array [0, ..., 4] of semaphore∶ &#x3D;(1,1,1,1,1); </span><br><span class=\"line\">\tprocessi</span><br><span class=\"line\">\t\trepeat</span><br><span class=\"line\">\t\t\tthink;</span><br><span class=\"line\">\t\t\tsswait(chopstick[(i+1) mod 5], chopstick [i]); </span><br><span class=\"line\">\t\t\teat;</span><br><span class=\"line\">\t\t\tssignat(chopstick [(i+1) mod 5], chopstick [i]);</span><br><span class=\"line\">\t\tuntil false;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-5-4-互斥与同步解决方法之四-管程\"><a href=\"#2-5-4-互斥与同步解决方法之四-管程\" class=\"headerlink\" title=\"2.5.4 互斥与同步解决方法之四 : 管程\"></a>2.5.4 互斥与同步解决方法之四 : 管程</h3><p><strong>1. 概念</strong></p>\n<ul>\n<li><p>出现原因：每个要访问临界资源的进程都必须自备<strong>同步操作</strong>wait(S)和signal(s)。这就使大量的同步操作分散在各个进程中。这不仅给系统的管理带来了麻烦，而且还会因同步操作的使用不当而导致系统死锁。</p>\n</li>\n<li><p>定义：将资源访问的同步，资源本身进行封装为一个“class”。同时，只能有一个“class”访问这个数据。Hansan为管程所下的定义是:“一个管程定义了一个数据结构和能为并发进程所执行(在该数据结构上)的一组操作，这组操作能同步进程和改变管程 中的数据”。</p>\n</li>\n<li><p>互斥保证：操作系统- 任何时刻，只能有一个进程在管程中运行</p>\n</li>\n<li><p>组成：1 局部于管程的共享变量说明;</p>\n<p>​            2 对该数据结构进行操作的一组过程</p>\n<p>​            3 对局部于管程的数据设置初始值的语句。 </p>\n<p>​            4 管程的名称</p>\n</li>\n</ul>\n<p><strong>2. 对生产者消费者问题的解决</strong></p>\n<p>在利用管程方法来解决生产者-消费者问题时， 首先便是为它们建立一个管程，并命名为Proclucer-Consumer, 或简称为PC。其中包括两个过程: </p>\n<p>(1)put(item)过程。 生产者利用该过程将自己生产的产品投放到缓冲池中，</p>\n<p>并用整型变量count来表示在缓冲池中已有的产品数目，当count≥n时，表示 缓冲池已满，生产者须等待。<br>(2) get(item)过程。消费者利用该过程从缓冲池中取出一个产品，当count≤0 时，表示缓冲池中已无可取用的产品， 消费者应等待。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">producer:begin </span><br><span class=\"line\">\trepeat</span><br><span class=\"line\">\t\tproduce an item in nextp;</span><br><span class=\"line\">\t\tPC.put(item); </span><br><span class=\"line\">\t\tuntil false;</span><br><span class=\"line\">\tend # 生产者进程</span><br><span class=\"line\">consumer:begin</span><br><span class=\"line\">\trepeat</span><br><span class=\"line\">\t\tPC.get(item);</span><br><span class=\"line\">\t\tconsume the item in nextc;</span><br><span class=\"line\">\t\tuntil false; </span><br><span class=\"line\">\tend # 消费者进程</span><br></pre></td></tr></table></figure>\n\n<p>将所有功能封装在<strong>PC</strong>这个“类”中，直接调用。</p>\n<h2 id=\"2-6-进程通信\"><a href=\"#2-6-进程通信\" class=\"headerlink\" title=\"2.6 进程通信\"></a>2.6 进程通信</h2><p><strong>概念：</strong>当进程进行通信合作时，各个进程之间需要建立连接，进程通信需要同步和协调。</p>\n<p>通讯类型：控制信息（低级）数据（高级）</p>\n<p>进程之间同步与互斥是一种低级通信,用来控制进程执行速度。</p>\n<p>– 效率低<br>– 通信对用户不透明</p>\n<h3 id=\"通信机制1-基于共享存储区方式\"><a href=\"#通信机制1-基于共享存储区方式\" class=\"headerlink\" title=\"通信机制1 基于共享存储区方式\"></a>通信机制1 基于共享存储区方式</h3><ol>\n<li><p>通过程序设计来实现。程序员设计程序时，利用程序指令设置共享数据结构， 并处理通信进程之间的同步等问题，操作系统只需提供共享存储区。</p>\n</li>\n<li><p>由操作系统在内存中划分出一块区域作为共享存储区。</p>\n</li>\n</ol>\n<p>– 进程在通信前向系统申请共享存储区中的一个分区。</p>\n<p>– 然后，申请进程把获得的共享存储分区连接到本进程上，此后便可象读/写 普通存储器一样地读/写共享存储分区。</p>\n<p>– 该方式下，通信进程之间的同步与互斥访问共享存储区可以由操作系统实 现。</p>\n<h3 id=\"通信机制2-管道通信\"><a href=\"#通信机制2-管道通信\" class=\"headerlink\" title=\"通信机制2 管道通信\"></a>通信机制2 管道通信</h3><ul>\n<li>所谓“管道”，是指用于连接一个读进程和一个写进程以实现他们之间通信 的一个共享文件，又名pipe文件。</li>\n<li>向管道(共享文件)提供输入的发送进程(即写进程)， 以字符流形式将大量的数 据送入管道;</li>\n<li>而接受管道输出的接收进程(即读进程)，则从管道中接收(读)数据。由于发送 进程和接收进程是利用管道进行通信的，故又称为管道通信。</li>\n<li>这种方式首创于UNIX系统，由于它能有效地传送大量数据，因而又被引入到 许多其它操作系统中。</li>\n</ul>\n<p>*<em>有名管道  *</em>：通过文件的读写（遵循FIFO原则</p>\n<p><strong>无名管道</strong>：内存</p>\n<h3 id=\"通信机制3-信息传递方式\"><a href=\"#通信机制3-信息传递方式\" class=\"headerlink\" title=\"通信机制3 信息传递方式\"></a>通信机制3 信息传递方式</h3><p>比如网络信息的传递，本机的进程与远端服务器链接并且传递。</p>\n<p>进程间的数据交换，是以格式化的消息(message)为单位的(计算机网络称为报文)</p>\n<h2 id=\"2-7-线程\"><a href=\"#2-7-线程\" class=\"headerlink\" title=\"2.7 线程\"></a>2.7 线程</h2><p>线程是一种比进程更小的独立运行单位：线程（threads） 可以比进程更好地提高程序的并行执行程度，并且提高系统的吞吐量。</p>\n<h3 id=\"2-7-1-线程的引入\"><a href=\"#2-7-1-线程的引入\" class=\"headerlink\" title=\"2.7.1 线程的引入\"></a>2.7.1 线程的引入</h3><p>进程特点：</p>\n<ul>\n<li><p>资源所有权:一个进程包括一个保存进程映像的虚地址空间，并且随时分配对。资源的的控制或所有权，包括内存、I/O通道、I/O设备、文件等。</p>\n<p>资源：处理机，io</p>\n</li>\n<li><p>调度/执行:进程是被操作系统调度的实体。</p>\n</li>\n</ul>\n<p>为区分这两个特点，调度并分派的部分通常称为线程或轻便进程(lightweight process)，而资源所有权的部分通常称为进程。</p>\n<h4 id=\"线程的属性：\"><a href=\"#线程的属性：\" class=\"headerlink\" title=\"线程的属性：\"></a>线程的属性：</h4><p>(1) 线程是一个被调度和分派的基本单位，并可独立运行的实体。大多数与 执行相关的信息可以保存在线程级的数据结构中;</p>\n<p>(2)线程是可以并发执行; (3)共享进程资源。</p>\n<p>(4)线程是轻型实体，在切换时只需保存少量寄存器的内容，不涉及存储器的 管理等，因此系统开销小。</p>\n<p>(5)进程中的所有线程共享同一个地址空间，挂起进程则会挂起进程中的所有 线程。类似地，进程的终止会导致进程中所有线程的终止。</p>\n<h4 id=\"线程优点\"><a href=\"#线程优点\" class=\"headerlink\" title=\"线程优点\"></a>线程优点</h4><ol>\n<li>在一个已有进程中创建一个新线程比创建一个全新进程所需的时间少。 </li>\n<li>终止一个线程比终止一个进程花费的时间少。 </li>\n<li>线程间切换比进程间切换花费的时间少。</li>\n<li>线程提高了不同的执行程序间通信的效率。同一个进程中的线程共享存储空 间和文件，它们无需调用内核就可以互相通信。</li>\n</ol>\n<h3 id=\"2-7-2-线程进程比较\"><a href=\"#2-7-2-线程进程比较\" class=\"headerlink\" title=\"2.7.2 线程进程比较\"></a>2.7.2 线程进程比较</h3><p>1、调度的基本单位 2、并发性 3、拥有资源 4、独立性 5、系统开销 6、支持多处理机</p>\n<h3 id=\"线程状态和线程控制块\"><a href=\"#线程状态和线程控制块\" class=\"headerlink\" title=\"线程状态和线程控制块\"></a>线程状态和线程控制块</h3><p>*<em>线程的状态有: *</em></p>\n<p>运行状态、就绪状态、阻塞状态等。</p>\n<p><strong>在线程切换时保存的线程信息:</strong></p>\n<p>1 一个执行栈。<br>2 每个线程静态存储局部变量。 3对存储器和其进程资源的访问，并与该进程中的其他线程共享这些资源。如:寄存器状态、堆栈、线程运行状态、 优先级、线程专有存储器、信 号屏蔽等</p>\n<h4 id=\"线程状态变化的4种基本操作\"><a href=\"#线程状态变化的4种基本操作\" class=\"headerlink\" title=\"线程状态变化的4种基本操作\"></a>线程状态变化的4种基本操作</h4><p>1派生(Spawn):当产生一个新进程时，同时也为该进程派生了一个“初始化 线程”，随后，可以在同一个进程中派生另一个线程，新线程被放置在就绪队列中。</p>\n<p>2阻塞(Block):当线程需要等待一个事件时，它将阻塞，此时处理器转而执 行另一个就绪线程。</p>\n<p>3解除阻塞(Unblock):当阻塞一个线程的事件发生时，该线程被转移到就绪 队列中。</p>\n<p>4结束(Finish):当一个线程完成时，其寄存器的信息和栈都被释放。</p>\n<h3 id=\"2-6-3-线程的分类\"><a href=\"#2-6-3-线程的分类\" class=\"headerlink\" title=\"2.6.3 线程的分类\"></a>2.6.3 线程的分类</h3><ol>\n<li>内核</li>\n<li>用户空间 （同时，用户层也可有资源所有权，线程在此层对进程直接进行调度</li>\n</ol>\n<h1 id=\"第三章-处理机与死锁\"><a href=\"#第三章-处理机与死锁\" class=\"headerlink\" title=\"第三章 处理机与死锁\"></a>第三章 处理机与死锁</h1><p>多到程序环境进程数目多于处理机数，处理机是十分重要的资源，如何分配尤为重要，它是由调度程序完成的，需要优秀的调度方法。</p>\n<p>调度需要解决的问题：1. 调度算法 2. 何时分配 3. 调度过程及其进程 的上下文切换</p>\n<h2 id=\"3-1-处理机调度的层次和调度算法目标\"><a href=\"#3-1-处理机调度的层次和调度算法目标\" class=\"headerlink\" title=\"3.1 处理机调度的层次和调度算法目标\"></a>3.1 处理机调度的层次和调度算法目标</h2><p>调度对象</p>\n<ul>\n<li>作业（job） 程序、数据、作业说明书</li>\n</ul>\n<h3 id=\"3-1-1-处理机调度的层次\"><a href=\"#3-1-1-处理机调度的层次\" class=\"headerlink\" title=\"3.1.1 处理机调度的层次\"></a>3.1.1 处理机调度的层次</h3><ol>\n<li><p>高级调度 </p>\n<p>作业调度或长程调度:用于决定把外存上处于后备队列中的哪些作业调入内存，并为它们创建进程、分配必要的资源，然后，再将新创建的进程排在就 绪队列上，准备执行 。</p>\n</li>\n<li><p>低级调度</p>\n<p>进程调度或短程调度:用来决定就绪队列中的哪个进程(或内核级线程) 应获得处理机，然后再由分派程序把处理机分配给该进程的具体操作。</p>\n</li>\n<li><p>中级调度</p>\n<p>目的：提高内存利用率和系统吞吐量。就绪状态–挂起状态 当系统负载过重，<em>将进程挂起到外存的专<em>用</em>区域</em></p>\n</li>\n</ol>\n<h4 id=\"1-高级调度\"><a href=\"#1-高级调度\" class=\"headerlink\" title=\"1. 高级调度\"></a>1. 高级调度</h4><p>作业调度或长程调度:用于决定把外存上处于后备队列中的哪些作业调入内存，并为它们创建进程、分配必要的资源，然后，再将新创建的进程排在就 绪队列上，准备执行 。</p>\n<ul>\n<li>接受作业数量：取决于多到程序度允许多少作业同时在内存运行</li>\n<li>接纳那些作业：取决于调度算法 （先入先出、短作业优先、基于作业优先权、相应比高者优先</li>\n</ul>\n<p><strong>阶段与状态：</strong></p>\n<p>收容运行段（后备状态）</p>\n<p>运行阶段（运行状态）</p>\n<p>完成阶段（完成状态）</p>\n<h4 id=\"2-低级调度\"><a href=\"#2-低级调度\" class=\"headerlink\" title=\"2. 低级调度\"></a>2. 低级调度</h4><p><strong>进程调度的主要任务</strong></p>\n<p>– 保存处理机的现场信息到进程PCB中，如:程序计数器、通用寄存器等<br>– 按某种算法选取进程，如优先级算法、轮转法等<br>– 由分派程序(Dispatcher)把处理器分配给进程，恢复进程处理机现场</p>\n<p><strong>进程调度机制的三个部分</strong></p>\n<p>– 排队器 对首进程即将要被调用的进程</p>\n<p>– 分派器 (分派程序) 将cpu分配</p>\n<p>– 上下文切换器 (两对)</p>\n<p>当前进程-&gt;分派程序-&gt;新进程</p>\n<p><strong>调度方式</strong></p>\n<ul>\n<li><p>非抢占式</p>\n<ol>\n<li><p>正在执行的进程执行完毕，或因发生某事件而不能再继续执(包括:当前执行进程被中断、挂起自己、退出等)</p>\n</li>\n<li><p>执行中的进程因提出I/O请求而暂停执行;</p>\n</li>\n<li><p>在进程通信或同步过程中执行了某种原语操作，如P操作原语，Block原语， Wakeup原语等。</p>\n</li>\n</ol>\n</li>\n<li><p>抢占式</p>\n<p>抢占原则： 优先权原则。短作业(进程)优先原则。时间片原则。</p>\n<p>优缺点：优点 满足对响应时间严格的实时任务 缺点 调度开销大</p>\n</li>\n</ul>\n<h4 id=\"3-中级调度\"><a href=\"#3-中级调度\" class=\"headerlink\" title=\"3. 中级调度\"></a>3. 中级调度</h4><p>目的：提高内存利用率和系统吞吐量。</p>\n<p><strong>挂起状态：</strong>使那些暂时不能运行的进程不再占用内存资源，而将它们调至外存上去等待。</p>\n<p>程序重又具备运行条件、且内存又稍有空闲时，由中级调度来决定把 外存上的哪些又具备运行条件的就绪进程，重新调入内存，并修改其状态为 就绪状态。</p>\n<h4 id=\"4-调度队列模型和调度准则\"><a href=\"#4-调度队列模型和调度准则\" class=\"headerlink\" title=\"4. 调度队列模型和调度准则\"></a>4. 调度队列模型和调度准则</h4><ol>\n<li>仅有进程调度的调度队列模型</li>\n</ol>\n<p><img src=\"https://img.cetacis.dev/uploads/big/a2f70281a16a73945aab3c237bd18ec3.png\" alt=\"\"></p>\n<ol start=\"2\">\n<li>有高级和低级调度的调度队列模型</li>\n</ol>\n<p><img src=\"https://img.cetacis.dev/uploads/big/9c92d3574c203412fcf950aa64936c72.png\" alt=\"\"></p>\n<ol start=\"3\">\n<li>同时具有三级调度的调度队列模型</li>\n</ol>\n<p><img src=\"https://img.cetacis.dev/uploads/big/b626a71c9dbaecdccd485b19c9fe8cb6.png\" alt=\"\"></p>\n<h3 id=\"3-1-2-处理机调度算法目标\"><a href=\"#3-1-2-处理机调度算法目标\" class=\"headerlink\" title=\"3.1.2 处理机调度算法目标\"></a>3.1.2 处理机调度算法目标</h3><h4 id=\"1-共同目标\"><a href=\"#1-共同目标\" class=\"headerlink\" title=\"1. 共同目标\"></a>1. 共同目标</h4><p><strong>资源利用率</strong> 最重要</p>\n<p><strong>公平性</strong> 合理cpu时间 合理不仅仅在于先入先出，而在于很多原则，比如优先权原则，短进程原则。</p>\n<p><strong>平衡性</strong> 保持各种cpu的系统资源使用平衡性</p>\n<p>策略强制执行</p>\n<h4 id=\"2-批处理系统目标\"><a href=\"#2-批处理系统目标\" class=\"headerlink\" title=\"2. 批处理系统目标\"></a>2. 批处理系统目标</h4><p><img src=\"https://img.cetacis.dev/uploads/big/47dcfdb60f8ab8ca9616e37659a6b8a2.png\" alt=\"\"></p>\n<p>平均周转时间求和即全部的周转时间</p>\n<p>平均带权周转时间求和是 周转时间/服务时间</p>\n<h4 id=\"3-分时系统目标\"><a href=\"#3-分时系统目标\" class=\"headerlink\" title=\"3. 分时系统目标\"></a>3. 分时系统目标</h4><ol>\n<li><p>响应时间快 用户体验好</p>\n</li>\n<li><p>均衡性 系统响应时间快慢与用户所请求服务的复杂性相适应</p>\n</li>\n</ol>\n<h4 id=\"4-实时系统的目标\"><a href=\"#4-实时系统的目标\" class=\"headerlink\" title=\"4. 实时系统的目标\"></a>4. 实时系统的目标</h4><ol>\n<li><strong>截止时间的保证</strong> 截止时间指任务必须开始执行或者必须完成的时间。实时系统调度算法的一个重要目标是保证实时任务对截止时间的要求。</li>\n<li>可预测性</li>\n</ol>\n<h2 id=\"3-3-调度算法\"><a href=\"#3-3-调度算法\" class=\"headerlink\" title=\"3.3 调度算法\"></a>3.3 调度算法</h2><p>调度算法：根据系统的资源分配策略所规定的资源分配算法。对于不同 的系统目标，通常采用不同的调度算法。</p>\n<p>1.先来先服务(FCFS) 2.短作业(短进程)优先(SJF) 3.时间片轮转(RR) 4.基于优先级的调度算法 5.剩余时间最短者优先 6.高响应比优先调度算法 7.多级反馈队列调度法</p>\n<p><em>有利于否在于带权周转时间的长短</em></p>\n<p>周转时间 = 完成时间 - 到达时间</p>\n<p>带权周转时间 = 周转时间 / 服务时间</p>\n<h3 id=\"3-3-1先来先服务\"><a href=\"#3-3-1先来先服务\" class=\"headerlink\" title=\"3.3.1先来先服务\"></a>3.3.1先来先服务</h3><p>有利于长作业不利于短作业（短作业可能会等待较长时间才能得到短时服务）</p>\n<p>非抢占式调度（批处理</p>\n<h3 id=\"3-3-2-短作业优先（短作业即服务时间短）\"><a href=\"#3-3-2-短作业优先（短作业即服务时间短）\" class=\"headerlink\" title=\"3.3.2 短作业优先（短作业即服务时间短）\"></a>3.3.2 短作业优先（短作业即服务时间短）</h3><p>首先从就绪队列调度估计时间最短的作业 </p>\n<p>有利于短作业不利于长作业（所有短作业完成以后长作业才可能开始，甚至可能导致长作业长期不被调度）</p>\n<p>非抢占式调度（批处理</p>\n<p>缺点：1. 有利于短作业不利于长作业 2. 非抢占式调度 3. 对于长短估计不一定准确，不能选到最短的</p>\n<h3 id=\"3-3-3-基于优先级的调度算法\"><a href=\"#3-3-3-基于优先级的调度算法\" class=\"headerlink\" title=\"3.3.3 基于优先级的调度算法\"></a>3.3.3 基于优先级的调度算法</h3><p>把处理机分配给就绪队列中优先级最高的进程</p>\n<p><strong>两种类型</strong>：非抢占式优先权算法   抢占式优先权调度算法</p>\n<h4 id=\"1-非抢占优先权算法\"><a href=\"#1-非抢占优先权算法\" class=\"headerlink\" title=\"1. 非抢占优先权算法\"></a>1. 非抢占优先权算法</h4><p>系统一旦把处理机分配给就绪队列中优先权最高的进程后， 该进程便一直执行下去，直至完成;或因发生某事件使该进程放弃处理机时， 系统方可再将处理机重新分配给另一优先权最高的进程。</p>\n<h4 id=\"2-抢占式优先权调度算法\"><a href=\"#2-抢占式优先权调度算法\" class=\"headerlink\" title=\"2. 抢占式优先权调度算法\"></a>2. 抢占式优先权调度算法</h4><p> 在其执行期间，只要又出现了另一个其优先权更高的进程，进程调度程序就 立即停止当前进程的执行，重新将处理机分配给新到的优先权最高的进程。</p>\n<p><strong>特点</strong>：能更好地满足紧迫作业的要求，故而常用于要求比较严格的实时系统中，以及对性能要求较高的批处理和分时系统中。</p>\n<h4 id=\"3-优先权的类型\"><a href=\"#3-优先权的类型\" class=\"headerlink\" title=\"3. 优先权的类型\"></a>3. 优先权的类型</h4><p><strong>静态优先权</strong>：在创建进程时确定的，且在进程的整个运行期间保持不变。</p>\n<p><strong>动态优先权</strong>：在创建进程时所赋予的优先权，是可以随进程的推进或随 其等待时间的增加而改变的，以便获得更好的调度性能。</p>\n<p><strong>确定进程优先权的依据有三个方面</strong>：</p>\n<p>(1)进程类型。<br>– 系统进程的优先权高于一般用户进程的优先权。</p>\n<p>(2)进程对资源的需求。<br>– 对执行时间和内存要求少的进程应赋予较高的优先权。</p>\n<p>(3)用户要求。<br>– 按照各进程的执行流程和进程的紧迫程度来指定进程的优先权。</p>\n<h4 id=\"4-高响应比-优先-调度算法\"><a href=\"#4-高响应比-优先-调度算法\" class=\"headerlink\" title=\"4. 高响应比 优先 调度算法\"></a>4. 高响应比 优先 调度算法</h4><p>响应比 Rp = 1 + 等待时间/要求服务时间 = 响应时间 / 要求服务时间 = （等待时间+要求服务时间）/要求服务时间</p>\n<p>即：要求服务时间越短，等待时间越长，响应比越大。</p>\n<p>分析：</p>\n<p>（1）时间同，越短优先权越高，<strong>有利于短作业</strong></p>\n<p>（2）实现的是先来先服务</p>\n<p>（3）对于长作业，也可以由等待时间的增加而提高，防止长作业无法被调度。</p>\n<ul>\n<li><p>优点 ： 该算法既照顾了短作业，又考虑了作业到达的先后次序，同时不会使 长作业长期得不到服务。</p>\n</li>\n<li><p>缺点： 利用该算法时，每次调度之前，都须先做响应比的计算，会增加系统 开销。</p>\n</li>\n</ul>\n<h3 id=\"3-3-4-时间片轮转调度费RR\"><a href=\"#3-3-4-时间片轮转调度费RR\" class=\"headerlink\" title=\"3.3.4 时间片轮转调度费RR\"></a>3.3.4 时间片轮转调度费RR</h3><h4 id=\"1-RR\"><a href=\"#1-RR\" class=\"headerlink\" title=\"1. RR\"></a>1. RR</h4><p>系统将所有的就绪进程按先来先服务的原则，排成一个 队列，每次调度时，把CPU分配给队首进程，并令执行一个时间片。当执行的时间片用完时，由一个计时器发出时钟中断请求， 调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾;</p>\n<p>切换情况： 时间片用完；时间片没有用完，但是进程执行错误/错误。</p>\n<p>特点：系统能在给定的时间内，响应所有用户的请求。</p>\n<p>时间片大小会影响计算机性能：短时间片有利于短作业，使其较快完成，但会频繁发生中断、进程上下文切换，增加系统开销;</p>\n<p>对于短的、计算型进程比较有利，因为该进程充分利用时间片，而I/O型进程 却不利，因为在两次I/O之间仅需很少的CPU时间，却需要等待一个时间片。</p>\n<p>常用于分时系统及事务处理系统。</p>\n<h4 id=\"2-多级反馈队列调度法（抢占式调度算法\"><a href=\"#2-多级反馈队列调度法（抢占式调度算法\" class=\"headerlink\" title=\"2. 多级反馈队列调度法（抢占式调度算法\"></a>2. 多级反馈队列调度法（抢占式调度算法</h4><ul>\n<li><p>设置多个继续队列，每个队列有不同的优先级。赋予不用队列的时间片的大小也各不相同。优先级高，时间片小。优先级低，时间片大。第一个队列往后，优先级逐渐降低。</p>\n</li>\n<li><p>当一个新进程进入内存后，首先将它放入第一队列的末尾，按FCFS原则排 队等待调度。</p>\n<p>– 当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统;<br>– 如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的</p>\n<p>末尾，再同样地按FCFS原则等待调度执行;<br>– 如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队</p>\n<p>列，……<br>– 当进程最后被降到第n队列后，在第n队列中按RR方式调度</p>\n</li>\n<li><p>当第一队列空闲，才调度第二队列中的进程运行。当1-（i-1）空闲，i队列才会运行。</p>\n<p>当新进程进入后，会抢占二/三队列的cpu。将正在运行的进程放回i队列末尾。</p>\n</li>\n</ul>\n<p>性能：</p>\n<p>(1)终端型作业用户。</p>\n<p>能在第一队列所规定的时间片内完成，可使终端型作业用户都感到满意。</p>\n<p>(2)对短作业用户有利。</p>\n<p>(3)长批处理作业用户。对于长作业，它将依次在第1，2,…，n个队列中运行， 然后再按轮转方式运行，用户不必担心其作业长期得不到处理。</p>\n<h2 id=\"3-4-实时系统与实时任务调度\"><a href=\"#3-4-实时系统与实时任务调度\" class=\"headerlink\" title=\"3.4 实时系统与实时任务调度\"></a>3.4 实时系统与实时任务调度</h2><p>由于在实时系统中都存在着若干个实时进程或任务，<br>– 实时进程通常带有某种程度的紧迫性<br>– 需要引入一种新的调度解决实时进程的调度，即实时调度。</p>\n<h3 id=\"3-4-1-实现实时调度系统的基本条件\"><a href=\"#3-4-1-实现实时调度系统的基本条件\" class=\"headerlink\" title=\"3.4.1 实现实时调度系统的基本条件\"></a>3.4.1 实现实时调度系统的基本条件</h3><h4 id=\"1-提供必要的信息\"><a href=\"#1-提供必要的信息\" class=\"headerlink\" title=\"1. 提供必要的信息\"></a>1. 提供必要的信息</h4><p>(1)就绪时间。 (2)开始截止时间或完成截止时间。 (3)处理时间。</p>\n<p>(4)资源要求。 (5)优先级。</p>\n<h4 id=\"2-系统处理能力强\"><a href=\"#2-系统处理能力强\" class=\"headerlink\" title=\"2. 系统处理能力强\"></a>2. 系统处理能力强</h4><p>在实时系统中，通常都有着多个实时任务。若处理机的处理能力不够强，则有 可能因处理机忙不过来而使某些实时任务不能得到及时处理。</p>\n<p>解决的方法是提高系统的处理能力，其途径有:</p>\n<ul>\n<li>对单处理机系统，增强其处理能力，以此显著地减少对每一个任务的处理时间;</li>\n<li>其二是采用多处理机系统。</li>\n</ul>\n<h4 id=\"3-采用抢占式调动机制\"><a href=\"#3-采用抢占式调动机制\" class=\"headerlink\" title=\"3. 采用抢占式调动机制\"></a>3. 采用抢占式调动机制</h4><p>在含有硬实时任务的实时系统中，广泛采用抢占机制。当一个优先权更高 的任务到达时，允许暂停当前任务，而令高优先权任务立即投入运行，这 样便可满足该硬实时任务对截止时间的要求。</p>\n<h4 id=\"4-具有快速切换机制\"><a href=\"#4-具有快速切换机制\" class=\"headerlink\" title=\"4. 具有快速切换机制\"></a>4. 具有快速切换机制</h4><p>（1）对外部中断的快速响应能力。</p>\n<p>（2）快速的任务分派能力。</p>\n<h3 id=\"3-4-2-实时调度算法的分类\"><a href=\"#3-4-2-实时调度算法的分类\" class=\"headerlink\" title=\"3.4.2 实时调度算法的分类\"></a>3.4.2 实时调度算法的分类</h3><p><img src=\"https://img.cetacis.dev/uploads/big/04eae4dfeee38b3ff3a71670585f7df6.png\" alt=\"实时调度算法的分类\"></p>\n<h3 id=\"3-4-3-常用的几种实时调度算法\"><a href=\"#3-4-3-常用的几种实时调度算法\" class=\"headerlink\" title=\"3.4.3 常用的几种实时调度算法\"></a>3.4.3 常用的几种实时调度算法</h3><h4 id=\"1-最早截止时间优先算法-EDF\"><a href=\"#1-最早截止时间优先算法-EDF\" class=\"headerlink\" title=\"1. 最早截止时间优先算法(EDF)\"></a>1. 最早截止时间优先算法(EDF)</h4><ul>\n<li>按照截止时间排序</li>\n<li>如果新进程截止时间早于当前进程截止时间，则进行抢占。</li>\n</ul>\n<h4 id=\"2-最低松弛度优先算法-LLF\"><a href=\"#2-最低松弛度优先算法-LLF\" class=\"headerlink\" title=\"2. 最低松弛度优先算法(LLF)\"></a>2. 最低松弛度优先算法(LLF)</h4><p>松弛度=完成截至时间–剩余运行时间–当前时间</p>\n<p>略</p>\n<h2 id=\"3-5-死锁概述\"><a href=\"#3-5-死锁概述\" class=\"headerlink\" title=\"3.5 死锁概述\"></a>3.5 死锁概述</h2><p><strong>死锁(Deadlock)</strong>：是指多个进程在运行过程中因争夺资源而造成的一 种僵局。必须由外力解决。</p>\n<h3 id=\"3-5-1-死锁原因\"><a href=\"#3-5-1-死锁原因\" class=\"headerlink\" title=\"3.5.1 死锁原因\"></a>3.5.1 死锁原因</h3><p>（1）资源竞争</p>\n<p>（2）进程间推进顺序非法</p>\n<h4 id=\"1-竞争资源\"><a href=\"#1-竞争资源\" class=\"headerlink\" title=\"1.  竞争资源\"></a>1.  竞争资源</h4><p>1) 可剥夺和非剥夺性资源</p>\n<ul>\n<li>可剥夺性资源: 是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺。如:处理机、内存等</li>\n<li>非剥夺性资源: 当系统把这类资源分配给某进程后，再不能强行收回，只能 在进程用完后自行释放。如打印机等</li>\n</ul>\n<p>2) 竞争非剥夺性资源</p>\n<ul>\n<li><p>在系统中所配置的非剥夺性资源，由于它们的数量不能满足诸进程运行的 需要，会使进程在运行过程中，因争夺这些资源而陷入僵局。 </p>\n</li>\n<li><p>例如，系统中只有一台打印机R1和一台磁带机R2，可供进程P1和P2共享。 处理不好，在P1与P2之间会形成僵局，引起死锁。 P1先R1后R2，P2先R2后R1，可能会死锁。</p>\n</li>\n</ul>\n<p>3)竞争临时性资源</p>\n<p>• 临时性资源，可以创造(生产)和撤消(消耗)的资源，也称之为消耗性资源，它也可能引起死锁。 </p>\n<p>• 如信号量、消息、buffer中的数据等资源。 </p>\n<p>• 例如:S1、S2和S3是临时性资源，是由进程P1、P2和P3产生的消息。如果 消息通信处理顺序不当也会发生死锁。 </p>\n<h4 id=\"2-进程推进顺序不当引起死锁\"><a href=\"#2-进程推进顺序不当引起死锁\" class=\"headerlink\" title=\"2. 进程推进顺序不当引起死锁\"></a>2. 进程推进顺序不当引起死锁</h4><h3 id=\"3-5-2-死锁必要条件\"><a href=\"#3-5-2-死锁必要条件\" class=\"headerlink\" title=\"3.5.2 死锁必要条件\"></a>3.5.2 死锁必要条件</h3><p>(1)互斥条件 : 指进程对所分配到的资源进行排它性使用 。</p>\n<p>(2)请求和保持条件 : 指进程已经保持了至少一个资源，但又提出了新的资源 请求 。</p>\n<p>(3)不剥夺条件 : 指进程已获得的资源，在未使用完之前，不能被剥夺，只能 在使用完时由自己释放。</p>\n<p>(4)环路等待条件 : 指在发生死锁时，必然存在一个进程——资源的环形链 。</p>\n<h3 id=\"3-5-3-解决死锁概述\"><a href=\"#3-5-3-解决死锁概述\" class=\"headerlink\" title=\"3.5.3 解决死锁概述\"></a>3.5.3 解决死锁概述</h3><p>(1)预防死锁:是通过设置某些限制条件，去破坏产生死锁的四个必要条件中 的一个或几个条件，来预防发生死锁。</p>\n<p>(2)避免死锁:是在资源的动态分配过程中，用某种方法去防止系统进入不安 全状态，从而避免发生死锁。</p>\n<p>(3)检测死锁:通过系统所设置的检测机构，及时地检测出死锁的发生，并精 确地确定与死锁有关的进程和资源;</p>\n<p>(4)解除死锁:当检测到系统中已发生死锁时，须将进程从死锁状态中解脱出 来。常用的实施方法是撤消或挂起一些进程。</p>\n<h2 id=\"3-6-预防死锁\"><a href=\"#3-6-预防死锁\" class=\"headerlink\" title=\"3.6 预防死锁\"></a>3.6 预防死锁</h2><h4 id=\"1-破坏“请求保持”条件\"><a href=\"#1-破坏“请求保持”条件\" class=\"headerlink\" title=\"1. 破坏“请求保持”条件\"></a>1. 破坏“请求保持”条件</h4><p>系统规定所有进程在开始运行之前，都必须一次性地申请其在整个运行过程 所需的全部资源。</p>\n<p>从而进程在整个运行期间，便不会再提出资源要求，从而摒弃了请求和保持 条件，由此可以避免发生死锁。</p>\n<p> 优点:简单、易于实现且很安全。<br> 缺点:资源被严重浪费，进程经常会发生饥饿现象。</p>\n<h4 id=\"2-摒弃“不剥夺”条件\"><a href=\"#2-摒弃“不剥夺”条件\" class=\"headerlink\" title=\"2. 摒弃“不剥夺”条件\"></a>2. 摒弃“不剥夺”条件</h4><p>当一个已经保持了某些资源的进程，再提出新的资源请求而不能立即得到满 足时，必须释放它已经保持了的所有资源。待以后需要时再重新申请。从而 摒弃了“不剥夺”条件。</p>\n<p><strong>缺点</strong>:实现起来比较复杂且要付出很大代价。</p>\n<ul>\n<li>一个资源在使用一段时间后，它的被迫释放可能会造成前段工作的失效。 – 会使进程前后两次运行的信息不连续。</li>\n<li>因反复地申请和释放资源，致使进程执行被无限推迟，延长进程周转时 间、增加系统开销、降低吞吐量</li>\n</ul>\n<h4 id=\"3-摒弃”环路等待“条件\"><a href=\"#3-摒弃”环路等待“条件\" class=\"headerlink\" title=\"3. 摒弃”环路等待“条件\"></a>3. 摒弃”环路等待“条件</h4><p>这种方法中规定，系统将所有资源按类型进行线性排队，并赋予不同的序号。 所有进程对资源的请求必须严格按照资源序号递增的次序提出，这样，在所 形成的资源分配图中，不可能再出现环路，因而摒弃了“环路等待”条件。</p>\n<p><strong>缺点：</strong></p>\n<ol>\n<li><p>为系统中各类资源分配的序号必须相对稳定，这就限制了新设备类型的</p>\n<p>增加;</p>\n</li>\n<li><p>经常发生作业使用资源的顺序与系统规定资源使用顺序不同的情况，造成资源浪费;</p>\n</li>\n<li><p>增加了程序设计难度。</p>\n</li>\n</ol>\n<h2 id=\"3-7-避免死锁\"><a href=\"#3-7-避免死锁\" class=\"headerlink\" title=\"3.7 避免死锁\"></a>3.7 避免死锁</h2><h3 id=\"3-7-1-安全状态\"><a href=\"#3-7-1-安全状态\" class=\"headerlink\" title=\"3.7.1 安全状态\"></a>3.7.1 安全状态</h3><ul>\n<li>所谓安全状态，是指系统能按某种进程顺序，如&lt;P1，P2，…，Pn&gt;，依次为n 个进程分配其所需资源，直至其最大需求，使每个进程都可顺利地完成，称 系统处于安全状态。</li>\n<li>称〈P1，P2，…，Pn〉序列为安全序列。否则，如果系统无法找到这样一个安 全序列，则称系统处于不安全状态。</li>\n</ul>\n<h3 id=\"3-7-2-银行家算法\"><a href=\"#3-7-2-银行家算法\" class=\"headerlink\" title=\"3.7.2 银行家算法\"></a>3.7.2 银行家算法</h3><p>避免死锁的关键在于如何准确的预测是否会出现死锁，从而避免死锁。最有 代表性的避免死锁的算法是Dijkstra的银行家算法。</p>\n<h4 id=\"1-银行家算法数据结构\"><a href=\"#1-银行家算法数据结构\" class=\"headerlink\" title=\"1. 银行家算法数据结构\"></a>1. 银行家算法数据结构</h4><p>(1)可利用资源向量Available:这是一个含有m个元素的数组，其中的每一个 元素代表一类可利用的资源数目。其数值随该类资源的分配和回收而动态地 改变。 Available[j]=k,表示系统中现有Rj类资源k个。</p>\n<p>(2)最大需求矩阵Max。这是一个n × m的矩阵，它定义了n个进程中每一个进 程对m类资源的最大需求。Max[i,j]=K，表示进程Pi需要Rj类资源的最大数目 为K。</p>\n<p>(3)分配矩阵Allocation是一个nxm矩阵，定义了系统中每一类资源当前已分配给每一进程的资源数。Allocation[i,j]=K，表示进程Pi当前已分 得Rj类资源的数目为K。</p>\n<p>(4)需求矩阵Need。这也是一个n×m的矩阵，用以表示每一个进程尚需的各 类资源数。Need[i,j]=K，表示进程Pi还需要Rj类资源K个，方能完成其任务。</p>\n<p>• 上述三个矩阵的关系:Need[i,j]=Max[i,j] - Allocation[i,j]</p>\n<h4 id=\"2-银行家算法\"><a href=\"#2-银行家算法\" class=\"headerlink\" title=\"2. 银行家算法\"></a>2. 银行家算法</h4><p>设Requesti，是进程Pi的请求向量，当Pi发出资源请求后，系统按下述步骤进行 检查:</p>\n<p>(1)如果Requesti[j]≤Need[i,j],便转向步骤2;否则认为出错，因为它所需要的 资源数已超过它所声明的最大值。</p>\n<p>(2)如果Requesti[j]≤Available[j]，便转向步(3)，否则，表示尚无足够资源， Pi须阻塞等待。</p>\n<p>(3)系统试探着把资源分配给进程Pi ，并修改下面数据结构中的数值: </p>\n<p>Available[j]:= Available[j] - Requesti[j]; Allocation[i,j] : = Allocation[i,j] + Requesti[j]; Need[i,j]: =Need[i,j] - Requesti[j]; </p>\n<p>(4)系统执行安全性算法，检查此次资源分配后，系统是否处于安全状态。若 安全，才正式将资源分配给进程Pi ，以完成本次分配;否则，将本次的试探 分配作废，恢复原来的资源分配状态，让进程Pi等待。 </p>\n<h4 id=\"3-安全性算法\"><a href=\"#3-安全性算法\" class=\"headerlink\" title=\"3. 安全性算法\"></a>3. 安全性算法</h4><p>系统所执行的安全性算法可描述如下:</p>\n<p> (1)设置两个向量:</p>\n<p>1工作向量Work: 它表示系统可提供给进程继续运行所需的各类资源数目，初始值Work:=Available</p>\n<p>2设置数组Finish[n]:初始值Finish[i]:=false; 当Finish[i]:=true时，进程Pi可获得其所需的全部资源，从而顺利执行完成。</p>\n<p>(2)从进程集合中找到一个能满足下述条件的进程Pi : </p>\n<p>1Finish[i]=false;  2 Need[i,j]≤work; <strong>寻找未完成的进程，它的所需资源量小于系统可用资源量</strong></p>\n<p>若找到，执行步骤(3),否则，执行步骤(4)。 </p>\n<p>(3)当进程Pi获得资源后，顺利执行直至完成，并释放出分配给它的资源，故应 执行: </p>\n<p>Work:= Work+Allocation[i,j]; Finish[i] :=true;  go to step 2; </p>\n<p>(4)如果所有进程的Finish[i]=true都满足，则表示系统处于安全状态;否则， 系统处于不安全状态。 </p>\n<p><strong>大题出现 ppt例子</strong></p>\n<h2 id=\"3-8-死锁的检测与解除\"><a href=\"#3-8-死锁的检测与解除\" class=\"headerlink\" title=\"3.8 死锁的检测与解除\"></a>3.8 死锁的检测与解除</h2><h3 id=\"3-8-1-死锁的检验\"><a href=\"#3-8-1-死锁的检验\" class=\"headerlink\" title=\"3.8.1 死锁的检验\"></a>3.8.1 死锁的检验</h3><h4 id=\"1-死锁检测\"><a href=\"#1-死锁检测\" class=\"headerlink\" title=\"1. 死锁检测\"></a>1. 死锁检测</h4><p>如果系统不愿意附加太多约束条件预防死锁，也不希望系统额外开销预测并避 免死锁，那么，只能允许死锁出现，然后，再解除它。</p>\n<p>• 因此，系统需要利用某种方法来检测死锁</p>\n<p>• 资源分配图 该图是由一组结点N和一组边E所组成的一个对偶G=(N,E)</p>\n<p>其中:</p>\n<p>(1)把N分为两个互斥的子集，即一组进程结点P={P1,P2，…，Pn)和一组资 源结点R={R1, R2 ，…， Rn}，N=PUR。 </p>\n<p>(2)凡属于E中的一个边e∈ E都连接着P中的一个结点和R中的一个结点 – e={Pi,Rj} </p>\n<p>它表示进程Pi请求一个单位的rj资源。 – e={Rj，Pi} </p>\n<p>它表示把一个单位的资源Rj分配给进程Pi 。 </p>\n<h4 id=\"2-死锁定理\"><a href=\"#2-死锁定理\" class=\"headerlink\" title=\"2. 死锁定理\"></a>2. 死锁定理</h4><p><img src=\"https://img.cetacis.dev/uploads/big/a4ed842da08a8e4aa93af662aa37612d.png\" alt=\"\"></p>\n<h4 id=\"3-死锁检测算法\"><a href=\"#3-死锁检测算法\" class=\"headerlink\" title=\"3. 死锁检测算法\"></a>3. 死锁检测算法</h4><p>若能消去资源分配图中所有结点的连接边，使全部结点都成为孤立结点，则称 该图是可完全简化图;若不能使该图完全简化，则称该图是不可完全化简图。</p>\n<p>可以证明:当且仅当系统某状态S所对应的资源分配图是不可完全化简的，则S 是死锁状态。该充分条件称为死锁定理。</p>\n<h4 id=\"4-死锁检测中的数据结构\"><a href=\"#4-死锁检测中的数据结构\" class=\"headerlink\" title=\"4.死锁检测中的数据结构\"></a>4.死锁检测中的数据结构</h4><p>(1)可利用资源向量Available，它表示了m类资源中每一类资源的可用数目。</p>\n<p> (2)把不占用资源的进程(Allocation:=0)记入L表中，即Li U L</p>\n<p> (3)从进程集合中找到一个Requesti≤work的进程，做如下处理:</p>\n<ol>\n<li><p>Work:=work十Allocationi，</p>\n</li>\n<li><p>将它记入L表中。</p>\n</li>\n</ol>\n<p>(4)若不能把所有进程都记入L表中，便表明系统状态S的资源分配图是不可 完全简化的。因此，该系统状态将发生死锁。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Work:&#x3D; Available; </span><br><span class=\"line\">\tL:&#x3D;&#123;Li|Allocationi&#x3D;0∩Requesti&#x3D;0&#125; </span><br><span class=\"line\">\tfor all Li∈L do</span><br><span class=\"line\">\tbegin</span><br><span class=\"line\">\tfor all Requesti≤Work do</span><br><span class=\"line\">\t\tbegin </span><br><span class=\"line\">\t\t\tWork:&#x3D;Work十Allocationi;</span><br><span class=\"line\">       Li∪L;</span><br><span class=\"line\">\t\tend </span><br><span class=\"line\">\tend</span><br><span class=\"line\">deadlock:&#x3D; (L&#x3D;&#123;P1，P2，.... ，Pn&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-8-2-死锁的解除\"><a href=\"#3-8-2-死锁的解除\" class=\"headerlink\" title=\"3.8.2 死锁的解除\"></a>3.8.2 死锁的解除</h3><p>当发现有进程死锁时，常采用的两种方法是解除死锁:</p>\n<p> (1)剥夺资源。从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态。</p>\n<p>(2)撤消进程。最简单的撤消进程的方法，是使全部死锁进程都夭折掉;或者 按照某种顺序逐个地撤消进程，直至有足够的资源可用，使死锁状态消除为</p>\n<p>止。</p>\n<p>按照解除死锁复杂度递增的顺序列出解除死锁的方法:</p>\n<ol>\n<li>撤消死锁进程。该方法是目前操作系统中解除死锁的常用方法。</li>\n<li>把死锁进程恢复到前一个检查点，重新执行每个进程。</li>\n<li>按照某种原则逐个选择死锁进程进行撤消，直到解除系统死锁。</li>\n<li>按照某种原则逐个剥夺进程资源，直到解除死锁。</li>\n</ol>\n<p><strong>最小代价原则</strong></p>\n<p>第三种和第四种方法需要选择系统付出代价最小的进程，最小代价原则: </p>\n<p>– 到目前为止，花费处理机的时间最少的进程;</p>\n<p>– 到目前为止，产生输出最少的进程;</p>\n<p>– 估计未执行部分最多的进程;</p>\n<p>– 到目前为止，已获得资源量最少的进程; – 优先级最低的进程。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"2-5-经典进程同步问题\"><a href=\"#2-5-经典进程同步问题\" class=\"headerlink\" title=\"2.5 经典进程同步问题\"></a>2.5 经典进程同步问题</h2><h3 id=\"2-5-1-生产者消费者问题\"><a href=\"#2-5-1-生产者消费者问题\" class=\"headerlink\" title=\"2.5.1 生产者消费者问题\"></a>2.5.1 生产者消费者问题</h3>","more":"<p><strong>1. 概念</strong></p>\n<ul>\n<li><p>代表一类具有相同属性的进程。</p>\n</li>\n<li><p>共享一个大小固定的缓冲区，一个或多个生产者生产数</p>\n<p>据，并将生产的数据存入缓冲区，并有一个消费者从缓冲区中取数据。</p>\n</li>\n<li><p>例如， 在输入时，输入进程是生产者，计算进程是消费者;而在输出时，则计 算进程是生产者，而打印进程是消费者。</p>\n</li>\n</ul>\n<p>分别设置两个指针in和out:<br>– in指向生产者将存放数据的存储单元 – out指向消费者将取数据的存储单元</p>\n<p><em>如果不控制生产者与消费者：生产者和消费者可能同时进入缓冲区，甚至可能同时读/写一个存储单**元，将导致执行结果不确定。</em></p>\n<p><strong>2. 解决方法1：信号量</strong></p>\n<p>互斥信号量mutex:实现诸进程对缓冲池的互斥使用; </p>\n<p>资源信号量empty:表示缓冲池中空缓冲区的数量;初始值定义为1</p>\n<p>资源信号量full:表示满缓冲区的数量; 初始值定义为0</p>\n<p>只要缓冲池未满，生产者便可将消息送入缓冲池;只要缓冲池未空，消费者便可从缓冲池中取走一个消息。</p>\n<p>生产者</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var mutex，empty，full:semaphore:&#x3D;1，n，0; </span><br><span class=\"line\">\tbuffer:array[0，...，n-1]of item; </span><br><span class=\"line\">\tin，out:integer:&#x3D;0，0;</span><br><span class=\"line\">\tbegin</span><br><span class=\"line\">\t\tparbegin </span><br><span class=\"line\">\t\t\tproceducer:begin</span><br><span class=\"line\">\t\t\t\trepeat</span><br><span class=\"line\">\t\t\t\t...</span><br><span class=\"line\">\t\t\t\tproducer an item nextp;</span><br><span class=\"line\">\t\t\t\t...</span><br><span class=\"line\">\t\t\t\twait(empty);\t当empty &#x3D;&#x3D; 1：1-1&#x3D;0 </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t当empty &#x3D;&#x3D; 0 说明缓冲区不空</span><br><span class=\"line\">\t\t\t\twait(mutex);  </span><br><span class=\"line\">\t\t\t\tbuffer(in):&#x3D;nextp; </span><br><span class=\"line\">\t\t\t\tin:&#x3D;(in+1)mod n; </span><br><span class=\"line\">\t\t\t\tsignal(mutex);释放缓冲区 </span><br><span class=\"line\">\t\t\t\tsignal(full); full代表数据个数</span><br><span class=\"line\">until false; end</span><br></pre></td></tr></table></figure>\n\n<p>消费者</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">consumer :begin </span><br><span class=\"line\">\t\t\t\t\t\trepeat</span><br><span class=\"line\">\t\t\t\t\twait (full); </span><br><span class=\"line\">\t\t\t\t\twait(mutex); 缓冲区是否有其他进程</span><br><span class=\"line\">\t\t\t\t\tnextc :&#x3D;buffer(out); </span><br><span class=\"line\">\t\t\t\t\tout:&#x3D; (out+1)mod n;</span><br><span class=\"line\">\t\t\t\t\tsignal(mutex); </span><br><span class=\"line\">\t\t\t\t\tsignal(empty);</span><br><span class=\"line\">\t\t\t\t\tconsumer the item in nextc;</span><br><span class=\"line\">\t\t\t\tuntil false; </span><br><span class=\"line\">\t\t\tend</span><br><span class=\"line\">\t\tparend </span><br><span class=\"line\">\tend</span><br></pre></td></tr></table></figure>\n\n<p><strong>3. 注意</strong></p>\n<ul>\n<li><p>先申请资源信号量，再申请互斥信号量</p>\n<p><em>资源信号量相当于你吃饭先预定个桌子如果你不预定 直接去吃饭 没桌子了你只好一直在那等了 别人吃完了桌子留给了预定的人 你没预定就得一直在那等 就是死锁了</em></p>\n<p><em>如两个进程都反过来操作，先互斥了，但是没有得到临界资源，发生死锁</em></p>\n</li>\n<li><p>对任何信号量的wait与signal操作必须配对。同一进程中的多对wait与signal语句只能嵌套，不能交叉。</p>\n</li>\n<li><p>对同一个资源信号量的wait与signal可以不在同一个进程中。</p>\n<p>– 例如，wait(empty)在计算进程中，而signal(empty)则在打印进程中，计 算进程若因执行wait(empty)而阻塞， 则以后将由打印进程将它唤醒</p>\n</li>\n<li><p>wait与signal语句不能颠倒顺序，wait语句一定先于signal语句，否则可能 引起进程死锁。</p>\n</li>\n</ul>\n<p><strong>4. 解决方法2：and信号量</strong></p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/25e90fb77f0065bee3136b76517b5f2b.png\" alt=\"and信号量（合并互斥和资源信号量）\"></p>\n<h3 id=\"2-5-2-读者和写者问题\"><a href=\"#2-5-2-读者和写者问题\" class=\"headerlink\" title=\"2.5.2 读者和写者问题\"></a>2.5.2 读者和写者问题</h3><p><strong>1. 概念</strong></p>\n<p>读者：只读不取</p>\n<p>读读不互斥，读写互斥，写写互斥。</p>\n<p><strong>2. 解决方法1：读者优先</strong></p>\n<p><strong>读者优先</strong>：一旦有读者正在读数据，允许多个读者同时进入读数据，只有 当全部读者退出，才允许写者进入写数据。</p>\n<p>可能问题：读者不断进入，写者长时间等待（饥饿）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Var rmutex, wmutex:semaphore∶ &#x3D;1,1;&#x2F;* 互斥信号量，初始化为1 *&#x2F;</span><br><span class=\"line\">\tReadcount:integer∶ &#x3D;0;; &#x2F;* 统计读者个数 *&#x2F; </span><br><span class=\"line\">\tbegin</span><br><span class=\"line\">\tparbegin</span><br><span class=\"line\">\tReader:begin </span><br><span class=\"line\">\t\trepeat</span><br><span class=\"line\">\t\twait(rmutex);# 共享变量，保证互斥</span><br><span class=\"line\">\t\tif readcount&#x3D;0 then wait(wmutex); # readcount &#x3D;&#x3D; 0 在此之前没有读者 </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t# 需要判断是否有写进程 如果有，则需要等待写进程</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t# wmutex：用于写进程互斥</span><br><span class=\"line\">\t\t\tReadcount∶ &#x3D;Readcount+1;   # 读者进程的共享变量</span><br><span class=\"line\">\t\tsignal(rmutex);</span><br><span class=\"line\">...</span><br><span class=\"line\">perform read operation;</span><br><span class=\"line\">...</span><br><span class=\"line\">\t\twait(rmutex); </span><br><span class=\"line\">\t\t\treadcount∶ &#x3D;readcount-1;</span><br><span class=\"line\">\t\t\tif readcount&#x3D;0 then signal(wmutex); # 最后一个读进程，有可能有进程在等，</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t# 判断是否需要唤醒</span><br><span class=\"line\">\t\t\tsignal(rmutex);</span><br><span class=\"line\">\t\t\tuntil false;</span><br><span class=\"line\">     end</span><br></pre></td></tr></table></figure>\n\n<p><strong>2. 解决方法2：信号量集</strong></p>\n<p>写者</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var RN integer;&#x2F;* 控制读者上限RN*&#x2F; </span><br><span class=\"line\">\tL, mx:semaphore∶ &#x3D;RN,1;</span><br><span class=\"line\">\tbegin</span><br><span class=\"line\">  \tparbegin</span><br><span class=\"line\">\t\t\treader:begin </span><br><span class=\"line\">\t\t\t\trepeat</span><br><span class=\"line\">\t\t\t\t\tswait(L,1,1);</span><br><span class=\"line\">\t\t\t\t\t&#x2F;* 每进入一个读者，L减一，控制总数RN个*&#x2F; </span><br><span class=\"line\">\t\t\t\t\tswait(mx,1,0);</span><br><span class=\"line\">\t\t\t\t\t&#x2F;* 开关，mx&#x3D;1标识无writer进程写*&#x2F;</span><br><span class=\"line\">...</span><br><span class=\"line\">\t\t\t\t\tperform read operation; </span><br><span class=\"line\">\t\t\t\t\t...</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://img.cetacis.dev/uploads/big/7710f66ad00fa7588b9bc758f3803f08.png\" alt=\"\"></p>\n<h3 id=\"2-5-3-哲学家就餐问题\"><a href=\"#2-5-3-哲学家就餐问题\" class=\"headerlink\" title=\"2.5.3 哲学家就餐问题\"></a>2.5.3 哲学家就餐问题</h3><p><strong>1. 问题描述</strong></p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/7e7c738894e76900b2d180fcf1e9e43b.png\" alt=\"哲学家问题\"></p>\n<p>经分析可知，放在桌子上的筷子是临界资源，在一段时间内只允许一位哲学 家使用。为了实现对筷子的互斥使用，可以用一个信号量表示一只筷子，由</p>\n<p>这五个信号量构成信号量数组。其描述如下: • Var chopstick: array[0, …, 4] of semaphore;</p>\n<p><strong>2. 解决方式1：信号量</strong></p>\n<ul>\n<li>每个筷子一个初值为1的信号量 </li>\n<li>每个哲学家是一个进程</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Var Chopstick;array [0,4]of semaphore; </span><br><span class=\"line\"> 第i个进程描述为(i&#x3D;0,... ,4)</span><br><span class=\"line\">repeat</span><br><span class=\"line\">\twait(chopstick[i]);取左筷子; </span><br><span class=\"line\">\twait(chopstick[(i+1)mod 5]);取右筷子; </span><br><span class=\"line\">\teat;</span><br><span class=\"line\">\tsignal(chopstick[i]);放左筷子</span><br><span class=\"line\">\tsignal (Chopstick[(i+1)mod 5];放右筷子; </span><br><span class=\"line\">\tthink;</span><br><span class=\"line\">until false;</span><br><span class=\"line\">(这可能导致死锁：只要相邻的两个人同时拿起左筷子就会发生死锁</span><br></pre></td></tr></table></figure>\n\n<p><em>对wait/signal的理解</em></p>\n<p><em>wait ：在取用一个资源时是否需要wait</em></p>\n<p><em>signal： 在放置一个资源时，设置此资源可获取</em></p>\n<p><strong>3. 解决方式2：and信号量（解决死锁</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Var chopsiick array [0, ..., 4] of semaphore∶ &#x3D;(1,1,1,1,1); </span><br><span class=\"line\">\tprocessi</span><br><span class=\"line\">\t\trepeat</span><br><span class=\"line\">\t\t\tthink;</span><br><span class=\"line\">\t\t\tsswait(chopstick[(i+1) mod 5], chopstick [i]); </span><br><span class=\"line\">\t\t\teat;</span><br><span class=\"line\">\t\t\tssignat(chopstick [(i+1) mod 5], chopstick [i]);</span><br><span class=\"line\">\t\tuntil false;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-5-4-互斥与同步解决方法之四-管程\"><a href=\"#2-5-4-互斥与同步解决方法之四-管程\" class=\"headerlink\" title=\"2.5.4 互斥与同步解决方法之四 : 管程\"></a>2.5.4 互斥与同步解决方法之四 : 管程</h3><p><strong>1. 概念</strong></p>\n<ul>\n<li><p>出现原因：每个要访问临界资源的进程都必须自备<strong>同步操作</strong>wait(S)和signal(s)。这就使大量的同步操作分散在各个进程中。这不仅给系统的管理带来了麻烦，而且还会因同步操作的使用不当而导致系统死锁。</p>\n</li>\n<li><p>定义：将资源访问的同步，资源本身进行封装为一个“class”。同时，只能有一个“class”访问这个数据。Hansan为管程所下的定义是:“一个管程定义了一个数据结构和能为并发进程所执行(在该数据结构上)的一组操作，这组操作能同步进程和改变管程 中的数据”。</p>\n</li>\n<li><p>互斥保证：操作系统- 任何时刻，只能有一个进程在管程中运行</p>\n</li>\n<li><p>组成：1 局部于管程的共享变量说明;</p>\n<p>​            2 对该数据结构进行操作的一组过程</p>\n<p>​            3 对局部于管程的数据设置初始值的语句。 </p>\n<p>​            4 管程的名称</p>\n</li>\n</ul>\n<p><strong>2. 对生产者消费者问题的解决</strong></p>\n<p>在利用管程方法来解决生产者-消费者问题时， 首先便是为它们建立一个管程，并命名为Proclucer-Consumer, 或简称为PC。其中包括两个过程: </p>\n<p>(1)put(item)过程。 生产者利用该过程将自己生产的产品投放到缓冲池中，</p>\n<p>并用整型变量count来表示在缓冲池中已有的产品数目，当count≥n时，表示 缓冲池已满，生产者须等待。<br>(2) get(item)过程。消费者利用该过程从缓冲池中取出一个产品，当count≤0 时，表示缓冲池中已无可取用的产品， 消费者应等待。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">producer:begin </span><br><span class=\"line\">\trepeat</span><br><span class=\"line\">\t\tproduce an item in nextp;</span><br><span class=\"line\">\t\tPC.put(item); </span><br><span class=\"line\">\t\tuntil false;</span><br><span class=\"line\">\tend # 生产者进程</span><br><span class=\"line\">consumer:begin</span><br><span class=\"line\">\trepeat</span><br><span class=\"line\">\t\tPC.get(item);</span><br><span class=\"line\">\t\tconsume the item in nextc;</span><br><span class=\"line\">\t\tuntil false; </span><br><span class=\"line\">\tend # 消费者进程</span><br></pre></td></tr></table></figure>\n\n<p>将所有功能封装在<strong>PC</strong>这个“类”中，直接调用。</p>\n<h2 id=\"2-6-进程通信\"><a href=\"#2-6-进程通信\" class=\"headerlink\" title=\"2.6 进程通信\"></a>2.6 进程通信</h2><p><strong>概念：</strong>当进程进行通信合作时，各个进程之间需要建立连接，进程通信需要同步和协调。</p>\n<p>通讯类型：控制信息（低级）数据（高级）</p>\n<p>进程之间同步与互斥是一种低级通信,用来控制进程执行速度。</p>\n<p>– 效率低<br>– 通信对用户不透明</p>\n<h3 id=\"通信机制1-基于共享存储区方式\"><a href=\"#通信机制1-基于共享存储区方式\" class=\"headerlink\" title=\"通信机制1 基于共享存储区方式\"></a>通信机制1 基于共享存储区方式</h3><ol>\n<li><p>通过程序设计来实现。程序员设计程序时，利用程序指令设置共享数据结构， 并处理通信进程之间的同步等问题，操作系统只需提供共享存储区。</p>\n</li>\n<li><p>由操作系统在内存中划分出一块区域作为共享存储区。</p>\n</li>\n</ol>\n<p>– 进程在通信前向系统申请共享存储区中的一个分区。</p>\n<p>– 然后，申请进程把获得的共享存储分区连接到本进程上，此后便可象读/写 普通存储器一样地读/写共享存储分区。</p>\n<p>– 该方式下，通信进程之间的同步与互斥访问共享存储区可以由操作系统实 现。</p>\n<h3 id=\"通信机制2-管道通信\"><a href=\"#通信机制2-管道通信\" class=\"headerlink\" title=\"通信机制2 管道通信\"></a>通信机制2 管道通信</h3><ul>\n<li>所谓“管道”，是指用于连接一个读进程和一个写进程以实现他们之间通信 的一个共享文件，又名pipe文件。</li>\n<li>向管道(共享文件)提供输入的发送进程(即写进程)， 以字符流形式将大量的数 据送入管道;</li>\n<li>而接受管道输出的接收进程(即读进程)，则从管道中接收(读)数据。由于发送 进程和接收进程是利用管道进行通信的，故又称为管道通信。</li>\n<li>这种方式首创于UNIX系统，由于它能有效地传送大量数据，因而又被引入到 许多其它操作系统中。</li>\n</ul>\n<p>*<em>有名管道  *</em>：通过文件的读写（遵循FIFO原则</p>\n<p><strong>无名管道</strong>：内存</p>\n<h3 id=\"通信机制3-信息传递方式\"><a href=\"#通信机制3-信息传递方式\" class=\"headerlink\" title=\"通信机制3 信息传递方式\"></a>通信机制3 信息传递方式</h3><p>比如网络信息的传递，本机的进程与远端服务器链接并且传递。</p>\n<p>进程间的数据交换，是以格式化的消息(message)为单位的(计算机网络称为报文)</p>\n<h2 id=\"2-7-线程\"><a href=\"#2-7-线程\" class=\"headerlink\" title=\"2.7 线程\"></a>2.7 线程</h2><p>线程是一种比进程更小的独立运行单位：线程（threads） 可以比进程更好地提高程序的并行执行程度，并且提高系统的吞吐量。</p>\n<h3 id=\"2-7-1-线程的引入\"><a href=\"#2-7-1-线程的引入\" class=\"headerlink\" title=\"2.7.1 线程的引入\"></a>2.7.1 线程的引入</h3><p>进程特点：</p>\n<ul>\n<li><p>资源所有权:一个进程包括一个保存进程映像的虚地址空间，并且随时分配对。资源的的控制或所有权，包括内存、I/O通道、I/O设备、文件等。</p>\n<p>资源：处理机，io</p>\n</li>\n<li><p>调度/执行:进程是被操作系统调度的实体。</p>\n</li>\n</ul>\n<p>为区分这两个特点，调度并分派的部分通常称为线程或轻便进程(lightweight process)，而资源所有权的部分通常称为进程。</p>\n<h4 id=\"线程的属性：\"><a href=\"#线程的属性：\" class=\"headerlink\" title=\"线程的属性：\"></a>线程的属性：</h4><p>(1) 线程是一个被调度和分派的基本单位，并可独立运行的实体。大多数与 执行相关的信息可以保存在线程级的数据结构中;</p>\n<p>(2)线程是可以并发执行; (3)共享进程资源。</p>\n<p>(4)线程是轻型实体，在切换时只需保存少量寄存器的内容，不涉及存储器的 管理等，因此系统开销小。</p>\n<p>(5)进程中的所有线程共享同一个地址空间，挂起进程则会挂起进程中的所有 线程。类似地，进程的终止会导致进程中所有线程的终止。</p>\n<h4 id=\"线程优点\"><a href=\"#线程优点\" class=\"headerlink\" title=\"线程优点\"></a>线程优点</h4><ol>\n<li>在一个已有进程中创建一个新线程比创建一个全新进程所需的时间少。 </li>\n<li>终止一个线程比终止一个进程花费的时间少。 </li>\n<li>线程间切换比进程间切换花费的时间少。</li>\n<li>线程提高了不同的执行程序间通信的效率。同一个进程中的线程共享存储空 间和文件，它们无需调用内核就可以互相通信。</li>\n</ol>\n<h3 id=\"2-7-2-线程进程比较\"><a href=\"#2-7-2-线程进程比较\" class=\"headerlink\" title=\"2.7.2 线程进程比较\"></a>2.7.2 线程进程比较</h3><p>1、调度的基本单位 2、并发性 3、拥有资源 4、独立性 5、系统开销 6、支持多处理机</p>\n<h3 id=\"线程状态和线程控制块\"><a href=\"#线程状态和线程控制块\" class=\"headerlink\" title=\"线程状态和线程控制块\"></a>线程状态和线程控制块</h3><p>*<em>线程的状态有: *</em></p>\n<p>运行状态、就绪状态、阻塞状态等。</p>\n<p><strong>在线程切换时保存的线程信息:</strong></p>\n<p>1 一个执行栈。<br>2 每个线程静态存储局部变量。 3对存储器和其进程资源的访问，并与该进程中的其他线程共享这些资源。如:寄存器状态、堆栈、线程运行状态、 优先级、线程专有存储器、信 号屏蔽等</p>\n<h4 id=\"线程状态变化的4种基本操作\"><a href=\"#线程状态变化的4种基本操作\" class=\"headerlink\" title=\"线程状态变化的4种基本操作\"></a>线程状态变化的4种基本操作</h4><p>1派生(Spawn):当产生一个新进程时，同时也为该进程派生了一个“初始化 线程”，随后，可以在同一个进程中派生另一个线程，新线程被放置在就绪队列中。</p>\n<p>2阻塞(Block):当线程需要等待一个事件时，它将阻塞，此时处理器转而执 行另一个就绪线程。</p>\n<p>3解除阻塞(Unblock):当阻塞一个线程的事件发生时，该线程被转移到就绪 队列中。</p>\n<p>4结束(Finish):当一个线程完成时，其寄存器的信息和栈都被释放。</p>\n<h3 id=\"2-6-3-线程的分类\"><a href=\"#2-6-3-线程的分类\" class=\"headerlink\" title=\"2.6.3 线程的分类\"></a>2.6.3 线程的分类</h3><ol>\n<li>内核</li>\n<li>用户空间 （同时，用户层也可有资源所有权，线程在此层对进程直接进行调度</li>\n</ol>\n<h1 id=\"第三章-处理机与死锁\"><a href=\"#第三章-处理机与死锁\" class=\"headerlink\" title=\"第三章 处理机与死锁\"></a>第三章 处理机与死锁</h1><p>多到程序环境进程数目多于处理机数，处理机是十分重要的资源，如何分配尤为重要，它是由调度程序完成的，需要优秀的调度方法。</p>\n<p>调度需要解决的问题：1. 调度算法 2. 何时分配 3. 调度过程及其进程 的上下文切换</p>\n<h2 id=\"3-1-处理机调度的层次和调度算法目标\"><a href=\"#3-1-处理机调度的层次和调度算法目标\" class=\"headerlink\" title=\"3.1 处理机调度的层次和调度算法目标\"></a>3.1 处理机调度的层次和调度算法目标</h2><p>调度对象</p>\n<ul>\n<li>作业（job） 程序、数据、作业说明书</li>\n</ul>\n<h3 id=\"3-1-1-处理机调度的层次\"><a href=\"#3-1-1-处理机调度的层次\" class=\"headerlink\" title=\"3.1.1 处理机调度的层次\"></a>3.1.1 处理机调度的层次</h3><ol>\n<li><p>高级调度 </p>\n<p>作业调度或长程调度:用于决定把外存上处于后备队列中的哪些作业调入内存，并为它们创建进程、分配必要的资源，然后，再将新创建的进程排在就 绪队列上，准备执行 。</p>\n</li>\n<li><p>低级调度</p>\n<p>进程调度或短程调度:用来决定就绪队列中的哪个进程(或内核级线程) 应获得处理机，然后再由分派程序把处理机分配给该进程的具体操作。</p>\n</li>\n<li><p>中级调度</p>\n<p>目的：提高内存利用率和系统吞吐量。就绪状态–挂起状态 当系统负载过重，<em>将进程挂起到外存的专<em>用</em>区域</em></p>\n</li>\n</ol>\n<h4 id=\"1-高级调度\"><a href=\"#1-高级调度\" class=\"headerlink\" title=\"1. 高级调度\"></a>1. 高级调度</h4><p>作业调度或长程调度:用于决定把外存上处于后备队列中的哪些作业调入内存，并为它们创建进程、分配必要的资源，然后，再将新创建的进程排在就 绪队列上，准备执行 。</p>\n<ul>\n<li>接受作业数量：取决于多到程序度允许多少作业同时在内存运行</li>\n<li>接纳那些作业：取决于调度算法 （先入先出、短作业优先、基于作业优先权、相应比高者优先</li>\n</ul>\n<p><strong>阶段与状态：</strong></p>\n<p>收容运行段（后备状态）</p>\n<p>运行阶段（运行状态）</p>\n<p>完成阶段（完成状态）</p>\n<h4 id=\"2-低级调度\"><a href=\"#2-低级调度\" class=\"headerlink\" title=\"2. 低级调度\"></a>2. 低级调度</h4><p><strong>进程调度的主要任务</strong></p>\n<p>– 保存处理机的现场信息到进程PCB中，如:程序计数器、通用寄存器等<br>– 按某种算法选取进程，如优先级算法、轮转法等<br>– 由分派程序(Dispatcher)把处理器分配给进程，恢复进程处理机现场</p>\n<p><strong>进程调度机制的三个部分</strong></p>\n<p>– 排队器 对首进程即将要被调用的进程</p>\n<p>– 分派器 (分派程序) 将cpu分配</p>\n<p>– 上下文切换器 (两对)</p>\n<p>当前进程-&gt;分派程序-&gt;新进程</p>\n<p><strong>调度方式</strong></p>\n<ul>\n<li><p>非抢占式</p>\n<ol>\n<li><p>正在执行的进程执行完毕，或因发生某事件而不能再继续执(包括:当前执行进程被中断、挂起自己、退出等)</p>\n</li>\n<li><p>执行中的进程因提出I/O请求而暂停执行;</p>\n</li>\n<li><p>在进程通信或同步过程中执行了某种原语操作，如P操作原语，Block原语， Wakeup原语等。</p>\n</li>\n</ol>\n</li>\n<li><p>抢占式</p>\n<p>抢占原则： 优先权原则。短作业(进程)优先原则。时间片原则。</p>\n<p>优缺点：优点 满足对响应时间严格的实时任务 缺点 调度开销大</p>\n</li>\n</ul>\n<h4 id=\"3-中级调度\"><a href=\"#3-中级调度\" class=\"headerlink\" title=\"3. 中级调度\"></a>3. 中级调度</h4><p>目的：提高内存利用率和系统吞吐量。</p>\n<p><strong>挂起状态：</strong>使那些暂时不能运行的进程不再占用内存资源，而将它们调至外存上去等待。</p>\n<p>程序重又具备运行条件、且内存又稍有空闲时，由中级调度来决定把 外存上的哪些又具备运行条件的就绪进程，重新调入内存，并修改其状态为 就绪状态。</p>\n<h4 id=\"4-调度队列模型和调度准则\"><a href=\"#4-调度队列模型和调度准则\" class=\"headerlink\" title=\"4. 调度队列模型和调度准则\"></a>4. 调度队列模型和调度准则</h4><ol>\n<li>仅有进程调度的调度队列模型</li>\n</ol>\n<p><img src=\"https://img.cetacis.dev/uploads/big/a2f70281a16a73945aab3c237bd18ec3.png\" alt=\"\"></p>\n<ol start=\"2\">\n<li>有高级和低级调度的调度队列模型</li>\n</ol>\n<p><img src=\"https://img.cetacis.dev/uploads/big/9c92d3574c203412fcf950aa64936c72.png\" alt=\"\"></p>\n<ol start=\"3\">\n<li>同时具有三级调度的调度队列模型</li>\n</ol>\n<p><img src=\"https://img.cetacis.dev/uploads/big/b626a71c9dbaecdccd485b19c9fe8cb6.png\" alt=\"\"></p>\n<h3 id=\"3-1-2-处理机调度算法目标\"><a href=\"#3-1-2-处理机调度算法目标\" class=\"headerlink\" title=\"3.1.2 处理机调度算法目标\"></a>3.1.2 处理机调度算法目标</h3><h4 id=\"1-共同目标\"><a href=\"#1-共同目标\" class=\"headerlink\" title=\"1. 共同目标\"></a>1. 共同目标</h4><p><strong>资源利用率</strong> 最重要</p>\n<p><strong>公平性</strong> 合理cpu时间 合理不仅仅在于先入先出，而在于很多原则，比如优先权原则，短进程原则。</p>\n<p><strong>平衡性</strong> 保持各种cpu的系统资源使用平衡性</p>\n<p>策略强制执行</p>\n<h4 id=\"2-批处理系统目标\"><a href=\"#2-批处理系统目标\" class=\"headerlink\" title=\"2. 批处理系统目标\"></a>2. 批处理系统目标</h4><p><img src=\"https://img.cetacis.dev/uploads/big/47dcfdb60f8ab8ca9616e37659a6b8a2.png\" alt=\"\"></p>\n<p>平均周转时间求和即全部的周转时间</p>\n<p>平均带权周转时间求和是 周转时间/服务时间</p>\n<h4 id=\"3-分时系统目标\"><a href=\"#3-分时系统目标\" class=\"headerlink\" title=\"3. 分时系统目标\"></a>3. 分时系统目标</h4><ol>\n<li><p>响应时间快 用户体验好</p>\n</li>\n<li><p>均衡性 系统响应时间快慢与用户所请求服务的复杂性相适应</p>\n</li>\n</ol>\n<h4 id=\"4-实时系统的目标\"><a href=\"#4-实时系统的目标\" class=\"headerlink\" title=\"4. 实时系统的目标\"></a>4. 实时系统的目标</h4><ol>\n<li><strong>截止时间的保证</strong> 截止时间指任务必须开始执行或者必须完成的时间。实时系统调度算法的一个重要目标是保证实时任务对截止时间的要求。</li>\n<li>可预测性</li>\n</ol>\n<h2 id=\"3-3-调度算法\"><a href=\"#3-3-调度算法\" class=\"headerlink\" title=\"3.3 调度算法\"></a>3.3 调度算法</h2><p>调度算法：根据系统的资源分配策略所规定的资源分配算法。对于不同 的系统目标，通常采用不同的调度算法。</p>\n<p>1.先来先服务(FCFS) 2.短作业(短进程)优先(SJF) 3.时间片轮转(RR) 4.基于优先级的调度算法 5.剩余时间最短者优先 6.高响应比优先调度算法 7.多级反馈队列调度法</p>\n<p><em>有利于否在于带权周转时间的长短</em></p>\n<p>周转时间 = 完成时间 - 到达时间</p>\n<p>带权周转时间 = 周转时间 / 服务时间</p>\n<h3 id=\"3-3-1先来先服务\"><a href=\"#3-3-1先来先服务\" class=\"headerlink\" title=\"3.3.1先来先服务\"></a>3.3.1先来先服务</h3><p>有利于长作业不利于短作业（短作业可能会等待较长时间才能得到短时服务）</p>\n<p>非抢占式调度（批处理</p>\n<h3 id=\"3-3-2-短作业优先（短作业即服务时间短）\"><a href=\"#3-3-2-短作业优先（短作业即服务时间短）\" class=\"headerlink\" title=\"3.3.2 短作业优先（短作业即服务时间短）\"></a>3.3.2 短作业优先（短作业即服务时间短）</h3><p>首先从就绪队列调度估计时间最短的作业 </p>\n<p>有利于短作业不利于长作业（所有短作业完成以后长作业才可能开始，甚至可能导致长作业长期不被调度）</p>\n<p>非抢占式调度（批处理</p>\n<p>缺点：1. 有利于短作业不利于长作业 2. 非抢占式调度 3. 对于长短估计不一定准确，不能选到最短的</p>\n<h3 id=\"3-3-3-基于优先级的调度算法\"><a href=\"#3-3-3-基于优先级的调度算法\" class=\"headerlink\" title=\"3.3.3 基于优先级的调度算法\"></a>3.3.3 基于优先级的调度算法</h3><p>把处理机分配给就绪队列中优先级最高的进程</p>\n<p><strong>两种类型</strong>：非抢占式优先权算法   抢占式优先权调度算法</p>\n<h4 id=\"1-非抢占优先权算法\"><a href=\"#1-非抢占优先权算法\" class=\"headerlink\" title=\"1. 非抢占优先权算法\"></a>1. 非抢占优先权算法</h4><p>系统一旦把处理机分配给就绪队列中优先权最高的进程后， 该进程便一直执行下去，直至完成;或因发生某事件使该进程放弃处理机时， 系统方可再将处理机重新分配给另一优先权最高的进程。</p>\n<h4 id=\"2-抢占式优先权调度算法\"><a href=\"#2-抢占式优先权调度算法\" class=\"headerlink\" title=\"2. 抢占式优先权调度算法\"></a>2. 抢占式优先权调度算法</h4><p> 在其执行期间，只要又出现了另一个其优先权更高的进程，进程调度程序就 立即停止当前进程的执行，重新将处理机分配给新到的优先权最高的进程。</p>\n<p><strong>特点</strong>：能更好地满足紧迫作业的要求，故而常用于要求比较严格的实时系统中，以及对性能要求较高的批处理和分时系统中。</p>\n<h4 id=\"3-优先权的类型\"><a href=\"#3-优先权的类型\" class=\"headerlink\" title=\"3. 优先权的类型\"></a>3. 优先权的类型</h4><p><strong>静态优先权</strong>：在创建进程时确定的，且在进程的整个运行期间保持不变。</p>\n<p><strong>动态优先权</strong>：在创建进程时所赋予的优先权，是可以随进程的推进或随 其等待时间的增加而改变的，以便获得更好的调度性能。</p>\n<p><strong>确定进程优先权的依据有三个方面</strong>：</p>\n<p>(1)进程类型。<br>– 系统进程的优先权高于一般用户进程的优先权。</p>\n<p>(2)进程对资源的需求。<br>– 对执行时间和内存要求少的进程应赋予较高的优先权。</p>\n<p>(3)用户要求。<br>– 按照各进程的执行流程和进程的紧迫程度来指定进程的优先权。</p>\n<h4 id=\"4-高响应比-优先-调度算法\"><a href=\"#4-高响应比-优先-调度算法\" class=\"headerlink\" title=\"4. 高响应比 优先 调度算法\"></a>4. 高响应比 优先 调度算法</h4><p>响应比 Rp = 1 + 等待时间/要求服务时间 = 响应时间 / 要求服务时间 = （等待时间+要求服务时间）/要求服务时间</p>\n<p>即：要求服务时间越短，等待时间越长，响应比越大。</p>\n<p>分析：</p>\n<p>（1）时间同，越短优先权越高，<strong>有利于短作业</strong></p>\n<p>（2）实现的是先来先服务</p>\n<p>（3）对于长作业，也可以由等待时间的增加而提高，防止长作业无法被调度。</p>\n<ul>\n<li><p>优点 ： 该算法既照顾了短作业，又考虑了作业到达的先后次序，同时不会使 长作业长期得不到服务。</p>\n</li>\n<li><p>缺点： 利用该算法时，每次调度之前，都须先做响应比的计算，会增加系统 开销。</p>\n</li>\n</ul>\n<h3 id=\"3-3-4-时间片轮转调度费RR\"><a href=\"#3-3-4-时间片轮转调度费RR\" class=\"headerlink\" title=\"3.3.4 时间片轮转调度费RR\"></a>3.3.4 时间片轮转调度费RR</h3><h4 id=\"1-RR\"><a href=\"#1-RR\" class=\"headerlink\" title=\"1. RR\"></a>1. RR</h4><p>系统将所有的就绪进程按先来先服务的原则，排成一个 队列，每次调度时，把CPU分配给队首进程，并令执行一个时间片。当执行的时间片用完时，由一个计时器发出时钟中断请求， 调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾;</p>\n<p>切换情况： 时间片用完；时间片没有用完，但是进程执行错误/错误。</p>\n<p>特点：系统能在给定的时间内，响应所有用户的请求。</p>\n<p>时间片大小会影响计算机性能：短时间片有利于短作业，使其较快完成，但会频繁发生中断、进程上下文切换，增加系统开销;</p>\n<p>对于短的、计算型进程比较有利，因为该进程充分利用时间片，而I/O型进程 却不利，因为在两次I/O之间仅需很少的CPU时间，却需要等待一个时间片。</p>\n<p>常用于分时系统及事务处理系统。</p>\n<h4 id=\"2-多级反馈队列调度法（抢占式调度算法\"><a href=\"#2-多级反馈队列调度法（抢占式调度算法\" class=\"headerlink\" title=\"2. 多级反馈队列调度法（抢占式调度算法\"></a>2. 多级反馈队列调度法（抢占式调度算法</h4><ul>\n<li><p>设置多个继续队列，每个队列有不同的优先级。赋予不用队列的时间片的大小也各不相同。优先级高，时间片小。优先级低，时间片大。第一个队列往后，优先级逐渐降低。</p>\n</li>\n<li><p>当一个新进程进入内存后，首先将它放入第一队列的末尾，按FCFS原则排 队等待调度。</p>\n<p>– 当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统;<br>– 如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的</p>\n<p>末尾，再同样地按FCFS原则等待调度执行;<br>– 如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队</p>\n<p>列，……<br>– 当进程最后被降到第n队列后，在第n队列中按RR方式调度</p>\n</li>\n<li><p>当第一队列空闲，才调度第二队列中的进程运行。当1-（i-1）空闲，i队列才会运行。</p>\n<p>当新进程进入后，会抢占二/三队列的cpu。将正在运行的进程放回i队列末尾。</p>\n</li>\n</ul>\n<p>性能：</p>\n<p>(1)终端型作业用户。</p>\n<p>能在第一队列所规定的时间片内完成，可使终端型作业用户都感到满意。</p>\n<p>(2)对短作业用户有利。</p>\n<p>(3)长批处理作业用户。对于长作业，它将依次在第1，2,…，n个队列中运行， 然后再按轮转方式运行，用户不必担心其作业长期得不到处理。</p>\n<h2 id=\"3-4-实时系统与实时任务调度\"><a href=\"#3-4-实时系统与实时任务调度\" class=\"headerlink\" title=\"3.4 实时系统与实时任务调度\"></a>3.4 实时系统与实时任务调度</h2><p>由于在实时系统中都存在着若干个实时进程或任务，<br>– 实时进程通常带有某种程度的紧迫性<br>– 需要引入一种新的调度解决实时进程的调度，即实时调度。</p>\n<h3 id=\"3-4-1-实现实时调度系统的基本条件\"><a href=\"#3-4-1-实现实时调度系统的基本条件\" class=\"headerlink\" title=\"3.4.1 实现实时调度系统的基本条件\"></a>3.4.1 实现实时调度系统的基本条件</h3><h4 id=\"1-提供必要的信息\"><a href=\"#1-提供必要的信息\" class=\"headerlink\" title=\"1. 提供必要的信息\"></a>1. 提供必要的信息</h4><p>(1)就绪时间。 (2)开始截止时间或完成截止时间。 (3)处理时间。</p>\n<p>(4)资源要求。 (5)优先级。</p>\n<h4 id=\"2-系统处理能力强\"><a href=\"#2-系统处理能力强\" class=\"headerlink\" title=\"2. 系统处理能力强\"></a>2. 系统处理能力强</h4><p>在实时系统中，通常都有着多个实时任务。若处理机的处理能力不够强，则有 可能因处理机忙不过来而使某些实时任务不能得到及时处理。</p>\n<p>解决的方法是提高系统的处理能力，其途径有:</p>\n<ul>\n<li>对单处理机系统，增强其处理能力，以此显著地减少对每一个任务的处理时间;</li>\n<li>其二是采用多处理机系统。</li>\n</ul>\n<h4 id=\"3-采用抢占式调动机制\"><a href=\"#3-采用抢占式调动机制\" class=\"headerlink\" title=\"3. 采用抢占式调动机制\"></a>3. 采用抢占式调动机制</h4><p>在含有硬实时任务的实时系统中，广泛采用抢占机制。当一个优先权更高 的任务到达时，允许暂停当前任务，而令高优先权任务立即投入运行，这 样便可满足该硬实时任务对截止时间的要求。</p>\n<h4 id=\"4-具有快速切换机制\"><a href=\"#4-具有快速切换机制\" class=\"headerlink\" title=\"4. 具有快速切换机制\"></a>4. 具有快速切换机制</h4><p>（1）对外部中断的快速响应能力。</p>\n<p>（2）快速的任务分派能力。</p>\n<h3 id=\"3-4-2-实时调度算法的分类\"><a href=\"#3-4-2-实时调度算法的分类\" class=\"headerlink\" title=\"3.4.2 实时调度算法的分类\"></a>3.4.2 实时调度算法的分类</h3><p><img src=\"https://img.cetacis.dev/uploads/big/04eae4dfeee38b3ff3a71670585f7df6.png\" alt=\"实时调度算法的分类\"></p>\n<h3 id=\"3-4-3-常用的几种实时调度算法\"><a href=\"#3-4-3-常用的几种实时调度算法\" class=\"headerlink\" title=\"3.4.3 常用的几种实时调度算法\"></a>3.4.3 常用的几种实时调度算法</h3><h4 id=\"1-最早截止时间优先算法-EDF\"><a href=\"#1-最早截止时间优先算法-EDF\" class=\"headerlink\" title=\"1. 最早截止时间优先算法(EDF)\"></a>1. 最早截止时间优先算法(EDF)</h4><ul>\n<li>按照截止时间排序</li>\n<li>如果新进程截止时间早于当前进程截止时间，则进行抢占。</li>\n</ul>\n<h4 id=\"2-最低松弛度优先算法-LLF\"><a href=\"#2-最低松弛度优先算法-LLF\" class=\"headerlink\" title=\"2. 最低松弛度优先算法(LLF)\"></a>2. 最低松弛度优先算法(LLF)</h4><p>松弛度=完成截至时间–剩余运行时间–当前时间</p>\n<p>略</p>\n<h2 id=\"3-5-死锁概述\"><a href=\"#3-5-死锁概述\" class=\"headerlink\" title=\"3.5 死锁概述\"></a>3.5 死锁概述</h2><p><strong>死锁(Deadlock)</strong>：是指多个进程在运行过程中因争夺资源而造成的一 种僵局。必须由外力解决。</p>\n<h3 id=\"3-5-1-死锁原因\"><a href=\"#3-5-1-死锁原因\" class=\"headerlink\" title=\"3.5.1 死锁原因\"></a>3.5.1 死锁原因</h3><p>（1）资源竞争</p>\n<p>（2）进程间推进顺序非法</p>\n<h4 id=\"1-竞争资源\"><a href=\"#1-竞争资源\" class=\"headerlink\" title=\"1.  竞争资源\"></a>1.  竞争资源</h4><p>1) 可剥夺和非剥夺性资源</p>\n<ul>\n<li>可剥夺性资源: 是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺。如:处理机、内存等</li>\n<li>非剥夺性资源: 当系统把这类资源分配给某进程后，再不能强行收回，只能 在进程用完后自行释放。如打印机等</li>\n</ul>\n<p>2) 竞争非剥夺性资源</p>\n<ul>\n<li><p>在系统中所配置的非剥夺性资源，由于它们的数量不能满足诸进程运行的 需要，会使进程在运行过程中，因争夺这些资源而陷入僵局。 </p>\n</li>\n<li><p>例如，系统中只有一台打印机R1和一台磁带机R2，可供进程P1和P2共享。 处理不好，在P1与P2之间会形成僵局，引起死锁。 P1先R1后R2，P2先R2后R1，可能会死锁。</p>\n</li>\n</ul>\n<p>3)竞争临时性资源</p>\n<p>• 临时性资源，可以创造(生产)和撤消(消耗)的资源，也称之为消耗性资源，它也可能引起死锁。 </p>\n<p>• 如信号量、消息、buffer中的数据等资源。 </p>\n<p>• 例如:S1、S2和S3是临时性资源，是由进程P1、P2和P3产生的消息。如果 消息通信处理顺序不当也会发生死锁。 </p>\n<h4 id=\"2-进程推进顺序不当引起死锁\"><a href=\"#2-进程推进顺序不当引起死锁\" class=\"headerlink\" title=\"2. 进程推进顺序不当引起死锁\"></a>2. 进程推进顺序不当引起死锁</h4><h3 id=\"3-5-2-死锁必要条件\"><a href=\"#3-5-2-死锁必要条件\" class=\"headerlink\" title=\"3.5.2 死锁必要条件\"></a>3.5.2 死锁必要条件</h3><p>(1)互斥条件 : 指进程对所分配到的资源进行排它性使用 。</p>\n<p>(2)请求和保持条件 : 指进程已经保持了至少一个资源，但又提出了新的资源 请求 。</p>\n<p>(3)不剥夺条件 : 指进程已获得的资源，在未使用完之前，不能被剥夺，只能 在使用完时由自己释放。</p>\n<p>(4)环路等待条件 : 指在发生死锁时，必然存在一个进程——资源的环形链 。</p>\n<h3 id=\"3-5-3-解决死锁概述\"><a href=\"#3-5-3-解决死锁概述\" class=\"headerlink\" title=\"3.5.3 解决死锁概述\"></a>3.5.3 解决死锁概述</h3><p>(1)预防死锁:是通过设置某些限制条件，去破坏产生死锁的四个必要条件中 的一个或几个条件，来预防发生死锁。</p>\n<p>(2)避免死锁:是在资源的动态分配过程中，用某种方法去防止系统进入不安 全状态，从而避免发生死锁。</p>\n<p>(3)检测死锁:通过系统所设置的检测机构，及时地检测出死锁的发生，并精 确地确定与死锁有关的进程和资源;</p>\n<p>(4)解除死锁:当检测到系统中已发生死锁时，须将进程从死锁状态中解脱出 来。常用的实施方法是撤消或挂起一些进程。</p>\n<h2 id=\"3-6-预防死锁\"><a href=\"#3-6-预防死锁\" class=\"headerlink\" title=\"3.6 预防死锁\"></a>3.6 预防死锁</h2><h4 id=\"1-破坏“请求保持”条件\"><a href=\"#1-破坏“请求保持”条件\" class=\"headerlink\" title=\"1. 破坏“请求保持”条件\"></a>1. 破坏“请求保持”条件</h4><p>系统规定所有进程在开始运行之前，都必须一次性地申请其在整个运行过程 所需的全部资源。</p>\n<p>从而进程在整个运行期间，便不会再提出资源要求，从而摒弃了请求和保持 条件，由此可以避免发生死锁。</p>\n<p> 优点:简单、易于实现且很安全。<br> 缺点:资源被严重浪费，进程经常会发生饥饿现象。</p>\n<h4 id=\"2-摒弃“不剥夺”条件\"><a href=\"#2-摒弃“不剥夺”条件\" class=\"headerlink\" title=\"2. 摒弃“不剥夺”条件\"></a>2. 摒弃“不剥夺”条件</h4><p>当一个已经保持了某些资源的进程，再提出新的资源请求而不能立即得到满 足时，必须释放它已经保持了的所有资源。待以后需要时再重新申请。从而 摒弃了“不剥夺”条件。</p>\n<p><strong>缺点</strong>:实现起来比较复杂且要付出很大代价。</p>\n<ul>\n<li>一个资源在使用一段时间后，它的被迫释放可能会造成前段工作的失效。 – 会使进程前后两次运行的信息不连续。</li>\n<li>因反复地申请和释放资源，致使进程执行被无限推迟，延长进程周转时 间、增加系统开销、降低吞吐量</li>\n</ul>\n<h4 id=\"3-摒弃”环路等待“条件\"><a href=\"#3-摒弃”环路等待“条件\" class=\"headerlink\" title=\"3. 摒弃”环路等待“条件\"></a>3. 摒弃”环路等待“条件</h4><p>这种方法中规定，系统将所有资源按类型进行线性排队，并赋予不同的序号。 所有进程对资源的请求必须严格按照资源序号递增的次序提出，这样，在所 形成的资源分配图中，不可能再出现环路，因而摒弃了“环路等待”条件。</p>\n<p><strong>缺点：</strong></p>\n<ol>\n<li><p>为系统中各类资源分配的序号必须相对稳定，这就限制了新设备类型的</p>\n<p>增加;</p>\n</li>\n<li><p>经常发生作业使用资源的顺序与系统规定资源使用顺序不同的情况，造成资源浪费;</p>\n</li>\n<li><p>增加了程序设计难度。</p>\n</li>\n</ol>\n<h2 id=\"3-7-避免死锁\"><a href=\"#3-7-避免死锁\" class=\"headerlink\" title=\"3.7 避免死锁\"></a>3.7 避免死锁</h2><h3 id=\"3-7-1-安全状态\"><a href=\"#3-7-1-安全状态\" class=\"headerlink\" title=\"3.7.1 安全状态\"></a>3.7.1 安全状态</h3><ul>\n<li>所谓安全状态，是指系统能按某种进程顺序，如&lt;P1，P2，…，Pn&gt;，依次为n 个进程分配其所需资源，直至其最大需求，使每个进程都可顺利地完成，称 系统处于安全状态。</li>\n<li>称〈P1，P2，…，Pn〉序列为安全序列。否则，如果系统无法找到这样一个安 全序列，则称系统处于不安全状态。</li>\n</ul>\n<h3 id=\"3-7-2-银行家算法\"><a href=\"#3-7-2-银行家算法\" class=\"headerlink\" title=\"3.7.2 银行家算法\"></a>3.7.2 银行家算法</h3><p>避免死锁的关键在于如何准确的预测是否会出现死锁，从而避免死锁。最有 代表性的避免死锁的算法是Dijkstra的银行家算法。</p>\n<h4 id=\"1-银行家算法数据结构\"><a href=\"#1-银行家算法数据结构\" class=\"headerlink\" title=\"1. 银行家算法数据结构\"></a>1. 银行家算法数据结构</h4><p>(1)可利用资源向量Available:这是一个含有m个元素的数组，其中的每一个 元素代表一类可利用的资源数目。其数值随该类资源的分配和回收而动态地 改变。 Available[j]=k,表示系统中现有Rj类资源k个。</p>\n<p>(2)最大需求矩阵Max。这是一个n × m的矩阵，它定义了n个进程中每一个进 程对m类资源的最大需求。Max[i,j]=K，表示进程Pi需要Rj类资源的最大数目 为K。</p>\n<p>(3)分配矩阵Allocation是一个nxm矩阵，定义了系统中每一类资源当前已分配给每一进程的资源数。Allocation[i,j]=K，表示进程Pi当前已分 得Rj类资源的数目为K。</p>\n<p>(4)需求矩阵Need。这也是一个n×m的矩阵，用以表示每一个进程尚需的各 类资源数。Need[i,j]=K，表示进程Pi还需要Rj类资源K个，方能完成其任务。</p>\n<p>• 上述三个矩阵的关系:Need[i,j]=Max[i,j] - Allocation[i,j]</p>\n<h4 id=\"2-银行家算法\"><a href=\"#2-银行家算法\" class=\"headerlink\" title=\"2. 银行家算法\"></a>2. 银行家算法</h4><p>设Requesti，是进程Pi的请求向量，当Pi发出资源请求后，系统按下述步骤进行 检查:</p>\n<p>(1)如果Requesti[j]≤Need[i,j],便转向步骤2;否则认为出错，因为它所需要的 资源数已超过它所声明的最大值。</p>\n<p>(2)如果Requesti[j]≤Available[j]，便转向步(3)，否则，表示尚无足够资源， Pi须阻塞等待。</p>\n<p>(3)系统试探着把资源分配给进程Pi ，并修改下面数据结构中的数值: </p>\n<p>Available[j]:= Available[j] - Requesti[j]; Allocation[i,j] : = Allocation[i,j] + Requesti[j]; Need[i,j]: =Need[i,j] - Requesti[j]; </p>\n<p>(4)系统执行安全性算法，检查此次资源分配后，系统是否处于安全状态。若 安全，才正式将资源分配给进程Pi ，以完成本次分配;否则，将本次的试探 分配作废，恢复原来的资源分配状态，让进程Pi等待。 </p>\n<h4 id=\"3-安全性算法\"><a href=\"#3-安全性算法\" class=\"headerlink\" title=\"3. 安全性算法\"></a>3. 安全性算法</h4><p>系统所执行的安全性算法可描述如下:</p>\n<p> (1)设置两个向量:</p>\n<p>1工作向量Work: 它表示系统可提供给进程继续运行所需的各类资源数目，初始值Work:=Available</p>\n<p>2设置数组Finish[n]:初始值Finish[i]:=false; 当Finish[i]:=true时，进程Pi可获得其所需的全部资源，从而顺利执行完成。</p>\n<p>(2)从进程集合中找到一个能满足下述条件的进程Pi : </p>\n<p>1Finish[i]=false;  2 Need[i,j]≤work; <strong>寻找未完成的进程，它的所需资源量小于系统可用资源量</strong></p>\n<p>若找到，执行步骤(3),否则，执行步骤(4)。 </p>\n<p>(3)当进程Pi获得资源后，顺利执行直至完成，并释放出分配给它的资源，故应 执行: </p>\n<p>Work:= Work+Allocation[i,j]; Finish[i] :=true;  go to step 2; </p>\n<p>(4)如果所有进程的Finish[i]=true都满足，则表示系统处于安全状态;否则， 系统处于不安全状态。 </p>\n<p><strong>大题出现 ppt例子</strong></p>\n<h2 id=\"3-8-死锁的检测与解除\"><a href=\"#3-8-死锁的检测与解除\" class=\"headerlink\" title=\"3.8 死锁的检测与解除\"></a>3.8 死锁的检测与解除</h2><h3 id=\"3-8-1-死锁的检验\"><a href=\"#3-8-1-死锁的检验\" class=\"headerlink\" title=\"3.8.1 死锁的检验\"></a>3.8.1 死锁的检验</h3><h4 id=\"1-死锁检测\"><a href=\"#1-死锁检测\" class=\"headerlink\" title=\"1. 死锁检测\"></a>1. 死锁检测</h4><p>如果系统不愿意附加太多约束条件预防死锁，也不希望系统额外开销预测并避 免死锁，那么，只能允许死锁出现，然后，再解除它。</p>\n<p>• 因此，系统需要利用某种方法来检测死锁</p>\n<p>• 资源分配图 该图是由一组结点N和一组边E所组成的一个对偶G=(N,E)</p>\n<p>其中:</p>\n<p>(1)把N分为两个互斥的子集，即一组进程结点P={P1,P2，…，Pn)和一组资 源结点R={R1, R2 ，…， Rn}，N=PUR。 </p>\n<p>(2)凡属于E中的一个边e∈ E都连接着P中的一个结点和R中的一个结点 – e={Pi,Rj} </p>\n<p>它表示进程Pi请求一个单位的rj资源。 – e={Rj，Pi} </p>\n<p>它表示把一个单位的资源Rj分配给进程Pi 。 </p>\n<h4 id=\"2-死锁定理\"><a href=\"#2-死锁定理\" class=\"headerlink\" title=\"2. 死锁定理\"></a>2. 死锁定理</h4><p><img src=\"https://img.cetacis.dev/uploads/big/a4ed842da08a8e4aa93af662aa37612d.png\" alt=\"\"></p>\n<h4 id=\"3-死锁检测算法\"><a href=\"#3-死锁检测算法\" class=\"headerlink\" title=\"3. 死锁检测算法\"></a>3. 死锁检测算法</h4><p>若能消去资源分配图中所有结点的连接边，使全部结点都成为孤立结点，则称 该图是可完全简化图;若不能使该图完全简化，则称该图是不可完全化简图。</p>\n<p>可以证明:当且仅当系统某状态S所对应的资源分配图是不可完全化简的，则S 是死锁状态。该充分条件称为死锁定理。</p>\n<h4 id=\"4-死锁检测中的数据结构\"><a href=\"#4-死锁检测中的数据结构\" class=\"headerlink\" title=\"4.死锁检测中的数据结构\"></a>4.死锁检测中的数据结构</h4><p>(1)可利用资源向量Available，它表示了m类资源中每一类资源的可用数目。</p>\n<p> (2)把不占用资源的进程(Allocation:=0)记入L表中，即Li U L</p>\n<p> (3)从进程集合中找到一个Requesti≤work的进程，做如下处理:</p>\n<ol>\n<li><p>Work:=work十Allocationi，</p>\n</li>\n<li><p>将它记入L表中。</p>\n</li>\n</ol>\n<p>(4)若不能把所有进程都记入L表中，便表明系统状态S的资源分配图是不可 完全简化的。因此，该系统状态将发生死锁。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Work:&#x3D; Available; </span><br><span class=\"line\">\tL:&#x3D;&#123;Li|Allocationi&#x3D;0∩Requesti&#x3D;0&#125; </span><br><span class=\"line\">\tfor all Li∈L do</span><br><span class=\"line\">\tbegin</span><br><span class=\"line\">\tfor all Requesti≤Work do</span><br><span class=\"line\">\t\tbegin </span><br><span class=\"line\">\t\t\tWork:&#x3D;Work十Allocationi;</span><br><span class=\"line\">       Li∪L;</span><br><span class=\"line\">\t\tend </span><br><span class=\"line\">\tend</span><br><span class=\"line\">deadlock:&#x3D; (L&#x3D;&#123;P1，P2，.... ，Pn&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-8-2-死锁的解除\"><a href=\"#3-8-2-死锁的解除\" class=\"headerlink\" title=\"3.8.2 死锁的解除\"></a>3.8.2 死锁的解除</h3><p>当发现有进程死锁时，常采用的两种方法是解除死锁:</p>\n<p> (1)剥夺资源。从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态。</p>\n<p>(2)撤消进程。最简单的撤消进程的方法，是使全部死锁进程都夭折掉;或者 按照某种顺序逐个地撤消进程，直至有足够的资源可用，使死锁状态消除为</p>\n<p>止。</p>\n<p>按照解除死锁复杂度递增的顺序列出解除死锁的方法:</p>\n<ol>\n<li>撤消死锁进程。该方法是目前操作系统中解除死锁的常用方法。</li>\n<li>把死锁进程恢复到前一个检查点，重新执行每个进程。</li>\n<li>按照某种原则逐个选择死锁进程进行撤消，直到解除系统死锁。</li>\n<li>按照某种原则逐个剥夺进程资源，直到解除死锁。</li>\n</ol>\n<p><strong>最小代价原则</strong></p>\n<p>第三种和第四种方法需要选择系统付出代价最小的进程，最小代价原则: </p>\n<p>– 到目前为止，花费处理机的时间最少的进程;</p>\n<p>– 到目前为止，产生输出最少的进程;</p>\n<p>– 估计未执行部分最多的进程;</p>\n<p>– 到目前为止，已获得资源量最少的进程; – 优先级最低的进程。</p>"},{"date":"2020-02-18T16:00:00.000Z","_content":"[自学视频](https://www.bilibili.com/video/av10281109?p=1)\n# Unity\n\n#### 1.1窗口界面分类\n\n![窗口](https://img.cetacis.dev/uploads/2020/02/18/Screen-Shot-2020-02-18-at-5.02.49-PM.png)\n\n* Game\n\n即玩家可见的画面。\n\n在游戏运行时对场景的改变不会存盘。\n\n* 右上角可改变layout\n<!-- more -->\n#### 1.2 菜单界面\n\n![](https://img.cetacis.dev/uploads/2020/02/18/Screen-Shot-2020-02-18-at-5.21.46-PM.png)\n\n#### 1.3 scene与场景漫游\n\nscene\n\n“Q”“W”“E”“R”在场景编辑窗口对窗口与内容进行改变。\n\n双点触控板，ASDWQE对视角进行改变。\n\n在edit->strp setting修改一步的大小\n\ncontrol+旋转/平移=定量旋转/修改\n\nglobal 全局坐标徐 local 自身坐标系\n\ncenter/pivot 同时选中两个物体时的坐标系 \n\n![](https://img.cetacis.dev/uploads/2020/02/18/Screen-Shot-2020-02-18-at-7.50.31-PM.png)\n\n![切换23d](https://img.cetacis.dev/uploads/2020/02/18/Screen-Shot-2020-02-18-at-7.55.15-PM.png)\n\n可以点xyz获得视野，也可以shift+中间获得45度视野 \n\n#### 1.4 Hierarchy与场景搭建\n\n1. 基本组件\n\n   game object\n\n   **camera **\n   **particle system（粒子系统）**\n\n   * emisson 释放速度\n   * shape 释放形状\n   * force over time 添加物理效果（坠落感）\n   *  external force（风）\n   * collision 粒子碰撞\n   * render 修改粒子材质\n\n   **GUIs**\n\n2. 灯光组件\n\n   平行光：模拟太阳光\n   \n   area light：只在最终渲染的时候用到，在场景中没有体现。\n   \n3. 物体组件\n\n   capsule collider 碰撞检测轮廓 绿色线框代表collider 蓝线为三角面\n\n   mesh filter 材质\n\n4. sprite组件\n\n   多用于展现2d动画资源。3d模拟背景动画。\n\n   将资源silce，apply以后就是sprite。\n\n5. terrain组件 \n\n   地形模型\n\n   创建到场景物体里的terrain会自动在assert中生成一个新的资源。\n\n#### 1.5 窗口操作资源管理\n\nproject\n\n对资源修改无法撤销\n\n新建：\n\n* script 脚本\n* shader 修饰材质\n* Newcomputeshader gpushader\n* prefab\n* material 材质\n* cubmap 立方体贴图 （天空盒）\n\n材质 = texture+shader\n\n**texture** ：UI、Mesh模型、粒子效果、视频资源 、render text（渲染贴图）：将camera捕捉到的东西通过渲染变成texture，比如小地图等\n\n![render texture](https://img.cetacis.dev/uploads/2020/02/19/Screen-Shot-2020-02-19-at-3.10.29-PM.png)\n\n**shader（着色器）**2.5.5\n\n* 标准着色器\n\n* 透明着色器\n\n* 镂空着色器\n\n* 自发光着色器\n\n* 反射着色器\n\n  在材质球处可以选择着色器\n\n  diffuse\n\n   bumped diffuse（texture+normal texture）\n\n  diffuse detail （加细节）\n\n  decal（多种贴图重叠效果）\n\n  ... \n\n#### 1.6 项目资源管理\n\n* 当导入package，当前文件夹有与导入文件夹重名的文件夹，可能会对文件夹进行合并，造成不必要的麻烦。应该新建文件夹再导入。\n\n* 特殊文件夹命名：\n\n  standard Assets/pro standard assets: 非unity内置包，会被预先加载。\n\n  Editor  拓展编辑器\n\n  Plugin 插件 dll文件\n\n  resources 资源\n\n#### 2.1 Inspector与游戏组件\n\n检视面板：inspecter 属性控制面板\n\nadd component（添加组件）2.6.4\n\neffect：\n\n* trail Render（轨迹组件）\n\n  *因为是特效组件，所以必须添加一个partical shader*\n\n* line render\n\n  画线（激光） \n\n* Lens flare \n\n  将asserts中的lens flare文件拖入此组件，即可实现太阳光晕效果\n\n* halo 光晕\n\n* projector 投影器\n\n  可以将材质达到plate上，实现对角色的灯光跟随\n\nrender：\n\n怎么将效果渲染在摄像机/屏幕上\n\n* camera 将看到的打到game中，或者render texture中\n\n  skybox、flare layer、audio layer、Guilayer\n\n*  Light Prode group 烘焙动态物体\n\n  1. gameobject加Light Prode group组件（设置探针计算光照）\n  2. 在物体上添加mesh render组件 并且勾选use light prode。\n  3. 烘焙 烘焙之后，一般移动物体光照就不会在变，但是在这里，因为加入了光照探针，所以会变化\n\n* Light 三中光源\n\n* LOPGROUP 不同距离的细节分级\n\n脚本组件\n\n![unity构架](https://img.cetacis.dev/uploads/2020/02/19/Screen-Shot-2020-02-19-at-8.50.05-PM.png)\n\nC# \n\n\n\n![struct](https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-12.20.49-PM.png)\n\n![枚举类型：限定变量可能性](https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-12.24.17-PM.png)\n\n![枚举类型强制类型转换](https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-12.28.11-PM.png)\n\nvar 声明\n\n**Class**\n\n 成员变量/方法 实例化 构造函数 \n\n静态方法/ 成员变量直接存储在class中，不需要实例化后调用（实际上，实例化无法调用static的方法/变量）\n\n![属性变量Age](https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-2.40.30-PM.png)\n\n*属性变量方便地完成了对变量的getset并且具有安全性*\n\n**interface**\n\n方法属性索引事件\n\n在接口中定义方法，在有一个类链接这个借口，在这个类中完成方法。\n\n![接口](https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-2.53.48-PM.png)\n\n**abstract class **\n\n抽象类：只声明方法，然后它被其他类继承，实现它的方法。\n\n![抽象类与类的继承](https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-2.57.39-PM.png)\n\n**抽象类和接口区别与共同点**\n\n抽象类归根结底是类，可以声明一个抽象方法但是由其他类继承抽象类来实现这个方法，也可以直接在抽象类里直接实现一个方法，根据父类的性质，它的 子类都可以调用这个方法。\n\n接口则没有类的性质，只能有方法属性索引事件，不能有成员变量字段。\n\n只能继承一个抽象类但是可以继承多个接口\n\n两者都不能被实例化\n\n**权限**\n\n字段一般都是private+setget方法。\n\n或者public属性\n\n![](https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-3.11.06-PM.png)\n\n脚本\n\n**debug信息**\n\n![](https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-5.02.18-PM.png)\n\n如果在 Update 里，则没一帧都会显示\n\n**脚本生命周期**\n\n![](https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-5.13.29-PM.png)\n\n* reset 是物体添加组件的时候\n\n* awake是物体存在就会调用\n\n* 当脚本被调用就会调用start\n\n  \n\n![](https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-5.15.57-PM.png)\n\n* fixupdate ->update ->LateUpdate\n\n  fixupdate是根据物理事件调用，update lateuodate是基于时间调用。\n\n![](https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-5.23.04-PM.png)\n\n* ondisable 脚本停止\n* ondestroy 物体销毁\n\n####  behavior事件相应\n\n\n\n**启动刷新函数：**\n\n1. 启动函数\n\n**awake()**\n\n* 初始化函数，游戏开始时系统自动调用\n* 一般用来创建变量\n* 无论脚本组件是否被激活都被调用\n\n**start()**\n\n* 初始化函数，在awake之后update之前\n* 一般给变量赋值\n* 只有脚本组件激活时才能被调用\n\n2. 刷新函数\n\n**update()**\n\n* 每一帧调用\n* 用于非物理运动（匀速运动）\n\n**FixedUpdate()**\n\n* 固定时间调用一次\n* 一般用于物理运动（物理运算）\n* edit->time可进行修改\n\n#### 交互函数\n\n![](https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-5.43.12-PM.png)\n\n![](https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-5.43.22-PM.png)\n\n**物理**\n\n![](https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-5.43.50-PM.png)\n\nOnTriggerEnter()\n\nCube1 :加入box collider组件（碰撞体），勾选trigger。cube1是触发器\n\n![cube1](https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-5.51.24-PM.png)\n\nCube2:挂脚本，加碰撞体，用rigidbody加重力。当cube1（触发器进入），则cube1 位移\n\n![cube2](https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-5.53.08-PM.png)\n\n![](https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-5.55.21-PM.png)\n\n**OnTriggerStay()**当碰撞体接触触发器时，此函数在每一帧被调用\n\n![](https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-6.02.26-PM.png)\n\n给cube2挂上脚本后，当cube1触碰cube2，cube1会向上移动。当cube1不加重力，他会一直上升。当它加上重力，当两者分开cube1又会下降。\n","source":"_posts/Unity.md","raw":"---\n\ndate: 2020/2/19\ntags:\n- 自学笔记\n- u3d\ncategories:\n- 游戏及图形学\n- unity\n---\n[自学视频](https://www.bilibili.com/video/av10281109?p=1)\n# Unity\n\n#### 1.1窗口界面分类\n\n![窗口](https://img.cetacis.dev/uploads/2020/02/18/Screen-Shot-2020-02-18-at-5.02.49-PM.png)\n\n* Game\n\n即玩家可见的画面。\n\n在游戏运行时对场景的改变不会存盘。\n\n* 右上角可改变layout\n<!-- more -->\n#### 1.2 菜单界面\n\n![](https://img.cetacis.dev/uploads/2020/02/18/Screen-Shot-2020-02-18-at-5.21.46-PM.png)\n\n#### 1.3 scene与场景漫游\n\nscene\n\n“Q”“W”“E”“R”在场景编辑窗口对窗口与内容进行改变。\n\n双点触控板，ASDWQE对视角进行改变。\n\n在edit->strp setting修改一步的大小\n\ncontrol+旋转/平移=定量旋转/修改\n\nglobal 全局坐标徐 local 自身坐标系\n\ncenter/pivot 同时选中两个物体时的坐标系 \n\n![](https://img.cetacis.dev/uploads/2020/02/18/Screen-Shot-2020-02-18-at-7.50.31-PM.png)\n\n![切换23d](https://img.cetacis.dev/uploads/2020/02/18/Screen-Shot-2020-02-18-at-7.55.15-PM.png)\n\n可以点xyz获得视野，也可以shift+中间获得45度视野 \n\n#### 1.4 Hierarchy与场景搭建\n\n1. 基本组件\n\n   game object\n\n   **camera **\n   **particle system（粒子系统）**\n\n   * emisson 释放速度\n   * shape 释放形状\n   * force over time 添加物理效果（坠落感）\n   *  external force（风）\n   * collision 粒子碰撞\n   * render 修改粒子材质\n\n   **GUIs**\n\n2. 灯光组件\n\n   平行光：模拟太阳光\n   \n   area light：只在最终渲染的时候用到，在场景中没有体现。\n   \n3. 物体组件\n\n   capsule collider 碰撞检测轮廓 绿色线框代表collider 蓝线为三角面\n\n   mesh filter 材质\n\n4. sprite组件\n\n   多用于展现2d动画资源。3d模拟背景动画。\n\n   将资源silce，apply以后就是sprite。\n\n5. terrain组件 \n\n   地形模型\n\n   创建到场景物体里的terrain会自动在assert中生成一个新的资源。\n\n#### 1.5 窗口操作资源管理\n\nproject\n\n对资源修改无法撤销\n\n新建：\n\n* script 脚本\n* shader 修饰材质\n* Newcomputeshader gpushader\n* prefab\n* material 材质\n* cubmap 立方体贴图 （天空盒）\n\n材质 = texture+shader\n\n**texture** ：UI、Mesh模型、粒子效果、视频资源 、render text（渲染贴图）：将camera捕捉到的东西通过渲染变成texture，比如小地图等\n\n![render texture](https://img.cetacis.dev/uploads/2020/02/19/Screen-Shot-2020-02-19-at-3.10.29-PM.png)\n\n**shader（着色器）**2.5.5\n\n* 标准着色器\n\n* 透明着色器\n\n* 镂空着色器\n\n* 自发光着色器\n\n* 反射着色器\n\n  在材质球处可以选择着色器\n\n  diffuse\n\n   bumped diffuse（texture+normal texture）\n\n  diffuse detail （加细节）\n\n  decal（多种贴图重叠效果）\n\n  ... \n\n#### 1.6 项目资源管理\n\n* 当导入package，当前文件夹有与导入文件夹重名的文件夹，可能会对文件夹进行合并，造成不必要的麻烦。应该新建文件夹再导入。\n\n* 特殊文件夹命名：\n\n  standard Assets/pro standard assets: 非unity内置包，会被预先加载。\n\n  Editor  拓展编辑器\n\n  Plugin 插件 dll文件\n\n  resources 资源\n\n#### 2.1 Inspector与游戏组件\n\n检视面板：inspecter 属性控制面板\n\nadd component（添加组件）2.6.4\n\neffect：\n\n* trail Render（轨迹组件）\n\n  *因为是特效组件，所以必须添加一个partical shader*\n\n* line render\n\n  画线（激光） \n\n* Lens flare \n\n  将asserts中的lens flare文件拖入此组件，即可实现太阳光晕效果\n\n* halo 光晕\n\n* projector 投影器\n\n  可以将材质达到plate上，实现对角色的灯光跟随\n\nrender：\n\n怎么将效果渲染在摄像机/屏幕上\n\n* camera 将看到的打到game中，或者render texture中\n\n  skybox、flare layer、audio layer、Guilayer\n\n*  Light Prode group 烘焙动态物体\n\n  1. gameobject加Light Prode group组件（设置探针计算光照）\n  2. 在物体上添加mesh render组件 并且勾选use light prode。\n  3. 烘焙 烘焙之后，一般移动物体光照就不会在变，但是在这里，因为加入了光照探针，所以会变化\n\n* Light 三中光源\n\n* LOPGROUP 不同距离的细节分级\n\n脚本组件\n\n![unity构架](https://img.cetacis.dev/uploads/2020/02/19/Screen-Shot-2020-02-19-at-8.50.05-PM.png)\n\nC# \n\n\n\n![struct](https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-12.20.49-PM.png)\n\n![枚举类型：限定变量可能性](https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-12.24.17-PM.png)\n\n![枚举类型强制类型转换](https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-12.28.11-PM.png)\n\nvar 声明\n\n**Class**\n\n 成员变量/方法 实例化 构造函数 \n\n静态方法/ 成员变量直接存储在class中，不需要实例化后调用（实际上，实例化无法调用static的方法/变量）\n\n![属性变量Age](https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-2.40.30-PM.png)\n\n*属性变量方便地完成了对变量的getset并且具有安全性*\n\n**interface**\n\n方法属性索引事件\n\n在接口中定义方法，在有一个类链接这个借口，在这个类中完成方法。\n\n![接口](https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-2.53.48-PM.png)\n\n**abstract class **\n\n抽象类：只声明方法，然后它被其他类继承，实现它的方法。\n\n![抽象类与类的继承](https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-2.57.39-PM.png)\n\n**抽象类和接口区别与共同点**\n\n抽象类归根结底是类，可以声明一个抽象方法但是由其他类继承抽象类来实现这个方法，也可以直接在抽象类里直接实现一个方法，根据父类的性质，它的 子类都可以调用这个方法。\n\n接口则没有类的性质，只能有方法属性索引事件，不能有成员变量字段。\n\n只能继承一个抽象类但是可以继承多个接口\n\n两者都不能被实例化\n\n**权限**\n\n字段一般都是private+setget方法。\n\n或者public属性\n\n![](https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-3.11.06-PM.png)\n\n脚本\n\n**debug信息**\n\n![](https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-5.02.18-PM.png)\n\n如果在 Update 里，则没一帧都会显示\n\n**脚本生命周期**\n\n![](https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-5.13.29-PM.png)\n\n* reset 是物体添加组件的时候\n\n* awake是物体存在就会调用\n\n* 当脚本被调用就会调用start\n\n  \n\n![](https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-5.15.57-PM.png)\n\n* fixupdate ->update ->LateUpdate\n\n  fixupdate是根据物理事件调用，update lateuodate是基于时间调用。\n\n![](https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-5.23.04-PM.png)\n\n* ondisable 脚本停止\n* ondestroy 物体销毁\n\n####  behavior事件相应\n\n\n\n**启动刷新函数：**\n\n1. 启动函数\n\n**awake()**\n\n* 初始化函数，游戏开始时系统自动调用\n* 一般用来创建变量\n* 无论脚本组件是否被激活都被调用\n\n**start()**\n\n* 初始化函数，在awake之后update之前\n* 一般给变量赋值\n* 只有脚本组件激活时才能被调用\n\n2. 刷新函数\n\n**update()**\n\n* 每一帧调用\n* 用于非物理运动（匀速运动）\n\n**FixedUpdate()**\n\n* 固定时间调用一次\n* 一般用于物理运动（物理运算）\n* edit->time可进行修改\n\n#### 交互函数\n\n![](https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-5.43.12-PM.png)\n\n![](https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-5.43.22-PM.png)\n\n**物理**\n\n![](https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-5.43.50-PM.png)\n\nOnTriggerEnter()\n\nCube1 :加入box collider组件（碰撞体），勾选trigger。cube1是触发器\n\n![cube1](https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-5.51.24-PM.png)\n\nCube2:挂脚本，加碰撞体，用rigidbody加重力。当cube1（触发器进入），则cube1 位移\n\n![cube2](https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-5.53.08-PM.png)\n\n![](https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-5.55.21-PM.png)\n\n**OnTriggerStay()**当碰撞体接触触发器时，此函数在每一帧被调用\n\n![](https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-6.02.26-PM.png)\n\n给cube2挂上脚本后，当cube1触碰cube2，cube1会向上移动。当cube1不加重力，他会一直上升。当它加上重力，当两者分开cube1又会下降。\n","slug":"Unity","published":1,"updated":"2020-03-25T01:38:33.000Z","title":"Unity","_id":"ck849aval0004thes0j7d8lhs","comments":1,"layout":"post","photos":[],"link":"","content":"<p><a href=\"https://www.bilibili.com/video/av10281109?p=1\" target=\"_blank\" rel=\"noopener\">自学视频</a></p>\n<h1 id=\"Unity\"><a href=\"#Unity\" class=\"headerlink\" title=\"Unity\"></a>Unity</h1><h4 id=\"1-1窗口界面分类\"><a href=\"#1-1窗口界面分类\" class=\"headerlink\" title=\"1.1窗口界面分类\"></a>1.1窗口界面分类</h4><p><img src=\"https://img.cetacis.dev/uploads/2020/02/18/Screen-Shot-2020-02-18-at-5.02.49-PM.png\" alt=\"窗口\"></p>\n<ul>\n<li>Game</li>\n</ul>\n<p>即玩家可见的画面。</p>\n<p>在游戏运行时对场景的改变不会存盘。</p>\n<ul>\n<li>右上角可改变layout<a id=\"more\"></a>\n<h4 id=\"1-2-菜单界面\"><a href=\"#1-2-菜单界面\" class=\"headerlink\" title=\"1.2 菜单界面\"></a>1.2 菜单界面</h4></li>\n</ul>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/18/Screen-Shot-2020-02-18-at-5.21.46-PM.png\" alt=\"\"></p>\n<h4 id=\"1-3-scene与场景漫游\"><a href=\"#1-3-scene与场景漫游\" class=\"headerlink\" title=\"1.3 scene与场景漫游\"></a>1.3 scene与场景漫游</h4><p>scene</p>\n<p>“Q”“W”“E”“R”在场景编辑窗口对窗口与内容进行改变。</p>\n<p>双点触控板，ASDWQE对视角进行改变。</p>\n<p>在edit-&gt;strp setting修改一步的大小</p>\n<p>control+旋转/平移=定量旋转/修改</p>\n<p>global 全局坐标徐 local 自身坐标系</p>\n<p>center/pivot 同时选中两个物体时的坐标系 </p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/18/Screen-Shot-2020-02-18-at-7.50.31-PM.png\" alt=\"\"></p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/18/Screen-Shot-2020-02-18-at-7.55.15-PM.png\" alt=\"切换23d\"></p>\n<p>可以点xyz获得视野，也可以shift+中间获得45度视野 </p>\n<h4 id=\"1-4-Hierarchy与场景搭建\"><a href=\"#1-4-Hierarchy与场景搭建\" class=\"headerlink\" title=\"1.4 Hierarchy与场景搭建\"></a>1.4 Hierarchy与场景搭建</h4><ol>\n<li><p>基本组件</p>\n<p>game object</p>\n<p><strong>camera **<br>**particle system（粒子系统）</strong></p>\n<ul>\n<li>emisson 释放速度</li>\n<li>shape 释放形状</li>\n<li>force over time 添加物理效果（坠落感）</li>\n<li>external force（风）</li>\n<li>collision 粒子碰撞</li>\n<li>render 修改粒子材质</li>\n</ul>\n<p><strong>GUIs</strong></p>\n</li>\n<li><p>灯光组件</p>\n<p>平行光：模拟太阳光</p>\n<p>area light：只在最终渲染的时候用到，在场景中没有体现。</p>\n</li>\n<li><p>物体组件</p>\n<p>capsule collider 碰撞检测轮廓 绿色线框代表collider 蓝线为三角面</p>\n<p>mesh filter 材质</p>\n</li>\n<li><p>sprite组件</p>\n<p>多用于展现2d动画资源。3d模拟背景动画。</p>\n<p>将资源silce，apply以后就是sprite。</p>\n</li>\n<li><p>terrain组件 </p>\n<p>地形模型</p>\n<p>创建到场景物体里的terrain会自动在assert中生成一个新的资源。</p>\n</li>\n</ol>\n<h4 id=\"1-5-窗口操作资源管理\"><a href=\"#1-5-窗口操作资源管理\" class=\"headerlink\" title=\"1.5 窗口操作资源管理\"></a>1.5 窗口操作资源管理</h4><p>project</p>\n<p>对资源修改无法撤销</p>\n<p>新建：</p>\n<ul>\n<li>script 脚本</li>\n<li>shader 修饰材质</li>\n<li>Newcomputeshader gpushader</li>\n<li>prefab</li>\n<li>material 材质</li>\n<li>cubmap 立方体贴图 （天空盒）</li>\n</ul>\n<p>材质 = texture+shader</p>\n<p><strong>texture</strong> ：UI、Mesh模型、粒子效果、视频资源 、render text（渲染贴图）：将camera捕捉到的东西通过渲染变成texture，比如小地图等</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/19/Screen-Shot-2020-02-19-at-3.10.29-PM.png\" alt=\"render texture\"></p>\n<p><strong>shader（着色器）</strong>2.5.5</p>\n<ul>\n<li><p>标准着色器</p>\n</li>\n<li><p>透明着色器</p>\n</li>\n<li><p>镂空着色器</p>\n</li>\n<li><p>自发光着色器</p>\n</li>\n<li><p>反射着色器</p>\n<p>在材质球处可以选择着色器</p>\n<p>diffuse</p>\n<p> bumped diffuse（texture+normal texture）</p>\n<p>diffuse detail （加细节）</p>\n<p>decal（多种贴图重叠效果）</p>\n<p>… </p>\n</li>\n</ul>\n<h4 id=\"1-6-项目资源管理\"><a href=\"#1-6-项目资源管理\" class=\"headerlink\" title=\"1.6 项目资源管理\"></a>1.6 项目资源管理</h4><ul>\n<li><p>当导入package，当前文件夹有与导入文件夹重名的文件夹，可能会对文件夹进行合并，造成不必要的麻烦。应该新建文件夹再导入。</p>\n</li>\n<li><p>特殊文件夹命名：</p>\n<p>standard Assets/pro standard assets: 非unity内置包，会被预先加载。</p>\n<p>Editor  拓展编辑器</p>\n<p>Plugin 插件 dll文件</p>\n<p>resources 资源</p>\n</li>\n</ul>\n<h4 id=\"2-1-Inspector与游戏组件\"><a href=\"#2-1-Inspector与游戏组件\" class=\"headerlink\" title=\"2.1 Inspector与游戏组件\"></a>2.1 Inspector与游戏组件</h4><p>检视面板：inspecter 属性控制面板</p>\n<p>add component（添加组件）2.6.4</p>\n<p>effect：</p>\n<ul>\n<li><p>trail Render（轨迹组件）</p>\n<p><em>因为是特效组件，所以必须添加一个partical shader</em></p>\n</li>\n<li><p>line render</p>\n<p>画线（激光） </p>\n</li>\n<li><p>Lens flare </p>\n<p>将asserts中的lens flare文件拖入此组件，即可实现太阳光晕效果</p>\n</li>\n<li><p>halo 光晕</p>\n</li>\n<li><p>projector 投影器</p>\n<p>可以将材质达到plate上，实现对角色的灯光跟随</p>\n</li>\n</ul>\n<p>render：</p>\n<p>怎么将效果渲染在摄像机/屏幕上</p>\n<ul>\n<li><p>camera 将看到的打到game中，或者render texture中</p>\n<p>skybox、flare layer、audio layer、Guilayer</p>\n</li>\n<li><p>Light Prode group 烘焙动态物体</p>\n<ol>\n<li>gameobject加Light Prode group组件（设置探针计算光照）</li>\n<li>在物体上添加mesh render组件 并且勾选use light prode。</li>\n<li>烘焙 烘焙之后，一般移动物体光照就不会在变，但是在这里，因为加入了光照探针，所以会变化</li>\n</ol>\n</li>\n<li><p>Light 三中光源</p>\n</li>\n<li><p>LOPGROUP 不同距离的细节分级</p>\n</li>\n</ul>\n<p>脚本组件</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/19/Screen-Shot-2020-02-19-at-8.50.05-PM.png\" alt=\"unity构架\"></p>\n<p>C# </p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-12.20.49-PM.png\" alt=\"struct\"></p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-12.24.17-PM.png\" alt=\"枚举类型：限定变量可能性\"></p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-12.28.11-PM.png\" alt=\"枚举类型强制类型转换\"></p>\n<p>var 声明</p>\n<p><strong>Class</strong></p>\n<p> 成员变量/方法 实例化 构造函数 </p>\n<p>静态方法/ 成员变量直接存储在class中，不需要实例化后调用（实际上，实例化无法调用static的方法/变量）</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-2.40.30-PM.png\" alt=\"属性变量Age\"></p>\n<p><em>属性变量方便地完成了对变量的getset并且具有安全性</em></p>\n<p><strong>interface</strong></p>\n<p>方法属性索引事件</p>\n<p>在接口中定义方法，在有一个类链接这个借口，在这个类中完成方法。</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-2.53.48-PM.png\" alt=\"接口\"></p>\n<p>*<em>abstract class *</em></p>\n<p>抽象类：只声明方法，然后它被其他类继承，实现它的方法。</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-2.57.39-PM.png\" alt=\"抽象类与类的继承\"></p>\n<p><strong>抽象类和接口区别与共同点</strong></p>\n<p>抽象类归根结底是类，可以声明一个抽象方法但是由其他类继承抽象类来实现这个方法，也可以直接在抽象类里直接实现一个方法，根据父类的性质，它的 子类都可以调用这个方法。</p>\n<p>接口则没有类的性质，只能有方法属性索引事件，不能有成员变量字段。</p>\n<p>只能继承一个抽象类但是可以继承多个接口</p>\n<p>两者都不能被实例化</p>\n<p><strong>权限</strong></p>\n<p>字段一般都是private+setget方法。</p>\n<p>或者public属性</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-3.11.06-PM.png\" alt=\"\"></p>\n<p>脚本</p>\n<p><strong>debug信息</strong></p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-5.02.18-PM.png\" alt=\"\"></p>\n<p>如果在 Update 里，则没一帧都会显示</p>\n<p><strong>脚本生命周期</strong></p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-5.13.29-PM.png\" alt=\"\"></p>\n<ul>\n<li><p>reset 是物体添加组件的时候</p>\n</li>\n<li><p>awake是物体存在就会调用</p>\n</li>\n<li><p>当脚本被调用就会调用start</p>\n</li>\n</ul>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-5.15.57-PM.png\" alt=\"\"></p>\n<ul>\n<li><p>fixupdate -&gt;update -&gt;LateUpdate</p>\n<p>fixupdate是根据物理事件调用，update lateuodate是基于时间调用。</p>\n</li>\n</ul>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-5.23.04-PM.png\" alt=\"\"></p>\n<ul>\n<li>ondisable 脚本停止</li>\n<li>ondestroy 物体销毁</li>\n</ul>\n<h4 id=\"behavior事件相应\"><a href=\"#behavior事件相应\" class=\"headerlink\" title=\"behavior事件相应\"></a>behavior事件相应</h4><p><strong>启动刷新函数：</strong></p>\n<ol>\n<li>启动函数</li>\n</ol>\n<p><strong>awake()</strong></p>\n<ul>\n<li>初始化函数，游戏开始时系统自动调用</li>\n<li>一般用来创建变量</li>\n<li>无论脚本组件是否被激活都被调用</li>\n</ul>\n<p><strong>start()</strong></p>\n<ul>\n<li>初始化函数，在awake之后update之前</li>\n<li>一般给变量赋值</li>\n<li>只有脚本组件激活时才能被调用</li>\n</ul>\n<ol start=\"2\">\n<li>刷新函数</li>\n</ol>\n<p><strong>update()</strong></p>\n<ul>\n<li>每一帧调用</li>\n<li>用于非物理运动（匀速运动）</li>\n</ul>\n<p><strong>FixedUpdate()</strong></p>\n<ul>\n<li>固定时间调用一次</li>\n<li>一般用于物理运动（物理运算）</li>\n<li>edit-&gt;time可进行修改</li>\n</ul>\n<h4 id=\"交互函数\"><a href=\"#交互函数\" class=\"headerlink\" title=\"交互函数\"></a>交互函数</h4><p><img src=\"https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-5.43.12-PM.png\" alt=\"\"></p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-5.43.22-PM.png\" alt=\"\"></p>\n<p><strong>物理</strong></p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-5.43.50-PM.png\" alt=\"\"></p>\n<p>OnTriggerEnter()</p>\n<p>Cube1 :加入box collider组件（碰撞体），勾选trigger。cube1是触发器</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-5.51.24-PM.png\" alt=\"cube1\"></p>\n<p>Cube2:挂脚本，加碰撞体，用rigidbody加重力。当cube1（触发器进入），则cube1 位移</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-5.53.08-PM.png\" alt=\"cube2\"></p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-5.55.21-PM.png\" alt=\"\"></p>\n<p><strong>OnTriggerStay()</strong>当碰撞体接触触发器时，此函数在每一帧被调用</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-6.02.26-PM.png\" alt=\"\"></p>\n<p>给cube2挂上脚本后，当cube1触碰cube2，cube1会向上移动。当cube1不加重力，他会一直上升。当它加上重力，当两者分开cube1又会下降。</p>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://www.bilibili.com/video/av10281109?p=1\" target=\"_blank\" rel=\"noopener\">自学视频</a></p>\n<h1 id=\"Unity\"><a href=\"#Unity\" class=\"headerlink\" title=\"Unity\"></a>Unity</h1><h4 id=\"1-1窗口界面分类\"><a href=\"#1-1窗口界面分类\" class=\"headerlink\" title=\"1.1窗口界面分类\"></a>1.1窗口界面分类</h4><p><img src=\"https://img.cetacis.dev/uploads/2020/02/18/Screen-Shot-2020-02-18-at-5.02.49-PM.png\" alt=\"窗口\"></p>\n<ul>\n<li>Game</li>\n</ul>\n<p>即玩家可见的画面。</p>\n<p>在游戏运行时对场景的改变不会存盘。</p>\n<ul>\n<li>右上角可改变layout","more":"<h4 id=\"1-2-菜单界面\"><a href=\"#1-2-菜单界面\" class=\"headerlink\" title=\"1.2 菜单界面\"></a>1.2 菜单界面</h4></li>\n</ul>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/18/Screen-Shot-2020-02-18-at-5.21.46-PM.png\" alt=\"\"></p>\n<h4 id=\"1-3-scene与场景漫游\"><a href=\"#1-3-scene与场景漫游\" class=\"headerlink\" title=\"1.3 scene与场景漫游\"></a>1.3 scene与场景漫游</h4><p>scene</p>\n<p>“Q”“W”“E”“R”在场景编辑窗口对窗口与内容进行改变。</p>\n<p>双点触控板，ASDWQE对视角进行改变。</p>\n<p>在edit-&gt;strp setting修改一步的大小</p>\n<p>control+旋转/平移=定量旋转/修改</p>\n<p>global 全局坐标徐 local 自身坐标系</p>\n<p>center/pivot 同时选中两个物体时的坐标系 </p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/18/Screen-Shot-2020-02-18-at-7.50.31-PM.png\" alt=\"\"></p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/18/Screen-Shot-2020-02-18-at-7.55.15-PM.png\" alt=\"切换23d\"></p>\n<p>可以点xyz获得视野，也可以shift+中间获得45度视野 </p>\n<h4 id=\"1-4-Hierarchy与场景搭建\"><a href=\"#1-4-Hierarchy与场景搭建\" class=\"headerlink\" title=\"1.4 Hierarchy与场景搭建\"></a>1.4 Hierarchy与场景搭建</h4><ol>\n<li><p>基本组件</p>\n<p>game object</p>\n<p><strong>camera **<br>**particle system（粒子系统）</strong></p>\n<ul>\n<li>emisson 释放速度</li>\n<li>shape 释放形状</li>\n<li>force over time 添加物理效果（坠落感）</li>\n<li>external force（风）</li>\n<li>collision 粒子碰撞</li>\n<li>render 修改粒子材质</li>\n</ul>\n<p><strong>GUIs</strong></p>\n</li>\n<li><p>灯光组件</p>\n<p>平行光：模拟太阳光</p>\n<p>area light：只在最终渲染的时候用到，在场景中没有体现。</p>\n</li>\n<li><p>物体组件</p>\n<p>capsule collider 碰撞检测轮廓 绿色线框代表collider 蓝线为三角面</p>\n<p>mesh filter 材质</p>\n</li>\n<li><p>sprite组件</p>\n<p>多用于展现2d动画资源。3d模拟背景动画。</p>\n<p>将资源silce，apply以后就是sprite。</p>\n</li>\n<li><p>terrain组件 </p>\n<p>地形模型</p>\n<p>创建到场景物体里的terrain会自动在assert中生成一个新的资源。</p>\n</li>\n</ol>\n<h4 id=\"1-5-窗口操作资源管理\"><a href=\"#1-5-窗口操作资源管理\" class=\"headerlink\" title=\"1.5 窗口操作资源管理\"></a>1.5 窗口操作资源管理</h4><p>project</p>\n<p>对资源修改无法撤销</p>\n<p>新建：</p>\n<ul>\n<li>script 脚本</li>\n<li>shader 修饰材质</li>\n<li>Newcomputeshader gpushader</li>\n<li>prefab</li>\n<li>material 材质</li>\n<li>cubmap 立方体贴图 （天空盒）</li>\n</ul>\n<p>材质 = texture+shader</p>\n<p><strong>texture</strong> ：UI、Mesh模型、粒子效果、视频资源 、render text（渲染贴图）：将camera捕捉到的东西通过渲染变成texture，比如小地图等</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/19/Screen-Shot-2020-02-19-at-3.10.29-PM.png\" alt=\"render texture\"></p>\n<p><strong>shader（着色器）</strong>2.5.5</p>\n<ul>\n<li><p>标准着色器</p>\n</li>\n<li><p>透明着色器</p>\n</li>\n<li><p>镂空着色器</p>\n</li>\n<li><p>自发光着色器</p>\n</li>\n<li><p>反射着色器</p>\n<p>在材质球处可以选择着色器</p>\n<p>diffuse</p>\n<p> bumped diffuse（texture+normal texture）</p>\n<p>diffuse detail （加细节）</p>\n<p>decal（多种贴图重叠效果）</p>\n<p>… </p>\n</li>\n</ul>\n<h4 id=\"1-6-项目资源管理\"><a href=\"#1-6-项目资源管理\" class=\"headerlink\" title=\"1.6 项目资源管理\"></a>1.6 项目资源管理</h4><ul>\n<li><p>当导入package，当前文件夹有与导入文件夹重名的文件夹，可能会对文件夹进行合并，造成不必要的麻烦。应该新建文件夹再导入。</p>\n</li>\n<li><p>特殊文件夹命名：</p>\n<p>standard Assets/pro standard assets: 非unity内置包，会被预先加载。</p>\n<p>Editor  拓展编辑器</p>\n<p>Plugin 插件 dll文件</p>\n<p>resources 资源</p>\n</li>\n</ul>\n<h4 id=\"2-1-Inspector与游戏组件\"><a href=\"#2-1-Inspector与游戏组件\" class=\"headerlink\" title=\"2.1 Inspector与游戏组件\"></a>2.1 Inspector与游戏组件</h4><p>检视面板：inspecter 属性控制面板</p>\n<p>add component（添加组件）2.6.4</p>\n<p>effect：</p>\n<ul>\n<li><p>trail Render（轨迹组件）</p>\n<p><em>因为是特效组件，所以必须添加一个partical shader</em></p>\n</li>\n<li><p>line render</p>\n<p>画线（激光） </p>\n</li>\n<li><p>Lens flare </p>\n<p>将asserts中的lens flare文件拖入此组件，即可实现太阳光晕效果</p>\n</li>\n<li><p>halo 光晕</p>\n</li>\n<li><p>projector 投影器</p>\n<p>可以将材质达到plate上，实现对角色的灯光跟随</p>\n</li>\n</ul>\n<p>render：</p>\n<p>怎么将效果渲染在摄像机/屏幕上</p>\n<ul>\n<li><p>camera 将看到的打到game中，或者render texture中</p>\n<p>skybox、flare layer、audio layer、Guilayer</p>\n</li>\n<li><p>Light Prode group 烘焙动态物体</p>\n<ol>\n<li>gameobject加Light Prode group组件（设置探针计算光照）</li>\n<li>在物体上添加mesh render组件 并且勾选use light prode。</li>\n<li>烘焙 烘焙之后，一般移动物体光照就不会在变，但是在这里，因为加入了光照探针，所以会变化</li>\n</ol>\n</li>\n<li><p>Light 三中光源</p>\n</li>\n<li><p>LOPGROUP 不同距离的细节分级</p>\n</li>\n</ul>\n<p>脚本组件</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/19/Screen-Shot-2020-02-19-at-8.50.05-PM.png\" alt=\"unity构架\"></p>\n<p>C# </p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-12.20.49-PM.png\" alt=\"struct\"></p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-12.24.17-PM.png\" alt=\"枚举类型：限定变量可能性\"></p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-12.28.11-PM.png\" alt=\"枚举类型强制类型转换\"></p>\n<p>var 声明</p>\n<p><strong>Class</strong></p>\n<p> 成员变量/方法 实例化 构造函数 </p>\n<p>静态方法/ 成员变量直接存储在class中，不需要实例化后调用（实际上，实例化无法调用static的方法/变量）</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-2.40.30-PM.png\" alt=\"属性变量Age\"></p>\n<p><em>属性变量方便地完成了对变量的getset并且具有安全性</em></p>\n<p><strong>interface</strong></p>\n<p>方法属性索引事件</p>\n<p>在接口中定义方法，在有一个类链接这个借口，在这个类中完成方法。</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-2.53.48-PM.png\" alt=\"接口\"></p>\n<p>*<em>abstract class *</em></p>\n<p>抽象类：只声明方法，然后它被其他类继承，实现它的方法。</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-2.57.39-PM.png\" alt=\"抽象类与类的继承\"></p>\n<p><strong>抽象类和接口区别与共同点</strong></p>\n<p>抽象类归根结底是类，可以声明一个抽象方法但是由其他类继承抽象类来实现这个方法，也可以直接在抽象类里直接实现一个方法，根据父类的性质，它的 子类都可以调用这个方法。</p>\n<p>接口则没有类的性质，只能有方法属性索引事件，不能有成员变量字段。</p>\n<p>只能继承一个抽象类但是可以继承多个接口</p>\n<p>两者都不能被实例化</p>\n<p><strong>权限</strong></p>\n<p>字段一般都是private+setget方法。</p>\n<p>或者public属性</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-3.11.06-PM.png\" alt=\"\"></p>\n<p>脚本</p>\n<p><strong>debug信息</strong></p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-5.02.18-PM.png\" alt=\"\"></p>\n<p>如果在 Update 里，则没一帧都会显示</p>\n<p><strong>脚本生命周期</strong></p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-5.13.29-PM.png\" alt=\"\"></p>\n<ul>\n<li><p>reset 是物体添加组件的时候</p>\n</li>\n<li><p>awake是物体存在就会调用</p>\n</li>\n<li><p>当脚本被调用就会调用start</p>\n</li>\n</ul>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-5.15.57-PM.png\" alt=\"\"></p>\n<ul>\n<li><p>fixupdate -&gt;update -&gt;LateUpdate</p>\n<p>fixupdate是根据物理事件调用，update lateuodate是基于时间调用。</p>\n</li>\n</ul>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-5.23.04-PM.png\" alt=\"\"></p>\n<ul>\n<li>ondisable 脚本停止</li>\n<li>ondestroy 物体销毁</li>\n</ul>\n<h4 id=\"behavior事件相应\"><a href=\"#behavior事件相应\" class=\"headerlink\" title=\"behavior事件相应\"></a>behavior事件相应</h4><p><strong>启动刷新函数：</strong></p>\n<ol>\n<li>启动函数</li>\n</ol>\n<p><strong>awake()</strong></p>\n<ul>\n<li>初始化函数，游戏开始时系统自动调用</li>\n<li>一般用来创建变量</li>\n<li>无论脚本组件是否被激活都被调用</li>\n</ul>\n<p><strong>start()</strong></p>\n<ul>\n<li>初始化函数，在awake之后update之前</li>\n<li>一般给变量赋值</li>\n<li>只有脚本组件激活时才能被调用</li>\n</ul>\n<ol start=\"2\">\n<li>刷新函数</li>\n</ol>\n<p><strong>update()</strong></p>\n<ul>\n<li>每一帧调用</li>\n<li>用于非物理运动（匀速运动）</li>\n</ul>\n<p><strong>FixedUpdate()</strong></p>\n<ul>\n<li>固定时间调用一次</li>\n<li>一般用于物理运动（物理运算）</li>\n<li>edit-&gt;time可进行修改</li>\n</ul>\n<h4 id=\"交互函数\"><a href=\"#交互函数\" class=\"headerlink\" title=\"交互函数\"></a>交互函数</h4><p><img src=\"https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-5.43.12-PM.png\" alt=\"\"></p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-5.43.22-PM.png\" alt=\"\"></p>\n<p><strong>物理</strong></p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-5.43.50-PM.png\" alt=\"\"></p>\n<p>OnTriggerEnter()</p>\n<p>Cube1 :加入box collider组件（碰撞体），勾选trigger。cube1是触发器</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-5.51.24-PM.png\" alt=\"cube1\"></p>\n<p>Cube2:挂脚本，加碰撞体，用rigidbody加重力。当cube1（触发器进入），则cube1 位移</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-5.53.08-PM.png\" alt=\"cube2\"></p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-5.55.21-PM.png\" alt=\"\"></p>\n<p><strong>OnTriggerStay()</strong>当碰撞体接触触发器时，此函数在每一帧被调用</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/20/Screen-Shot-2020-02-20-at-6.02.26-PM.png\" alt=\"\"></p>\n<p>给cube2挂上脚本后，当cube1触碰cube2，cube1会向上移动。当cube1不加重力，他会一直上升。当它加上重力，当两者分开cube1又会下降。</p>"},{"date":"2020-02-07T16:00:00.000Z","_content":"# Kelo算法课堂(持续更新)\n\n*kelo做算法题并在其博客上连载，窃以为其思想精妙，故书吾感，记以学之。*\n\n***原作见友链***\n<!-- more -->\n1. 求最长回文串（Manacher）\n\n   * 思想\n\n     * 预处理 将原串中加入#，目的在于可以识别#a#b#b#a的回文串。\n\n       ​\t\t\t 在开头加入&,目的在于使回文串的识别从1开始\n\n     * for循环对length[i]进行求解。length[i]的实际意义是**回文半径**\n\n       ```\n       # a # b # c # c # b # d #\n       1 2 1 2 1 2 5 2 1 2 1 2 1 \n       ```\n\n       如上，第二行即为回文半径表，我们可以看出，以length[i].max为中心，根据其回文半径取得的回文字符串去掉#后即为最长回文串。\n\n       问题转化为求length[i]，以及**最大的回文长度(max_length)**和**回文中心(max_mid)**。实际上，最大的max_length和max_mid在i循环求length[i]的过程中进行更新即可。\n\n     * 当i在推算出来的现在所处的最大回文序列的右边界的左侧，则可以通过**简便方式推算**。\n\n       * 当max_right对结果无影响时（max_right足够大），我们可以直接先令 length[i] = length[2 * pos - i]\n       * 如果以i为中心的回文串长度超过max_right时候，由于我们无法判断max_right之后的情形，我们只能令length[i] = max_right - i\n       * 如果在最大回文序列右侧，则将它初始化为一\n\n     * 以i为中心，while循环测试以此时的i为中心向两边扩展，当两边没有达到边界且两边相同时，length[i]++\n\n     * 更新当前i为中心的回文序列的右边界max_right\n\n     * 将当前的回文序列长度和最大回文序列长度比较判断是否需要更新这个长度。\n\n   * 代码实现\n\n   ```javascript\n   /**\n    * @param {string} s\n    * @return {string}\n    */\n   \n   let s = \"afkfkfkaaaafkfk\";\n   \n   var longestPalindrome = function(s) {\n       let f = \"&#\";\n       for (let i = 0;i < s.length; i++){\n           f = f + s[i];\n           f = f + \"#\";\n       }\n       let length = [];\n       let max_right = 0, max_length = 0, pos = 0, max_pos = 0;\n       for (let i = 1;i < f.length;i++) {//求length[i]的循环\n           if (i < max_right) {\n               /*如果要求的i在推算出来的现在所处的最大回文序列的右边界的左侧，则可以通过简便方式进行推算：\n               当max_right对结果无影响时（max_right足够大），我们可以直接先令 length[i] = length[2 * pos - i]\n               如果以i为中心的回文串长度超过max_right时候，由于我们无法判断max_right之后的情形，我们只能令length[i] = max_right - i*/\n               length[i] = Math.min(max_right - i, length[2 * pos - i]);\n           } else length[i] = 1;\n           while (i - length[i] >=0 && i + length[i] < f.length && f[i - length[i]] === f[i + length[i]]){\n               length[i] = length[i] + 1;\n           }//这个循环就是在测试以此时的i为中心向两边扩展，1.没有到达数组边界 2.两方相等。如果两个条件都满足，则length[i]++\n           if (i + length[i] - 1 > max_right) {\n               max_right = i + length[i] - 1;\n               pos = i;\n           }//更新当前所在的最大回文序列的右边界\n           if (length[i] > max_length) {\n               max_length = length[i];\n               max_pos = i;\n           }//更新最大的回文长度和回文中心\n       }\n       let max_sub_string = f.substring(max_pos - max_length + 1, max_pos + max_length);\n       let real_sub = \"\";\n       for (let i = 0;i < max_sub_string.length;i++) {\n           if (max_sub_string[i] === \"#\") continue;\n           real_sub = real_sub + max_sub_string[i];\n       }\n       return real_sub;\n   };\n   \n   console.log(longestPalindrome(s));\n   ```\n\n2. 给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。（双指针法）\n\n   设置l，r两个指针，l指向数组开头，r指向数组结尾，计算容量，然后将较短的指针向前中间移动。每次移动指针后计算容量判断是否更新max。\n\n   *注：移动较短的是因为移动结果为容量变大或者不变。但是移动较长的只会容量变小或者不变*\n\n   ```javascript\n   var maxArea = function(height) {\n       let l = 0;\n       let r = height.length - 1;\n       let max_area = 0;\n       while (l !== r) {\n           max_area = Math.max(max_area, (r - l) * Math.min(height[l], height[r]));\n           if (height[l] < height[r]) l++;\n           else r--;\n       }\n       return max_area;\n   };\n   ```\n\n   * 数组.length\n   * Math.mac()\n   * L !== r\n   \n3. 已知n个括号对，将输出这些括号对的合法搭配，比如2个括号对的合法组合是：()(), (())\n\n   ```javascript\n   var generateParenthesis = function(n) {\n       let ans = [];\n       for (let set = 0; set < 1 << (2 * n); set++) {\n           let flag = 0;\n           let sub_ans = \"\";\n           for (let i = (1 << (2*n -1)); i ; i = i >> 1) {\n               if ((set & i) === i){\n                   flag = flag + 1;\n                   sub_ans = sub_ans + \"(\";\n               }else{\n                   flag = flag - 1;\n                   sub_ans = sub_ans + \")\"\n               }\n               if (flag < 0 || flag > n) break;\n           }\n           if (flag === 0) {\n               ans.push(sub_ans);\n           }\n       }\n       return ans;\n   };\n   console.log(generateParenthesis(3));\n   ```\n\n1看做左括号，0看做右括号，set为整个括号序列的二进制代表 ()()->1010\n\n遍历set即遍历0000 -> 1111\n\n取每一个set 对i进行遍历，与set比对。比如set = 1100，i取1000，100，10，1，分别与set进行&操作，1100 & 1000 == 1000，1100 & 1== 0，由此可以判断set每一位是1/0。\n\n1则flag加1，0则flag-1，当flag<0(右在左)或者flag>n(左括号已经肯定多于右括号)跳出。\n\ni循环完或者break后，对flag进行判断，如果flag === 0，则此set合法，将其压栈。\n\n4. 两数相加**（链表的应用）**\n\n```javascript\n\n/*Definition for singly-linked list.*/\nfunction ListNode(val) {\n    this.val = val;\n    this.next = null;\n}\n/**\n * @param {ListNode} l1\n * @param {ListNode} l2\n * @return {ListNode}\n */\n\nvar changeType = function(num){\n    let node = new ListNode(-1);\n    let node1 = new ListNode(-1);\n    for(let i = 10;; i*=10){\n        let part = (num % i)/(i/10);\n        num -=(part*(i/10));\n        if(node.val !== -1){\n            node1 = new ListNode(part);\n            node1.next = node;\n            node = node1;\n        }else{\n            node = new ListNode(part);\n        }\n        if(i > num)\n            break;\n    }\n    return node1;\n}\n\nvar addTwoNumbers = function(l1, l2) {\n    let head = new ListNode;\n    let present = head;\n    let c = 0;\n    while (1 === 1) {\n        let tmp = new ListNode;\n        if (l1 === null && l2 === null) {\n            if (c === 1) {\n                tmp.val = c;\n                tmp.next = null;\n                present.next = tmp;\n                present = present.next\n            }\n            break;\n        }\n        if (l1 === null) {\n            tmp.val = l2.val + c;\n            if (tmp.val >= 10) {\n                tmp.val = tmp. val - 10;\n                c = 1;\n            } else c = 0;\n            tmp.next = null;\n        } else\n        if (l2 === null) {\n            tmp.val = l1.val + c;\n            if (tmp.val >= 10) {\n                tmp.val = tmp. val - 10;\n                c = 1;\n            } else c = 0;\n            tmp.next = null;\n        } else {\n            let tmp_ans = l1.val + l2.val + c;\n            if (tmp_ans >= 10) {\n                tmp_ans = tmp_ans - 10;\n                c = 1;\n            } else c = 0;\n            tmp.val = tmp_ans;\n        }\n        tmp.next = null;\n        present.next = tmp;\n        present = present.next;\n        if (l1 === null) l2 = l2.next;\n        else if (l2 === null) l1 = l1.next;\n        else {\n            l1 = l1.next;\n            l2 = l2.next;\n        }\n    }\n    head = head.next;\n    return head;\n};\n\nconsole.log(addTwoNumbers(changeType(12),changeType(12)));\n```\n\n用到了链表的数据结构，changType改变(int)num为链表，addTwoNumbers将两个链表对应的数相加。\n\n5. 求一个字符串的最大无重复子串**（滑动窗口）**\n\n```javascript\n/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLongestSubstring = function(s) {\n    let map = new Map();\n    let l = 0;\n    let r = 1;\n    let max_length = s.length;\n    let max_ans = 1;\n    let substring = s.substring(l, r);\n    map.set(s[l], 1);\n    while (r < max_length && max_length-r-1>max_ans) {\n        if (!map.has(s[r])) {\n            map.set(s[r], 1);\n            r++;\n            if (r - l > max_ans) {\n                max_ans = r - l;\n                substring = s.substring(l, r);\n            }\n        } else {\n            map.delete(s[l]);\n            l++;\n        }\n    }\n    return substring.length;\n};\n```\n\n类似于双指针，初始化l=0，r=1，r右移，新收入的s[r]与之前的比，如果有相同，则l右移直至没有相同的。\n\n6. leetcode42 \n\n![](https://img.cetacis.dev/uploads/big/8408af07f366c184d8ff194926fe450b.png)\n\n**单调栈的使用**\n\n```python\nfrom typing import List\n\n\nclass Solution:\n    def trap(self, height: List[int]) -> int:\n        if not height:\n            return 0\n        ans = 0\n        stack = []\n        i = 0\n        while i + 1 < len(height) and height[i] < height[i + 1]:\n            i = i + 1\n        stack.append((height[i], i))\n        i = i + 1\n        while i < len(height):\n            if height[i] <= stack[-1][0]:\n                stack.append((height[i], i))\n            else:\n                last_height = -1\n                while len(stack) != 0 and stack[-1][0] < height[i]:\n                    if last_height == -1:\n                        last_height = stack[-1][0] \n                    else:\n                        ans = ans + (i - stack[-1][1] - 1) * (stack[-1][0] - last_height)\n                        last_height = stack[-1][0]\n                    stack.pop()\n                if len(stack) != 0:\n                    ans = ans + (i - stack[-1][1] - 1) * (height[i] - last_height)\n                stack.append((height[i], i))\n            i = i + 1\n        return ans\n\n\nif __name__ == '__main__':\n    a = [3,2,1,3]\n    print(Solution().trap(a))\n\n```\n\n数据结构：\n\n* stack的操作：[].append(***)入栈；[].pop()出栈；栈顶是stack[-1]\n* list判空：if (not) list:/if list is (not) None:/if len(list)==0\n* 二元组：a = (X, X)  访问的时候a[0]/a[1]。在此例中，(x, x)可作为栈元素，来确定元素在栈的位置。\n\n思想：\n\n* 开始先将单调递增的部分取出，这部分不可能装水\n* 将单调递减的部分入栈，然后在出现比栈顶大的部分进入计算部分。\n* 设置last_height，并且维护。\n\n主函数调用：\n\n```python\nif __name__ == '__main__':\n```\n\n7. leetcode 29\n\n快速除法\n\n```python\ndef minus(x, y, step, origin_y) -> int:\n    #  真正的除法过程\n    ans = 0\n    if x == 0:\n        return 0\n    while x - y >= 0:\n        x = x - y\n        ans = ans + pow(2, step)\n    if y == origin_y:\n        return ans\n    return minus(x, y >> 1, step - 1, origin_y) + ans\n\n\nclass Solution:\n    def divide(self, dividend: int, divisor: int) -> int:\n        flag = 0\n        if dividend < 0:\n            # 被除数小于零\n            dividend = - dividend\n            flag = flag ^ 1\n        if divisor < 0:\n            divisor = - divisor\n            flag = flag ^ 1\n            # flag代表正负\n        ans = minus(dividend, divisor << 32, 32, divisor)\n        ans = ans if flag == 0 else -ans\n        ans = ans if ans < 2147483647 else 2147483647\n        return ans\n\n\nif __name__ == '__main__':\n    a = 2\n    b = 1\n    c = Solution()\n    print(Solution.divide(c,a, b))\n\n```\n\n思想：\n\n核心思想在于，每一个数都可以拆成二的不同次幂的线性组合\n\n本题是除法，即将被除数拆成系数为除数倍数的不同二次幂的组合。\n\n比如：8/2 即8=2x(2^4) 9/3即9 = 3x(2^1+2^0) 27/3 = 3x(2x2^2+2^0)\n\n方法即从 除数x2^32 开始和被除数比较，并且每次比较后，如果被除数比除数乘2的次方小，则将除数乘2的次方右移（除以2）。用到了递归的方法。\n\n语法积累：\n\n* \n\n* ```python\n   ans = ans if flag == 0 else -ans\n  ```\n\n* 抑或\n\n  ```python\n   flag = flag ^ 1\n  ```\n\n* 如果本类中的某方法要调用本类中的其他方法，则需要加入self的参数。因为要调用类方法，必须要对类进行实例化。\n\n8. leetcode33\n\n本来有一个有序数列，如[1,2,3,4,5,6,7]\n\n从某个位置进行切割拼接 如[4, 5, 6, 7, 1, 2, 3]\n\n思路：\n\n* 主要还是二分法\n* 在这里有所不同，就是开始的时候分类，当nums[left] <= nums[mid]，即改变点在中点右侧，则left到改变点之间是可以用二分法的，则当nums[left] <= target < nums[mid]，right = mid-1，之后即为普通二分法，如果其他，则将left移动到mid+1.这样做，迟早会找到一个符合nums[left] <= target < nums[mid]或者nums[mid] < target <= nums[right]:的区间，然后就是正常的二分法了。\n\n```javascript\nclass Solution:\n    def search(self, nums, target):\n        if not nums:\n            return -1\n        left = 0\n        right = len(nums) - 1\n        while left < right:\n            print(left, right)\n            mid = (left + right) >> 1\n            if nums[mid] == target:\n                return mid\n            if nums[left] <= nums[mid]:\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        return left if nums[left] == target else -1\n\n```\n\n9. leetcode 34\n\n在排列数组中找到某一个target number的位置。\n\n二分+递归，当二分失败l>r return，或者target == a[mid]return，或者ans[0] < mid < ans[1]，主要是对l/r和ans[0],and[1]进行大小比对。\n\n```python\nfrom typing import List\n\n\nclass Solution:\n    def bin_search(self, a:List[int], l:int, r:int, target:int, ans:List[int]):\n        if l > r:\n            return\n        mid = (l + r) >> 1\n        if a[l] == target:\n            ans[0] = min(ans[0], l)\n            ans[1] = max(ans[1], l)\n        if a[r] == target:\n            ans[0] = min(ans[0], r)\n            ans[1] = max(ans[1], r)\n        if ans[0] < mid < ans[1]:\n            return\n        if target == a[mid]:\n            ans[0] = min(ans[0], mid)\n            ans[1] = max(ans[1], mid)\n            self.bin_search(a, l, mid - 1, target, ans)\n            self.bin_search(a, mid + 1, r, target, ans)\n            return\n        else:\n            if target > a[mid]:\n                self.bin_search(a, mid + 1, r, target, ans)\n            else:\n                self.bin_search(a, l, mid - 1, target, ans)\n\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n        ans = [200000000, -1]\n        self.bin_search(nums, 0, len(nums) - 1, target, ans)\n        if ans[1] == -1:\n            return [-1, -1]\n        else:\n            return ans\n\n\nif __name__ == '__main__':\n    nums = [7, 7, 7, 7, 7, 7, 10]\n    target = 7\n    print(Solution().searchRange(nums, target))\n\n\n```\n\n10. leetcode 36\n\n![题意](https://img.cetacis.dev/uploads/big/e379af099611ed74f5ef430b3ce538f1.png)\n\n**题解**\n\n看到这道题，很自然地想到嵌套循环，设置i,j分别遍历横排，竖排和3x3的块。难点在于python没有提供二维数组，所以要用自定义的数据结构存储和访问每一个元素。其中有一个flag要素，其实就是对每一个数字进行标记，如果某个数字的flag大于一，即出现了两次以上，则return false。\n\n```python\nfrom typing import List\n\n\nclass Solution:\n    def isValidSudoku(self, board: List[List[str]]):\n        for i in range(0, 9):\n            flag = [0] * 10\n            for j in range(0, 9):\n                if board[i][j] == \".\":\n                    continue\n                if flag[int(board[i][j])] == 0:\n                    flag[int(board[i][j])] = 1\n                else:\n                    return False\n        j = 0\n        while j < 9:\n            flag = [0] * 10\n            for i in range(0, 9):\n                if board[i][j] == \".\":\n                    continue\n                if flag[int(board[i][j])] == 0:\n                    flag[int(board[i][j])] = 1\n                else:\n                    return False\n            j = j + 1\n        for i in range(0, 9, 3):\n            for j in range(0, 9, 3):\n                flag = [0] * 10\n                for step_i in range(0, 3):\n                    for step_j in range(0, 3):\n                        if board[i + step_i][j + step_j] == \".\":\n                            continue\n                        if flag[int(board[i + step_i][j + step_j])] == 0:\n                            flag[int(board[i + step_i][j + step_j])] = 1\n                        else:\n                            return False\n        return True\na = Solution()\nif Solution.isValidSudoku(a,[[\"7\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],\n                             [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],\n                             [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],\n                             [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],\n                             [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],\n                             [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],\n                             [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],\n                             [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],\n                             [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]):\n    print (\"True\")\nelse:\n    print (\"False\")\n```\n\n11. leetcode 50\n\n快速幂 即通过简单乘法实现幂运算\n\n**题解**\n\n有一些像之前lt29做过的减法实现除法，一个指数可以拆分成很多子项相乘，比如3^8 = 3^4 x 3^4，此时，我们计算3^4再将结果相乘就可得到正确答案，这样节省了算两次3^4 的时间，可以满足时间复杂度。\n\n又 3^4 = 3^2 x 3^2，此时计算3^2 = 3*3。可以看出，这是一个递归的过程，每次将幂 >> 1，结束条件是幂=0 return 1。当然，幂也有奇数的可能性，当幂是奇数，只要将这一次的return改成 底数 x temp x temp即可。如果幂是偶数，则返回temp x temp。\n\n但是这个求幂的过程，底数和指数只能是正数，当底数和指数是负数的时候，需要将负数变为正数，再使用如上递归方程。并且对求得的幂进行符号/倒数修改，这就要求对底数、指数进行分类讨论。\n\nuna代码如下：\n\n````python\nclass Solution(object):\n    def Pow(self, x, n):\n        if n == 0:\n            return 1\n        else:\n            temp = self.Pow(x, n >> 1)\n        if n % 2 == 0:\n            return temp * temp\n        else:\n            return x * temp * temp\n\n    def myPow(self, x, n):\n        if x < 0 and n % 2 == 0:\n            return self.Pow(-x, n) if n > 0 else self.Pow(-x, -n)\n        elif x < 0 and n > 0:\n            return -self.Pow(-x, n)\n        if n < 0:\n            return 1/self.Pow(x, -n) if x > 0 else 1/-self.Pow(-x, -n)\n        else:\n            return self.Pow(x, n)\n\na = Solution()\nprint (Solution.myPow(a, -1, -2))\n\n````\n\nkelo代码如下：\n\n```python\nclass Solution:\n    def quick(self, x: float, n: int) -> float:\n        if n == 0:\n            return 1\n        if n == 1:\n            return x\n        res = 1\n        if n & 1 == 1:\n            res = x\n        half = self.quick(x, n >> 1)\n        return half * half * res\n\n    def myPow(self, x: float, n: int) -> float:\n        if n > 0:\n            return self.quick(x, n)\n        else:\n            return self.quick(1/x, -n)\n```\n\n12. leetcode 37 解数独\n\n顾名思义，解决数独，默认题目可解且有唯一解。\n\n**题解**\n\n第一想法是直接试错法，但是一想这个实验次数岂不是指数爆炸而且极其不美观，现实代码中使用递归试错（穷举）。\n\n值得注意的点除了这种递归的方法进行穷举以外，还有对某个数字是否出现过的控制方式。具体的做法和解析写在了注释里。\n\n```python\nfrom typing import List\n\n\nclass Solution:\n    COL = [0] * 10\n    ROW = [0] * 10\n    BLOCK = [0] * 10\n    Flag = 0\n\n    def solve(self, board: List[List[str]], i, j):\n        if self.Flag == 1:\n            return\n        if j == 9:\n            self.solve(board, i + 1, 0)\n            return\n        if i == 9:\n            self.Flag = 1\n            return\n        if board[i][j] != \".\":\n            self.solve(board, i, j + 1)\n            return\n        for x in range(1, 10):\n            if self.COL[i] & (1 << x) == 1 << x or self.ROW[j] & (1 << x) == 1 << x or \\\n                    self.BLOCK[int(i / 3) * 3 + int(j / 3)] & (1 << x) == 1 << x:\n                # 当行/列/块为x，则跳出本步循环。\n                # 即当x这个数已经在i行/列/块存在，不对需要col/row/block进行操作\n                # 因为已经有此数，则意味着不能填入此数\n                continue\n            board[i][j] = str(x)\n            # 填入x\n            self.COL[i] = self.COL[i] | (1 << x)\n            self.ROW[j] = self.ROW[j] | (1 << x)\n            self.BLOCK[int(i / 3) * 3 + int(j / 3)] = self.BLOCK[int(i / 3) * 3 + int(j / 3)] | (1 << x)\n            # 填入x后在col，row，block中进行维护\n            self.solve(board, i, j + 1)\n            if self.Flag == 1:\n                return\n            # 当i=9，即将所有的数字按照规则填充完成，则flag = 1，退出。\n            self.COL[i] = self.COL[i] ^ (1 << x)\n            self.ROW[j] = self.ROW[j] ^ (1 << x)\n            self.BLOCK[int(i / 3) * 3 + int(j / 3)] = self.BLOCK[int(i / 3) * 3 + int(j / 3)] ^ (1 << x)\n            board[i][j] = \".\"\n     # flag != 1,即未正确填充，则将此数，将col,row,block标记修改回之前的样子，并且将board[]\n    def solveSudoku(self, board: List[List[str]]) -> None:\n        for i in range(0, 10):\n            self.COL[i] = 0\n            self.ROW[i] = 0\n            self.BLOCK[i] = 0\n        for i in range(0, 9):\n            for j in range(0, 9):\n                if board[i][j] == \".\":\n                    continue\n                self.COL[i] = self.COL[i] | (1 << int(board[i][j]))\n                self.ROW[j] = self.ROW[j] | (1 << int(board[i][j]))\n                self.BLOCK[int(i / 3) * 3 + int(j / 3)] = self.BLOCK[int(i / 3) * 3 + int(j / 3)] | (1 << int(board[i][j]))\n            # 举例理解，当为i = 0，j = 0,board[0][0]=2, col[0] = 00000000100\n            # 当j++, i = 0,j = 1,board[0][1] = 1 col[0]= 0000000110\n            # 即，col[i]记录的，是i行的那些数字出现过。如0000000110就是1，2出现过（注意是第零位为0）\n        self.solve(board, 0, 0)\n\n\nif __name__ == '__main__':\n    bd = [[\".\", \".\", \"9\", \"7\", \"4\", \"8\", \".\", \".\", \".\"], [\"7\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\n     [\".\", \"2\", \".\", \"1\", \".\", \"9\", \".\", \".\", \".\"], [\".\", \".\", \"7\", \".\", \".\", \".\", \"2\", \"4\", \".\"],\n     [\".\", \"6\", \"4\", \".\", \"1\", \".\", \"5\", \"9\", \".\"], [\".\", \"9\", \"8\", \".\", \".\", \".\", \"3\", \".\", \".\"],\n     [\".\", \".\", \".\", \"8\", \".\", \"3\", \".\", \"2\", \".\"], [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \"6\"],\n     [\".\", \".\", \".\", \"2\", \"7\", \"5\", \"9\", \".\", \".\"]]\n    print(Solution().solveSudoku(bd))\n    print(bd)\n\n```\n\n13. leetcode 38 外观数组\n\n「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。前五项如下：\n\n1.     1\n2.     11\n3.     21\n4.     1211\n5.     111221\n1 被读作  \"one 1\"  (\"一个一\") , 即 11。\n11 被读作 \"two 1s\" (\"两个一\"）, 即 21。\n21 被读作 \"one 2\",  \"one 1\" （\"一个二\" ,  \"一个一\") , 即 1211。\n\n给定一个正整数 n（1 ≤ n ≤ 30），输出外观数列的第 n 项。\n\n注意：整数序列中的每一项将表示为一个字符串。\n\n**题解**\n\n因为ans[i]由ans[i-1]得来，则需从ans[2]开始求直到求到ans[n]。\n\n为了求ans[i]，可对ans[i-1]进行遍历，对ans[i-1] [j]的j进行循环，当ans[i-1] [j] = ans[i-1] [j+1]，则time ++，相当于如果一个数字重复出现，对出现次数进行++。\n\n直到ans[i-1] [j] ！= ans[i-1] [j+1]，则ans[i]+(str)time+ans[i-1] [j]，然后对time清零，再次进行如上循环操作。\n\n**代码如下**\n\n```python\nclass Solution(object):\n    def countAndSay(self, n):\n        ans = [\"\"] * 100\n        ans[1] = \"1\"\n        i = 1\n        j = 0\n\n        while i < n:\n            time = 1\n            while j + 1 < len(ans[i]) and ans[i][j] == ans[i][j + 1]:\n                time += 1\n                j = j + 1\n            ans[i + 1] = ans[i + 1] + str(time)+ans[i][j]\n            j = j + 1\n            if j == len(ans[i]):\n                i = i + 1\n                j = 0\n        return ans[n]\n\nprint (Solution().countAndSay(5))\n```\n\n14. leetcode 39 40\n\n给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。\n\ncandidates 中的数字可以无限制重复被选取。\n\n说明：\n\n所有数字（包括 target）都是正整数。\n解集不能包含重复的组合。 \n示例 1:\n\n```\n输入: candidates = [2,3,6,7], target = 7,\n所求解集为:\n[\n  [7],\n  [2,2,3]\n]\n```\n\n示例 2:\n\n```\n输入: candidates = [2,3,5], target = 8,\n所求解集为:\n[\n  [2,2,2,2],\n  [2,3,3],\n  [3,5]\n]\n```\n\n**题解**\n\n这道题我想到先从小到大sort candidates，然后累加最小的元素 candidates[0]，直到 = target 或者大于target。当 = 成立，则将此种list加入set，\n\n后续的操作两种情况一样，将最后两个candidates[0]出栈，尝试加入一个candidates[1]，如果= target 则将此种list加入set。之后，= target 或者大于target都将最后两个元素出栈，尝试加入candidates[1]，若小于则直接加入candidates[3]... \n\n这种不免为一种思路，我的想法是减少显而易见的优化方法，将工作交给计算机，就是每次减少一个在获得全部由candidates[0]组成的target（可能会大于或相等）然后尝试加入candidates[1]，如果能加入，则再加入candidate[1]，直到加到 和为target或者大于target，如同之前对candidates[0]的操作，将candidates[1]减少一个，试图加入candidates[2]..\n\n这样应该可以用到递归。\n\n之后，我看了kelo的代码，差不多是一样的思路，都用到了res = res - candidates[step]的思想（初试res即为target），这样，可以将res当做一个新的target，对其进行操作。\n\n```python\nfrom typing import List\n\n\nclass Solution:\n    ANS = set()\n    SUB_ANS = []\n\n    def find(self, step, res, candidates):\n        if res == 0:\n            self.ANS.add(tuple(self.SUB_ANS))\n            return\n\n        if step == len(candidates):\n            return\n\n        if candidates[step] <= res:\n            res = res - candidates[step]\n            self.SUB_ANS.append(candidates[step])\n            self.find(step, res, candidates)\n            self.find(step + 1, res, candidates)\n            res = res + candidates[step]\n            del self.SUB_ANS[-1]\n        self.find(step + 1, res, candidates)\n\n    def combinationSum(self, candidates, target):\n        self.ANS.clear()\n        self.SUB_ANS = []\n        candidates.sort()\n        self.find(0, target, candidates)\n        fin = []\n        for x in self.ANS:\n            fin.insert(len(fin), list(x))\n        return fin\n\n\nif __name__ == '__main__':\n    candidates = [1,2,3]\n    ta = 3\n    print(Solution().combinationSum(candidates, ta))\n```\n\n当不能重复使用时，将代码改成如下：\n\n```python\nfrom typing import List\n\n\nclass Solution:\n    ANS = set()\n    SUB_ANS = []\n\n    def find(self, step, res, candidates):\n        if res == 0:\n            self.ANS.add(tuple(self.SUB_ANS))\n            return\n\n        if step == len(candidates):\n            return\n\n        if candidates[step] <= res:\n            res = res - candidates[step]\n            self.SUB_ANS.append(candidates[step])\n            self.find(step + 1, res, candidates)\n            res = res + candidates[step]\n            del self.SUB_ANS[-1]\n        self.find(step + 1, res, candidates)\n\n    def combinationSum(self, candidates, target):\n        self.ANS.clear()\n        self.SUB_ANS = []\n        candidates.sort()\n        self.find(0, target, candidates)\n        fin = []\n        for x in self.ANS:\n            fin.insert(len(fin), list(x))\n        return fin\n\n\nif __name__ == '__main__':\n    candidates = [1,2,3]\n    ta = 3\n    print(Solution().combinationSum(candidates, ta))\n```\n\n15. leetcode 41\n\n得到一个数组中最小正整数\n\n如：[1,-1,3,5] 得到2\n\n**题解**\n\n这道题……确实只要遍历就可以了，但是对于时间和空间复杂度都有要求，所以可以采用一种自身哈希的方法，在前面的题中也提过。\n\n首先，根据抽屉定理，answer <= n+1\n\n将其中大于n的，小于等于零的设为1。（在这一步之前，先测其中是否有1，如果没有1则输出1）\n\n关键是将索引值作为哈希key。\n\n[1, 6, 2 , -1 , 3, 8]--->] [1, 6, 2, 1,3, 1]  （即包含1 - n元素的数组）\n\n对这个从1-n进行遍历：如果读到数字a，则将第几个元素的符号改变。（使用下表0代表n）\n\n最后返回第一个正数。如果没有，则判断0位置，如果还没有正数则返回n+1。\n\n代码：\n\n```python\nclass Solution:\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        \n        # 基本情况\n        if 1 not in nums:\n            return 1\n        \n        # nums = [1]\n        if n == 1:\n            return 2\n        \n        # 用 1 替换负数，0，\n        # 和大于 n 的数\n        # 在转换以后，nums 只会包含\n        # 正数\n        for i in range(n):\n            if nums[i] <= 0 or nums[i] > n:\n                nums[i] = 1\n        \n        # 使用索引和数字符号作为检查器\n        # 例如，如果 nums[1] 是负数表示在数组中出现了数字 `1`\n        # 如果 nums[2] 是正数 表示数字 2 没有出现\n        for i in range(n): \n            a = abs(nums[i])\n            # 如果发现了一个数字 a - 改变第 a 个元素的符号\n            # 注意重复元素只需操作一次\n            if a == n:\n                nums[0] = - abs(nums[0])\n            else:\n                nums[a] = - abs(nums[a])\n            \n        # 现在第一个正数的下标\n        # 就是第一个缺失的数\n        for i in range(1, n):\n            if nums[i] > 0:\n                return i\n        \n        if nums[0] > 0:\n            return n\n            \n        return n + 1\n```\n\n16. leetcode 45\n\n题意：\n\n给定一个非负整数数组，你最初位于数组的第一个位置。\n\n数组中的每个元素代表你在该位置可以跳跃的最大长度。\n\n你的目标是使用最少的跳跃次数到达数组的最后一个位置。\n\n```\n输入: [2,3,1,1,4]\n输出: 2\n解释: 跳到最后一个位置的最小跳跃数是 2。\n     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。\n```\n\n**题解**\n\n例子是[2, 3, 1, 1, 4]\n\n结合例子进行解释，nums[0] = 2, 因此跳一次最多到 nums[1]或者nums[2], 将2固定为max_pos，因为这是第一次跳跃后能够到达的最远位置。\n\n- i从0到1到max_pos进行遍历，每次更新max_arrive = max(max_arrive,nums[i]+i)。\n\n  *比如i=1，max_arrive = max(2, 4) = 4*\n\n  这个遍历其实是一个对第一步跳跃后，第二步跳跃可能情况的一个遍历，选出最大的max_arrive。\n\n- 当i和第一次固定的max_pos重叠时，将此时的max_pos 固定在max _arrive，并且跳跃步数++，相当于其实是选中了从确定max_arrive那次的i开始第二次起跳，max_pos 固定在此时的max _arrive, 进行与第一次相同的循环，直到i和max_pos 重叠。\n\n这个的实质其实是忽略i每次跳的位置（可以在max_arrive确定时确定），只记录跳的次数，进行多次相同的循环操作。\n\n代码如下：\n\n```python\nclass Solution:\n    def jump(self,nums):\n        max_pos = 0\n        max_arrive = 0\n        ans = 0\n        for i in range(0,len(nums)-1):\n            max_arrive = max(max_arrive,nums[i]+i)\n            if i>= max_pos:\n                max_pos = max_arrive\n                ans = ans + 1\n        return  ans\n```\n\n17. Leetcode 43字符串数的乘法\n\n如“67”‘89“，不能直接乘\n\n**题解：**\n\n* 按照乘法的规律，乘数为num1，被乘数为num2，先对num2进行遍历，跟num1的第一位相乘，num2中每取一个数，将答案的数组ans往后挪移一位。\n\n  同时对num1进行遍历，每次遍历，ans的起始下标加一。对每个num1元素跟num2的每个元素乘，加到ans的对应的位数。\n\n  ```python\n    for i in range(0, len(num1)):\n              local = i\n              for j in range(0, len(num2)):\n                  ans[local] += int(num1[len(num1) - i - 1]) * int(num2[len(num2) - j - 1])\n                  local = local + 1\n  ```\n\n* 如果ans的某位>10 则说明需要进位：\n\n  ```python\n          for i in range(0, local):\n              if ans[local - 1] >= 10:\n                  local = local + 1\n              ans[i + 1] += int(ans[i] / 10)\n              ans[i] %=10\n  ```\n\n* 判断最高位是否为0\n\n  ```python\n          while True:\n              if local == 1:\n                  break\n              if ans[local - 1] == 0:\n                  local = local - 1\n              else:\n                  break\n  ```\n\n* 将ans整合为final ans\n\n  ```python\n          for i in range(0, local):\n              final_ans = final_ans + str(ans[local - i - 1])\n  ```\n\n总体的代码如下：\n\n```python\nclass Solution:\n    def multiply(self, num1, num2) :\n        ans = [0] * 15000\n        local = 0\n        for i in range(0, len(num1)):\n            local = i\n            for j in range(0, len(num2)):\n                ans[local] += int(num1[len(num1) - i - 1]) * int(num2[len(num2) - j - 1])\n                local = local + 1\n        for i in range(0, local):\n            if ans[local - 1] >= 10:\n                local = local + 1\n            ans[i + 1] += int(ans[i] / 10)\n            ans[i] %=10\n        final_ans = \"\"\n        while True:\n            if local == 1:\n                break\n            if ans[local - 1] == 0:\n                local = local - 1\n            else:\n                break\n        for i in range(0, local):\n            final_ans = final_ans + str(ans[local - i - 1])\n        return final_ans\n\n\nif __name__ == '__main__':\n    a = \"12\"\n    b = \"12\"\n    c = Solution()\n    print(Solution().multiply(a, b))\n```\n\n18. Leetcode 46 全排列（无元素重复）\n\n用到了**回溯**的算法，这是一种通过探索所有可能的候选解来找出所有的解的算法。如果候选解被确认 不是 一个解的话（或者至少不是 最后一个 解），回溯算法会通过在上一步进行一些变化抛弃该解，即**回溯**并且再次尝试。\n\n一个回溯函数，使用第一个整数的索引作为参数 `backtrack(first)`\n\n如果整数索引为n则return, 并且在一次return后，将做的变化换回（即试错，重新进行其他尝试，在本题中不算试错，本题只是要算得每一种情况）\n\n**题解**\n\n* 如果第一个整数有索引 n，意味着当前排列已完成。\n* 遍历索引 first 到索引 n - 1 的所有整数。Iterate over the integers from index first to index n - 1.\n  * 在排列中放置第 i 个整数，\n    即 swap(nums[first], nums[i]).\n  * 继续生成从第 i 个整数开始的所有排列: backtrack(first + 1).\n  * 现在回溯，即通过 swap(nums[first], nums[i]) 还原.\n\n回溯法伪代码实现：\n\n```python\nclass Solution:\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        def backtrack(first = 0):\n            # if all integers are used up\n            if first == n:  \n                output.append(nums[:])\n            for i in range(first, n):\n                # place i-th integer first \n                # in the current permutation\n                nums[first], nums[i] = nums[i], nums[first]\n                # use next integers to complete the permutations\n                backtrack(first + 1)\n                # backtrack\n                nums[first], nums[i] = nums[i], nums[first]\n        \n        n = len(nums)\n        output = []\n        backtrack()\n        return output\n```\n\n*本题的思想在解数独中也出现过*\n\n下面是kelo的具体实现：\n\n```python\nfrom typing import List\n\n\nclass Solution:\n    ANS = []\n    SUB_ASN = []\n    set = 0\n    tot = 0\n    INF = 55\n\n    def dfs(self, nums: List[int], step):\n        if step == len(nums):\n            self.ANS.append(self.SUB_ASN[:])\n            return\n        for i in range(0, len(nums)):\n            if self.set & (1 << i) == 1 << i:\n                continue\n            self.SUB_ASN.append(nums[i])\n            self.set |= 1 << i\n            self.dfs(nums, step + 1)\n            self.set ^= 1 << i\n            del self.SUB_ASN[-1]\n\n    def permute(self, nums: List[int]):\n        self.ANS: List[List[int]]\n        self.ANS = []\n        self.tot = 0\n        self.SUB_ASN = []\n        self.dfs(nums, 0)\n        temp = []\n        for item in self.ANS:\n                temp.append(item)\n        return temp\n\n\nif __name__ == '__main__':\n    a = [1, 1, 3]\n    print(Solution().permute(a))\n```\n\n19. leetcode 47 全排列（有元素重复）\n\n只需要在无重复的基础上，将相同的去除即可。\n\n```python\n \t\t\t\tfor item in self.ANS:\n            if item not in temp:\n                temp.append(item)\n        return temp\n```\n\n20. leetcode49 单词的同分异构体\n\n例子：输入 a = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]，将其变为List(List(string))\n\n* \"\".join(sorted(string)) \n\n\"\".join()  : 将字符用“” 串联起来\n\nsorted(string) : 将string元素排序，得到一串字符集合。但是并不会改变原string\n\n* 此题用到哈希表\n\n**代码如下**\n\n```python\nfrom typing import List\n\n\nclass Solution:\n    def groupAnagrams(self, strs):\n        hash_map = {}\n        sort_string = [\"\".join(sorted(string)) for string in strs]\n        for i in range(0, len(sort_string)):\n            if sort_string[i] in hash_map:\n                hash_map[sort_string[i]].append(strs[i])\n            else:\n                hash_map[sort_string[i]] = [strs[i]]\n        return [x for x in hash_map.values()]\n\n\nif __name__ == '__main__':\n    a = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\n    print(Solution().groupAnagrams(a))\n```\n\nHash_map 是一个字典，key为排序过的str\n\n21. leetcode 44\n\n给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 '?' 和 '*' 的通配符匹配。\n\n'?' 可以匹配任何单个字符。\n'*' 可以匹配任意字符串（包括空字符串）。\n两个字符串完全匹配才算匹配成功。\n\n说明:\n\ns 可能为空，且只包含从 a-z 的小写字母。\np 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。\n\n**示例 1:**\n\n输入:\ns = \"aa\"\np = \"a\"\n输出: false\n解释: \"a\" 无法匹配 \"aa\" 整个字符串。\n\n**示例 2:**\n\n输入:\ns = \"aa\"\np = \"*\"\n输出: true\n解释: '*' 可以匹配任意字符串。\n\n**题解**\n\n最普遍的情况是，当p[j]=s[i]，或者为？，*时，如果s[i-1]，p[j-1]也匹配，则p[j]，s[i]匹配。\n\n历遍i j，如果p[-1] 与 s[-1]匹配，则结果为ture.要实现遍历，构建bool类型“二维数组”。\n\n```python\n f = [[False] * (len(p)) for _ in range(len(s))]\n# for _ in range(len(s)) 中 _ 表示占位符 不管是什么，反正只要循环就行了\n```\n\n实际上，有很多启动元素和特殊情况\n\n* f\\[0][0]的情况单独判断\n\n```python\nif s[0] == p[0] or p[0] == \"*\" or p[0] == \"?\":\n\tf[0][0] = True\n```\n\n* p开头为*, 需要单独判断所有的p与s[0]的匹配情况\n\n```python\nif p[0] == \"*\":\n    while len(p) > first and p[first] == \"*\":\n        f[0][first] = True\n        first = first + 1\n    if len(p) > first and (s[0] == p[first] or p[first] == \"?\"):\n        f[0][first] = True\n```\n\n* 接下来就是遍历\n\n```python\n  for i in range(0, len(s)):\n            for j in range(0, len(p)):\n                if p[j] == \"*\" and i > 0:\n                    f[i][j] |= f[i - 1][j]\n                if p[j] == \"*\" and j > 0:\n                    f[i][j] |= f[i][j - 1]\n                    # 如果p中前一个匹配，则\n                if (s[i] == p[j] or p[j] == \"?\" or p[j] == \"*\") and i > 0 and j > 0:\n                    f[i][j] |= f[i - 1][j - 1]\n                    # 当i>0 j>0 当s[i] == p[j] or p[j] == \"?\" or p[j] == \"*\" 前一个匹配，则此对匹配\n        return f[-1][-1]\n```\n\n代码如下\n\n```python\nclass Solution:\n    def isMatch(self, s, p):\n        if not s and p:\n            for i in range(0, len(p)):\n                if p[i] != \"*\":\n                    return False\n            return True\n        if s and not p:\n            return False\n        if not s and not p:\n            return True\n        f = [[False] * (len(p)) for _ in range(len(s))]\n        # for _ in range(len(s)) 中 _ 表示占位符 不管是什么，反正只要循环就行了\n        if s[0] == p[0] or p[0] == \"*\" or p[0] == \"?\":\n            f[0][0] = True\n        first = 1\n        if p[0] == \"*\":\n            while len(p) > first and p[first] == \"*\":\n                f[0][first] = True\n                first = first + 1\n            if len(p) > first and (s[0] == p[first] or p[first] == \"?\"):\n                f[0][first] = True\n            # 这个while 和 这个 if 的意义在于解决那些在p开头的*\n        for i in range(0, len(s)):\n            for j in range(0, len(p)):\n                if p[j] == \"*\" and i > 0:\n                    f[i][j] |= f[i - 1][j]\n                if p[j] == \"*\" and j > 0:\n                    f[i][j] |= f[i][j - 1]\n                    # 如果p中前一个匹配，则\n                if (s[i] == p[j] or p[j] == \"?\" or p[j] == \"*\") and i > 0 and j > 0:\n                    f[i][j] |= f[i - 1][j - 1]\n                    # 当i>0 j>0 当s[i] == p[j] or p[j] == \"?\" or p[j] == \"*\" 前一个匹配，则此对匹配\n        return f[-1][-1]\n\n\nif __name__ == '__main__':\n    s = \"mississippsssssi\"\n    p = \"*sssi\"\n    print(Solution().isMatch(s, p))\n\n```\n\n\n\n","source":"_posts/kelo算法课堂.md","raw":"---\ndate: 2020/2/8\ntags:\n- 自学笔记\n- 算法\ncategories:\n- 算法\n---\n# Kelo算法课堂(持续更新)\n\n*kelo做算法题并在其博客上连载，窃以为其思想精妙，故书吾感，记以学之。*\n\n***原作见友链***\n<!-- more -->\n1. 求最长回文串（Manacher）\n\n   * 思想\n\n     * 预处理 将原串中加入#，目的在于可以识别#a#b#b#a的回文串。\n\n       ​\t\t\t 在开头加入&,目的在于使回文串的识别从1开始\n\n     * for循环对length[i]进行求解。length[i]的实际意义是**回文半径**\n\n       ```\n       # a # b # c # c # b # d #\n       1 2 1 2 1 2 5 2 1 2 1 2 1 \n       ```\n\n       如上，第二行即为回文半径表，我们可以看出，以length[i].max为中心，根据其回文半径取得的回文字符串去掉#后即为最长回文串。\n\n       问题转化为求length[i]，以及**最大的回文长度(max_length)**和**回文中心(max_mid)**。实际上，最大的max_length和max_mid在i循环求length[i]的过程中进行更新即可。\n\n     * 当i在推算出来的现在所处的最大回文序列的右边界的左侧，则可以通过**简便方式推算**。\n\n       * 当max_right对结果无影响时（max_right足够大），我们可以直接先令 length[i] = length[2 * pos - i]\n       * 如果以i为中心的回文串长度超过max_right时候，由于我们无法判断max_right之后的情形，我们只能令length[i] = max_right - i\n       * 如果在最大回文序列右侧，则将它初始化为一\n\n     * 以i为中心，while循环测试以此时的i为中心向两边扩展，当两边没有达到边界且两边相同时，length[i]++\n\n     * 更新当前i为中心的回文序列的右边界max_right\n\n     * 将当前的回文序列长度和最大回文序列长度比较判断是否需要更新这个长度。\n\n   * 代码实现\n\n   ```javascript\n   /**\n    * @param {string} s\n    * @return {string}\n    */\n   \n   let s = \"afkfkfkaaaafkfk\";\n   \n   var longestPalindrome = function(s) {\n       let f = \"&#\";\n       for (let i = 0;i < s.length; i++){\n           f = f + s[i];\n           f = f + \"#\";\n       }\n       let length = [];\n       let max_right = 0, max_length = 0, pos = 0, max_pos = 0;\n       for (let i = 1;i < f.length;i++) {//求length[i]的循环\n           if (i < max_right) {\n               /*如果要求的i在推算出来的现在所处的最大回文序列的右边界的左侧，则可以通过简便方式进行推算：\n               当max_right对结果无影响时（max_right足够大），我们可以直接先令 length[i] = length[2 * pos - i]\n               如果以i为中心的回文串长度超过max_right时候，由于我们无法判断max_right之后的情形，我们只能令length[i] = max_right - i*/\n               length[i] = Math.min(max_right - i, length[2 * pos - i]);\n           } else length[i] = 1;\n           while (i - length[i] >=0 && i + length[i] < f.length && f[i - length[i]] === f[i + length[i]]){\n               length[i] = length[i] + 1;\n           }//这个循环就是在测试以此时的i为中心向两边扩展，1.没有到达数组边界 2.两方相等。如果两个条件都满足，则length[i]++\n           if (i + length[i] - 1 > max_right) {\n               max_right = i + length[i] - 1;\n               pos = i;\n           }//更新当前所在的最大回文序列的右边界\n           if (length[i] > max_length) {\n               max_length = length[i];\n               max_pos = i;\n           }//更新最大的回文长度和回文中心\n       }\n       let max_sub_string = f.substring(max_pos - max_length + 1, max_pos + max_length);\n       let real_sub = \"\";\n       for (let i = 0;i < max_sub_string.length;i++) {\n           if (max_sub_string[i] === \"#\") continue;\n           real_sub = real_sub + max_sub_string[i];\n       }\n       return real_sub;\n   };\n   \n   console.log(longestPalindrome(s));\n   ```\n\n2. 给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。（双指针法）\n\n   设置l，r两个指针，l指向数组开头，r指向数组结尾，计算容量，然后将较短的指针向前中间移动。每次移动指针后计算容量判断是否更新max。\n\n   *注：移动较短的是因为移动结果为容量变大或者不变。但是移动较长的只会容量变小或者不变*\n\n   ```javascript\n   var maxArea = function(height) {\n       let l = 0;\n       let r = height.length - 1;\n       let max_area = 0;\n       while (l !== r) {\n           max_area = Math.max(max_area, (r - l) * Math.min(height[l], height[r]));\n           if (height[l] < height[r]) l++;\n           else r--;\n       }\n       return max_area;\n   };\n   ```\n\n   * 数组.length\n   * Math.mac()\n   * L !== r\n   \n3. 已知n个括号对，将输出这些括号对的合法搭配，比如2个括号对的合法组合是：()(), (())\n\n   ```javascript\n   var generateParenthesis = function(n) {\n       let ans = [];\n       for (let set = 0; set < 1 << (2 * n); set++) {\n           let flag = 0;\n           let sub_ans = \"\";\n           for (let i = (1 << (2*n -1)); i ; i = i >> 1) {\n               if ((set & i) === i){\n                   flag = flag + 1;\n                   sub_ans = sub_ans + \"(\";\n               }else{\n                   flag = flag - 1;\n                   sub_ans = sub_ans + \")\"\n               }\n               if (flag < 0 || flag > n) break;\n           }\n           if (flag === 0) {\n               ans.push(sub_ans);\n           }\n       }\n       return ans;\n   };\n   console.log(generateParenthesis(3));\n   ```\n\n1看做左括号，0看做右括号，set为整个括号序列的二进制代表 ()()->1010\n\n遍历set即遍历0000 -> 1111\n\n取每一个set 对i进行遍历，与set比对。比如set = 1100，i取1000，100，10，1，分别与set进行&操作，1100 & 1000 == 1000，1100 & 1== 0，由此可以判断set每一位是1/0。\n\n1则flag加1，0则flag-1，当flag<0(右在左)或者flag>n(左括号已经肯定多于右括号)跳出。\n\ni循环完或者break后，对flag进行判断，如果flag === 0，则此set合法，将其压栈。\n\n4. 两数相加**（链表的应用）**\n\n```javascript\n\n/*Definition for singly-linked list.*/\nfunction ListNode(val) {\n    this.val = val;\n    this.next = null;\n}\n/**\n * @param {ListNode} l1\n * @param {ListNode} l2\n * @return {ListNode}\n */\n\nvar changeType = function(num){\n    let node = new ListNode(-1);\n    let node1 = new ListNode(-1);\n    for(let i = 10;; i*=10){\n        let part = (num % i)/(i/10);\n        num -=(part*(i/10));\n        if(node.val !== -1){\n            node1 = new ListNode(part);\n            node1.next = node;\n            node = node1;\n        }else{\n            node = new ListNode(part);\n        }\n        if(i > num)\n            break;\n    }\n    return node1;\n}\n\nvar addTwoNumbers = function(l1, l2) {\n    let head = new ListNode;\n    let present = head;\n    let c = 0;\n    while (1 === 1) {\n        let tmp = new ListNode;\n        if (l1 === null && l2 === null) {\n            if (c === 1) {\n                tmp.val = c;\n                tmp.next = null;\n                present.next = tmp;\n                present = present.next\n            }\n            break;\n        }\n        if (l1 === null) {\n            tmp.val = l2.val + c;\n            if (tmp.val >= 10) {\n                tmp.val = tmp. val - 10;\n                c = 1;\n            } else c = 0;\n            tmp.next = null;\n        } else\n        if (l2 === null) {\n            tmp.val = l1.val + c;\n            if (tmp.val >= 10) {\n                tmp.val = tmp. val - 10;\n                c = 1;\n            } else c = 0;\n            tmp.next = null;\n        } else {\n            let tmp_ans = l1.val + l2.val + c;\n            if (tmp_ans >= 10) {\n                tmp_ans = tmp_ans - 10;\n                c = 1;\n            } else c = 0;\n            tmp.val = tmp_ans;\n        }\n        tmp.next = null;\n        present.next = tmp;\n        present = present.next;\n        if (l1 === null) l2 = l2.next;\n        else if (l2 === null) l1 = l1.next;\n        else {\n            l1 = l1.next;\n            l2 = l2.next;\n        }\n    }\n    head = head.next;\n    return head;\n};\n\nconsole.log(addTwoNumbers(changeType(12),changeType(12)));\n```\n\n用到了链表的数据结构，changType改变(int)num为链表，addTwoNumbers将两个链表对应的数相加。\n\n5. 求一个字符串的最大无重复子串**（滑动窗口）**\n\n```javascript\n/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLongestSubstring = function(s) {\n    let map = new Map();\n    let l = 0;\n    let r = 1;\n    let max_length = s.length;\n    let max_ans = 1;\n    let substring = s.substring(l, r);\n    map.set(s[l], 1);\n    while (r < max_length && max_length-r-1>max_ans) {\n        if (!map.has(s[r])) {\n            map.set(s[r], 1);\n            r++;\n            if (r - l > max_ans) {\n                max_ans = r - l;\n                substring = s.substring(l, r);\n            }\n        } else {\n            map.delete(s[l]);\n            l++;\n        }\n    }\n    return substring.length;\n};\n```\n\n类似于双指针，初始化l=0，r=1，r右移，新收入的s[r]与之前的比，如果有相同，则l右移直至没有相同的。\n\n6. leetcode42 \n\n![](https://img.cetacis.dev/uploads/big/8408af07f366c184d8ff194926fe450b.png)\n\n**单调栈的使用**\n\n```python\nfrom typing import List\n\n\nclass Solution:\n    def trap(self, height: List[int]) -> int:\n        if not height:\n            return 0\n        ans = 0\n        stack = []\n        i = 0\n        while i + 1 < len(height) and height[i] < height[i + 1]:\n            i = i + 1\n        stack.append((height[i], i))\n        i = i + 1\n        while i < len(height):\n            if height[i] <= stack[-1][0]:\n                stack.append((height[i], i))\n            else:\n                last_height = -1\n                while len(stack) != 0 and stack[-1][0] < height[i]:\n                    if last_height == -1:\n                        last_height = stack[-1][0] \n                    else:\n                        ans = ans + (i - stack[-1][1] - 1) * (stack[-1][0] - last_height)\n                        last_height = stack[-1][0]\n                    stack.pop()\n                if len(stack) != 0:\n                    ans = ans + (i - stack[-1][1] - 1) * (height[i] - last_height)\n                stack.append((height[i], i))\n            i = i + 1\n        return ans\n\n\nif __name__ == '__main__':\n    a = [3,2,1,3]\n    print(Solution().trap(a))\n\n```\n\n数据结构：\n\n* stack的操作：[].append(***)入栈；[].pop()出栈；栈顶是stack[-1]\n* list判空：if (not) list:/if list is (not) None:/if len(list)==0\n* 二元组：a = (X, X)  访问的时候a[0]/a[1]。在此例中，(x, x)可作为栈元素，来确定元素在栈的位置。\n\n思想：\n\n* 开始先将单调递增的部分取出，这部分不可能装水\n* 将单调递减的部分入栈，然后在出现比栈顶大的部分进入计算部分。\n* 设置last_height，并且维护。\n\n主函数调用：\n\n```python\nif __name__ == '__main__':\n```\n\n7. leetcode 29\n\n快速除法\n\n```python\ndef minus(x, y, step, origin_y) -> int:\n    #  真正的除法过程\n    ans = 0\n    if x == 0:\n        return 0\n    while x - y >= 0:\n        x = x - y\n        ans = ans + pow(2, step)\n    if y == origin_y:\n        return ans\n    return minus(x, y >> 1, step - 1, origin_y) + ans\n\n\nclass Solution:\n    def divide(self, dividend: int, divisor: int) -> int:\n        flag = 0\n        if dividend < 0:\n            # 被除数小于零\n            dividend = - dividend\n            flag = flag ^ 1\n        if divisor < 0:\n            divisor = - divisor\n            flag = flag ^ 1\n            # flag代表正负\n        ans = minus(dividend, divisor << 32, 32, divisor)\n        ans = ans if flag == 0 else -ans\n        ans = ans if ans < 2147483647 else 2147483647\n        return ans\n\n\nif __name__ == '__main__':\n    a = 2\n    b = 1\n    c = Solution()\n    print(Solution.divide(c,a, b))\n\n```\n\n思想：\n\n核心思想在于，每一个数都可以拆成二的不同次幂的线性组合\n\n本题是除法，即将被除数拆成系数为除数倍数的不同二次幂的组合。\n\n比如：8/2 即8=2x(2^4) 9/3即9 = 3x(2^1+2^0) 27/3 = 3x(2x2^2+2^0)\n\n方法即从 除数x2^32 开始和被除数比较，并且每次比较后，如果被除数比除数乘2的次方小，则将除数乘2的次方右移（除以2）。用到了递归的方法。\n\n语法积累：\n\n* \n\n* ```python\n   ans = ans if flag == 0 else -ans\n  ```\n\n* 抑或\n\n  ```python\n   flag = flag ^ 1\n  ```\n\n* 如果本类中的某方法要调用本类中的其他方法，则需要加入self的参数。因为要调用类方法，必须要对类进行实例化。\n\n8. leetcode33\n\n本来有一个有序数列，如[1,2,3,4,5,6,7]\n\n从某个位置进行切割拼接 如[4, 5, 6, 7, 1, 2, 3]\n\n思路：\n\n* 主要还是二分法\n* 在这里有所不同，就是开始的时候分类，当nums[left] <= nums[mid]，即改变点在中点右侧，则left到改变点之间是可以用二分法的，则当nums[left] <= target < nums[mid]，right = mid-1，之后即为普通二分法，如果其他，则将left移动到mid+1.这样做，迟早会找到一个符合nums[left] <= target < nums[mid]或者nums[mid] < target <= nums[right]:的区间，然后就是正常的二分法了。\n\n```javascript\nclass Solution:\n    def search(self, nums, target):\n        if not nums:\n            return -1\n        left = 0\n        right = len(nums) - 1\n        while left < right:\n            print(left, right)\n            mid = (left + right) >> 1\n            if nums[mid] == target:\n                return mid\n            if nums[left] <= nums[mid]:\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        return left if nums[left] == target else -1\n\n```\n\n9. leetcode 34\n\n在排列数组中找到某一个target number的位置。\n\n二分+递归，当二分失败l>r return，或者target == a[mid]return，或者ans[0] < mid < ans[1]，主要是对l/r和ans[0],and[1]进行大小比对。\n\n```python\nfrom typing import List\n\n\nclass Solution:\n    def bin_search(self, a:List[int], l:int, r:int, target:int, ans:List[int]):\n        if l > r:\n            return\n        mid = (l + r) >> 1\n        if a[l] == target:\n            ans[0] = min(ans[0], l)\n            ans[1] = max(ans[1], l)\n        if a[r] == target:\n            ans[0] = min(ans[0], r)\n            ans[1] = max(ans[1], r)\n        if ans[0] < mid < ans[1]:\n            return\n        if target == a[mid]:\n            ans[0] = min(ans[0], mid)\n            ans[1] = max(ans[1], mid)\n            self.bin_search(a, l, mid - 1, target, ans)\n            self.bin_search(a, mid + 1, r, target, ans)\n            return\n        else:\n            if target > a[mid]:\n                self.bin_search(a, mid + 1, r, target, ans)\n            else:\n                self.bin_search(a, l, mid - 1, target, ans)\n\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n        ans = [200000000, -1]\n        self.bin_search(nums, 0, len(nums) - 1, target, ans)\n        if ans[1] == -1:\n            return [-1, -1]\n        else:\n            return ans\n\n\nif __name__ == '__main__':\n    nums = [7, 7, 7, 7, 7, 7, 10]\n    target = 7\n    print(Solution().searchRange(nums, target))\n\n\n```\n\n10. leetcode 36\n\n![题意](https://img.cetacis.dev/uploads/big/e379af099611ed74f5ef430b3ce538f1.png)\n\n**题解**\n\n看到这道题，很自然地想到嵌套循环，设置i,j分别遍历横排，竖排和3x3的块。难点在于python没有提供二维数组，所以要用自定义的数据结构存储和访问每一个元素。其中有一个flag要素，其实就是对每一个数字进行标记，如果某个数字的flag大于一，即出现了两次以上，则return false。\n\n```python\nfrom typing import List\n\n\nclass Solution:\n    def isValidSudoku(self, board: List[List[str]]):\n        for i in range(0, 9):\n            flag = [0] * 10\n            for j in range(0, 9):\n                if board[i][j] == \".\":\n                    continue\n                if flag[int(board[i][j])] == 0:\n                    flag[int(board[i][j])] = 1\n                else:\n                    return False\n        j = 0\n        while j < 9:\n            flag = [0] * 10\n            for i in range(0, 9):\n                if board[i][j] == \".\":\n                    continue\n                if flag[int(board[i][j])] == 0:\n                    flag[int(board[i][j])] = 1\n                else:\n                    return False\n            j = j + 1\n        for i in range(0, 9, 3):\n            for j in range(0, 9, 3):\n                flag = [0] * 10\n                for step_i in range(0, 3):\n                    for step_j in range(0, 3):\n                        if board[i + step_i][j + step_j] == \".\":\n                            continue\n                        if flag[int(board[i + step_i][j + step_j])] == 0:\n                            flag[int(board[i + step_i][j + step_j])] = 1\n                        else:\n                            return False\n        return True\na = Solution()\nif Solution.isValidSudoku(a,[[\"7\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],\n                             [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],\n                             [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],\n                             [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],\n                             [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],\n                             [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],\n                             [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],\n                             [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],\n                             [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]):\n    print (\"True\")\nelse:\n    print (\"False\")\n```\n\n11. leetcode 50\n\n快速幂 即通过简单乘法实现幂运算\n\n**题解**\n\n有一些像之前lt29做过的减法实现除法，一个指数可以拆分成很多子项相乘，比如3^8 = 3^4 x 3^4，此时，我们计算3^4再将结果相乘就可得到正确答案，这样节省了算两次3^4 的时间，可以满足时间复杂度。\n\n又 3^4 = 3^2 x 3^2，此时计算3^2 = 3*3。可以看出，这是一个递归的过程，每次将幂 >> 1，结束条件是幂=0 return 1。当然，幂也有奇数的可能性，当幂是奇数，只要将这一次的return改成 底数 x temp x temp即可。如果幂是偶数，则返回temp x temp。\n\n但是这个求幂的过程，底数和指数只能是正数，当底数和指数是负数的时候，需要将负数变为正数，再使用如上递归方程。并且对求得的幂进行符号/倒数修改，这就要求对底数、指数进行分类讨论。\n\nuna代码如下：\n\n````python\nclass Solution(object):\n    def Pow(self, x, n):\n        if n == 0:\n            return 1\n        else:\n            temp = self.Pow(x, n >> 1)\n        if n % 2 == 0:\n            return temp * temp\n        else:\n            return x * temp * temp\n\n    def myPow(self, x, n):\n        if x < 0 and n % 2 == 0:\n            return self.Pow(-x, n) if n > 0 else self.Pow(-x, -n)\n        elif x < 0 and n > 0:\n            return -self.Pow(-x, n)\n        if n < 0:\n            return 1/self.Pow(x, -n) if x > 0 else 1/-self.Pow(-x, -n)\n        else:\n            return self.Pow(x, n)\n\na = Solution()\nprint (Solution.myPow(a, -1, -2))\n\n````\n\nkelo代码如下：\n\n```python\nclass Solution:\n    def quick(self, x: float, n: int) -> float:\n        if n == 0:\n            return 1\n        if n == 1:\n            return x\n        res = 1\n        if n & 1 == 1:\n            res = x\n        half = self.quick(x, n >> 1)\n        return half * half * res\n\n    def myPow(self, x: float, n: int) -> float:\n        if n > 0:\n            return self.quick(x, n)\n        else:\n            return self.quick(1/x, -n)\n```\n\n12. leetcode 37 解数独\n\n顾名思义，解决数独，默认题目可解且有唯一解。\n\n**题解**\n\n第一想法是直接试错法，但是一想这个实验次数岂不是指数爆炸而且极其不美观，现实代码中使用递归试错（穷举）。\n\n值得注意的点除了这种递归的方法进行穷举以外，还有对某个数字是否出现过的控制方式。具体的做法和解析写在了注释里。\n\n```python\nfrom typing import List\n\n\nclass Solution:\n    COL = [0] * 10\n    ROW = [0] * 10\n    BLOCK = [0] * 10\n    Flag = 0\n\n    def solve(self, board: List[List[str]], i, j):\n        if self.Flag == 1:\n            return\n        if j == 9:\n            self.solve(board, i + 1, 0)\n            return\n        if i == 9:\n            self.Flag = 1\n            return\n        if board[i][j] != \".\":\n            self.solve(board, i, j + 1)\n            return\n        for x in range(1, 10):\n            if self.COL[i] & (1 << x) == 1 << x or self.ROW[j] & (1 << x) == 1 << x or \\\n                    self.BLOCK[int(i / 3) * 3 + int(j / 3)] & (1 << x) == 1 << x:\n                # 当行/列/块为x，则跳出本步循环。\n                # 即当x这个数已经在i行/列/块存在，不对需要col/row/block进行操作\n                # 因为已经有此数，则意味着不能填入此数\n                continue\n            board[i][j] = str(x)\n            # 填入x\n            self.COL[i] = self.COL[i] | (1 << x)\n            self.ROW[j] = self.ROW[j] | (1 << x)\n            self.BLOCK[int(i / 3) * 3 + int(j / 3)] = self.BLOCK[int(i / 3) * 3 + int(j / 3)] | (1 << x)\n            # 填入x后在col，row，block中进行维护\n            self.solve(board, i, j + 1)\n            if self.Flag == 1:\n                return\n            # 当i=9，即将所有的数字按照规则填充完成，则flag = 1，退出。\n            self.COL[i] = self.COL[i] ^ (1 << x)\n            self.ROW[j] = self.ROW[j] ^ (1 << x)\n            self.BLOCK[int(i / 3) * 3 + int(j / 3)] = self.BLOCK[int(i / 3) * 3 + int(j / 3)] ^ (1 << x)\n            board[i][j] = \".\"\n     # flag != 1,即未正确填充，则将此数，将col,row,block标记修改回之前的样子，并且将board[]\n    def solveSudoku(self, board: List[List[str]]) -> None:\n        for i in range(0, 10):\n            self.COL[i] = 0\n            self.ROW[i] = 0\n            self.BLOCK[i] = 0\n        for i in range(0, 9):\n            for j in range(0, 9):\n                if board[i][j] == \".\":\n                    continue\n                self.COL[i] = self.COL[i] | (1 << int(board[i][j]))\n                self.ROW[j] = self.ROW[j] | (1 << int(board[i][j]))\n                self.BLOCK[int(i / 3) * 3 + int(j / 3)] = self.BLOCK[int(i / 3) * 3 + int(j / 3)] | (1 << int(board[i][j]))\n            # 举例理解，当为i = 0，j = 0,board[0][0]=2, col[0] = 00000000100\n            # 当j++, i = 0,j = 1,board[0][1] = 1 col[0]= 0000000110\n            # 即，col[i]记录的，是i行的那些数字出现过。如0000000110就是1，2出现过（注意是第零位为0）\n        self.solve(board, 0, 0)\n\n\nif __name__ == '__main__':\n    bd = [[\".\", \".\", \"9\", \"7\", \"4\", \"8\", \".\", \".\", \".\"], [\"7\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\n     [\".\", \"2\", \".\", \"1\", \".\", \"9\", \".\", \".\", \".\"], [\".\", \".\", \"7\", \".\", \".\", \".\", \"2\", \"4\", \".\"],\n     [\".\", \"6\", \"4\", \".\", \"1\", \".\", \"5\", \"9\", \".\"], [\".\", \"9\", \"8\", \".\", \".\", \".\", \"3\", \".\", \".\"],\n     [\".\", \".\", \".\", \"8\", \".\", \"3\", \".\", \"2\", \".\"], [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \"6\"],\n     [\".\", \".\", \".\", \"2\", \"7\", \"5\", \"9\", \".\", \".\"]]\n    print(Solution().solveSudoku(bd))\n    print(bd)\n\n```\n\n13. leetcode 38 外观数组\n\n「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。前五项如下：\n\n1.     1\n2.     11\n3.     21\n4.     1211\n5.     111221\n1 被读作  \"one 1\"  (\"一个一\") , 即 11。\n11 被读作 \"two 1s\" (\"两个一\"）, 即 21。\n21 被读作 \"one 2\",  \"one 1\" （\"一个二\" ,  \"一个一\") , 即 1211。\n\n给定一个正整数 n（1 ≤ n ≤ 30），输出外观数列的第 n 项。\n\n注意：整数序列中的每一项将表示为一个字符串。\n\n**题解**\n\n因为ans[i]由ans[i-1]得来，则需从ans[2]开始求直到求到ans[n]。\n\n为了求ans[i]，可对ans[i-1]进行遍历，对ans[i-1] [j]的j进行循环，当ans[i-1] [j] = ans[i-1] [j+1]，则time ++，相当于如果一个数字重复出现，对出现次数进行++。\n\n直到ans[i-1] [j] ！= ans[i-1] [j+1]，则ans[i]+(str)time+ans[i-1] [j]，然后对time清零，再次进行如上循环操作。\n\n**代码如下**\n\n```python\nclass Solution(object):\n    def countAndSay(self, n):\n        ans = [\"\"] * 100\n        ans[1] = \"1\"\n        i = 1\n        j = 0\n\n        while i < n:\n            time = 1\n            while j + 1 < len(ans[i]) and ans[i][j] == ans[i][j + 1]:\n                time += 1\n                j = j + 1\n            ans[i + 1] = ans[i + 1] + str(time)+ans[i][j]\n            j = j + 1\n            if j == len(ans[i]):\n                i = i + 1\n                j = 0\n        return ans[n]\n\nprint (Solution().countAndSay(5))\n```\n\n14. leetcode 39 40\n\n给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。\n\ncandidates 中的数字可以无限制重复被选取。\n\n说明：\n\n所有数字（包括 target）都是正整数。\n解集不能包含重复的组合。 \n示例 1:\n\n```\n输入: candidates = [2,3,6,7], target = 7,\n所求解集为:\n[\n  [7],\n  [2,2,3]\n]\n```\n\n示例 2:\n\n```\n输入: candidates = [2,3,5], target = 8,\n所求解集为:\n[\n  [2,2,2,2],\n  [2,3,3],\n  [3,5]\n]\n```\n\n**题解**\n\n这道题我想到先从小到大sort candidates，然后累加最小的元素 candidates[0]，直到 = target 或者大于target。当 = 成立，则将此种list加入set，\n\n后续的操作两种情况一样，将最后两个candidates[0]出栈，尝试加入一个candidates[1]，如果= target 则将此种list加入set。之后，= target 或者大于target都将最后两个元素出栈，尝试加入candidates[1]，若小于则直接加入candidates[3]... \n\n这种不免为一种思路，我的想法是减少显而易见的优化方法，将工作交给计算机，就是每次减少一个在获得全部由candidates[0]组成的target（可能会大于或相等）然后尝试加入candidates[1]，如果能加入，则再加入candidate[1]，直到加到 和为target或者大于target，如同之前对candidates[0]的操作，将candidates[1]减少一个，试图加入candidates[2]..\n\n这样应该可以用到递归。\n\n之后，我看了kelo的代码，差不多是一样的思路，都用到了res = res - candidates[step]的思想（初试res即为target），这样，可以将res当做一个新的target，对其进行操作。\n\n```python\nfrom typing import List\n\n\nclass Solution:\n    ANS = set()\n    SUB_ANS = []\n\n    def find(self, step, res, candidates):\n        if res == 0:\n            self.ANS.add(tuple(self.SUB_ANS))\n            return\n\n        if step == len(candidates):\n            return\n\n        if candidates[step] <= res:\n            res = res - candidates[step]\n            self.SUB_ANS.append(candidates[step])\n            self.find(step, res, candidates)\n            self.find(step + 1, res, candidates)\n            res = res + candidates[step]\n            del self.SUB_ANS[-1]\n        self.find(step + 1, res, candidates)\n\n    def combinationSum(self, candidates, target):\n        self.ANS.clear()\n        self.SUB_ANS = []\n        candidates.sort()\n        self.find(0, target, candidates)\n        fin = []\n        for x in self.ANS:\n            fin.insert(len(fin), list(x))\n        return fin\n\n\nif __name__ == '__main__':\n    candidates = [1,2,3]\n    ta = 3\n    print(Solution().combinationSum(candidates, ta))\n```\n\n当不能重复使用时，将代码改成如下：\n\n```python\nfrom typing import List\n\n\nclass Solution:\n    ANS = set()\n    SUB_ANS = []\n\n    def find(self, step, res, candidates):\n        if res == 0:\n            self.ANS.add(tuple(self.SUB_ANS))\n            return\n\n        if step == len(candidates):\n            return\n\n        if candidates[step] <= res:\n            res = res - candidates[step]\n            self.SUB_ANS.append(candidates[step])\n            self.find(step + 1, res, candidates)\n            res = res + candidates[step]\n            del self.SUB_ANS[-1]\n        self.find(step + 1, res, candidates)\n\n    def combinationSum(self, candidates, target):\n        self.ANS.clear()\n        self.SUB_ANS = []\n        candidates.sort()\n        self.find(0, target, candidates)\n        fin = []\n        for x in self.ANS:\n            fin.insert(len(fin), list(x))\n        return fin\n\n\nif __name__ == '__main__':\n    candidates = [1,2,3]\n    ta = 3\n    print(Solution().combinationSum(candidates, ta))\n```\n\n15. leetcode 41\n\n得到一个数组中最小正整数\n\n如：[1,-1,3,5] 得到2\n\n**题解**\n\n这道题……确实只要遍历就可以了，但是对于时间和空间复杂度都有要求，所以可以采用一种自身哈希的方法，在前面的题中也提过。\n\n首先，根据抽屉定理，answer <= n+1\n\n将其中大于n的，小于等于零的设为1。（在这一步之前，先测其中是否有1，如果没有1则输出1）\n\n关键是将索引值作为哈希key。\n\n[1, 6, 2 , -1 , 3, 8]--->] [1, 6, 2, 1,3, 1]  （即包含1 - n元素的数组）\n\n对这个从1-n进行遍历：如果读到数字a，则将第几个元素的符号改变。（使用下表0代表n）\n\n最后返回第一个正数。如果没有，则判断0位置，如果还没有正数则返回n+1。\n\n代码：\n\n```python\nclass Solution:\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        \n        # 基本情况\n        if 1 not in nums:\n            return 1\n        \n        # nums = [1]\n        if n == 1:\n            return 2\n        \n        # 用 1 替换负数，0，\n        # 和大于 n 的数\n        # 在转换以后，nums 只会包含\n        # 正数\n        for i in range(n):\n            if nums[i] <= 0 or nums[i] > n:\n                nums[i] = 1\n        \n        # 使用索引和数字符号作为检查器\n        # 例如，如果 nums[1] 是负数表示在数组中出现了数字 `1`\n        # 如果 nums[2] 是正数 表示数字 2 没有出现\n        for i in range(n): \n            a = abs(nums[i])\n            # 如果发现了一个数字 a - 改变第 a 个元素的符号\n            # 注意重复元素只需操作一次\n            if a == n:\n                nums[0] = - abs(nums[0])\n            else:\n                nums[a] = - abs(nums[a])\n            \n        # 现在第一个正数的下标\n        # 就是第一个缺失的数\n        for i in range(1, n):\n            if nums[i] > 0:\n                return i\n        \n        if nums[0] > 0:\n            return n\n            \n        return n + 1\n```\n\n16. leetcode 45\n\n题意：\n\n给定一个非负整数数组，你最初位于数组的第一个位置。\n\n数组中的每个元素代表你在该位置可以跳跃的最大长度。\n\n你的目标是使用最少的跳跃次数到达数组的最后一个位置。\n\n```\n输入: [2,3,1,1,4]\n输出: 2\n解释: 跳到最后一个位置的最小跳跃数是 2。\n     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。\n```\n\n**题解**\n\n例子是[2, 3, 1, 1, 4]\n\n结合例子进行解释，nums[0] = 2, 因此跳一次最多到 nums[1]或者nums[2], 将2固定为max_pos，因为这是第一次跳跃后能够到达的最远位置。\n\n- i从0到1到max_pos进行遍历，每次更新max_arrive = max(max_arrive,nums[i]+i)。\n\n  *比如i=1，max_arrive = max(2, 4) = 4*\n\n  这个遍历其实是一个对第一步跳跃后，第二步跳跃可能情况的一个遍历，选出最大的max_arrive。\n\n- 当i和第一次固定的max_pos重叠时，将此时的max_pos 固定在max _arrive，并且跳跃步数++，相当于其实是选中了从确定max_arrive那次的i开始第二次起跳，max_pos 固定在此时的max _arrive, 进行与第一次相同的循环，直到i和max_pos 重叠。\n\n这个的实质其实是忽略i每次跳的位置（可以在max_arrive确定时确定），只记录跳的次数，进行多次相同的循环操作。\n\n代码如下：\n\n```python\nclass Solution:\n    def jump(self,nums):\n        max_pos = 0\n        max_arrive = 0\n        ans = 0\n        for i in range(0,len(nums)-1):\n            max_arrive = max(max_arrive,nums[i]+i)\n            if i>= max_pos:\n                max_pos = max_arrive\n                ans = ans + 1\n        return  ans\n```\n\n17. Leetcode 43字符串数的乘法\n\n如“67”‘89“，不能直接乘\n\n**题解：**\n\n* 按照乘法的规律，乘数为num1，被乘数为num2，先对num2进行遍历，跟num1的第一位相乘，num2中每取一个数，将答案的数组ans往后挪移一位。\n\n  同时对num1进行遍历，每次遍历，ans的起始下标加一。对每个num1元素跟num2的每个元素乘，加到ans的对应的位数。\n\n  ```python\n    for i in range(0, len(num1)):\n              local = i\n              for j in range(0, len(num2)):\n                  ans[local] += int(num1[len(num1) - i - 1]) * int(num2[len(num2) - j - 1])\n                  local = local + 1\n  ```\n\n* 如果ans的某位>10 则说明需要进位：\n\n  ```python\n          for i in range(0, local):\n              if ans[local - 1] >= 10:\n                  local = local + 1\n              ans[i + 1] += int(ans[i] / 10)\n              ans[i] %=10\n  ```\n\n* 判断最高位是否为0\n\n  ```python\n          while True:\n              if local == 1:\n                  break\n              if ans[local - 1] == 0:\n                  local = local - 1\n              else:\n                  break\n  ```\n\n* 将ans整合为final ans\n\n  ```python\n          for i in range(0, local):\n              final_ans = final_ans + str(ans[local - i - 1])\n  ```\n\n总体的代码如下：\n\n```python\nclass Solution:\n    def multiply(self, num1, num2) :\n        ans = [0] * 15000\n        local = 0\n        for i in range(0, len(num1)):\n            local = i\n            for j in range(0, len(num2)):\n                ans[local] += int(num1[len(num1) - i - 1]) * int(num2[len(num2) - j - 1])\n                local = local + 1\n        for i in range(0, local):\n            if ans[local - 1] >= 10:\n                local = local + 1\n            ans[i + 1] += int(ans[i] / 10)\n            ans[i] %=10\n        final_ans = \"\"\n        while True:\n            if local == 1:\n                break\n            if ans[local - 1] == 0:\n                local = local - 1\n            else:\n                break\n        for i in range(0, local):\n            final_ans = final_ans + str(ans[local - i - 1])\n        return final_ans\n\n\nif __name__ == '__main__':\n    a = \"12\"\n    b = \"12\"\n    c = Solution()\n    print(Solution().multiply(a, b))\n```\n\n18. Leetcode 46 全排列（无元素重复）\n\n用到了**回溯**的算法，这是一种通过探索所有可能的候选解来找出所有的解的算法。如果候选解被确认 不是 一个解的话（或者至少不是 最后一个 解），回溯算法会通过在上一步进行一些变化抛弃该解，即**回溯**并且再次尝试。\n\n一个回溯函数，使用第一个整数的索引作为参数 `backtrack(first)`\n\n如果整数索引为n则return, 并且在一次return后，将做的变化换回（即试错，重新进行其他尝试，在本题中不算试错，本题只是要算得每一种情况）\n\n**题解**\n\n* 如果第一个整数有索引 n，意味着当前排列已完成。\n* 遍历索引 first 到索引 n - 1 的所有整数。Iterate over the integers from index first to index n - 1.\n  * 在排列中放置第 i 个整数，\n    即 swap(nums[first], nums[i]).\n  * 继续生成从第 i 个整数开始的所有排列: backtrack(first + 1).\n  * 现在回溯，即通过 swap(nums[first], nums[i]) 还原.\n\n回溯法伪代码实现：\n\n```python\nclass Solution:\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        def backtrack(first = 0):\n            # if all integers are used up\n            if first == n:  \n                output.append(nums[:])\n            for i in range(first, n):\n                # place i-th integer first \n                # in the current permutation\n                nums[first], nums[i] = nums[i], nums[first]\n                # use next integers to complete the permutations\n                backtrack(first + 1)\n                # backtrack\n                nums[first], nums[i] = nums[i], nums[first]\n        \n        n = len(nums)\n        output = []\n        backtrack()\n        return output\n```\n\n*本题的思想在解数独中也出现过*\n\n下面是kelo的具体实现：\n\n```python\nfrom typing import List\n\n\nclass Solution:\n    ANS = []\n    SUB_ASN = []\n    set = 0\n    tot = 0\n    INF = 55\n\n    def dfs(self, nums: List[int], step):\n        if step == len(nums):\n            self.ANS.append(self.SUB_ASN[:])\n            return\n        for i in range(0, len(nums)):\n            if self.set & (1 << i) == 1 << i:\n                continue\n            self.SUB_ASN.append(nums[i])\n            self.set |= 1 << i\n            self.dfs(nums, step + 1)\n            self.set ^= 1 << i\n            del self.SUB_ASN[-1]\n\n    def permute(self, nums: List[int]):\n        self.ANS: List[List[int]]\n        self.ANS = []\n        self.tot = 0\n        self.SUB_ASN = []\n        self.dfs(nums, 0)\n        temp = []\n        for item in self.ANS:\n                temp.append(item)\n        return temp\n\n\nif __name__ == '__main__':\n    a = [1, 1, 3]\n    print(Solution().permute(a))\n```\n\n19. leetcode 47 全排列（有元素重复）\n\n只需要在无重复的基础上，将相同的去除即可。\n\n```python\n \t\t\t\tfor item in self.ANS:\n            if item not in temp:\n                temp.append(item)\n        return temp\n```\n\n20. leetcode49 单词的同分异构体\n\n例子：输入 a = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]，将其变为List(List(string))\n\n* \"\".join(sorted(string)) \n\n\"\".join()  : 将字符用“” 串联起来\n\nsorted(string) : 将string元素排序，得到一串字符集合。但是并不会改变原string\n\n* 此题用到哈希表\n\n**代码如下**\n\n```python\nfrom typing import List\n\n\nclass Solution:\n    def groupAnagrams(self, strs):\n        hash_map = {}\n        sort_string = [\"\".join(sorted(string)) for string in strs]\n        for i in range(0, len(sort_string)):\n            if sort_string[i] in hash_map:\n                hash_map[sort_string[i]].append(strs[i])\n            else:\n                hash_map[sort_string[i]] = [strs[i]]\n        return [x for x in hash_map.values()]\n\n\nif __name__ == '__main__':\n    a = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\n    print(Solution().groupAnagrams(a))\n```\n\nHash_map 是一个字典，key为排序过的str\n\n21. leetcode 44\n\n给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 '?' 和 '*' 的通配符匹配。\n\n'?' 可以匹配任何单个字符。\n'*' 可以匹配任意字符串（包括空字符串）。\n两个字符串完全匹配才算匹配成功。\n\n说明:\n\ns 可能为空，且只包含从 a-z 的小写字母。\np 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。\n\n**示例 1:**\n\n输入:\ns = \"aa\"\np = \"a\"\n输出: false\n解释: \"a\" 无法匹配 \"aa\" 整个字符串。\n\n**示例 2:**\n\n输入:\ns = \"aa\"\np = \"*\"\n输出: true\n解释: '*' 可以匹配任意字符串。\n\n**题解**\n\n最普遍的情况是，当p[j]=s[i]，或者为？，*时，如果s[i-1]，p[j-1]也匹配，则p[j]，s[i]匹配。\n\n历遍i j，如果p[-1] 与 s[-1]匹配，则结果为ture.要实现遍历，构建bool类型“二维数组”。\n\n```python\n f = [[False] * (len(p)) for _ in range(len(s))]\n# for _ in range(len(s)) 中 _ 表示占位符 不管是什么，反正只要循环就行了\n```\n\n实际上，有很多启动元素和特殊情况\n\n* f\\[0][0]的情况单独判断\n\n```python\nif s[0] == p[0] or p[0] == \"*\" or p[0] == \"?\":\n\tf[0][0] = True\n```\n\n* p开头为*, 需要单独判断所有的p与s[0]的匹配情况\n\n```python\nif p[0] == \"*\":\n    while len(p) > first and p[first] == \"*\":\n        f[0][first] = True\n        first = first + 1\n    if len(p) > first and (s[0] == p[first] or p[first] == \"?\"):\n        f[0][first] = True\n```\n\n* 接下来就是遍历\n\n```python\n  for i in range(0, len(s)):\n            for j in range(0, len(p)):\n                if p[j] == \"*\" and i > 0:\n                    f[i][j] |= f[i - 1][j]\n                if p[j] == \"*\" and j > 0:\n                    f[i][j] |= f[i][j - 1]\n                    # 如果p中前一个匹配，则\n                if (s[i] == p[j] or p[j] == \"?\" or p[j] == \"*\") and i > 0 and j > 0:\n                    f[i][j] |= f[i - 1][j - 1]\n                    # 当i>0 j>0 当s[i] == p[j] or p[j] == \"?\" or p[j] == \"*\" 前一个匹配，则此对匹配\n        return f[-1][-1]\n```\n\n代码如下\n\n```python\nclass Solution:\n    def isMatch(self, s, p):\n        if not s and p:\n            for i in range(0, len(p)):\n                if p[i] != \"*\":\n                    return False\n            return True\n        if s and not p:\n            return False\n        if not s and not p:\n            return True\n        f = [[False] * (len(p)) for _ in range(len(s))]\n        # for _ in range(len(s)) 中 _ 表示占位符 不管是什么，反正只要循环就行了\n        if s[0] == p[0] or p[0] == \"*\" or p[0] == \"?\":\n            f[0][0] = True\n        first = 1\n        if p[0] == \"*\":\n            while len(p) > first and p[first] == \"*\":\n                f[0][first] = True\n                first = first + 1\n            if len(p) > first and (s[0] == p[first] or p[first] == \"?\"):\n                f[0][first] = True\n            # 这个while 和 这个 if 的意义在于解决那些在p开头的*\n        for i in range(0, len(s)):\n            for j in range(0, len(p)):\n                if p[j] == \"*\" and i > 0:\n                    f[i][j] |= f[i - 1][j]\n                if p[j] == \"*\" and j > 0:\n                    f[i][j] |= f[i][j - 1]\n                    # 如果p中前一个匹配，则\n                if (s[i] == p[j] or p[j] == \"?\" or p[j] == \"*\") and i > 0 and j > 0:\n                    f[i][j] |= f[i - 1][j - 1]\n                    # 当i>0 j>0 当s[i] == p[j] or p[j] == \"?\" or p[j] == \"*\" 前一个匹配，则此对匹配\n        return f[-1][-1]\n\n\nif __name__ == '__main__':\n    s = \"mississippsssssi\"\n    p = \"*sssi\"\n    print(Solution().isMatch(s, p))\n\n```\n\n\n\n","slug":"kelo算法课堂","published":1,"updated":"2020-03-12T15:19:33.220Z","title":"kelo算法课堂","comments":1,"layout":"post","photos":[],"link":"","_id":"ck849avan0005thes0spw6l0a","content":"<h1 id=\"Kelo算法课堂-持续更新\"><a href=\"#Kelo算法课堂-持续更新\" class=\"headerlink\" title=\"Kelo算法课堂(持续更新)\"></a>Kelo算法课堂(持续更新)</h1><p><em>kelo做算法题并在其博客上连载，窃以为其思想精妙，故书吾感，记以学之。</em></p>\n<p><strong><em>原作见友链</em></strong></p>\n<a id=\"more\"></a>\n<ol>\n<li><p>求最长回文串（Manacher）</p>\n<ul>\n<li><p>思想</p>\n<ul>\n<li><p>预处理 将原串中加入#，目的在于可以识别#a#b#b#a的回文串。</p>\n<p>​             在开头加入&amp;,目的在于使回文串的识别从1开始</p>\n</li>\n<li><p>for循环对length[i]进行求解。length[i]的实际意义是<strong>回文半径</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># a # b # c # c # b # d #</span><br><span class=\"line\">1 2 1 2 1 2 5 2 1 2 1 2 1</span><br></pre></td></tr></table></figure>\n\n<p>如上，第二行即为回文半径表，我们可以看出，以length[i].max为中心，根据其回文半径取得的回文字符串去掉#后即为最长回文串。</p>\n<p>问题转化为求length[i]，以及<strong>最大的回文长度(max_length)</strong>和<strong>回文中心(max_mid)</strong>。实际上，最大的max_length和max_mid在i循环求length[i]的过程中进行更新即可。</p>\n</li>\n<li><p>当i在推算出来的现在所处的最大回文序列的右边界的左侧，则可以通过<strong>简便方式推算</strong>。</p>\n<ul>\n<li>当max_right对结果无影响时（max_right足够大），我们可以直接先令 length[i] = length[2 * pos - i]</li>\n<li>如果以i为中心的回文串长度超过max_right时候，由于我们无法判断max_right之后的情形，我们只能令length[i] = max_right - i</li>\n<li>如果在最大回文序列右侧，则将它初始化为一</li>\n</ul>\n</li>\n<li><p>以i为中心，while循环测试以此时的i为中心向两边扩展，当两边没有达到边界且两边相同时，length[i]++</p>\n</li>\n<li><p>更新当前i为中心的回文序列的右边界max_right</p>\n</li>\n<li><p>将当前的回文序列长度和最大回文序列长度比较判断是否需要更新这个长度。</p>\n</li>\n</ul>\n</li>\n<li><p>代码实现</p>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;string&#125;</span> <span class=\"variable\">s</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return <span class=\"type\">&#123;string&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"string\">\"afkfkfkaaaafkfk\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> longestPalindrome = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">s</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> f = <span class=\"string\">\"&amp;#\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>;i &lt; s.length; i++)&#123;</span><br><span class=\"line\">        f = f + s[i];</span><br><span class=\"line\">        f = f + <span class=\"string\">\"#\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> length = [];</span><br><span class=\"line\">    <span class=\"keyword\">let</span> max_right = <span class=\"number\">0</span>, max_length = <span class=\"number\">0</span>, pos = <span class=\"number\">0</span>, max_pos = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>;i &lt; f.length;i++) &#123;<span class=\"comment\">//求length[i]的循环</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &lt; max_right) &#123;</span><br><span class=\"line\">            <span class=\"comment\">/*如果要求的i在推算出来的现在所处的最大回文序列的右边界的左侧，则可以通过简便方式进行推算：</span></span><br><span class=\"line\"><span class=\"comment\">            当max_right对结果无影响时（max_right足够大），我们可以直接先令 length[i] = length[2 * pos - i]</span></span><br><span class=\"line\"><span class=\"comment\">            如果以i为中心的回文串长度超过max_right时候，由于我们无法判断max_right之后的情形，我们只能令length[i] = max_right - i*/</span></span><br><span class=\"line\">            length[i] = <span class=\"built_in\">Math</span>.min(max_right - i, length[<span class=\"number\">2</span> * pos - i]);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> length[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i - length[i] &gt;=<span class=\"number\">0</span> &amp;&amp; i + length[i] &lt; f.length &amp;&amp; f[i - length[i]] === f[i + length[i]])&#123;</span><br><span class=\"line\">            length[i] = length[i] + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;<span class=\"comment\">//这个循环就是在测试以此时的i为中心向两边扩展，1.没有到达数组边界 2.两方相等。如果两个条件都满足，则length[i]++</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i + length[i] - <span class=\"number\">1</span> &gt; max_right) &#123;</span><br><span class=\"line\">            max_right = i + length[i] - <span class=\"number\">1</span>;</span><br><span class=\"line\">            pos = i;</span><br><span class=\"line\">        &#125;<span class=\"comment\">//更新当前所在的最大回文序列的右边界</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (length[i] &gt; max_length) &#123;</span><br><span class=\"line\">            max_length = length[i];</span><br><span class=\"line\">            max_pos = i;</span><br><span class=\"line\">        &#125;<span class=\"comment\">//更新最大的回文长度和回文中心</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> max_sub_string = f.substring(max_pos - max_length + <span class=\"number\">1</span>, max_pos + max_length);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> real_sub = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>;i &lt; max_sub_string.length;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (max_sub_string[i] === <span class=\"string\">\"#\"</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        real_sub = real_sub + max_sub_string[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> real_sub;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(longestPalindrome(s));</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。（双指针法）</p>\n<p>设置l，r两个指针，l指向数组开头，r指向数组结尾，计算容量，然后将较短的指针向前中间移动。每次移动指针后计算容量判断是否更新max。</p>\n<p><em>注：移动较短的是因为移动结果为容量变大或者不变。但是移动较长的只会容量变小或者不变</em></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> maxArea = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">height</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> l = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> r = height.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> max_area = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (l !== r) &#123;</span><br><span class=\"line\">        max_area = <span class=\"built_in\">Math</span>.max(max_area, (r - l) * <span class=\"built_in\">Math</span>.min(height[l], height[r]));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (height[l] &lt; height[r]) l++;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> r--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max_area;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>数组.length</li>\n<li>Math.mac()</li>\n<li>L !== r</li>\n</ul>\n</li>\n<li><p>已知n个括号对，将输出这些括号对的合法搭配，比如2个括号对的合法组合是：()(), (())</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> generateParenthesis = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> ans = [];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> <span class=\"keyword\">set</span> = 0; <span class=\"keyword\">set</span> &lt; 1 &lt;&lt; (2 * n); <span class=\"keyword\">set</span>++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> sub_ans = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = (<span class=\"number\">1</span> &lt;&lt; (<span class=\"number\">2</span>*n <span class=\"number\">-1</span>)); i ; i = i &gt;&gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((<span class=\"keyword\">set</span> &amp; i) === i)&#123;</span><br><span class=\"line\">                flag = flag + <span class=\"number\">1</span>;</span><br><span class=\"line\">                sub_ans = sub_ans + <span class=\"string\">\"(\"</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                flag = flag - <span class=\"number\">1</span>;</span><br><span class=\"line\">                sub_ans = sub_ans + <span class=\"string\">\")\"</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (flag &lt; <span class=\"number\">0</span> || flag &gt; n) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (flag === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            ans.push(sub_ans);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(generateParenthesis(<span class=\"number\">3</span>));</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>1看做左括号，0看做右括号，set为整个括号序列的二进制代表 ()()-&gt;1010</p>\n<p>遍历set即遍历0000 -&gt; 1111</p>\n<p>取每一个set 对i进行遍历，与set比对。比如set = 1100，i取1000，100，10，1，分别与set进行&amp;操作，1100 &amp; 1000 == 1000，1100 &amp; 1== 0，由此可以判断set每一位是1/0。</p>\n<p>1则flag加1，0则flag-1，当flag&lt;0(右在左)或者flag&gt;n(左括号已经肯定多于右括号)跳出。</p>\n<p>i循环完或者break后，对flag进行判断，如果flag === 0，则此set合法，将其压栈。</p>\n<ol start=\"4\">\n<li>两数相加<strong>（链表的应用）</strong></li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*Definition for singly-linked list.*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ListNode</span>(<span class=\"params\">val</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.val = val;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.next = <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;ListNode&#125;</span> <span class=\"variable\">l1</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;ListNode&#125;</span> <span class=\"variable\">l2</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return <span class=\"type\">&#123;ListNode&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> changeType = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">num</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> node = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">-1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> node1 = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">-1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">10</span>;; i*=<span class=\"number\">10</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> part = (num % i)/(i/<span class=\"number\">10</span>);</span><br><span class=\"line\">        num -=(part*(i/<span class=\"number\">10</span>));</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(node.val !== <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">            node1 = <span class=\"keyword\">new</span> ListNode(part);</span><br><span class=\"line\">            node1.next = node;</span><br><span class=\"line\">            node = node1;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            node = <span class=\"keyword\">new</span> ListNode(part);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i &gt; num)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> addTwoNumbers = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">l1, l2</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> head = <span class=\"keyword\">new</span> ListNode;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> present = head;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> c = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span> === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> tmp = <span class=\"keyword\">new</span> ListNode;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l1 === <span class=\"literal\">null</span> &amp;&amp; l2 === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                tmp.val = c;</span><br><span class=\"line\">                tmp.next = <span class=\"literal\">null</span>;</span><br><span class=\"line\">                present.next = tmp;</span><br><span class=\"line\">                present = present.next</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l1 === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            tmp.val = l2.val + c;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (tmp.val &gt;= <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">                tmp.val = tmp. val - <span class=\"number\">10</span>;</span><br><span class=\"line\">                c = <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> c = <span class=\"number\">0</span>;</span><br><span class=\"line\">            tmp.next = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l2 === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            tmp.val = l1.val + c;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (tmp.val &gt;= <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">                tmp.val = tmp. val - <span class=\"number\">10</span>;</span><br><span class=\"line\">                c = <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> c = <span class=\"number\">0</span>;</span><br><span class=\"line\">            tmp.next = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> tmp_ans = l1.val + l2.val + c;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (tmp_ans &gt;= <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">                tmp_ans = tmp_ans - <span class=\"number\">10</span>;</span><br><span class=\"line\">                c = <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> c = <span class=\"number\">0</span>;</span><br><span class=\"line\">            tmp.val = tmp_ans;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        tmp.next = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        present.next = tmp;</span><br><span class=\"line\">        present = present.next;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l1 === <span class=\"literal\">null</span>) l2 = l2.next;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (l2 === <span class=\"literal\">null</span>) l1 = l1.next;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            l1 = l1.next;</span><br><span class=\"line\">            l2 = l2.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    head = head.next;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(addTwoNumbers(changeType(<span class=\"number\">12</span>),changeType(<span class=\"number\">12</span>)));</span><br></pre></td></tr></table></figure>\n\n<p>用到了链表的数据结构，changType改变(int)num为链表，addTwoNumbers将两个链表对应的数相加。</p>\n<ol start=\"5\">\n<li>求一个字符串的最大无重复子串<strong>（滑动窗口）</strong></li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;string&#125;</span> <span class=\"variable\">s</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return <span class=\"type\">&#123;number&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> lengthOfLongestSubstring = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">s</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">    <span class=\"keyword\">let</span> l = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> r = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> max_length = s.length;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> max_ans = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> substring = s.substring(l, r);</span><br><span class=\"line\">    map.set(s[l], <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (r &lt; max_length &amp;&amp; max_length-r<span class=\"number\">-1</span>&gt;max_ans) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!map.has(s[r])) &#123;</span><br><span class=\"line\">            map.set(s[r], <span class=\"number\">1</span>);</span><br><span class=\"line\">            r++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r - l &gt; max_ans) &#123;</span><br><span class=\"line\">                max_ans = r - l;</span><br><span class=\"line\">                substring = s.substring(l, r);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            map.delete(s[l]);</span><br><span class=\"line\">            l++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> substring.length;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>类似于双指针，初始化l=0，r=1，r右移，新收入的s[r]与之前的比，如果有相同，则l右移直至没有相同的。</p>\n<ol start=\"6\">\n<li>leetcode42 </li>\n</ol>\n<p><img src=\"https://img.cetacis.dev/uploads/big/8408af07f366c184d8ff194926fe450b.png\" alt=\"\"></p>\n<p><strong>单调栈的使用</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> typing <span class=\"keyword\">import</span> List</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">trap</span><span class=\"params\">(self, height: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> height:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        ans = <span class=\"number\">0</span></span><br><span class=\"line\">        stack = []</span><br><span class=\"line\">        i = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> i + <span class=\"number\">1</span> &lt; len(height) <span class=\"keyword\">and</span> height[i] &lt; height[i + <span class=\"number\">1</span>]:</span><br><span class=\"line\">            i = i + <span class=\"number\">1</span></span><br><span class=\"line\">        stack.append((height[i], i))</span><br><span class=\"line\">        i = i + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> i &lt; len(height):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> height[i] &lt;= stack[<span class=\"number\">-1</span>][<span class=\"number\">0</span>]:</span><br><span class=\"line\">                stack.append((height[i], i))</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                last_height = <span class=\"number\">-1</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> len(stack) != <span class=\"number\">0</span> <span class=\"keyword\">and</span> stack[<span class=\"number\">-1</span>][<span class=\"number\">0</span>] &lt; height[i]:</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> last_height == <span class=\"number\">-1</span>:</span><br><span class=\"line\">                        last_height = stack[<span class=\"number\">-1</span>][<span class=\"number\">0</span>] </span><br><span class=\"line\">                    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                        ans = ans + (i - stack[<span class=\"number\">-1</span>][<span class=\"number\">1</span>] - <span class=\"number\">1</span>) * (stack[<span class=\"number\">-1</span>][<span class=\"number\">0</span>] - last_height)</span><br><span class=\"line\">                        last_height = stack[<span class=\"number\">-1</span>][<span class=\"number\">0</span>]</span><br><span class=\"line\">                    stack.pop()</span><br><span class=\"line\">                <span class=\"keyword\">if</span> len(stack) != <span class=\"number\">0</span>:</span><br><span class=\"line\">                    ans = ans + (i - stack[<span class=\"number\">-1</span>][<span class=\"number\">1</span>] - <span class=\"number\">1</span>) * (height[i] - last_height)</span><br><span class=\"line\">                stack.append((height[i], i))</span><br><span class=\"line\">            i = i + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    a = [<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">    print(Solution().trap(a))</span><br></pre></td></tr></table></figure>\n\n<p>数据结构：</p>\n<ul>\n<li>stack的操作：[].append(***)入栈；[].pop()出栈；栈顶是stack[-1]</li>\n<li>list判空：if (not) list:/if list is (not) None:/if len(list)==0</li>\n<li>二元组：a = (X, X)  访问的时候a[0]/a[1]。在此例中，(x, x)可作为栈元素，来确定元素在栈的位置。</li>\n</ul>\n<p>思想：</p>\n<ul>\n<li>开始先将单调递增的部分取出，这部分不可能装水</li>\n<li>将单调递减的部分入栈，然后在出现比栈顶大的部分进入计算部分。</li>\n<li>设置last_height，并且维护。</li>\n</ul>\n<p>主函数调用：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br></pre></td></tr></table></figure>\n\n<ol start=\"7\">\n<li>leetcode 29</li>\n</ol>\n<p>快速除法</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minus</span><span class=\"params\">(x, y, step, origin_y)</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"comment\">#  真正的除法过程</span></span><br><span class=\"line\">    ans = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> x == <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> x - y &gt;= <span class=\"number\">0</span>:</span><br><span class=\"line\">        x = x - y</span><br><span class=\"line\">        ans = ans + pow(<span class=\"number\">2</span>, step)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> y == origin_y:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">    <span class=\"keyword\">return</span> minus(x, y &gt;&gt; <span class=\"number\">1</span>, step - <span class=\"number\">1</span>, origin_y) + ans</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">divide</span><span class=\"params\">(self, dividend: int, divisor: int)</span> -&gt; int:</span></span><br><span class=\"line\">        flag = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> dividend &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"comment\"># 被除数小于零</span></span><br><span class=\"line\">            dividend = - dividend</span><br><span class=\"line\">            flag = flag ^ <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> divisor &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            divisor = - divisor</span><br><span class=\"line\">            flag = flag ^ <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"comment\"># flag代表正负</span></span><br><span class=\"line\">        ans = minus(dividend, divisor &lt;&lt; <span class=\"number\">32</span>, <span class=\"number\">32</span>, divisor)</span><br><span class=\"line\">        ans = ans <span class=\"keyword\">if</span> flag == <span class=\"number\">0</span> <span class=\"keyword\">else</span> -ans</span><br><span class=\"line\">        ans = ans <span class=\"keyword\">if</span> ans &lt; <span class=\"number\">2147483647</span> <span class=\"keyword\">else</span> <span class=\"number\">2147483647</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    a = <span class=\"number\">2</span></span><br><span class=\"line\">    b = <span class=\"number\">1</span></span><br><span class=\"line\">    c = Solution()</span><br><span class=\"line\">    print(Solution.divide(c,a, b))</span><br></pre></td></tr></table></figure>\n\n<p>思想：</p>\n<p>核心思想在于，每一个数都可以拆成二的不同次幂的线性组合</p>\n<p>本题是除法，即将被除数拆成系数为除数倍数的不同二次幂的组合。</p>\n<p>比如：8/2 即8=2x(2^4) 9/3即9 = 3x(2^1+2^0) 27/3 = 3x(2x2^2+2^0)</p>\n<p>方法即从 除数x2^32 开始和被除数比较，并且每次比较后，如果被除数比除数乘2的次方小，则将除数乘2的次方右移（除以2）。用到了递归的方法。</p>\n<p>语法积累：</p>\n<ul>\n<li></li>\n<li><pre><code class=\"python\"> ans = ans <span class=\"keyword\">if</span> flag == <span class=\"number\">0</span> <span class=\"keyword\">else</span> -ans\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* 抑或</span><br><span class=\"line\"></span><br><span class=\"line\">  &#96;&#96;&#96;python</span><br><span class=\"line\">   flag &#x3D; flag ^ 1</span><br></pre></td></tr></table></figure></code></pre>\n</li>\n<li><p>如果本类中的某方法要调用本类中的其他方法，则需要加入self的参数。因为要调用类方法，必须要对类进行实例化。</p>\n</li>\n</ul>\n<ol start=\"8\">\n<li>leetcode33</li>\n</ol>\n<p>本来有一个有序数列，如[1,2,3,4,5,6,7]</p>\n<p>从某个位置进行切割拼接 如[4, 5, 6, 7, 1, 2, 3]</p>\n<p>思路：</p>\n<ul>\n<li>主要还是二分法</li>\n<li>在这里有所不同，就是开始的时候分类，当nums[left] &lt;= nums[mid]，即改变点在中点右侧，则left到改变点之间是可以用二分法的，则当nums[left] &lt;= target &lt; nums[mid]，right = mid-1，之后即为普通二分法，如果其他，则将left移动到mid+1.这样做，迟早会找到一个符合nums[left] &lt;= target &lt; nums[mid]或者nums[mid] &lt; target &lt;= nums[right]:的区间，然后就是正常的二分法了。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution:</span><br><span class=\"line\">    def search(self, nums, target):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> not nums:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">        left = <span class=\"number\">0</span></span><br><span class=\"line\">        right = len(nums) - <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> left &lt; right:</span><br><span class=\"line\">            print(left, right)</span><br><span class=\"line\">            mid = (left + right) &gt;&gt; <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[mid] == target:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> mid</span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[left] &lt;= nums[mid]:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> nums[left] &lt;= target &lt; nums[mid]:</span><br><span class=\"line\">                    right = mid - <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    left = mid + <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> nums[mid] &lt; target &lt;= nums[right]:</span><br><span class=\"line\">                    left = mid + <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    right = mid - <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> left <span class=\"keyword\">if</span> nums[left] == target <span class=\"keyword\">else</span> <span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"9\">\n<li>leetcode 34</li>\n</ol>\n<p>在排列数组中找到某一个target number的位置。</p>\n<p>二分+递归，当二分失败l&gt;r return，或者target == a[mid]return，或者ans[0] &lt; mid &lt; ans[1]，主要是对l/r和ans[0],and[1]进行大小比对。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> typing <span class=\"keyword\">import</span> List</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">bin_search</span><span class=\"params\">(self, a:List[int], l:int, r:int, target:int, ans:List[int])</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> l &gt; r:</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        mid = (l + r) &gt;&gt; <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> a[l] == target:</span><br><span class=\"line\">            ans[<span class=\"number\">0</span>] = min(ans[<span class=\"number\">0</span>], l)</span><br><span class=\"line\">            ans[<span class=\"number\">1</span>] = max(ans[<span class=\"number\">1</span>], l)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> a[r] == target:</span><br><span class=\"line\">            ans[<span class=\"number\">0</span>] = min(ans[<span class=\"number\">0</span>], r)</span><br><span class=\"line\">            ans[<span class=\"number\">1</span>] = max(ans[<span class=\"number\">1</span>], r)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ans[<span class=\"number\">0</span>] &lt; mid &lt; ans[<span class=\"number\">1</span>]:</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> target == a[mid]:</span><br><span class=\"line\">            ans[<span class=\"number\">0</span>] = min(ans[<span class=\"number\">0</span>], mid)</span><br><span class=\"line\">            ans[<span class=\"number\">1</span>] = max(ans[<span class=\"number\">1</span>], mid)</span><br><span class=\"line\">            self.bin_search(a, l, mid - <span class=\"number\">1</span>, target, ans)</span><br><span class=\"line\">            self.bin_search(a, mid + <span class=\"number\">1</span>, r, target, ans)</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> target &gt; a[mid]:</span><br><span class=\"line\">                self.bin_search(a, mid + <span class=\"number\">1</span>, r, target, ans)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                self.bin_search(a, l, mid - <span class=\"number\">1</span>, target, ans)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">searchRange</span><span class=\"params\">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class=\"line\">        ans = [<span class=\"number\">200000000</span>, <span class=\"number\">-1</span>]</span><br><span class=\"line\">        self.bin_search(nums, <span class=\"number\">0</span>, len(nums) - <span class=\"number\">1</span>, target, ans)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ans[<span class=\"number\">1</span>] == <span class=\"number\">-1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> [<span class=\"number\">-1</span>, <span class=\"number\">-1</span>]</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ans</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    nums = [<span class=\"number\">7</span>, <span class=\"number\">7</span>, <span class=\"number\">7</span>, <span class=\"number\">7</span>, <span class=\"number\">7</span>, <span class=\"number\">7</span>, <span class=\"number\">10</span>]</span><br><span class=\"line\">    target = <span class=\"number\">7</span></span><br><span class=\"line\">    print(Solution().searchRange(nums, target))</span><br></pre></td></tr></table></figure>\n\n<ol start=\"10\">\n<li>leetcode 36</li>\n</ol>\n<p><img src=\"https://img.cetacis.dev/uploads/big/e379af099611ed74f5ef430b3ce538f1.png\" alt=\"题意\"></p>\n<p><strong>题解</strong></p>\n<p>看到这道题，很自然地想到嵌套循环，设置i,j分别遍历横排，竖排和3x3的块。难点在于python没有提供二维数组，所以要用自定义的数据结构存储和访问每一个元素。其中有一个flag要素，其实就是对每一个数字进行标记，如果某个数字的flag大于一，即出现了两次以上，则return false。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> typing <span class=\"keyword\">import</span> List</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isValidSudoku</span><span class=\"params\">(self, board: List[List[str]])</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, <span class=\"number\">9</span>):</span><br><span class=\"line\">            flag = [<span class=\"number\">0</span>] * <span class=\"number\">10</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, <span class=\"number\">9</span>):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> board[i][j] == <span class=\"string\">\".\"</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> flag[int(board[i][j])] == <span class=\"number\">0</span>:</span><br><span class=\"line\">                    flag[int(board[i][j])] = <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        j = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> j &lt; <span class=\"number\">9</span>:</span><br><span class=\"line\">            flag = [<span class=\"number\">0</span>] * <span class=\"number\">10</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, <span class=\"number\">9</span>):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> board[i][j] == <span class=\"string\">\".\"</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> flag[int(board[i][j])] == <span class=\"number\">0</span>:</span><br><span class=\"line\">                    flag[int(board[i][j])] = <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">            j = j + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, <span class=\"number\">9</span>, <span class=\"number\">3</span>):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, <span class=\"number\">9</span>, <span class=\"number\">3</span>):</span><br><span class=\"line\">                flag = [<span class=\"number\">0</span>] * <span class=\"number\">10</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> step_i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, <span class=\"number\">3</span>):</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> step_j <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, <span class=\"number\">3</span>):</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> board[i + step_i][j + step_j] == <span class=\"string\">\".\"</span>:</span><br><span class=\"line\">                            <span class=\"keyword\">continue</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> flag[int(board[i + step_i][j + step_j])] == <span class=\"number\">0</span>:</span><br><span class=\"line\">                            flag[int(board[i + step_i][j + step_j])] = <span class=\"number\">1</span></span><br><span class=\"line\">                        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">a = Solution()</span><br><span class=\"line\"><span class=\"keyword\">if</span> Solution.isValidSudoku(a,[[<span class=\"string\">\"7\"</span>,<span class=\"string\">\"3\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\"7\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\".\"</span>],</span><br><span class=\"line\">                             [<span class=\"string\">\"6\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\"1\"</span>,<span class=\"string\">\"9\"</span>,<span class=\"string\">\"5\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\".\"</span>],</span><br><span class=\"line\">                             [<span class=\"string\">\".\"</span>,<span class=\"string\">\"9\"</span>,<span class=\"string\">\"8\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\"6\"</span>,<span class=\"string\">\".\"</span>],</span><br><span class=\"line\">                             [<span class=\"string\">\"8\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\"6\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\"3\"</span>],</span><br><span class=\"line\">                             [<span class=\"string\">\"4\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\"8\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\"3\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\"1\"</span>],</span><br><span class=\"line\">                             [<span class=\"string\">\"7\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\"2\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\"6\"</span>],</span><br><span class=\"line\">                             [<span class=\"string\">\".\"</span>,<span class=\"string\">\"6\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\"2\"</span>,<span class=\"string\">\"8\"</span>,<span class=\"string\">\".\"</span>],</span><br><span class=\"line\">                             [<span class=\"string\">\".\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\"4\"</span>,<span class=\"string\">\"1\"</span>,<span class=\"string\">\"9\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\"5\"</span>],</span><br><span class=\"line\">                             [<span class=\"string\">\".\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\"8\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\"7\"</span>,<span class=\"string\">\"9\"</span>]]):</span><br><span class=\"line\">    <span class=\"keyword\">print</span> (<span class=\"string\">\"True\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">    <span class=\"keyword\">print</span> (<span class=\"string\">\"False\"</span>)</span><br></pre></td></tr></table></figure>\n\n<ol start=\"11\">\n<li>leetcode 50</li>\n</ol>\n<p>快速幂 即通过简单乘法实现幂运算</p>\n<p><strong>题解</strong></p>\n<p>有一些像之前lt29做过的减法实现除法，一个指数可以拆分成很多子项相乘，比如3^8 = 3^4 x 3^4，此时，我们计算3^4再将结果相乘就可得到正确答案，这样节省了算两次3^4 的时间，可以满足时间复杂度。</p>\n<p>又 3^4 = 3^2 x 3^2，此时计算3^2 = 3*3。可以看出，这是一个递归的过程，每次将幂 &gt;&gt; 1，结束条件是幂=0 return 1。当然，幂也有奇数的可能性，当幂是奇数，只要将这一次的return改成 底数 x temp x temp即可。如果幂是偶数，则返回temp x temp。</p>\n<p>但是这个求幂的过程，底数和指数只能是正数，当底数和指数是负数的时候，需要将负数变为正数，再使用如上递归方程。并且对求得的幂进行符号/倒数修改，这就要求对底数、指数进行分类讨论。</p>\n<p>una代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">Pow</span><span class=\"params\">(self, x, n)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            temp = self.Pow(x, n &gt;&gt; <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n % <span class=\"number\">2</span> == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> temp * temp</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> x * temp * temp</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">myPow</span><span class=\"params\">(self, x, n)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> x &lt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> n % <span class=\"number\">2</span> == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.Pow(-x, n) <span class=\"keyword\">if</span> n &gt; <span class=\"number\">0</span> <span class=\"keyword\">else</span> self.Pow(-x, -n)</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> x &lt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> n &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -self.Pow(-x, n)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>/self.Pow(x, -n) <span class=\"keyword\">if</span> x &gt; <span class=\"number\">0</span> <span class=\"keyword\">else</span> <span class=\"number\">1</span>/-self.Pow(-x, -n)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.Pow(x, n)</span><br><span class=\"line\"></span><br><span class=\"line\">a = Solution()</span><br><span class=\"line\"><span class=\"keyword\">print</span> (Solution.myPow(a, <span class=\"number\">-1</span>, <span class=\"number\">-2</span>))</span><br></pre></td></tr></table></figure>\n\n<p>kelo代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">quick</span><span class=\"params\">(self, x: float, n: int)</span> -&gt; float:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> x</span><br><span class=\"line\">        res = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> n &amp; <span class=\"number\">1</span> == <span class=\"number\">1</span>:</span><br><span class=\"line\">            res = x</span><br><span class=\"line\">        half = self.quick(x, n &gt;&gt; <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> half * half * res</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">myPow</span><span class=\"params\">(self, x: float, n: int)</span> -&gt; float:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> n &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.quick(x, n)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.quick(<span class=\"number\">1</span>/x, -n)</span><br></pre></td></tr></table></figure>\n\n<ol start=\"12\">\n<li>leetcode 37 解数独</li>\n</ol>\n<p>顾名思义，解决数独，默认题目可解且有唯一解。</p>\n<p><strong>题解</strong></p>\n<p>第一想法是直接试错法，但是一想这个实验次数岂不是指数爆炸而且极其不美观，现实代码中使用递归试错（穷举）。</p>\n<p>值得注意的点除了这种递归的方法进行穷举以外，还有对某个数字是否出现过的控制方式。具体的做法和解析写在了注释里。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> typing <span class=\"keyword\">import</span> List</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    COL = [<span class=\"number\">0</span>] * <span class=\"number\">10</span></span><br><span class=\"line\">    ROW = [<span class=\"number\">0</span>] * <span class=\"number\">10</span></span><br><span class=\"line\">    BLOCK = [<span class=\"number\">0</span>] * <span class=\"number\">10</span></span><br><span class=\"line\">    Flag = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">solve</span><span class=\"params\">(self, board: List[List[str]], i, j)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.Flag == <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> j == <span class=\"number\">9</span>:</span><br><span class=\"line\">            self.solve(board, i + <span class=\"number\">1</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> i == <span class=\"number\">9</span>:</span><br><span class=\"line\">            self.Flag = <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> board[i][j] != <span class=\"string\">\".\"</span>:</span><br><span class=\"line\">            self.solve(board, i, j + <span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, <span class=\"number\">10</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> self.COL[i] &amp; (<span class=\"number\">1</span> &lt;&lt; x) == <span class=\"number\">1</span> &lt;&lt; x <span class=\"keyword\">or</span> self.ROW[j] &amp; (<span class=\"number\">1</span> &lt;&lt; x) == <span class=\"number\">1</span> &lt;&lt; x <span class=\"keyword\">or</span> \\</span><br><span class=\"line\">                    self.BLOCK[int(i / <span class=\"number\">3</span>) * <span class=\"number\">3</span> + int(j / <span class=\"number\">3</span>)] &amp; (<span class=\"number\">1</span> &lt;&lt; x) == <span class=\"number\">1</span> &lt;&lt; x:</span><br><span class=\"line\">                <span class=\"comment\"># 当行/列/块为x，则跳出本步循环。</span></span><br><span class=\"line\">                <span class=\"comment\"># 即当x这个数已经在i行/列/块存在，不对需要col/row/block进行操作</span></span><br><span class=\"line\">                <span class=\"comment\"># 因为已经有此数，则意味着不能填入此数</span></span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            board[i][j] = str(x)</span><br><span class=\"line\">            <span class=\"comment\"># 填入x</span></span><br><span class=\"line\">            self.COL[i] = self.COL[i] | (<span class=\"number\">1</span> &lt;&lt; x)</span><br><span class=\"line\">            self.ROW[j] = self.ROW[j] | (<span class=\"number\">1</span> &lt;&lt; x)</span><br><span class=\"line\">            self.BLOCK[int(i / <span class=\"number\">3</span>) * <span class=\"number\">3</span> + int(j / <span class=\"number\">3</span>)] = self.BLOCK[int(i / <span class=\"number\">3</span>) * <span class=\"number\">3</span> + int(j / <span class=\"number\">3</span>)] | (<span class=\"number\">1</span> &lt;&lt; x)</span><br><span class=\"line\">            <span class=\"comment\"># 填入x后在col，row，block中进行维护</span></span><br><span class=\"line\">            self.solve(board, i, j + <span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> self.Flag == <span class=\"number\">1</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span></span><br><span class=\"line\">            <span class=\"comment\"># 当i=9，即将所有的数字按照规则填充完成，则flag = 1，退出。</span></span><br><span class=\"line\">            self.COL[i] = self.COL[i] ^ (<span class=\"number\">1</span> &lt;&lt; x)</span><br><span class=\"line\">            self.ROW[j] = self.ROW[j] ^ (<span class=\"number\">1</span> &lt;&lt; x)</span><br><span class=\"line\">            self.BLOCK[int(i / <span class=\"number\">3</span>) * <span class=\"number\">3</span> + int(j / <span class=\"number\">3</span>)] = self.BLOCK[int(i / <span class=\"number\">3</span>) * <span class=\"number\">3</span> + int(j / <span class=\"number\">3</span>)] ^ (<span class=\"number\">1</span> &lt;&lt; x)</span><br><span class=\"line\">            board[i][j] = <span class=\"string\">\".\"</span></span><br><span class=\"line\">     <span class=\"comment\"># flag != 1,即未正确填充，则将此数，将col,row,block标记修改回之前的样子，并且将board[]</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">solveSudoku</span><span class=\"params\">(self, board: List[List[str]])</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, <span class=\"number\">10</span>):</span><br><span class=\"line\">            self.COL[i] = <span class=\"number\">0</span></span><br><span class=\"line\">            self.ROW[i] = <span class=\"number\">0</span></span><br><span class=\"line\">            self.BLOCK[i] = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, <span class=\"number\">9</span>):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, <span class=\"number\">9</span>):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> board[i][j] == <span class=\"string\">\".\"</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span></span><br><span class=\"line\">                self.COL[i] = self.COL[i] | (<span class=\"number\">1</span> &lt;&lt; int(board[i][j]))</span><br><span class=\"line\">                self.ROW[j] = self.ROW[j] | (<span class=\"number\">1</span> &lt;&lt; int(board[i][j]))</span><br><span class=\"line\">                self.BLOCK[int(i / <span class=\"number\">3</span>) * <span class=\"number\">3</span> + int(j / <span class=\"number\">3</span>)] = self.BLOCK[int(i / <span class=\"number\">3</span>) * <span class=\"number\">3</span> + int(j / <span class=\"number\">3</span>)] | (<span class=\"number\">1</span> &lt;&lt; int(board[i][j]))</span><br><span class=\"line\">            <span class=\"comment\"># 举例理解，当为i = 0，j = 0,board[0][0]=2, col[0] = 00000000100</span></span><br><span class=\"line\">            <span class=\"comment\"># 当j++, i = 0,j = 1,board[0][1] = 1 col[0]= 0000000110</span></span><br><span class=\"line\">            <span class=\"comment\"># 即，col[i]记录的，是i行的那些数字出现过。如0000000110就是1，2出现过（注意是第零位为0）</span></span><br><span class=\"line\">        self.solve(board, <span class=\"number\">0</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    bd = [[<span class=\"string\">\".\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\"9\"</span>, <span class=\"string\">\"7\"</span>, <span class=\"string\">\"4\"</span>, <span class=\"string\">\"8\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\".\"</span>], [<span class=\"string\">\"7\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\".\"</span>],</span><br><span class=\"line\">     [<span class=\"string\">\".\"</span>, <span class=\"string\">\"2\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\"1\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\"9\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\".\"</span>], [<span class=\"string\">\".\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\"7\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\"2\"</span>, <span class=\"string\">\"4\"</span>, <span class=\"string\">\".\"</span>],</span><br><span class=\"line\">     [<span class=\"string\">\".\"</span>, <span class=\"string\">\"6\"</span>, <span class=\"string\">\"4\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\"1\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\"5\"</span>, <span class=\"string\">\"9\"</span>, <span class=\"string\">\".\"</span>], [<span class=\"string\">\".\"</span>, <span class=\"string\">\"9\"</span>, <span class=\"string\">\"8\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\"3\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\".\"</span>],</span><br><span class=\"line\">     [<span class=\"string\">\".\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\"8\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\"3\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\"2\"</span>, <span class=\"string\">\".\"</span>], [<span class=\"string\">\".\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\"6\"</span>],</span><br><span class=\"line\">     [<span class=\"string\">\".\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\"2\"</span>, <span class=\"string\">\"7\"</span>, <span class=\"string\">\"5\"</span>, <span class=\"string\">\"9\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\".\"</span>]]</span><br><span class=\"line\">    print(Solution().solveSudoku(bd))</span><br><span class=\"line\">    print(bd)</span><br></pre></td></tr></table></figure>\n\n<ol start=\"13\">\n<li>leetcode 38 外观数组</li>\n</ol>\n<p>「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。前五项如下：</p>\n<ol>\n<li>1</li>\n<li>11</li>\n<li>21</li>\n<li>1211</li>\n<li>111221<br>1 被读作  “one 1”  (“一个一”) , 即 11。<br>11 被读作 “two 1s” (“两个一”）, 即 21。<br>21 被读作 “one 2”,  “one 1” （”一个二” ,  “一个一”) , 即 1211。</li>\n</ol>\n<p>给定一个正整数 n（1 ≤ n ≤ 30），输出外观数列的第 n 项。</p>\n<p>注意：整数序列中的每一项将表示为一个字符串。</p>\n<p><strong>题解</strong></p>\n<p>因为ans[i]由ans[i-1]得来，则需从ans[2]开始求直到求到ans[n]。</p>\n<p>为了求ans[i]，可对ans[i-1]进行遍历，对ans[i-1] [j]的j进行循环，当ans[i-1] [j] = ans[i-1] [j+1]，则time ++，相当于如果一个数字重复出现，对出现次数进行++。</p>\n<p>直到ans[i-1] [j] ！= ans[i-1] [j+1]，则ans[i]+(str)time+ans[i-1] [j]，然后对time清零，再次进行如上循环操作。</p>\n<p><strong>代码如下</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">countAndSay</span><span class=\"params\">(self, n)</span>:</span></span><br><span class=\"line\">        ans = [<span class=\"string\">\"\"</span>] * <span class=\"number\">100</span></span><br><span class=\"line\">        ans[<span class=\"number\">1</span>] = <span class=\"string\">\"1\"</span></span><br><span class=\"line\">        i = <span class=\"number\">1</span></span><br><span class=\"line\">        j = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> i &lt; n:</span><br><span class=\"line\">            time = <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> j + <span class=\"number\">1</span> &lt; len(ans[i]) <span class=\"keyword\">and</span> ans[i][j] == ans[i][j + <span class=\"number\">1</span>]:</span><br><span class=\"line\">                time += <span class=\"number\">1</span></span><br><span class=\"line\">                j = j + <span class=\"number\">1</span></span><br><span class=\"line\">            ans[i + <span class=\"number\">1</span>] = ans[i + <span class=\"number\">1</span>] + str(time)+ans[i][j]</span><br><span class=\"line\">            j = j + <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> j == len(ans[i]):</span><br><span class=\"line\">                i = i + <span class=\"number\">1</span></span><br><span class=\"line\">                j = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans[n]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">print</span> (Solution().countAndSay(<span class=\"number\">5</span>))</span><br></pre></td></tr></table></figure>\n\n<ol start=\"14\">\n<li>leetcode 39 40</li>\n</ol>\n<p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>\n<p>candidates 中的数字可以无限制重复被选取。</p>\n<p>说明：</p>\n<p>所有数字（包括 target）都是正整数。<br>解集不能包含重复的组合。<br>示例 1:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: candidates &#x3D; [2,3,6,7], target &#x3D; 7,</span><br><span class=\"line\">所求解集为:</span><br><span class=\"line\">[</span><br><span class=\"line\">  [7],</span><br><span class=\"line\">  [2,2,3]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>示例 2:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: candidates &#x3D; [2,3,5], target &#x3D; 8,</span><br><span class=\"line\">所求解集为:</span><br><span class=\"line\">[</span><br><span class=\"line\">  [2,2,2,2],</span><br><span class=\"line\">  [2,3,3],</span><br><span class=\"line\">  [3,5]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p><strong>题解</strong></p>\n<p>这道题我想到先从小到大sort candidates，然后累加最小的元素 candidates[0]，直到 = target 或者大于target。当 = 成立，则将此种list加入set，</p>\n<p>后续的操作两种情况一样，将最后两个candidates[0]出栈，尝试加入一个candidates[1]，如果= target 则将此种list加入set。之后，= target 或者大于target都将最后两个元素出栈，尝试加入candidates[1]，若小于则直接加入candidates[3]… </p>\n<p>这种不免为一种思路，我的想法是减少显而易见的优化方法，将工作交给计算机，就是每次减少一个在获得全部由candidates[0]组成的target（可能会大于或相等）然后尝试加入candidates[1]，如果能加入，则再加入candidate[1]，直到加到 和为target或者大于target，如同之前对candidates[0]的操作，将candidates[1]减少一个，试图加入candidates[2]..</p>\n<p>这样应该可以用到递归。</p>\n<p>之后，我看了kelo的代码，差不多是一样的思路，都用到了res = res - candidates[step]的思想（初试res即为target），这样，可以将res当做一个新的target，对其进行操作。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> typing <span class=\"keyword\">import</span> List</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    ANS = set()</span><br><span class=\"line\">    SUB_ANS = []</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">find</span><span class=\"params\">(self, step, res, candidates)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> res == <span class=\"number\">0</span>:</span><br><span class=\"line\">            self.ANS.add(tuple(self.SUB_ANS))</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> step == len(candidates):</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> candidates[step] &lt;= res:</span><br><span class=\"line\">            res = res - candidates[step]</span><br><span class=\"line\">            self.SUB_ANS.append(candidates[step])</span><br><span class=\"line\">            self.find(step, res, candidates)</span><br><span class=\"line\">            self.find(step + <span class=\"number\">1</span>, res, candidates)</span><br><span class=\"line\">            res = res + candidates[step]</span><br><span class=\"line\">            <span class=\"keyword\">del</span> self.SUB_ANS[<span class=\"number\">-1</span>]</span><br><span class=\"line\">        self.find(step + <span class=\"number\">1</span>, res, candidates)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">combinationSum</span><span class=\"params\">(self, candidates, target)</span>:</span></span><br><span class=\"line\">        self.ANS.clear()</span><br><span class=\"line\">        self.SUB_ANS = []</span><br><span class=\"line\">        candidates.sort()</span><br><span class=\"line\">        self.find(<span class=\"number\">0</span>, target, candidates)</span><br><span class=\"line\">        fin = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> self.ANS:</span><br><span class=\"line\">            fin.insert(len(fin), list(x))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fin</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    candidates = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">    ta = <span class=\"number\">3</span></span><br><span class=\"line\">    print(Solution().combinationSum(candidates, ta))</span><br></pre></td></tr></table></figure>\n\n<p>当不能重复使用时，将代码改成如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> typing <span class=\"keyword\">import</span> List</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    ANS = set()</span><br><span class=\"line\">    SUB_ANS = []</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">find</span><span class=\"params\">(self, step, res, candidates)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> res == <span class=\"number\">0</span>:</span><br><span class=\"line\">            self.ANS.add(tuple(self.SUB_ANS))</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> step == len(candidates):</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> candidates[step] &lt;= res:</span><br><span class=\"line\">            res = res - candidates[step]</span><br><span class=\"line\">            self.SUB_ANS.append(candidates[step])</span><br><span class=\"line\">            self.find(step + <span class=\"number\">1</span>, res, candidates)</span><br><span class=\"line\">            res = res + candidates[step]</span><br><span class=\"line\">            <span class=\"keyword\">del</span> self.SUB_ANS[<span class=\"number\">-1</span>]</span><br><span class=\"line\">        self.find(step + <span class=\"number\">1</span>, res, candidates)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">combinationSum</span><span class=\"params\">(self, candidates, target)</span>:</span></span><br><span class=\"line\">        self.ANS.clear()</span><br><span class=\"line\">        self.SUB_ANS = []</span><br><span class=\"line\">        candidates.sort()</span><br><span class=\"line\">        self.find(<span class=\"number\">0</span>, target, candidates)</span><br><span class=\"line\">        fin = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> self.ANS:</span><br><span class=\"line\">            fin.insert(len(fin), list(x))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fin</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    candidates = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">    ta = <span class=\"number\">3</span></span><br><span class=\"line\">    print(Solution().combinationSum(candidates, ta))</span><br></pre></td></tr></table></figure>\n\n<ol start=\"15\">\n<li>leetcode 41</li>\n</ol>\n<p>得到一个数组中最小正整数</p>\n<p>如：[1,-1,3,5] 得到2</p>\n<p><strong>题解</strong></p>\n<p>这道题……确实只要遍历就可以了，但是对于时间和空间复杂度都有要求，所以可以采用一种自身哈希的方法，在前面的题中也提过。</p>\n<p>首先，根据抽屉定理，answer &lt;= n+1</p>\n<p>将其中大于n的，小于等于零的设为1。（在这一步之前，先测其中是否有1，如果没有1则输出1）</p>\n<p>关键是将索引值作为哈希key。</p>\n<p>[1, 6, 2 , -1 , 3, 8]—&gt;] [1, 6, 2, 1,3, 1]  （即包含1 - n元素的数组）</p>\n<p>对这个从1-n进行遍历：如果读到数字a，则将第几个元素的符号改变。（使用下表0代表n）</p>\n<p>最后返回第一个正数。如果没有，则判断0位置，如果还没有正数则返回n+1。</p>\n<p>代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">firstMissingPositive</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        n = len(nums)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 基本情况</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"number\">1</span> <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># nums = [1]</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">2</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 用 1 替换负数，0，</span></span><br><span class=\"line\">        <span class=\"comment\"># 和大于 n 的数</span></span><br><span class=\"line\">        <span class=\"comment\"># 在转换以后，nums 只会包含</span></span><br><span class=\"line\">        <span class=\"comment\"># 正数</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[i] &lt;= <span class=\"number\">0</span> <span class=\"keyword\">or</span> nums[i] &gt; n:</span><br><span class=\"line\">                nums[i] = <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 使用索引和数字符号作为检查器</span></span><br><span class=\"line\">        <span class=\"comment\"># 例如，如果 nums[1] 是负数表示在数组中出现了数字 `1`</span></span><br><span class=\"line\">        <span class=\"comment\"># 如果 nums[2] 是正数 表示数字 2 没有出现</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n): </span><br><span class=\"line\">            a = abs(nums[i])</span><br><span class=\"line\">            <span class=\"comment\"># 如果发现了一个数字 a - 改变第 a 个元素的符号</span></span><br><span class=\"line\">            <span class=\"comment\"># 注意重复元素只需操作一次</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> a == n:</span><br><span class=\"line\">                nums[<span class=\"number\">0</span>] = - abs(nums[<span class=\"number\">0</span>])</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                nums[a] = - abs(nums[a])</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"comment\"># 现在第一个正数的下标</span></span><br><span class=\"line\">        <span class=\"comment\"># 就是第一个缺失的数</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, n):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[i] &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> i</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> nums[<span class=\"number\">0</span>] &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> n</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">return</span> n + <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"16\">\n<li>leetcode 45</li>\n</ol>\n<p>题意：</p>\n<p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>\n<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>\n<p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [2,3,1,1,4]</span><br><span class=\"line\">输出: 2</span><br><span class=\"line\">解释: 跳到最后一个位置的最小跳跃数是 2。</span><br><span class=\"line\">     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</span><br></pre></td></tr></table></figure>\n\n<p><strong>题解</strong></p>\n<p>例子是[2, 3, 1, 1, 4]</p>\n<p>结合例子进行解释，nums[0] = 2, 因此跳一次最多到 nums[1]或者nums[2], 将2固定为max_pos，因为这是第一次跳跃后能够到达的最远位置。</p>\n<ul>\n<li><p>i从0到1到max_pos进行遍历，每次更新max_arrive = max(max_arrive,nums[i]+i)。</p>\n<p><em>比如i=1，max_arrive = max(2, 4) = 4</em></p>\n<p>这个遍历其实是一个对第一步跳跃后，第二步跳跃可能情况的一个遍历，选出最大的max_arrive。</p>\n</li>\n<li><p>当i和第一次固定的max_pos重叠时，将此时的max_pos 固定在max _arrive，并且跳跃步数++，相当于其实是选中了从确定max_arrive那次的i开始第二次起跳，max_pos 固定在此时的max _arrive, 进行与第一次相同的循环，直到i和max_pos 重叠。</p>\n</li>\n</ul>\n<p>这个的实质其实是忽略i每次跳的位置（可以在max_arrive确定时确定），只记录跳的次数，进行多次相同的循环操作。</p>\n<p>代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">jump</span><span class=\"params\">(self,nums)</span>:</span></span><br><span class=\"line\">        max_pos = <span class=\"number\">0</span></span><br><span class=\"line\">        max_arrive = <span class=\"number\">0</span></span><br><span class=\"line\">        ans = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>,len(nums)<span class=\"number\">-1</span>):</span><br><span class=\"line\">            max_arrive = max(max_arrive,nums[i]+i)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i&gt;= max_pos:</span><br><span class=\"line\">                max_pos = max_arrive</span><br><span class=\"line\">                ans = ans + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>  ans</span><br></pre></td></tr></table></figure>\n\n<ol start=\"17\">\n<li>Leetcode 43字符串数的乘法</li>\n</ol>\n<p>如“67”‘89“，不能直接乘</p>\n<p><strong>题解：</strong></p>\n<ul>\n<li><p>按照乘法的规律，乘数为num1，被乘数为num2，先对num2进行遍历，跟num1的第一位相乘，num2中每取一个数，将答案的数组ans往后挪移一位。</p>\n<p>同时对num1进行遍历，每次遍历，ans的起始下标加一。对每个num1元素跟num2的每个元素乘，加到ans的对应的位数。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, len(num1)):</span><br><span class=\"line\">          local = i</span><br><span class=\"line\">          <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, len(num2)):</span><br><span class=\"line\">              ans[local] += int(num1[len(num1) - i - <span class=\"number\">1</span>]) * int(num2[len(num2) - j - <span class=\"number\">1</span>])</span><br><span class=\"line\">              local = local + <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果ans的某位&gt;10 则说明需要进位：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, local):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ans[local - <span class=\"number\">1</span>] &gt;= <span class=\"number\">10</span>:</span><br><span class=\"line\">        local = local + <span class=\"number\">1</span></span><br><span class=\"line\">    ans[i + <span class=\"number\">1</span>] += int(ans[i] / <span class=\"number\">10</span>)</span><br><span class=\"line\">    ans[i] %=<span class=\"number\">10</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>判断最高位是否为0</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">    <span class=\"keyword\">if</span> local == <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ans[local - <span class=\"number\">1</span>] == <span class=\"number\">0</span>:</span><br><span class=\"line\">        local = local - <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>将ans整合为final ans</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, local):</span><br><span class=\"line\">    final_ans = final_ans + str(ans[local - i - <span class=\"number\">1</span>])</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>总体的代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">multiply</span><span class=\"params\">(self, num1, num2)</span> :</span></span><br><span class=\"line\">        ans = [<span class=\"number\">0</span>] * <span class=\"number\">15000</span></span><br><span class=\"line\">        local = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, len(num1)):</span><br><span class=\"line\">            local = i</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, len(num2)):</span><br><span class=\"line\">                ans[local] += int(num1[len(num1) - i - <span class=\"number\">1</span>]) * int(num2[len(num2) - j - <span class=\"number\">1</span>])</span><br><span class=\"line\">                local = local + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, local):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ans[local - <span class=\"number\">1</span>] &gt;= <span class=\"number\">10</span>:</span><br><span class=\"line\">                local = local + <span class=\"number\">1</span></span><br><span class=\"line\">            ans[i + <span class=\"number\">1</span>] += int(ans[i] / <span class=\"number\">10</span>)</span><br><span class=\"line\">            ans[i] %=<span class=\"number\">10</span></span><br><span class=\"line\">        final_ans = <span class=\"string\">\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> local == <span class=\"number\">1</span>:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ans[local - <span class=\"number\">1</span>] == <span class=\"number\">0</span>:</span><br><span class=\"line\">                local = local - <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, local):</span><br><span class=\"line\">            final_ans = final_ans + str(ans[local - i - <span class=\"number\">1</span>])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> final_ans</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    a = <span class=\"string\">\"12\"</span></span><br><span class=\"line\">    b = <span class=\"string\">\"12\"</span></span><br><span class=\"line\">    c = Solution()</span><br><span class=\"line\">    print(Solution().multiply(a, b))</span><br></pre></td></tr></table></figure>\n\n<ol start=\"18\">\n<li>Leetcode 46 全排列（无元素重复）</li>\n</ol>\n<p>用到了<strong>回溯</strong>的算法，这是一种通过探索所有可能的候选解来找出所有的解的算法。如果候选解被确认 不是 一个解的话（或者至少不是 最后一个 解），回溯算法会通过在上一步进行一些变化抛弃该解，即<strong>回溯</strong>并且再次尝试。</p>\n<p>一个回溯函数，使用第一个整数的索引作为参数 <code>backtrack(first)</code></p>\n<p>如果整数索引为n则return, 并且在一次return后，将做的变化换回（即试错，重新进行其他尝试，在本题中不算试错，本题只是要算得每一种情况）</p>\n<p><strong>题解</strong></p>\n<ul>\n<li>如果第一个整数有索引 n，意味着当前排列已完成。</li>\n<li>遍历索引 first 到索引 n - 1 的所有整数。Iterate over the integers from index first to index n - 1.<ul>\n<li>在排列中放置第 i 个整数，<br>即 swap(nums[first], nums[i]).</li>\n<li>继续生成从第 i 个整数开始的所有排列: backtrack(first + 1).</li>\n<li>现在回溯，即通过 swap(nums[first], nums[i]) 还原.</li>\n</ul>\n</li>\n</ul>\n<p>回溯法伪代码实现：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">permute</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[List[int]]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">backtrack</span><span class=\"params\">(first = <span class=\"number\">0</span>)</span>:</span></span><br><span class=\"line\">            <span class=\"comment\"># if all integers are used up</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> first == n:  </span><br><span class=\"line\">                output.append(nums[:])</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(first, n):</span><br><span class=\"line\">                <span class=\"comment\"># place i-th integer first </span></span><br><span class=\"line\">                <span class=\"comment\"># in the current permutation</span></span><br><span class=\"line\">                nums[first], nums[i] = nums[i], nums[first]</span><br><span class=\"line\">                <span class=\"comment\"># use next integers to complete the permutations</span></span><br><span class=\"line\">                backtrack(first + <span class=\"number\">1</span>)</span><br><span class=\"line\">                <span class=\"comment\"># backtrack</span></span><br><span class=\"line\">                nums[first], nums[i] = nums[i], nums[first]</span><br><span class=\"line\">        </span><br><span class=\"line\">        n = len(nums)</span><br><span class=\"line\">        output = []</span><br><span class=\"line\">        backtrack()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> output</span><br></pre></td></tr></table></figure>\n\n<p><em>本题的思想在解数独中也出现过</em></p>\n<p>下面是kelo的具体实现：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> typing <span class=\"keyword\">import</span> List</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    ANS = []</span><br><span class=\"line\">    SUB_ASN = []</span><br><span class=\"line\">    set = <span class=\"number\">0</span></span><br><span class=\"line\">    tot = <span class=\"number\">0</span></span><br><span class=\"line\">    INF = <span class=\"number\">55</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(self, nums: List[int], step)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> step == len(nums):</span><br><span class=\"line\">            self.ANS.append(self.SUB_ASN[:])</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, len(nums)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> self.set &amp; (<span class=\"number\">1</span> &lt;&lt; i) == <span class=\"number\">1</span> &lt;&lt; i:</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            self.SUB_ASN.append(nums[i])</span><br><span class=\"line\">            self.set |= <span class=\"number\">1</span> &lt;&lt; i</span><br><span class=\"line\">            self.dfs(nums, step + <span class=\"number\">1</span>)</span><br><span class=\"line\">            self.set ^= <span class=\"number\">1</span> &lt;&lt; i</span><br><span class=\"line\">            <span class=\"keyword\">del</span> self.SUB_ASN[<span class=\"number\">-1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">permute</span><span class=\"params\">(self, nums: List[int])</span>:</span></span><br><span class=\"line\">        self.ANS: List[List[int]]</span><br><span class=\"line\">        self.ANS = []</span><br><span class=\"line\">        self.tot = <span class=\"number\">0</span></span><br><span class=\"line\">        self.SUB_ASN = []</span><br><span class=\"line\">        self.dfs(nums, <span class=\"number\">0</span>)</span><br><span class=\"line\">        temp = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> self.ANS:</span><br><span class=\"line\">                temp.append(item)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> temp</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    a = [<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\">    print(Solution().permute(a))</span><br></pre></td></tr></table></figure>\n\n<ol start=\"19\">\n<li>leetcode 47 全排列（有元素重复）</li>\n</ol>\n<p>只需要在无重复的基础上，将相同的去除即可。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> self.ANS:</span><br><span class=\"line\">       <span class=\"keyword\">if</span> item <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> temp:</span><br><span class=\"line\">           temp.append(item)</span><br><span class=\"line\">   <span class=\"keyword\">return</span> temp</span><br></pre></td></tr></table></figure>\n\n<ol start=\"20\">\n<li>leetcode49 单词的同分异构体</li>\n</ol>\n<p>例子：输入 a = [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”]，将其变为List(List(string))</p>\n<ul>\n<li>“”.join(sorted(string)) </li>\n</ul>\n<p>“”.join()  : 将字符用“” 串联起来</p>\n<p>sorted(string) : 将string元素排序，得到一串字符集合。但是并不会改变原string</p>\n<ul>\n<li>此题用到哈希表</li>\n</ul>\n<p><strong>代码如下</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> typing <span class=\"keyword\">import</span> List</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">groupAnagrams</span><span class=\"params\">(self, strs)</span>:</span></span><br><span class=\"line\">        hash_map = &#123;&#125;</span><br><span class=\"line\">        sort_string = [<span class=\"string\">\"\"</span>.join(sorted(string)) <span class=\"keyword\">for</span> string <span class=\"keyword\">in</span> strs]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, len(sort_string)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> sort_string[i] <span class=\"keyword\">in</span> hash_map:</span><br><span class=\"line\">                hash_map[sort_string[i]].append(strs[i])</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                hash_map[sort_string[i]] = [strs[i]]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> [x <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> hash_map.values()]</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    a = [<span class=\"string\">\"eat\"</span>, <span class=\"string\">\"tea\"</span>, <span class=\"string\">\"tan\"</span>, <span class=\"string\">\"ate\"</span>, <span class=\"string\">\"nat\"</span>, <span class=\"string\">\"bat\"</span>]</span><br><span class=\"line\">    print(Solution().groupAnagrams(a))</span><br></pre></td></tr></table></figure>\n\n<p>Hash_map 是一个字典，key为排序过的str</p>\n<ol start=\"21\">\n<li>leetcode 44</li>\n</ol>\n<p>给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 ‘?’ 和 ‘*’ 的通配符匹配。</p>\n<p>‘?’ 可以匹配任何单个字符。<br>‘*’ 可以匹配任意字符串（包括空字符串）。<br>两个字符串完全匹配才算匹配成功。</p>\n<p>说明:</p>\n<p>s 可能为空，且只包含从 a-z 的小写字母。<br>p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。</p>\n<p><strong>示例 1:</strong></p>\n<p>输入:<br>s = “aa”<br>p = “a”<br>输出: false<br>解释: “a” 无法匹配 “aa” 整个字符串。</p>\n<p><strong>示例 2:</strong></p>\n<p>输入:<br>s = “aa”<br>p = “*”<br>输出: true<br>解释: ‘*’ 可以匹配任意字符串。</p>\n<p><strong>题解</strong></p>\n<p>最普遍的情况是，当p[j]=s[i]，或者为？，*时，如果s[i-1]，p[j-1]也匹配，则p[j]，s[i]匹配。</p>\n<p>历遍i j，如果p[-1] 与 s[-1]匹配，则结果为ture.要实现遍历，构建bool类型“二维数组”。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> f = [[<span class=\"literal\">False</span>] * (len(p)) <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(len(s))]</span><br><span class=\"line\"><span class=\"comment\"># for _ in range(len(s)) 中 _ 表示占位符 不管是什么，反正只要循环就行了</span></span><br></pre></td></tr></table></figure>\n\n<p>实际上，有很多启动元素和特殊情况</p>\n<ul>\n<li>f[0][0]的情况单独判断</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> s[<span class=\"number\">0</span>] == p[<span class=\"number\">0</span>] <span class=\"keyword\">or</span> p[<span class=\"number\">0</span>] == <span class=\"string\">\"*\"</span> <span class=\"keyword\">or</span> p[<span class=\"number\">0</span>] == <span class=\"string\">\"?\"</span>:</span><br><span class=\"line\">\tf[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"literal\">True</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>p开头为*, 需要单独判断所有的p与s[0]的匹配情况</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> p[<span class=\"number\">0</span>] == <span class=\"string\">\"*\"</span>:</span><br><span class=\"line\">    <span class=\"keyword\">while</span> len(p) &gt; first <span class=\"keyword\">and</span> p[first] == <span class=\"string\">\"*\"</span>:</span><br><span class=\"line\">        f[<span class=\"number\">0</span>][first] = <span class=\"literal\">True</span></span><br><span class=\"line\">        first = first + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> len(p) &gt; first <span class=\"keyword\">and</span> (s[<span class=\"number\">0</span>] == p[first] <span class=\"keyword\">or</span> p[first] == <span class=\"string\">\"?\"</span>):</span><br><span class=\"line\">        f[<span class=\"number\">0</span>][first] = <span class=\"literal\">True</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>接下来就是遍历</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, len(s)):</span><br><span class=\"line\">          <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, len(p)):</span><br><span class=\"line\">              <span class=\"keyword\">if</span> p[j] == <span class=\"string\">\"*\"</span> <span class=\"keyword\">and</span> i &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">                  f[i][j] |= f[i - <span class=\"number\">1</span>][j]</span><br><span class=\"line\">              <span class=\"keyword\">if</span> p[j] == <span class=\"string\">\"*\"</span> <span class=\"keyword\">and</span> j &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">                  f[i][j] |= f[i][j - <span class=\"number\">1</span>]</span><br><span class=\"line\">                  <span class=\"comment\"># 如果p中前一个匹配，则</span></span><br><span class=\"line\">              <span class=\"keyword\">if</span> (s[i] == p[j] <span class=\"keyword\">or</span> p[j] == <span class=\"string\">\"?\"</span> <span class=\"keyword\">or</span> p[j] == <span class=\"string\">\"*\"</span>) <span class=\"keyword\">and</span> i &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> j &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">                  f[i][j] |= f[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>]</span><br><span class=\"line\">                  <span class=\"comment\"># 当i&gt;0 j&gt;0 当s[i] == p[j] or p[j] == \"?\" or p[j] == \"*\" 前一个匹配，则此对匹配</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> f[<span class=\"number\">-1</span>][<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n\n<p>代码如下</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isMatch</span><span class=\"params\">(self, s, p)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> s <span class=\"keyword\">and</span> p:</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, len(p)):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> p[i] != <span class=\"string\">\"*\"</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> s <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> p:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> s <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> p:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        f = [[<span class=\"literal\">False</span>] * (len(p)) <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(len(s))]</span><br><span class=\"line\">        <span class=\"comment\"># for _ in range(len(s)) 中 _ 表示占位符 不管是什么，反正只要循环就行了</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> s[<span class=\"number\">0</span>] == p[<span class=\"number\">0</span>] <span class=\"keyword\">or</span> p[<span class=\"number\">0</span>] == <span class=\"string\">\"*\"</span> <span class=\"keyword\">or</span> p[<span class=\"number\">0</span>] == <span class=\"string\">\"?\"</span>:</span><br><span class=\"line\">            f[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"literal\">True</span></span><br><span class=\"line\">        first = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> p[<span class=\"number\">0</span>] == <span class=\"string\">\"*\"</span>:</span><br><span class=\"line\">            <span class=\"keyword\">while</span> len(p) &gt; first <span class=\"keyword\">and</span> p[first] == <span class=\"string\">\"*\"</span>:</span><br><span class=\"line\">                f[<span class=\"number\">0</span>][first] = <span class=\"literal\">True</span></span><br><span class=\"line\">                first = first + <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> len(p) &gt; first <span class=\"keyword\">and</span> (s[<span class=\"number\">0</span>] == p[first] <span class=\"keyword\">or</span> p[first] == <span class=\"string\">\"?\"</span>):</span><br><span class=\"line\">                f[<span class=\"number\">0</span>][first] = <span class=\"literal\">True</span></span><br><span class=\"line\">            <span class=\"comment\"># 这个while 和 这个 if 的意义在于解决那些在p开头的*</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, len(s)):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, len(p)):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> p[j] == <span class=\"string\">\"*\"</span> <span class=\"keyword\">and</span> i &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">                    f[i][j] |= f[i - <span class=\"number\">1</span>][j]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> p[j] == <span class=\"string\">\"*\"</span> <span class=\"keyword\">and</span> j &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">                    f[i][j] |= f[i][j - <span class=\"number\">1</span>]</span><br><span class=\"line\">                    <span class=\"comment\"># 如果p中前一个匹配，则</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (s[i] == p[j] <span class=\"keyword\">or</span> p[j] == <span class=\"string\">\"?\"</span> <span class=\"keyword\">or</span> p[j] == <span class=\"string\">\"*\"</span>) <span class=\"keyword\">and</span> i &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> j &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">                    f[i][j] |= f[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>]</span><br><span class=\"line\">                    <span class=\"comment\"># 当i&gt;0 j&gt;0 当s[i] == p[j] or p[j] == \"?\" or p[j] == \"*\" 前一个匹配，则此对匹配</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> f[<span class=\"number\">-1</span>][<span class=\"number\">-1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    s = <span class=\"string\">\"mississippsssssi\"</span></span><br><span class=\"line\">    p = <span class=\"string\">\"*sssi\"</span></span><br><span class=\"line\">    print(Solution().isMatch(s, p))</span><br></pre></td></tr></table></figure>\n\n\n\n","site":{"data":{}},"excerpt":"<h1 id=\"Kelo算法课堂-持续更新\"><a href=\"#Kelo算法课堂-持续更新\" class=\"headerlink\" title=\"Kelo算法课堂(持续更新)\"></a>Kelo算法课堂(持续更新)</h1><p><em>kelo做算法题并在其博客上连载，窃以为其思想精妙，故书吾感，记以学之。</em></p>\n<p><strong><em>原作见友链</em></strong></p>","more":"<ol>\n<li><p>求最长回文串（Manacher）</p>\n<ul>\n<li><p>思想</p>\n<ul>\n<li><p>预处理 将原串中加入#，目的在于可以识别#a#b#b#a的回文串。</p>\n<p>​             在开头加入&amp;,目的在于使回文串的识别从1开始</p>\n</li>\n<li><p>for循环对length[i]进行求解。length[i]的实际意义是<strong>回文半径</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># a # b # c # c # b # d #</span><br><span class=\"line\">1 2 1 2 1 2 5 2 1 2 1 2 1</span><br></pre></td></tr></table></figure>\n\n<p>如上，第二行即为回文半径表，我们可以看出，以length[i].max为中心，根据其回文半径取得的回文字符串去掉#后即为最长回文串。</p>\n<p>问题转化为求length[i]，以及<strong>最大的回文长度(max_length)</strong>和<strong>回文中心(max_mid)</strong>。实际上，最大的max_length和max_mid在i循环求length[i]的过程中进行更新即可。</p>\n</li>\n<li><p>当i在推算出来的现在所处的最大回文序列的右边界的左侧，则可以通过<strong>简便方式推算</strong>。</p>\n<ul>\n<li>当max_right对结果无影响时（max_right足够大），我们可以直接先令 length[i] = length[2 * pos - i]</li>\n<li>如果以i为中心的回文串长度超过max_right时候，由于我们无法判断max_right之后的情形，我们只能令length[i] = max_right - i</li>\n<li>如果在最大回文序列右侧，则将它初始化为一</li>\n</ul>\n</li>\n<li><p>以i为中心，while循环测试以此时的i为中心向两边扩展，当两边没有达到边界且两边相同时，length[i]++</p>\n</li>\n<li><p>更新当前i为中心的回文序列的右边界max_right</p>\n</li>\n<li><p>将当前的回文序列长度和最大回文序列长度比较判断是否需要更新这个长度。</p>\n</li>\n</ul>\n</li>\n<li><p>代码实现</p>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;string&#125;</span> <span class=\"variable\">s</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return <span class=\"type\">&#123;string&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"string\">\"afkfkfkaaaafkfk\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> longestPalindrome = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">s</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> f = <span class=\"string\">\"&amp;#\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>;i &lt; s.length; i++)&#123;</span><br><span class=\"line\">        f = f + s[i];</span><br><span class=\"line\">        f = f + <span class=\"string\">\"#\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> length = [];</span><br><span class=\"line\">    <span class=\"keyword\">let</span> max_right = <span class=\"number\">0</span>, max_length = <span class=\"number\">0</span>, pos = <span class=\"number\">0</span>, max_pos = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>;i &lt; f.length;i++) &#123;<span class=\"comment\">//求length[i]的循环</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &lt; max_right) &#123;</span><br><span class=\"line\">            <span class=\"comment\">/*如果要求的i在推算出来的现在所处的最大回文序列的右边界的左侧，则可以通过简便方式进行推算：</span></span><br><span class=\"line\"><span class=\"comment\">            当max_right对结果无影响时（max_right足够大），我们可以直接先令 length[i] = length[2 * pos - i]</span></span><br><span class=\"line\"><span class=\"comment\">            如果以i为中心的回文串长度超过max_right时候，由于我们无法判断max_right之后的情形，我们只能令length[i] = max_right - i*/</span></span><br><span class=\"line\">            length[i] = <span class=\"built_in\">Math</span>.min(max_right - i, length[<span class=\"number\">2</span> * pos - i]);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> length[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i - length[i] &gt;=<span class=\"number\">0</span> &amp;&amp; i + length[i] &lt; f.length &amp;&amp; f[i - length[i]] === f[i + length[i]])&#123;</span><br><span class=\"line\">            length[i] = length[i] + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;<span class=\"comment\">//这个循环就是在测试以此时的i为中心向两边扩展，1.没有到达数组边界 2.两方相等。如果两个条件都满足，则length[i]++</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i + length[i] - <span class=\"number\">1</span> &gt; max_right) &#123;</span><br><span class=\"line\">            max_right = i + length[i] - <span class=\"number\">1</span>;</span><br><span class=\"line\">            pos = i;</span><br><span class=\"line\">        &#125;<span class=\"comment\">//更新当前所在的最大回文序列的右边界</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (length[i] &gt; max_length) &#123;</span><br><span class=\"line\">            max_length = length[i];</span><br><span class=\"line\">            max_pos = i;</span><br><span class=\"line\">        &#125;<span class=\"comment\">//更新最大的回文长度和回文中心</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> max_sub_string = f.substring(max_pos - max_length + <span class=\"number\">1</span>, max_pos + max_length);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> real_sub = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>;i &lt; max_sub_string.length;i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (max_sub_string[i] === <span class=\"string\">\"#\"</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        real_sub = real_sub + max_sub_string[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> real_sub;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(longestPalindrome(s));</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。（双指针法）</p>\n<p>设置l，r两个指针，l指向数组开头，r指向数组结尾，计算容量，然后将较短的指针向前中间移动。每次移动指针后计算容量判断是否更新max。</p>\n<p><em>注：移动较短的是因为移动结果为容量变大或者不变。但是移动较长的只会容量变小或者不变</em></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> maxArea = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">height</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> l = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> r = height.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> max_area = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (l !== r) &#123;</span><br><span class=\"line\">        max_area = <span class=\"built_in\">Math</span>.max(max_area, (r - l) * <span class=\"built_in\">Math</span>.min(height[l], height[r]));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (height[l] &lt; height[r]) l++;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> r--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max_area;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>数组.length</li>\n<li>Math.mac()</li>\n<li>L !== r</li>\n</ul>\n</li>\n<li><p>已知n个括号对，将输出这些括号对的合法搭配，比如2个括号对的合法组合是：()(), (())</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> generateParenthesis = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> ans = [];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> <span class=\"keyword\">set</span> = 0; <span class=\"keyword\">set</span> &lt; 1 &lt;&lt; (2 * n); <span class=\"keyword\">set</span>++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> sub_ans = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = (<span class=\"number\">1</span> &lt;&lt; (<span class=\"number\">2</span>*n <span class=\"number\">-1</span>)); i ; i = i &gt;&gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((<span class=\"keyword\">set</span> &amp; i) === i)&#123;</span><br><span class=\"line\">                flag = flag + <span class=\"number\">1</span>;</span><br><span class=\"line\">                sub_ans = sub_ans + <span class=\"string\">\"(\"</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                flag = flag - <span class=\"number\">1</span>;</span><br><span class=\"line\">                sub_ans = sub_ans + <span class=\"string\">\")\"</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (flag &lt; <span class=\"number\">0</span> || flag &gt; n) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (flag === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            ans.push(sub_ans);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(generateParenthesis(<span class=\"number\">3</span>));</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>1看做左括号，0看做右括号，set为整个括号序列的二进制代表 ()()-&gt;1010</p>\n<p>遍历set即遍历0000 -&gt; 1111</p>\n<p>取每一个set 对i进行遍历，与set比对。比如set = 1100，i取1000，100，10，1，分别与set进行&amp;操作，1100 &amp; 1000 == 1000，1100 &amp; 1== 0，由此可以判断set每一位是1/0。</p>\n<p>1则flag加1，0则flag-1，当flag&lt;0(右在左)或者flag&gt;n(左括号已经肯定多于右括号)跳出。</p>\n<p>i循环完或者break后，对flag进行判断，如果flag === 0，则此set合法，将其压栈。</p>\n<ol start=\"4\">\n<li>两数相加<strong>（链表的应用）</strong></li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*Definition for singly-linked list.*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ListNode</span>(<span class=\"params\">val</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.val = val;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.next = <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;ListNode&#125;</span> <span class=\"variable\">l1</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;ListNode&#125;</span> <span class=\"variable\">l2</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return <span class=\"type\">&#123;ListNode&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> changeType = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">num</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> node = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">-1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> node1 = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">-1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">10</span>;; i*=<span class=\"number\">10</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> part = (num % i)/(i/<span class=\"number\">10</span>);</span><br><span class=\"line\">        num -=(part*(i/<span class=\"number\">10</span>));</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(node.val !== <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">            node1 = <span class=\"keyword\">new</span> ListNode(part);</span><br><span class=\"line\">            node1.next = node;</span><br><span class=\"line\">            node = node1;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            node = <span class=\"keyword\">new</span> ListNode(part);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i &gt; num)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> addTwoNumbers = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">l1, l2</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> head = <span class=\"keyword\">new</span> ListNode;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> present = head;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> c = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span> === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> tmp = <span class=\"keyword\">new</span> ListNode;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l1 === <span class=\"literal\">null</span> &amp;&amp; l2 === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                tmp.val = c;</span><br><span class=\"line\">                tmp.next = <span class=\"literal\">null</span>;</span><br><span class=\"line\">                present.next = tmp;</span><br><span class=\"line\">                present = present.next</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l1 === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            tmp.val = l2.val + c;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (tmp.val &gt;= <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">                tmp.val = tmp. val - <span class=\"number\">10</span>;</span><br><span class=\"line\">                c = <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> c = <span class=\"number\">0</span>;</span><br><span class=\"line\">            tmp.next = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l2 === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            tmp.val = l1.val + c;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (tmp.val &gt;= <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">                tmp.val = tmp. val - <span class=\"number\">10</span>;</span><br><span class=\"line\">                c = <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> c = <span class=\"number\">0</span>;</span><br><span class=\"line\">            tmp.next = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> tmp_ans = l1.val + l2.val + c;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (tmp_ans &gt;= <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">                tmp_ans = tmp_ans - <span class=\"number\">10</span>;</span><br><span class=\"line\">                c = <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> c = <span class=\"number\">0</span>;</span><br><span class=\"line\">            tmp.val = tmp_ans;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        tmp.next = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        present.next = tmp;</span><br><span class=\"line\">        present = present.next;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l1 === <span class=\"literal\">null</span>) l2 = l2.next;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (l2 === <span class=\"literal\">null</span>) l1 = l1.next;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            l1 = l1.next;</span><br><span class=\"line\">            l2 = l2.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    head = head.next;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(addTwoNumbers(changeType(<span class=\"number\">12</span>),changeType(<span class=\"number\">12</span>)));</span><br></pre></td></tr></table></figure>\n\n<p>用到了链表的数据结构，changType改变(int)num为链表，addTwoNumbers将两个链表对应的数相加。</p>\n<ol start=\"5\">\n<li>求一个字符串的最大无重复子串<strong>（滑动窗口）</strong></li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;string&#125;</span> <span class=\"variable\">s</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return <span class=\"type\">&#123;number&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> lengthOfLongestSubstring = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">s</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">    <span class=\"keyword\">let</span> l = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> r = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> max_length = s.length;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> max_ans = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> substring = s.substring(l, r);</span><br><span class=\"line\">    map.set(s[l], <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (r &lt; max_length &amp;&amp; max_length-r<span class=\"number\">-1</span>&gt;max_ans) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!map.has(s[r])) &#123;</span><br><span class=\"line\">            map.set(s[r], <span class=\"number\">1</span>);</span><br><span class=\"line\">            r++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r - l &gt; max_ans) &#123;</span><br><span class=\"line\">                max_ans = r - l;</span><br><span class=\"line\">                substring = s.substring(l, r);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            map.delete(s[l]);</span><br><span class=\"line\">            l++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> substring.length;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>类似于双指针，初始化l=0，r=1，r右移，新收入的s[r]与之前的比，如果有相同，则l右移直至没有相同的。</p>\n<ol start=\"6\">\n<li>leetcode42 </li>\n</ol>\n<p><img src=\"https://img.cetacis.dev/uploads/big/8408af07f366c184d8ff194926fe450b.png\" alt=\"\"></p>\n<p><strong>单调栈的使用</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> typing <span class=\"keyword\">import</span> List</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">trap</span><span class=\"params\">(self, height: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> height:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        ans = <span class=\"number\">0</span></span><br><span class=\"line\">        stack = []</span><br><span class=\"line\">        i = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> i + <span class=\"number\">1</span> &lt; len(height) <span class=\"keyword\">and</span> height[i] &lt; height[i + <span class=\"number\">1</span>]:</span><br><span class=\"line\">            i = i + <span class=\"number\">1</span></span><br><span class=\"line\">        stack.append((height[i], i))</span><br><span class=\"line\">        i = i + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> i &lt; len(height):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> height[i] &lt;= stack[<span class=\"number\">-1</span>][<span class=\"number\">0</span>]:</span><br><span class=\"line\">                stack.append((height[i], i))</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                last_height = <span class=\"number\">-1</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> len(stack) != <span class=\"number\">0</span> <span class=\"keyword\">and</span> stack[<span class=\"number\">-1</span>][<span class=\"number\">0</span>] &lt; height[i]:</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> last_height == <span class=\"number\">-1</span>:</span><br><span class=\"line\">                        last_height = stack[<span class=\"number\">-1</span>][<span class=\"number\">0</span>] </span><br><span class=\"line\">                    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                        ans = ans + (i - stack[<span class=\"number\">-1</span>][<span class=\"number\">1</span>] - <span class=\"number\">1</span>) * (stack[<span class=\"number\">-1</span>][<span class=\"number\">0</span>] - last_height)</span><br><span class=\"line\">                        last_height = stack[<span class=\"number\">-1</span>][<span class=\"number\">0</span>]</span><br><span class=\"line\">                    stack.pop()</span><br><span class=\"line\">                <span class=\"keyword\">if</span> len(stack) != <span class=\"number\">0</span>:</span><br><span class=\"line\">                    ans = ans + (i - stack[<span class=\"number\">-1</span>][<span class=\"number\">1</span>] - <span class=\"number\">1</span>) * (height[i] - last_height)</span><br><span class=\"line\">                stack.append((height[i], i))</span><br><span class=\"line\">            i = i + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    a = [<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">    print(Solution().trap(a))</span><br></pre></td></tr></table></figure>\n\n<p>数据结构：</p>\n<ul>\n<li>stack的操作：[].append(***)入栈；[].pop()出栈；栈顶是stack[-1]</li>\n<li>list判空：if (not) list:/if list is (not) None:/if len(list)==0</li>\n<li>二元组：a = (X, X)  访问的时候a[0]/a[1]。在此例中，(x, x)可作为栈元素，来确定元素在栈的位置。</li>\n</ul>\n<p>思想：</p>\n<ul>\n<li>开始先将单调递增的部分取出，这部分不可能装水</li>\n<li>将单调递减的部分入栈，然后在出现比栈顶大的部分进入计算部分。</li>\n<li>设置last_height，并且维护。</li>\n</ul>\n<p>主函数调用：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br></pre></td></tr></table></figure>\n\n<ol start=\"7\">\n<li>leetcode 29</li>\n</ol>\n<p>快速除法</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minus</span><span class=\"params\">(x, y, step, origin_y)</span> -&gt; int:</span></span><br><span class=\"line\">    <span class=\"comment\">#  真正的除法过程</span></span><br><span class=\"line\">    ans = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> x == <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> x - y &gt;= <span class=\"number\">0</span>:</span><br><span class=\"line\">        x = x - y</span><br><span class=\"line\">        ans = ans + pow(<span class=\"number\">2</span>, step)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> y == origin_y:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">    <span class=\"keyword\">return</span> minus(x, y &gt;&gt; <span class=\"number\">1</span>, step - <span class=\"number\">1</span>, origin_y) + ans</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">divide</span><span class=\"params\">(self, dividend: int, divisor: int)</span> -&gt; int:</span></span><br><span class=\"line\">        flag = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> dividend &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"comment\"># 被除数小于零</span></span><br><span class=\"line\">            dividend = - dividend</span><br><span class=\"line\">            flag = flag ^ <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> divisor &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            divisor = - divisor</span><br><span class=\"line\">            flag = flag ^ <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"comment\"># flag代表正负</span></span><br><span class=\"line\">        ans = minus(dividend, divisor &lt;&lt; <span class=\"number\">32</span>, <span class=\"number\">32</span>, divisor)</span><br><span class=\"line\">        ans = ans <span class=\"keyword\">if</span> flag == <span class=\"number\">0</span> <span class=\"keyword\">else</span> -ans</span><br><span class=\"line\">        ans = ans <span class=\"keyword\">if</span> ans &lt; <span class=\"number\">2147483647</span> <span class=\"keyword\">else</span> <span class=\"number\">2147483647</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    a = <span class=\"number\">2</span></span><br><span class=\"line\">    b = <span class=\"number\">1</span></span><br><span class=\"line\">    c = Solution()</span><br><span class=\"line\">    print(Solution.divide(c,a, b))</span><br></pre></td></tr></table></figure>\n\n<p>思想：</p>\n<p>核心思想在于，每一个数都可以拆成二的不同次幂的线性组合</p>\n<p>本题是除法，即将被除数拆成系数为除数倍数的不同二次幂的组合。</p>\n<p>比如：8/2 即8=2x(2^4) 9/3即9 = 3x(2^1+2^0) 27/3 = 3x(2x2^2+2^0)</p>\n<p>方法即从 除数x2^32 开始和被除数比较，并且每次比较后，如果被除数比除数乘2的次方小，则将除数乘2的次方右移（除以2）。用到了递归的方法。</p>\n<p>语法积累：</p>\n<ul>\n<li></li>\n<li><pre><code class=\"python\"> ans = ans <span class=\"keyword\">if</span> flag == <span class=\"number\">0</span> <span class=\"keyword\">else</span> -ans\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* 抑或</span><br><span class=\"line\"></span><br><span class=\"line\">  &#96;&#96;&#96;python</span><br><span class=\"line\">   flag &#x3D; flag ^ 1</span><br></pre></td></tr></table></figure></code></pre>\n</li>\n<li><p>如果本类中的某方法要调用本类中的其他方法，则需要加入self的参数。因为要调用类方法，必须要对类进行实例化。</p>\n</li>\n</ul>\n<ol start=\"8\">\n<li>leetcode33</li>\n</ol>\n<p>本来有一个有序数列，如[1,2,3,4,5,6,7]</p>\n<p>从某个位置进行切割拼接 如[4, 5, 6, 7, 1, 2, 3]</p>\n<p>思路：</p>\n<ul>\n<li>主要还是二分法</li>\n<li>在这里有所不同，就是开始的时候分类，当nums[left] &lt;= nums[mid]，即改变点在中点右侧，则left到改变点之间是可以用二分法的，则当nums[left] &lt;= target &lt; nums[mid]，right = mid-1，之后即为普通二分法，如果其他，则将left移动到mid+1.这样做，迟早会找到一个符合nums[left] &lt;= target &lt; nums[mid]或者nums[mid] &lt; target &lt;= nums[right]:的区间，然后就是正常的二分法了。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution:</span><br><span class=\"line\">    def search(self, nums, target):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> not nums:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">        left = <span class=\"number\">0</span></span><br><span class=\"line\">        right = len(nums) - <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> left &lt; right:</span><br><span class=\"line\">            print(left, right)</span><br><span class=\"line\">            mid = (left + right) &gt;&gt; <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[mid] == target:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> mid</span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[left] &lt;= nums[mid]:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> nums[left] &lt;= target &lt; nums[mid]:</span><br><span class=\"line\">                    right = mid - <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    left = mid + <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> nums[mid] &lt; target &lt;= nums[right]:</span><br><span class=\"line\">                    left = mid + <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    right = mid - <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> left <span class=\"keyword\">if</span> nums[left] == target <span class=\"keyword\">else</span> <span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"9\">\n<li>leetcode 34</li>\n</ol>\n<p>在排列数组中找到某一个target number的位置。</p>\n<p>二分+递归，当二分失败l&gt;r return，或者target == a[mid]return，或者ans[0] &lt; mid &lt; ans[1]，主要是对l/r和ans[0],and[1]进行大小比对。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> typing <span class=\"keyword\">import</span> List</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">bin_search</span><span class=\"params\">(self, a:List[int], l:int, r:int, target:int, ans:List[int])</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> l &gt; r:</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        mid = (l + r) &gt;&gt; <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> a[l] == target:</span><br><span class=\"line\">            ans[<span class=\"number\">0</span>] = min(ans[<span class=\"number\">0</span>], l)</span><br><span class=\"line\">            ans[<span class=\"number\">1</span>] = max(ans[<span class=\"number\">1</span>], l)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> a[r] == target:</span><br><span class=\"line\">            ans[<span class=\"number\">0</span>] = min(ans[<span class=\"number\">0</span>], r)</span><br><span class=\"line\">            ans[<span class=\"number\">1</span>] = max(ans[<span class=\"number\">1</span>], r)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ans[<span class=\"number\">0</span>] &lt; mid &lt; ans[<span class=\"number\">1</span>]:</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> target == a[mid]:</span><br><span class=\"line\">            ans[<span class=\"number\">0</span>] = min(ans[<span class=\"number\">0</span>], mid)</span><br><span class=\"line\">            ans[<span class=\"number\">1</span>] = max(ans[<span class=\"number\">1</span>], mid)</span><br><span class=\"line\">            self.bin_search(a, l, mid - <span class=\"number\">1</span>, target, ans)</span><br><span class=\"line\">            self.bin_search(a, mid + <span class=\"number\">1</span>, r, target, ans)</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> target &gt; a[mid]:</span><br><span class=\"line\">                self.bin_search(a, mid + <span class=\"number\">1</span>, r, target, ans)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                self.bin_search(a, l, mid - <span class=\"number\">1</span>, target, ans)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">searchRange</span><span class=\"params\">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class=\"line\">        ans = [<span class=\"number\">200000000</span>, <span class=\"number\">-1</span>]</span><br><span class=\"line\">        self.bin_search(nums, <span class=\"number\">0</span>, len(nums) - <span class=\"number\">1</span>, target, ans)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ans[<span class=\"number\">1</span>] == <span class=\"number\">-1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> [<span class=\"number\">-1</span>, <span class=\"number\">-1</span>]</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ans</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    nums = [<span class=\"number\">7</span>, <span class=\"number\">7</span>, <span class=\"number\">7</span>, <span class=\"number\">7</span>, <span class=\"number\">7</span>, <span class=\"number\">7</span>, <span class=\"number\">10</span>]</span><br><span class=\"line\">    target = <span class=\"number\">7</span></span><br><span class=\"line\">    print(Solution().searchRange(nums, target))</span><br></pre></td></tr></table></figure>\n\n<ol start=\"10\">\n<li>leetcode 36</li>\n</ol>\n<p><img src=\"https://img.cetacis.dev/uploads/big/e379af099611ed74f5ef430b3ce538f1.png\" alt=\"题意\"></p>\n<p><strong>题解</strong></p>\n<p>看到这道题，很自然地想到嵌套循环，设置i,j分别遍历横排，竖排和3x3的块。难点在于python没有提供二维数组，所以要用自定义的数据结构存储和访问每一个元素。其中有一个flag要素，其实就是对每一个数字进行标记，如果某个数字的flag大于一，即出现了两次以上，则return false。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> typing <span class=\"keyword\">import</span> List</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isValidSudoku</span><span class=\"params\">(self, board: List[List[str]])</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, <span class=\"number\">9</span>):</span><br><span class=\"line\">            flag = [<span class=\"number\">0</span>] * <span class=\"number\">10</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, <span class=\"number\">9</span>):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> board[i][j] == <span class=\"string\">\".\"</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> flag[int(board[i][j])] == <span class=\"number\">0</span>:</span><br><span class=\"line\">                    flag[int(board[i][j])] = <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        j = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> j &lt; <span class=\"number\">9</span>:</span><br><span class=\"line\">            flag = [<span class=\"number\">0</span>] * <span class=\"number\">10</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, <span class=\"number\">9</span>):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> board[i][j] == <span class=\"string\">\".\"</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> flag[int(board[i][j])] == <span class=\"number\">0</span>:</span><br><span class=\"line\">                    flag[int(board[i][j])] = <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">            j = j + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, <span class=\"number\">9</span>, <span class=\"number\">3</span>):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, <span class=\"number\">9</span>, <span class=\"number\">3</span>):</span><br><span class=\"line\">                flag = [<span class=\"number\">0</span>] * <span class=\"number\">10</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> step_i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, <span class=\"number\">3</span>):</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> step_j <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, <span class=\"number\">3</span>):</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> board[i + step_i][j + step_j] == <span class=\"string\">\".\"</span>:</span><br><span class=\"line\">                            <span class=\"keyword\">continue</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> flag[int(board[i + step_i][j + step_j])] == <span class=\"number\">0</span>:</span><br><span class=\"line\">                            flag[int(board[i + step_i][j + step_j])] = <span class=\"number\">1</span></span><br><span class=\"line\">                        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">a = Solution()</span><br><span class=\"line\"><span class=\"keyword\">if</span> Solution.isValidSudoku(a,[[<span class=\"string\">\"7\"</span>,<span class=\"string\">\"3\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\"7\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\".\"</span>],</span><br><span class=\"line\">                             [<span class=\"string\">\"6\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\"1\"</span>,<span class=\"string\">\"9\"</span>,<span class=\"string\">\"5\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\".\"</span>],</span><br><span class=\"line\">                             [<span class=\"string\">\".\"</span>,<span class=\"string\">\"9\"</span>,<span class=\"string\">\"8\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\"6\"</span>,<span class=\"string\">\".\"</span>],</span><br><span class=\"line\">                             [<span class=\"string\">\"8\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\"6\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\"3\"</span>],</span><br><span class=\"line\">                             [<span class=\"string\">\"4\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\"8\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\"3\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\"1\"</span>],</span><br><span class=\"line\">                             [<span class=\"string\">\"7\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\"2\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\"6\"</span>],</span><br><span class=\"line\">                             [<span class=\"string\">\".\"</span>,<span class=\"string\">\"6\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\"2\"</span>,<span class=\"string\">\"8\"</span>,<span class=\"string\">\".\"</span>],</span><br><span class=\"line\">                             [<span class=\"string\">\".\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\"4\"</span>,<span class=\"string\">\"1\"</span>,<span class=\"string\">\"9\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\"5\"</span>],</span><br><span class=\"line\">                             [<span class=\"string\">\".\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\"8\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\"7\"</span>,<span class=\"string\">\"9\"</span>]]):</span><br><span class=\"line\">    <span class=\"keyword\">print</span> (<span class=\"string\">\"True\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">    <span class=\"keyword\">print</span> (<span class=\"string\">\"False\"</span>)</span><br></pre></td></tr></table></figure>\n\n<ol start=\"11\">\n<li>leetcode 50</li>\n</ol>\n<p>快速幂 即通过简单乘法实现幂运算</p>\n<p><strong>题解</strong></p>\n<p>有一些像之前lt29做过的减法实现除法，一个指数可以拆分成很多子项相乘，比如3^8 = 3^4 x 3^4，此时，我们计算3^4再将结果相乘就可得到正确答案，这样节省了算两次3^4 的时间，可以满足时间复杂度。</p>\n<p>又 3^4 = 3^2 x 3^2，此时计算3^2 = 3*3。可以看出，这是一个递归的过程，每次将幂 &gt;&gt; 1，结束条件是幂=0 return 1。当然，幂也有奇数的可能性，当幂是奇数，只要将这一次的return改成 底数 x temp x temp即可。如果幂是偶数，则返回temp x temp。</p>\n<p>但是这个求幂的过程，底数和指数只能是正数，当底数和指数是负数的时候，需要将负数变为正数，再使用如上递归方程。并且对求得的幂进行符号/倒数修改，这就要求对底数、指数进行分类讨论。</p>\n<p>una代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">Pow</span><span class=\"params\">(self, x, n)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            temp = self.Pow(x, n &gt;&gt; <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n % <span class=\"number\">2</span> == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> temp * temp</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> x * temp * temp</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">myPow</span><span class=\"params\">(self, x, n)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> x &lt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> n % <span class=\"number\">2</span> == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.Pow(-x, n) <span class=\"keyword\">if</span> n &gt; <span class=\"number\">0</span> <span class=\"keyword\">else</span> self.Pow(-x, -n)</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> x &lt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> n &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -self.Pow(-x, n)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>/self.Pow(x, -n) <span class=\"keyword\">if</span> x &gt; <span class=\"number\">0</span> <span class=\"keyword\">else</span> <span class=\"number\">1</span>/-self.Pow(-x, -n)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.Pow(x, n)</span><br><span class=\"line\"></span><br><span class=\"line\">a = Solution()</span><br><span class=\"line\"><span class=\"keyword\">print</span> (Solution.myPow(a, <span class=\"number\">-1</span>, <span class=\"number\">-2</span>))</span><br></pre></td></tr></table></figure>\n\n<p>kelo代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">quick</span><span class=\"params\">(self, x: float, n: int)</span> -&gt; float:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> x</span><br><span class=\"line\">        res = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> n &amp; <span class=\"number\">1</span> == <span class=\"number\">1</span>:</span><br><span class=\"line\">            res = x</span><br><span class=\"line\">        half = self.quick(x, n &gt;&gt; <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> half * half * res</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">myPow</span><span class=\"params\">(self, x: float, n: int)</span> -&gt; float:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> n &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.quick(x, n)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.quick(<span class=\"number\">1</span>/x, -n)</span><br></pre></td></tr></table></figure>\n\n<ol start=\"12\">\n<li>leetcode 37 解数独</li>\n</ol>\n<p>顾名思义，解决数独，默认题目可解且有唯一解。</p>\n<p><strong>题解</strong></p>\n<p>第一想法是直接试错法，但是一想这个实验次数岂不是指数爆炸而且极其不美观，现实代码中使用递归试错（穷举）。</p>\n<p>值得注意的点除了这种递归的方法进行穷举以外，还有对某个数字是否出现过的控制方式。具体的做法和解析写在了注释里。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> typing <span class=\"keyword\">import</span> List</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    COL = [<span class=\"number\">0</span>] * <span class=\"number\">10</span></span><br><span class=\"line\">    ROW = [<span class=\"number\">0</span>] * <span class=\"number\">10</span></span><br><span class=\"line\">    BLOCK = [<span class=\"number\">0</span>] * <span class=\"number\">10</span></span><br><span class=\"line\">    Flag = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">solve</span><span class=\"params\">(self, board: List[List[str]], i, j)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.Flag == <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> j == <span class=\"number\">9</span>:</span><br><span class=\"line\">            self.solve(board, i + <span class=\"number\">1</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> i == <span class=\"number\">9</span>:</span><br><span class=\"line\">            self.Flag = <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> board[i][j] != <span class=\"string\">\".\"</span>:</span><br><span class=\"line\">            self.solve(board, i, j + <span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, <span class=\"number\">10</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> self.COL[i] &amp; (<span class=\"number\">1</span> &lt;&lt; x) == <span class=\"number\">1</span> &lt;&lt; x <span class=\"keyword\">or</span> self.ROW[j] &amp; (<span class=\"number\">1</span> &lt;&lt; x) == <span class=\"number\">1</span> &lt;&lt; x <span class=\"keyword\">or</span> \\</span><br><span class=\"line\">                    self.BLOCK[int(i / <span class=\"number\">3</span>) * <span class=\"number\">3</span> + int(j / <span class=\"number\">3</span>)] &amp; (<span class=\"number\">1</span> &lt;&lt; x) == <span class=\"number\">1</span> &lt;&lt; x:</span><br><span class=\"line\">                <span class=\"comment\"># 当行/列/块为x，则跳出本步循环。</span></span><br><span class=\"line\">                <span class=\"comment\"># 即当x这个数已经在i行/列/块存在，不对需要col/row/block进行操作</span></span><br><span class=\"line\">                <span class=\"comment\"># 因为已经有此数，则意味着不能填入此数</span></span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            board[i][j] = str(x)</span><br><span class=\"line\">            <span class=\"comment\"># 填入x</span></span><br><span class=\"line\">            self.COL[i] = self.COL[i] | (<span class=\"number\">1</span> &lt;&lt; x)</span><br><span class=\"line\">            self.ROW[j] = self.ROW[j] | (<span class=\"number\">1</span> &lt;&lt; x)</span><br><span class=\"line\">            self.BLOCK[int(i / <span class=\"number\">3</span>) * <span class=\"number\">3</span> + int(j / <span class=\"number\">3</span>)] = self.BLOCK[int(i / <span class=\"number\">3</span>) * <span class=\"number\">3</span> + int(j / <span class=\"number\">3</span>)] | (<span class=\"number\">1</span> &lt;&lt; x)</span><br><span class=\"line\">            <span class=\"comment\"># 填入x后在col，row，block中进行维护</span></span><br><span class=\"line\">            self.solve(board, i, j + <span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> self.Flag == <span class=\"number\">1</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span></span><br><span class=\"line\">            <span class=\"comment\"># 当i=9，即将所有的数字按照规则填充完成，则flag = 1，退出。</span></span><br><span class=\"line\">            self.COL[i] = self.COL[i] ^ (<span class=\"number\">1</span> &lt;&lt; x)</span><br><span class=\"line\">            self.ROW[j] = self.ROW[j] ^ (<span class=\"number\">1</span> &lt;&lt; x)</span><br><span class=\"line\">            self.BLOCK[int(i / <span class=\"number\">3</span>) * <span class=\"number\">3</span> + int(j / <span class=\"number\">3</span>)] = self.BLOCK[int(i / <span class=\"number\">3</span>) * <span class=\"number\">3</span> + int(j / <span class=\"number\">3</span>)] ^ (<span class=\"number\">1</span> &lt;&lt; x)</span><br><span class=\"line\">            board[i][j] = <span class=\"string\">\".\"</span></span><br><span class=\"line\">     <span class=\"comment\"># flag != 1,即未正确填充，则将此数，将col,row,block标记修改回之前的样子，并且将board[]</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">solveSudoku</span><span class=\"params\">(self, board: List[List[str]])</span> -&gt; <span class=\"keyword\">None</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, <span class=\"number\">10</span>):</span><br><span class=\"line\">            self.COL[i] = <span class=\"number\">0</span></span><br><span class=\"line\">            self.ROW[i] = <span class=\"number\">0</span></span><br><span class=\"line\">            self.BLOCK[i] = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, <span class=\"number\">9</span>):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, <span class=\"number\">9</span>):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> board[i][j] == <span class=\"string\">\".\"</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span></span><br><span class=\"line\">                self.COL[i] = self.COL[i] | (<span class=\"number\">1</span> &lt;&lt; int(board[i][j]))</span><br><span class=\"line\">                self.ROW[j] = self.ROW[j] | (<span class=\"number\">1</span> &lt;&lt; int(board[i][j]))</span><br><span class=\"line\">                self.BLOCK[int(i / <span class=\"number\">3</span>) * <span class=\"number\">3</span> + int(j / <span class=\"number\">3</span>)] = self.BLOCK[int(i / <span class=\"number\">3</span>) * <span class=\"number\">3</span> + int(j / <span class=\"number\">3</span>)] | (<span class=\"number\">1</span> &lt;&lt; int(board[i][j]))</span><br><span class=\"line\">            <span class=\"comment\"># 举例理解，当为i = 0，j = 0,board[0][0]=2, col[0] = 00000000100</span></span><br><span class=\"line\">            <span class=\"comment\"># 当j++, i = 0,j = 1,board[0][1] = 1 col[0]= 0000000110</span></span><br><span class=\"line\">            <span class=\"comment\"># 即，col[i]记录的，是i行的那些数字出现过。如0000000110就是1，2出现过（注意是第零位为0）</span></span><br><span class=\"line\">        self.solve(board, <span class=\"number\">0</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    bd = [[<span class=\"string\">\".\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\"9\"</span>, <span class=\"string\">\"7\"</span>, <span class=\"string\">\"4\"</span>, <span class=\"string\">\"8\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\".\"</span>], [<span class=\"string\">\"7\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\".\"</span>],</span><br><span class=\"line\">     [<span class=\"string\">\".\"</span>, <span class=\"string\">\"2\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\"1\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\"9\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\".\"</span>], [<span class=\"string\">\".\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\"7\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\"2\"</span>, <span class=\"string\">\"4\"</span>, <span class=\"string\">\".\"</span>],</span><br><span class=\"line\">     [<span class=\"string\">\".\"</span>, <span class=\"string\">\"6\"</span>, <span class=\"string\">\"4\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\"1\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\"5\"</span>, <span class=\"string\">\"9\"</span>, <span class=\"string\">\".\"</span>], [<span class=\"string\">\".\"</span>, <span class=\"string\">\"9\"</span>, <span class=\"string\">\"8\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\"3\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\".\"</span>],</span><br><span class=\"line\">     [<span class=\"string\">\".\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\"8\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\"3\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\"2\"</span>, <span class=\"string\">\".\"</span>], [<span class=\"string\">\".\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\"6\"</span>],</span><br><span class=\"line\">     [<span class=\"string\">\".\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\"2\"</span>, <span class=\"string\">\"7\"</span>, <span class=\"string\">\"5\"</span>, <span class=\"string\">\"9\"</span>, <span class=\"string\">\".\"</span>, <span class=\"string\">\".\"</span>]]</span><br><span class=\"line\">    print(Solution().solveSudoku(bd))</span><br><span class=\"line\">    print(bd)</span><br></pre></td></tr></table></figure>\n\n<ol start=\"13\">\n<li>leetcode 38 外观数组</li>\n</ol>\n<p>「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。前五项如下：</p>\n<ol>\n<li>1</li>\n<li>11</li>\n<li>21</li>\n<li>1211</li>\n<li>111221<br>1 被读作  “one 1”  (“一个一”) , 即 11。<br>11 被读作 “two 1s” (“两个一”）, 即 21。<br>21 被读作 “one 2”,  “one 1” （”一个二” ,  “一个一”) , 即 1211。</li>\n</ol>\n<p>给定一个正整数 n（1 ≤ n ≤ 30），输出外观数列的第 n 项。</p>\n<p>注意：整数序列中的每一项将表示为一个字符串。</p>\n<p><strong>题解</strong></p>\n<p>因为ans[i]由ans[i-1]得来，则需从ans[2]开始求直到求到ans[n]。</p>\n<p>为了求ans[i]，可对ans[i-1]进行遍历，对ans[i-1] [j]的j进行循环，当ans[i-1] [j] = ans[i-1] [j+1]，则time ++，相当于如果一个数字重复出现，对出现次数进行++。</p>\n<p>直到ans[i-1] [j] ！= ans[i-1] [j+1]，则ans[i]+(str)time+ans[i-1] [j]，然后对time清零，再次进行如上循环操作。</p>\n<p><strong>代码如下</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">countAndSay</span><span class=\"params\">(self, n)</span>:</span></span><br><span class=\"line\">        ans = [<span class=\"string\">\"\"</span>] * <span class=\"number\">100</span></span><br><span class=\"line\">        ans[<span class=\"number\">1</span>] = <span class=\"string\">\"1\"</span></span><br><span class=\"line\">        i = <span class=\"number\">1</span></span><br><span class=\"line\">        j = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> i &lt; n:</span><br><span class=\"line\">            time = <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> j + <span class=\"number\">1</span> &lt; len(ans[i]) <span class=\"keyword\">and</span> ans[i][j] == ans[i][j + <span class=\"number\">1</span>]:</span><br><span class=\"line\">                time += <span class=\"number\">1</span></span><br><span class=\"line\">                j = j + <span class=\"number\">1</span></span><br><span class=\"line\">            ans[i + <span class=\"number\">1</span>] = ans[i + <span class=\"number\">1</span>] + str(time)+ans[i][j]</span><br><span class=\"line\">            j = j + <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> j == len(ans[i]):</span><br><span class=\"line\">                i = i + <span class=\"number\">1</span></span><br><span class=\"line\">                j = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans[n]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">print</span> (Solution().countAndSay(<span class=\"number\">5</span>))</span><br></pre></td></tr></table></figure>\n\n<ol start=\"14\">\n<li>leetcode 39 40</li>\n</ol>\n<p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>\n<p>candidates 中的数字可以无限制重复被选取。</p>\n<p>说明：</p>\n<p>所有数字（包括 target）都是正整数。<br>解集不能包含重复的组合。<br>示例 1:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: candidates &#x3D; [2,3,6,7], target &#x3D; 7,</span><br><span class=\"line\">所求解集为:</span><br><span class=\"line\">[</span><br><span class=\"line\">  [7],</span><br><span class=\"line\">  [2,2,3]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>示例 2:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: candidates &#x3D; [2,3,5], target &#x3D; 8,</span><br><span class=\"line\">所求解集为:</span><br><span class=\"line\">[</span><br><span class=\"line\">  [2,2,2,2],</span><br><span class=\"line\">  [2,3,3],</span><br><span class=\"line\">  [3,5]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p><strong>题解</strong></p>\n<p>这道题我想到先从小到大sort candidates，然后累加最小的元素 candidates[0]，直到 = target 或者大于target。当 = 成立，则将此种list加入set，</p>\n<p>后续的操作两种情况一样，将最后两个candidates[0]出栈，尝试加入一个candidates[1]，如果= target 则将此种list加入set。之后，= target 或者大于target都将最后两个元素出栈，尝试加入candidates[1]，若小于则直接加入candidates[3]… </p>\n<p>这种不免为一种思路，我的想法是减少显而易见的优化方法，将工作交给计算机，就是每次减少一个在获得全部由candidates[0]组成的target（可能会大于或相等）然后尝试加入candidates[1]，如果能加入，则再加入candidate[1]，直到加到 和为target或者大于target，如同之前对candidates[0]的操作，将candidates[1]减少一个，试图加入candidates[2]..</p>\n<p>这样应该可以用到递归。</p>\n<p>之后，我看了kelo的代码，差不多是一样的思路，都用到了res = res - candidates[step]的思想（初试res即为target），这样，可以将res当做一个新的target，对其进行操作。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> typing <span class=\"keyword\">import</span> List</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    ANS = set()</span><br><span class=\"line\">    SUB_ANS = []</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">find</span><span class=\"params\">(self, step, res, candidates)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> res == <span class=\"number\">0</span>:</span><br><span class=\"line\">            self.ANS.add(tuple(self.SUB_ANS))</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> step == len(candidates):</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> candidates[step] &lt;= res:</span><br><span class=\"line\">            res = res - candidates[step]</span><br><span class=\"line\">            self.SUB_ANS.append(candidates[step])</span><br><span class=\"line\">            self.find(step, res, candidates)</span><br><span class=\"line\">            self.find(step + <span class=\"number\">1</span>, res, candidates)</span><br><span class=\"line\">            res = res + candidates[step]</span><br><span class=\"line\">            <span class=\"keyword\">del</span> self.SUB_ANS[<span class=\"number\">-1</span>]</span><br><span class=\"line\">        self.find(step + <span class=\"number\">1</span>, res, candidates)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">combinationSum</span><span class=\"params\">(self, candidates, target)</span>:</span></span><br><span class=\"line\">        self.ANS.clear()</span><br><span class=\"line\">        self.SUB_ANS = []</span><br><span class=\"line\">        candidates.sort()</span><br><span class=\"line\">        self.find(<span class=\"number\">0</span>, target, candidates)</span><br><span class=\"line\">        fin = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> self.ANS:</span><br><span class=\"line\">            fin.insert(len(fin), list(x))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fin</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    candidates = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">    ta = <span class=\"number\">3</span></span><br><span class=\"line\">    print(Solution().combinationSum(candidates, ta))</span><br></pre></td></tr></table></figure>\n\n<p>当不能重复使用时，将代码改成如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> typing <span class=\"keyword\">import</span> List</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    ANS = set()</span><br><span class=\"line\">    SUB_ANS = []</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">find</span><span class=\"params\">(self, step, res, candidates)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> res == <span class=\"number\">0</span>:</span><br><span class=\"line\">            self.ANS.add(tuple(self.SUB_ANS))</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> step == len(candidates):</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> candidates[step] &lt;= res:</span><br><span class=\"line\">            res = res - candidates[step]</span><br><span class=\"line\">            self.SUB_ANS.append(candidates[step])</span><br><span class=\"line\">            self.find(step + <span class=\"number\">1</span>, res, candidates)</span><br><span class=\"line\">            res = res + candidates[step]</span><br><span class=\"line\">            <span class=\"keyword\">del</span> self.SUB_ANS[<span class=\"number\">-1</span>]</span><br><span class=\"line\">        self.find(step + <span class=\"number\">1</span>, res, candidates)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">combinationSum</span><span class=\"params\">(self, candidates, target)</span>:</span></span><br><span class=\"line\">        self.ANS.clear()</span><br><span class=\"line\">        self.SUB_ANS = []</span><br><span class=\"line\">        candidates.sort()</span><br><span class=\"line\">        self.find(<span class=\"number\">0</span>, target, candidates)</span><br><span class=\"line\">        fin = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> self.ANS:</span><br><span class=\"line\">            fin.insert(len(fin), list(x))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fin</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    candidates = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">    ta = <span class=\"number\">3</span></span><br><span class=\"line\">    print(Solution().combinationSum(candidates, ta))</span><br></pre></td></tr></table></figure>\n\n<ol start=\"15\">\n<li>leetcode 41</li>\n</ol>\n<p>得到一个数组中最小正整数</p>\n<p>如：[1,-1,3,5] 得到2</p>\n<p><strong>题解</strong></p>\n<p>这道题……确实只要遍历就可以了，但是对于时间和空间复杂度都有要求，所以可以采用一种自身哈希的方法，在前面的题中也提过。</p>\n<p>首先，根据抽屉定理，answer &lt;= n+1</p>\n<p>将其中大于n的，小于等于零的设为1。（在这一步之前，先测其中是否有1，如果没有1则输出1）</p>\n<p>关键是将索引值作为哈希key。</p>\n<p>[1, 6, 2 , -1 , 3, 8]—&gt;] [1, 6, 2, 1,3, 1]  （即包含1 - n元素的数组）</p>\n<p>对这个从1-n进行遍历：如果读到数字a，则将第几个元素的符号改变。（使用下表0代表n）</p>\n<p>最后返回第一个正数。如果没有，则判断0位置，如果还没有正数则返回n+1。</p>\n<p>代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">firstMissingPositive</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        n = len(nums)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 基本情况</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"number\">1</span> <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># nums = [1]</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">2</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 用 1 替换负数，0，</span></span><br><span class=\"line\">        <span class=\"comment\"># 和大于 n 的数</span></span><br><span class=\"line\">        <span class=\"comment\"># 在转换以后，nums 只会包含</span></span><br><span class=\"line\">        <span class=\"comment\"># 正数</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[i] &lt;= <span class=\"number\">0</span> <span class=\"keyword\">or</span> nums[i] &gt; n:</span><br><span class=\"line\">                nums[i] = <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 使用索引和数字符号作为检查器</span></span><br><span class=\"line\">        <span class=\"comment\"># 例如，如果 nums[1] 是负数表示在数组中出现了数字 `1`</span></span><br><span class=\"line\">        <span class=\"comment\"># 如果 nums[2] 是正数 表示数字 2 没有出现</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n): </span><br><span class=\"line\">            a = abs(nums[i])</span><br><span class=\"line\">            <span class=\"comment\"># 如果发现了一个数字 a - 改变第 a 个元素的符号</span></span><br><span class=\"line\">            <span class=\"comment\"># 注意重复元素只需操作一次</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> a == n:</span><br><span class=\"line\">                nums[<span class=\"number\">0</span>] = - abs(nums[<span class=\"number\">0</span>])</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                nums[a] = - abs(nums[a])</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"comment\"># 现在第一个正数的下标</span></span><br><span class=\"line\">        <span class=\"comment\"># 就是第一个缺失的数</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, n):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[i] &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> i</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> nums[<span class=\"number\">0</span>] &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> n</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">return</span> n + <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"16\">\n<li>leetcode 45</li>\n</ol>\n<p>题意：</p>\n<p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>\n<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>\n<p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [2,3,1,1,4]</span><br><span class=\"line\">输出: 2</span><br><span class=\"line\">解释: 跳到最后一个位置的最小跳跃数是 2。</span><br><span class=\"line\">     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</span><br></pre></td></tr></table></figure>\n\n<p><strong>题解</strong></p>\n<p>例子是[2, 3, 1, 1, 4]</p>\n<p>结合例子进行解释，nums[0] = 2, 因此跳一次最多到 nums[1]或者nums[2], 将2固定为max_pos，因为这是第一次跳跃后能够到达的最远位置。</p>\n<ul>\n<li><p>i从0到1到max_pos进行遍历，每次更新max_arrive = max(max_arrive,nums[i]+i)。</p>\n<p><em>比如i=1，max_arrive = max(2, 4) = 4</em></p>\n<p>这个遍历其实是一个对第一步跳跃后，第二步跳跃可能情况的一个遍历，选出最大的max_arrive。</p>\n</li>\n<li><p>当i和第一次固定的max_pos重叠时，将此时的max_pos 固定在max _arrive，并且跳跃步数++，相当于其实是选中了从确定max_arrive那次的i开始第二次起跳，max_pos 固定在此时的max _arrive, 进行与第一次相同的循环，直到i和max_pos 重叠。</p>\n</li>\n</ul>\n<p>这个的实质其实是忽略i每次跳的位置（可以在max_arrive确定时确定），只记录跳的次数，进行多次相同的循环操作。</p>\n<p>代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">jump</span><span class=\"params\">(self,nums)</span>:</span></span><br><span class=\"line\">        max_pos = <span class=\"number\">0</span></span><br><span class=\"line\">        max_arrive = <span class=\"number\">0</span></span><br><span class=\"line\">        ans = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>,len(nums)<span class=\"number\">-1</span>):</span><br><span class=\"line\">            max_arrive = max(max_arrive,nums[i]+i)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i&gt;= max_pos:</span><br><span class=\"line\">                max_pos = max_arrive</span><br><span class=\"line\">                ans = ans + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>  ans</span><br></pre></td></tr></table></figure>\n\n<ol start=\"17\">\n<li>Leetcode 43字符串数的乘法</li>\n</ol>\n<p>如“67”‘89“，不能直接乘</p>\n<p><strong>题解：</strong></p>\n<ul>\n<li><p>按照乘法的规律，乘数为num1，被乘数为num2，先对num2进行遍历，跟num1的第一位相乘，num2中每取一个数，将答案的数组ans往后挪移一位。</p>\n<p>同时对num1进行遍历，每次遍历，ans的起始下标加一。对每个num1元素跟num2的每个元素乘，加到ans的对应的位数。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, len(num1)):</span><br><span class=\"line\">          local = i</span><br><span class=\"line\">          <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, len(num2)):</span><br><span class=\"line\">              ans[local] += int(num1[len(num1) - i - <span class=\"number\">1</span>]) * int(num2[len(num2) - j - <span class=\"number\">1</span>])</span><br><span class=\"line\">              local = local + <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果ans的某位&gt;10 则说明需要进位：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, local):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ans[local - <span class=\"number\">1</span>] &gt;= <span class=\"number\">10</span>:</span><br><span class=\"line\">        local = local + <span class=\"number\">1</span></span><br><span class=\"line\">    ans[i + <span class=\"number\">1</span>] += int(ans[i] / <span class=\"number\">10</span>)</span><br><span class=\"line\">    ans[i] %=<span class=\"number\">10</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>判断最高位是否为0</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">    <span class=\"keyword\">if</span> local == <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ans[local - <span class=\"number\">1</span>] == <span class=\"number\">0</span>:</span><br><span class=\"line\">        local = local - <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>将ans整合为final ans</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, local):</span><br><span class=\"line\">    final_ans = final_ans + str(ans[local - i - <span class=\"number\">1</span>])</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>总体的代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">multiply</span><span class=\"params\">(self, num1, num2)</span> :</span></span><br><span class=\"line\">        ans = [<span class=\"number\">0</span>] * <span class=\"number\">15000</span></span><br><span class=\"line\">        local = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, len(num1)):</span><br><span class=\"line\">            local = i</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, len(num2)):</span><br><span class=\"line\">                ans[local] += int(num1[len(num1) - i - <span class=\"number\">1</span>]) * int(num2[len(num2) - j - <span class=\"number\">1</span>])</span><br><span class=\"line\">                local = local + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, local):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ans[local - <span class=\"number\">1</span>] &gt;= <span class=\"number\">10</span>:</span><br><span class=\"line\">                local = local + <span class=\"number\">1</span></span><br><span class=\"line\">            ans[i + <span class=\"number\">1</span>] += int(ans[i] / <span class=\"number\">10</span>)</span><br><span class=\"line\">            ans[i] %=<span class=\"number\">10</span></span><br><span class=\"line\">        final_ans = <span class=\"string\">\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> local == <span class=\"number\">1</span>:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ans[local - <span class=\"number\">1</span>] == <span class=\"number\">0</span>:</span><br><span class=\"line\">                local = local - <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, local):</span><br><span class=\"line\">            final_ans = final_ans + str(ans[local - i - <span class=\"number\">1</span>])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> final_ans</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    a = <span class=\"string\">\"12\"</span></span><br><span class=\"line\">    b = <span class=\"string\">\"12\"</span></span><br><span class=\"line\">    c = Solution()</span><br><span class=\"line\">    print(Solution().multiply(a, b))</span><br></pre></td></tr></table></figure>\n\n<ol start=\"18\">\n<li>Leetcode 46 全排列（无元素重复）</li>\n</ol>\n<p>用到了<strong>回溯</strong>的算法，这是一种通过探索所有可能的候选解来找出所有的解的算法。如果候选解被确认 不是 一个解的话（或者至少不是 最后一个 解），回溯算法会通过在上一步进行一些变化抛弃该解，即<strong>回溯</strong>并且再次尝试。</p>\n<p>一个回溯函数，使用第一个整数的索引作为参数 <code>backtrack(first)</code></p>\n<p>如果整数索引为n则return, 并且在一次return后，将做的变化换回（即试错，重新进行其他尝试，在本题中不算试错，本题只是要算得每一种情况）</p>\n<p><strong>题解</strong></p>\n<ul>\n<li>如果第一个整数有索引 n，意味着当前排列已完成。</li>\n<li>遍历索引 first 到索引 n - 1 的所有整数。Iterate over the integers from index first to index n - 1.<ul>\n<li>在排列中放置第 i 个整数，<br>即 swap(nums[first], nums[i]).</li>\n<li>继续生成从第 i 个整数开始的所有排列: backtrack(first + 1).</li>\n<li>现在回溯，即通过 swap(nums[first], nums[i]) 还原.</li>\n</ul>\n</li>\n</ul>\n<p>回溯法伪代码实现：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">permute</span><span class=\"params\">(self, nums)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[List[int]]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">backtrack</span><span class=\"params\">(first = <span class=\"number\">0</span>)</span>:</span></span><br><span class=\"line\">            <span class=\"comment\"># if all integers are used up</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> first == n:  </span><br><span class=\"line\">                output.append(nums[:])</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(first, n):</span><br><span class=\"line\">                <span class=\"comment\"># place i-th integer first </span></span><br><span class=\"line\">                <span class=\"comment\"># in the current permutation</span></span><br><span class=\"line\">                nums[first], nums[i] = nums[i], nums[first]</span><br><span class=\"line\">                <span class=\"comment\"># use next integers to complete the permutations</span></span><br><span class=\"line\">                backtrack(first + <span class=\"number\">1</span>)</span><br><span class=\"line\">                <span class=\"comment\"># backtrack</span></span><br><span class=\"line\">                nums[first], nums[i] = nums[i], nums[first]</span><br><span class=\"line\">        </span><br><span class=\"line\">        n = len(nums)</span><br><span class=\"line\">        output = []</span><br><span class=\"line\">        backtrack()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> output</span><br></pre></td></tr></table></figure>\n\n<p><em>本题的思想在解数独中也出现过</em></p>\n<p>下面是kelo的具体实现：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> typing <span class=\"keyword\">import</span> List</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    ANS = []</span><br><span class=\"line\">    SUB_ASN = []</span><br><span class=\"line\">    set = <span class=\"number\">0</span></span><br><span class=\"line\">    tot = <span class=\"number\">0</span></span><br><span class=\"line\">    INF = <span class=\"number\">55</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(self, nums: List[int], step)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> step == len(nums):</span><br><span class=\"line\">            self.ANS.append(self.SUB_ASN[:])</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, len(nums)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> self.set &amp; (<span class=\"number\">1</span> &lt;&lt; i) == <span class=\"number\">1</span> &lt;&lt; i:</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            self.SUB_ASN.append(nums[i])</span><br><span class=\"line\">            self.set |= <span class=\"number\">1</span> &lt;&lt; i</span><br><span class=\"line\">            self.dfs(nums, step + <span class=\"number\">1</span>)</span><br><span class=\"line\">            self.set ^= <span class=\"number\">1</span> &lt;&lt; i</span><br><span class=\"line\">            <span class=\"keyword\">del</span> self.SUB_ASN[<span class=\"number\">-1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">permute</span><span class=\"params\">(self, nums: List[int])</span>:</span></span><br><span class=\"line\">        self.ANS: List[List[int]]</span><br><span class=\"line\">        self.ANS = []</span><br><span class=\"line\">        self.tot = <span class=\"number\">0</span></span><br><span class=\"line\">        self.SUB_ASN = []</span><br><span class=\"line\">        self.dfs(nums, <span class=\"number\">0</span>)</span><br><span class=\"line\">        temp = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> self.ANS:</span><br><span class=\"line\">                temp.append(item)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> temp</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    a = [<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\">    print(Solution().permute(a))</span><br></pre></td></tr></table></figure>\n\n<ol start=\"19\">\n<li>leetcode 47 全排列（有元素重复）</li>\n</ol>\n<p>只需要在无重复的基础上，将相同的去除即可。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> self.ANS:</span><br><span class=\"line\">       <span class=\"keyword\">if</span> item <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> temp:</span><br><span class=\"line\">           temp.append(item)</span><br><span class=\"line\">   <span class=\"keyword\">return</span> temp</span><br></pre></td></tr></table></figure>\n\n<ol start=\"20\">\n<li>leetcode49 单词的同分异构体</li>\n</ol>\n<p>例子：输入 a = [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”]，将其变为List(List(string))</p>\n<ul>\n<li>“”.join(sorted(string)) </li>\n</ul>\n<p>“”.join()  : 将字符用“” 串联起来</p>\n<p>sorted(string) : 将string元素排序，得到一串字符集合。但是并不会改变原string</p>\n<ul>\n<li>此题用到哈希表</li>\n</ul>\n<p><strong>代码如下</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> typing <span class=\"keyword\">import</span> List</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">groupAnagrams</span><span class=\"params\">(self, strs)</span>:</span></span><br><span class=\"line\">        hash_map = &#123;&#125;</span><br><span class=\"line\">        sort_string = [<span class=\"string\">\"\"</span>.join(sorted(string)) <span class=\"keyword\">for</span> string <span class=\"keyword\">in</span> strs]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, len(sort_string)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> sort_string[i] <span class=\"keyword\">in</span> hash_map:</span><br><span class=\"line\">                hash_map[sort_string[i]].append(strs[i])</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                hash_map[sort_string[i]] = [strs[i]]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> [x <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> hash_map.values()]</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    a = [<span class=\"string\">\"eat\"</span>, <span class=\"string\">\"tea\"</span>, <span class=\"string\">\"tan\"</span>, <span class=\"string\">\"ate\"</span>, <span class=\"string\">\"nat\"</span>, <span class=\"string\">\"bat\"</span>]</span><br><span class=\"line\">    print(Solution().groupAnagrams(a))</span><br></pre></td></tr></table></figure>\n\n<p>Hash_map 是一个字典，key为排序过的str</p>\n<ol start=\"21\">\n<li>leetcode 44</li>\n</ol>\n<p>给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 ‘?’ 和 ‘*’ 的通配符匹配。</p>\n<p>‘?’ 可以匹配任何单个字符。<br>‘*’ 可以匹配任意字符串（包括空字符串）。<br>两个字符串完全匹配才算匹配成功。</p>\n<p>说明:</p>\n<p>s 可能为空，且只包含从 a-z 的小写字母。<br>p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。</p>\n<p><strong>示例 1:</strong></p>\n<p>输入:<br>s = “aa”<br>p = “a”<br>输出: false<br>解释: “a” 无法匹配 “aa” 整个字符串。</p>\n<p><strong>示例 2:</strong></p>\n<p>输入:<br>s = “aa”<br>p = “*”<br>输出: true<br>解释: ‘*’ 可以匹配任意字符串。</p>\n<p><strong>题解</strong></p>\n<p>最普遍的情况是，当p[j]=s[i]，或者为？，*时，如果s[i-1]，p[j-1]也匹配，则p[j]，s[i]匹配。</p>\n<p>历遍i j，如果p[-1] 与 s[-1]匹配，则结果为ture.要实现遍历，构建bool类型“二维数组”。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> f = [[<span class=\"literal\">False</span>] * (len(p)) <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(len(s))]</span><br><span class=\"line\"><span class=\"comment\"># for _ in range(len(s)) 中 _ 表示占位符 不管是什么，反正只要循环就行了</span></span><br></pre></td></tr></table></figure>\n\n<p>实际上，有很多启动元素和特殊情况</p>\n<ul>\n<li>f[0][0]的情况单独判断</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> s[<span class=\"number\">0</span>] == p[<span class=\"number\">0</span>] <span class=\"keyword\">or</span> p[<span class=\"number\">0</span>] == <span class=\"string\">\"*\"</span> <span class=\"keyword\">or</span> p[<span class=\"number\">0</span>] == <span class=\"string\">\"?\"</span>:</span><br><span class=\"line\">\tf[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"literal\">True</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>p开头为*, 需要单独判断所有的p与s[0]的匹配情况</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> p[<span class=\"number\">0</span>] == <span class=\"string\">\"*\"</span>:</span><br><span class=\"line\">    <span class=\"keyword\">while</span> len(p) &gt; first <span class=\"keyword\">and</span> p[first] == <span class=\"string\">\"*\"</span>:</span><br><span class=\"line\">        f[<span class=\"number\">0</span>][first] = <span class=\"literal\">True</span></span><br><span class=\"line\">        first = first + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> len(p) &gt; first <span class=\"keyword\">and</span> (s[<span class=\"number\">0</span>] == p[first] <span class=\"keyword\">or</span> p[first] == <span class=\"string\">\"?\"</span>):</span><br><span class=\"line\">        f[<span class=\"number\">0</span>][first] = <span class=\"literal\">True</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>接下来就是遍历</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, len(s)):</span><br><span class=\"line\">          <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, len(p)):</span><br><span class=\"line\">              <span class=\"keyword\">if</span> p[j] == <span class=\"string\">\"*\"</span> <span class=\"keyword\">and</span> i &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">                  f[i][j] |= f[i - <span class=\"number\">1</span>][j]</span><br><span class=\"line\">              <span class=\"keyword\">if</span> p[j] == <span class=\"string\">\"*\"</span> <span class=\"keyword\">and</span> j &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">                  f[i][j] |= f[i][j - <span class=\"number\">1</span>]</span><br><span class=\"line\">                  <span class=\"comment\"># 如果p中前一个匹配，则</span></span><br><span class=\"line\">              <span class=\"keyword\">if</span> (s[i] == p[j] <span class=\"keyword\">or</span> p[j] == <span class=\"string\">\"?\"</span> <span class=\"keyword\">or</span> p[j] == <span class=\"string\">\"*\"</span>) <span class=\"keyword\">and</span> i &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> j &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">                  f[i][j] |= f[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>]</span><br><span class=\"line\">                  <span class=\"comment\"># 当i&gt;0 j&gt;0 当s[i] == p[j] or p[j] == \"?\" or p[j] == \"*\" 前一个匹配，则此对匹配</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> f[<span class=\"number\">-1</span>][<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n\n<p>代码如下</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isMatch</span><span class=\"params\">(self, s, p)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> s <span class=\"keyword\">and</span> p:</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, len(p)):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> p[i] != <span class=\"string\">\"*\"</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> s <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> p:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> s <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> p:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        f = [[<span class=\"literal\">False</span>] * (len(p)) <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(len(s))]</span><br><span class=\"line\">        <span class=\"comment\"># for _ in range(len(s)) 中 _ 表示占位符 不管是什么，反正只要循环就行了</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> s[<span class=\"number\">0</span>] == p[<span class=\"number\">0</span>] <span class=\"keyword\">or</span> p[<span class=\"number\">0</span>] == <span class=\"string\">\"*\"</span> <span class=\"keyword\">or</span> p[<span class=\"number\">0</span>] == <span class=\"string\">\"?\"</span>:</span><br><span class=\"line\">            f[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"literal\">True</span></span><br><span class=\"line\">        first = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> p[<span class=\"number\">0</span>] == <span class=\"string\">\"*\"</span>:</span><br><span class=\"line\">            <span class=\"keyword\">while</span> len(p) &gt; first <span class=\"keyword\">and</span> p[first] == <span class=\"string\">\"*\"</span>:</span><br><span class=\"line\">                f[<span class=\"number\">0</span>][first] = <span class=\"literal\">True</span></span><br><span class=\"line\">                first = first + <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> len(p) &gt; first <span class=\"keyword\">and</span> (s[<span class=\"number\">0</span>] == p[first] <span class=\"keyword\">or</span> p[first] == <span class=\"string\">\"?\"</span>):</span><br><span class=\"line\">                f[<span class=\"number\">0</span>][first] = <span class=\"literal\">True</span></span><br><span class=\"line\">            <span class=\"comment\"># 这个while 和 这个 if 的意义在于解决那些在p开头的*</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, len(s)):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, len(p)):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> p[j] == <span class=\"string\">\"*\"</span> <span class=\"keyword\">and</span> i &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">                    f[i][j] |= f[i - <span class=\"number\">1</span>][j]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> p[j] == <span class=\"string\">\"*\"</span> <span class=\"keyword\">and</span> j &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">                    f[i][j] |= f[i][j - <span class=\"number\">1</span>]</span><br><span class=\"line\">                    <span class=\"comment\"># 如果p中前一个匹配，则</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (s[i] == p[j] <span class=\"keyword\">or</span> p[j] == <span class=\"string\">\"?\"</span> <span class=\"keyword\">or</span> p[j] == <span class=\"string\">\"*\"</span>) <span class=\"keyword\">and</span> i &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> j &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">                    f[i][j] |= f[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>]</span><br><span class=\"line\">                    <span class=\"comment\"># 当i&gt;0 j&gt;0 当s[i] == p[j] or p[j] == \"?\" or p[j] == \"*\" 前一个匹配，则此对匹配</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> f[<span class=\"number\">-1</span>][<span class=\"number\">-1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    s = <span class=\"string\">\"mississippsssssi\"</span></span><br><span class=\"line\">    p = <span class=\"string\">\"*sssi\"</span></span><br><span class=\"line\">    print(Solution().isMatch(s, p))</span><br></pre></td></tr></table></figure>"},{"date":"2020-02-09T16:00:00.000Z","_content":"# 第四章 静态链接\n\n#### 4.1 空间与地址分配\n\n输出文件（可执行文件）的空间怎么分配给输入文件\n\n*这里的空间分配可以指在可执行文件中空间的分配，也可指装载后的虚拟地址中的虚拟地址空间*\n\n*但是.data其实在可执行文件中是不存在的，它的分配空间的意义仅局限于虚拟地址空间*\n\n*事实上，我们谈空间分配只关注于虚拟地址空间的分配*\n\n<!-- more -->\n\n1. 按序叠加\n\n   ![按序叠加](https://img.cetacis.dev/uploads/2020/02/09/Screen-Shot-2020-02-09-at-11.20.35-PM.png)\n\n过于零散。浪费空间：x86硬件，段的装载地址和空间的对齐单位是页（4096字节），如果一个段长度只有1字节，也会占用4096字节\n\n2. 相似段合并（常用）\n\n   .text放在一起，.data放在一起，等。\n\n   方法：两步链接 \n\n   * 第一步 空间与地址分配 链接器获得所有输入文件的段长度，并且合并，建立映射关系。\n\n   * 第二步 符号解析与重定位 （核心）符号解析、**重定位**、调整代码地址\n\n     ```\n     $ld a.o b.o -e main -o ab\n     ```\n\n     -e main 表示将main作为程序入口，ld链接器默认入口为_start。\n\n     -o ab 链接输出文件为ab 默认a.out \n\n     **VMA **： Virtual Memory Layout 虚拟地址\n\n     ![目标文件、可执行文件、进程空间](https://img.cetacis.dev/uploads/2020/02/10/Screen-Shot-2020-02-10-at-12.17.14-PM.png)\n\n     \n\n#### 4.2 符号解析与重定位\n\n1. 重定位（链接关键）\n\n   将目标文件反编译以后读文件会发现，一些符号（定义在其他文件中）的地址是00000或者其它\n\n暂定的替代地址。链接后，重定位的入口都会被修正到正确的位置。\n\n2. 重定位表\n\n   ELF有一个段叫做重定位段（重定位表），用于描述如何修改相应段的内容。\n\n   .text有.rel.text的重定位段。.data有.rel.data的重定位段。\n\n   ```\n   $ objdumo -r a.o\n   ```\n\n   ![重定位表](https://img.cetacis.dev/uploads/2020/02/10/Screen-Shot-2020-02-10-at-2.58.53-PM.png)\n\n   \n\n   可以查看a.o需重定位的地方。每个要被重定位的地方叫**relocation entry（重定位入口）**。\n\n   **偏移量（offset）**表示该入口在要被重定位的段中的位置，0000001c和00000027是代码段中”mov“和”call“指令的地址\n\n   此表为代码段的重定位表。\n\n#### 4.3 C++相关问题\n\n1. 重复代码消除\n\n   * 代码级别链接\n\n     **问题：**C++编译器可产生很多重复代码，如模板（Templates）、外部关联函数（Extend Inline Function）、虚函数表（Virtual Function Table）。如模板，他在一个编译单元被实例化，再其他单元也被实例化，会产生重复代码。会造成空间浪费/地址出错/指令运行效率低。\n\n     **解决方法：**方法即将每个模板的实例化代码放在一个段。同一个模板的实例化代码会有相同的名字，因此在链接器连接时，相同的模板实例段会被合并入最后的代码段。这个机制被广泛运用。GCC编译器（Link Once）和VISUAL C++（COMDAT）\n\n     **缺点：**当相同名称的段拥有不同的内容，不同编译单元使用不同的编译器版本/优化选项，会使一个函数编译出来的代码有所不同，会随机选择其中一个副本作为连接输入并提供一个警告信息。\n\n   - 函数级别链接\n\n     **问题：**目前库/程序庞大，一个目标文件包含很多函数/变量。我们需要某目标文件的任意函数/变量，必须将它整个链接，将没用的函数同时链接，这样链接输出会很大。\n\n     **解决方法：**VISUAL C++提供函数界别链接。将每个函数保存到独立段，当链接器需要某函数，将其合并到输出文件，其他函数舍弃。可以减少输出文件长度。GCC提供相应机制：”-ffunction-sections“和\"-fdata-sections\"，将每个函数/变量分别保持在独立段中。\n\n     **缺点：**优化选项减慢编译/链接过程，链接器计算各个函数的依赖关系；目标函数的段数量增加，重定位过程因段的数目增加而复杂，目标文件因段增加而增大。\n\n2. 全局构造与析构\n\n   C/C++源代码层面上是从main开始，到main结束。实际上，main调用前，需初始化进程执行环境。如分配初始化、线程子程序。\n\n   C++全局对象构造函数在这一时期执行、C++全局对象的析构函数在main之后执行。\n\n   _start是可执行文件程序初始化部分的入口。\n\n   因此ELF文件还定义可两种特殊段：\n\n   * .init 保存可执行指令。main调用之前，Glibc初始化部分安排执行此段代码。\n   * .fini 保存进程终止代码指令。main正常退出，Glibc安排执行此段代码。\n\n3. C++与ABI\n\n   ABI（Application Binary Interface）：二进制层面接口。符号修饰标准、变量的内存布局、函数调用方式等与可执行代码二进制兼容性相关的内容。\n\n   API（Application Programming Interface）：源代码层的接口。如POSIX\n\n   API相同不一定ABI相同。ABI不兼容会导致目标文件无法相互连接。硬件、编译语言、编译器、链接器、操作系统都会影响ABI，对于C的目标代码来说，下面几个方面会决定目标文件是否二级制兼容：\n\n   * 内置类型（inr float char）的大小和存储器放置方式（大小端、对齐方式）\n   * 组合类型 （struct、union、array）的存储方式和内存分布\n   * 外部符号与用户定义符号之间的命名方式和解析方式。如函数名func在c语言的目标文件中是否被解析成_func.\n   * 函数调用方式，如参数入栈顺序、返回值保存\n   * 堆栈分布方式\n   * 寄存器使用约定\n\n   类似还有很多内容，C++在C的基础上增添了很多内容，使其兼容更为不易\n\n   * 继承类体系的内存分布，如基类在继承类中的位置\n\n   * 指向成员函数的指针的内存分布，如何荣国成员函数的指针来调用成员函数。\n\n     ...\n\n   C++的二进制兼容性不好。不仅不同编译器不好，甚至一个编译器兼容性不好。C++ ABI标准一直没有统一，现在形成了微软VISUAL C++和GCC（Intel Itanium C++ ABI）为首的两大派系。\n\n\n#### 4.4 静态库链接\n\n程序会有输入输出，输入输出的可以是程序、人、另一台计算器。操作系统提供的**应用程序编程接口（API）**可进行输入。\n\n语言开发环境会附带语言库，库即是操作系统API的包装。如C的printf，此函数对字符串进行一些处理后，调用操作系统API。各个操作系统，调用API不同，在Linux，调用”write“，windows调用”WriteConsole“。同时，一些库函数也不需要调用API。\n\n一个静态库即一组目标文件的集合。如Linux中C的静态库libc；对于windows，常见的c库由IDE附带的运行库组成，一般由编异器厂提供，如Visual C++附带的C/C++运行库。\n\n对于一个helloworld!文件，本身编译为hello.o，然后还需要libc.a解压缩后得到的printf.o，以及printf.o所依赖的各种.o文件。collect2 是ld链接器的一个包装，调用链接器来完成链接，并对链接结果处理：收集与初始化相关的信息并且构造初始化结构。\n\n#### 4.5 连接过程控制\n\n*操作系统内核：从本质来说 他就是一个程序。比如Windows内核 ntoskrnl.exe就是常见的PE文件。*\n\n连接控制脚本\n\n控制链接器产生用户所需的文件的方法：\n\n- 命令行指定参数。比如ld的-o（指定名称），-e(指定入口函数)，-static（静态链接）-s（禁止链接器产生符号表）就属于这类\n- 链接指令放在目标文件里边。比如VISUAL C++会把参数放在PE目标文件.drectve段来传递参数。\n- 使用链接控制脚本。（*）\n\nld在链接时会默认链接脚本。\n\n```\n$ld -verbose\n$ld -T link.script\n```\n\n我们也可以自己写一个脚本，使用-T参数：\n\n*具体内容与语法可以查本书4.6.3 4.6.4*\n\nld链接脚本有专门的的语言\n\n#### 4.6 BFD库\n\n现代硬件软件平台繁多，包括cpu位数、字节序大小端、MMU有无、内存地址对齐与否… 种种差异导致编译器、链接器很难处理不同平台的目标文件。对于GCC、binutils等跨平台文件，统一接口很重要。\n\nBFD库（Binary File Descriptor library）就是一个GNU项目，目标在于通过统一接口处理不同目标文件格式。它将编译器、链接器本身同具体的目标文件格式隔离开来，一旦我们需要支持新的目标文件格式，只需要修改BFD。目前为止，BFD库支持大约25种处理器平台。\n\n\n\n# 第六章 可执行文件的装载与进程\n\n装载：可执行文件装载到内存。\n\n#### 6.1 进程虚拟地址空间\n\n1. *程序进程区别*：\n\n   * 程序（狭义为可执行文件）是一个静态概念，由预编译好的指令和数据集合的文件。\n   * 进程：动态概念，程序运行的过程。Runtime\n\n2. 虚拟空间\n\n   32位，一共4GB空间。64位，2^32*4GB。\n\n   以32位为例，一般会分配1GB给操作系统，3GB给程序使用空间。但是这个比例是可以改的。\n\n3. PAE\n\n   PAE(Physical Address Extension)：一种地址扩展方式。可以将32位扩展至36位地址线，Intel修改了页映射的方式，使得新的映射方式可访问更多的物理内存。\n\n   但是这是补救方式，真正解决办法还是使用64位处理器和操作系统。\n\n#### 6.2 装载方式\n\n**动态载入**：内存的大小是一定的，如果将指令、数据全部装入内存中，内存数量不够。经研究，程序运行是有局部性原理的，我们可将程序最常用的部分驻留在内存中，将不常用的数据的存放在磁盘，这是动态载入的原理。\n\n**覆盖装入（Overlay）** **页映射（Paging）**是两种典型动态装载方式。\n\n1. 覆盖装入\n\n   由程序员手动分割程序，然后编写一个小辅助代码管理模块何时应驻留内存何时被替换。\n\n2. 页映射\n\n   是虚拟存储机制的一部分。页一般是4096字节。\n\n   装载管理器即是现代的操作系统的存储管理器。\n\n   ![页映射与页装载](https://img.cetacis.dev/uploads/2020/02/11/Screen-Shot-2020-02-11-at-3.47.13-PM.png)\n\n   当物理内存满了之后，可通过FIFO（先入先出算法）也可通过LUR（最少使用算法）进行覆盖。\n\n   windows对PE文件的装载、Linux对ELF文件的装载都是这样完成的。\n\n#### 6.3 操作系统角度理解可执行文件装载\n\n1. 进程的建立\n\n   进程最关键特征在于它拥有独立的虚拟地址空间，这使它有别其他进程。一个程序被执行同时伴随一个新的进程的创建。上述过程开始于三件事：\n\n   * 创建独立的虚拟地址空间\n\n     虚拟空间由一组页映射函数将虚拟空间的各个页映射至相应的屋里空间，这一步实际上是创建映射函数所需要的相应数据结构，即**虚拟空间到物理内存的映射**\n\n   * 读取可执行文件头，建立虚拟空间和可执行文件的映射关系\n\n     建立**虚拟空间和可执行文件的映射关系**。即操作系统知道程序当前所需要的页在可执行文件中的哪一个位置。这一步是装载中最重要的一步。可执行文件也可称为image（映像文件）\n\n     VMA（Virtual Memory Area）虚拟内存区域\n\n     如下图，操作系统建立进程后，会在进程相应数据结构中设置一个.text段的VMA。\n\n     ![可执行文件与进程虚拟空间](https://img.cetacis.dev/uploads/2020/02/11/Screen-Shot-2020-02-11-at-4.15.58-PM.png)\n\n     \n\n   * 将CPU的指令寄存器设置成可执行文件的入口地址，启动运行\n\n     CPU执行跳转指令，跳转至可执行文件的入口地址。\n\n# 第七章 动态链接\n\n1. 动态链接（Dynamic Linking）：程序运行时链接。\n\n   解决问题：共享的目标文件多个副本浪费磁盘、内存的问题；更新困难的问题\n\n   缺点：新的模块与旧的模块不兼容，导致原有程序无法运行。称为”DLL Hell“；动态链接在每次装载时重新进行链接，会有相应的时间损失和性能损失。\n\n2. 程序可扩展性和兼容性\n\n   因为动态链接有在程序运行时动态地选择加载各个程序模块的特点，**插件（plug-in）**应运而生。\n\n   作用：（1）实现程序功能的扩展\n\n   ​\t\t\t（2）加强程序兼容性。动态地链接到由操作系统提供的动态链接库，这些动态链接库相当于在程序和操作系统增加了一个中间层，消除了程序对不同平台之间依赖的差异性。\n\n3. 动态链接的基本实现\n\n   主流操作系统支持动态链接：Linux的ELF动态链接文件称为动态共享对象（DSO，Dynamic Shared Objects），简称共享对象，以\".so\"为扩展名。windows系统中，动态链接文件称为**动态链接库（Dynamical Linking Library）**，他们就是我们平时常见的\".dll\"为扩展名的文件。\n\n   比如C语言库的运行库glibc，它的动态链接形式的版本保存在”/lib“目录下，文件名叫做”libc.so“。\n\n   程序被装载->系统的动态链接器将程序所需要的所有动态链接库（libc.so）装载到进程的地址空间，并且将程序中所有未决议的符号绑定到相应的动态链接库中，并进行重定位。\n\n4. 装载时重定位和地址无关代码是解决绝对地址引用问题的两个方法，装载时重定位的缺点是无法共享代码段，但运行速度快。地址无关代码缺点是运行速度慢，但可实现代码段在各个进程之间的共享。\n\n# 第八章 Linux共享库组织\n\n共享库和共享对象从文件结构看，没有区别，Linux下的共享库即是普通的ELF共享对象。\n\n1. 共享库的兼容性\n\n   基于动态链接的灵活性，开发者可以不断更新共享库版本。如libfoo.so的开发者更新新版的libfoo.so后，理论上我们只需要将新版替换旧版。\n\n   但是实际上共享库版本的更新可能导致接口的更改/删除。\n\n   因此，共享库更新分为：\n\n   * 兼容更新\n   * 不兼容更新 改变原有接口\n\n   这里讨论的接口是ABI，这里主要包括一些堆栈结构、符号命名、参数规则、数据结构的内存分布风规则。\n\n   ABI十分难以保持兼容，特别是C++，它支持诸如模板等一些高级特性，他们对于ABI的兼容影响很大。\n\n   尽量遵循下列原则：\n\n   ![注意事项](https://img.cetacis.dev/uploads/2020/02/11/Screen-Shot-2020-02-11-at-6.29.10-PM.png)\n\n2. 共享版本库的命名 libname.so.x.y.z\n\n   x是主版本号，不同的主版本号会不兼容\n\n   y是次版本号，新版保存原有所有接口，同时增加一些新的接口符号。\n\n   z是发布版本号，不添加接口，进行错误修正\n\n   SO-NAME 机制，libfoo.so.x.y.z的SO-NAME是libfoo.so.x，即只保存主版本号，并且产生软连接，使每一次y.z进行改变时，始终保持x不变的最新版。同时，如果主版本号升级，系统会产生新的SO_NAME，SO-NAME不同不会对已有的程序影响。\n\n   Linux提供了一个工具叫做”Idconfig“，当系统安装/更新一个共享库，他会遍历所有默认共享库目录(/usr/lib)，然后更新所有软；链接，指向最新的共享库。如果安装新的，则会为其创建相应的软连接\n\n3. 链接名\n\n   libname.so.x.y.z 中，name即为**链接名**。使用共享库时：\n\n   ```\n   -l name \n   ```\n\n   查找最新版本的”name“库\n\n   -lc 可以根据输出文件情况（静态/动态）选择适合版本的库\n\n   ld -static（静态链接）时，\"-lc\"会查找libc.a；\n\n   ld -Bdynamic(动态链接)时，\"-lc\"会查找最新版本的libc.so.x.y.z(默认)。\n\n","source":"_posts/程序员的自我修养（二）静态链接，装载，动态链接与Linux共享文件.md","raw":"---\ndate: 2020/2/10\ntags:\n- 自学笔记\n- 符号解析\n- 重定位\n- 静态/动态链接\n- 装载\n- 共享库\ncategories:\n- 操作系统\n- 程序员的自我修养\n---\n# 第四章 静态链接\n\n#### 4.1 空间与地址分配\n\n输出文件（可执行文件）的空间怎么分配给输入文件\n\n*这里的空间分配可以指在可执行文件中空间的分配，也可指装载后的虚拟地址中的虚拟地址空间*\n\n*但是.data其实在可执行文件中是不存在的，它的分配空间的意义仅局限于虚拟地址空间*\n\n*事实上，我们谈空间分配只关注于虚拟地址空间的分配*\n\n<!-- more -->\n\n1. 按序叠加\n\n   ![按序叠加](https://img.cetacis.dev/uploads/2020/02/09/Screen-Shot-2020-02-09-at-11.20.35-PM.png)\n\n过于零散。浪费空间：x86硬件，段的装载地址和空间的对齐单位是页（4096字节），如果一个段长度只有1字节，也会占用4096字节\n\n2. 相似段合并（常用）\n\n   .text放在一起，.data放在一起，等。\n\n   方法：两步链接 \n\n   * 第一步 空间与地址分配 链接器获得所有输入文件的段长度，并且合并，建立映射关系。\n\n   * 第二步 符号解析与重定位 （核心）符号解析、**重定位**、调整代码地址\n\n     ```\n     $ld a.o b.o -e main -o ab\n     ```\n\n     -e main 表示将main作为程序入口，ld链接器默认入口为_start。\n\n     -o ab 链接输出文件为ab 默认a.out \n\n     **VMA **： Virtual Memory Layout 虚拟地址\n\n     ![目标文件、可执行文件、进程空间](https://img.cetacis.dev/uploads/2020/02/10/Screen-Shot-2020-02-10-at-12.17.14-PM.png)\n\n     \n\n#### 4.2 符号解析与重定位\n\n1. 重定位（链接关键）\n\n   将目标文件反编译以后读文件会发现，一些符号（定义在其他文件中）的地址是00000或者其它\n\n暂定的替代地址。链接后，重定位的入口都会被修正到正确的位置。\n\n2. 重定位表\n\n   ELF有一个段叫做重定位段（重定位表），用于描述如何修改相应段的内容。\n\n   .text有.rel.text的重定位段。.data有.rel.data的重定位段。\n\n   ```\n   $ objdumo -r a.o\n   ```\n\n   ![重定位表](https://img.cetacis.dev/uploads/2020/02/10/Screen-Shot-2020-02-10-at-2.58.53-PM.png)\n\n   \n\n   可以查看a.o需重定位的地方。每个要被重定位的地方叫**relocation entry（重定位入口）**。\n\n   **偏移量（offset）**表示该入口在要被重定位的段中的位置，0000001c和00000027是代码段中”mov“和”call“指令的地址\n\n   此表为代码段的重定位表。\n\n#### 4.3 C++相关问题\n\n1. 重复代码消除\n\n   * 代码级别链接\n\n     **问题：**C++编译器可产生很多重复代码，如模板（Templates）、外部关联函数（Extend Inline Function）、虚函数表（Virtual Function Table）。如模板，他在一个编译单元被实例化，再其他单元也被实例化，会产生重复代码。会造成空间浪费/地址出错/指令运行效率低。\n\n     **解决方法：**方法即将每个模板的实例化代码放在一个段。同一个模板的实例化代码会有相同的名字，因此在链接器连接时，相同的模板实例段会被合并入最后的代码段。这个机制被广泛运用。GCC编译器（Link Once）和VISUAL C++（COMDAT）\n\n     **缺点：**当相同名称的段拥有不同的内容，不同编译单元使用不同的编译器版本/优化选项，会使一个函数编译出来的代码有所不同，会随机选择其中一个副本作为连接输入并提供一个警告信息。\n\n   - 函数级别链接\n\n     **问题：**目前库/程序庞大，一个目标文件包含很多函数/变量。我们需要某目标文件的任意函数/变量，必须将它整个链接，将没用的函数同时链接，这样链接输出会很大。\n\n     **解决方法：**VISUAL C++提供函数界别链接。将每个函数保存到独立段，当链接器需要某函数，将其合并到输出文件，其他函数舍弃。可以减少输出文件长度。GCC提供相应机制：”-ffunction-sections“和\"-fdata-sections\"，将每个函数/变量分别保持在独立段中。\n\n     **缺点：**优化选项减慢编译/链接过程，链接器计算各个函数的依赖关系；目标函数的段数量增加，重定位过程因段的数目增加而复杂，目标文件因段增加而增大。\n\n2. 全局构造与析构\n\n   C/C++源代码层面上是从main开始，到main结束。实际上，main调用前，需初始化进程执行环境。如分配初始化、线程子程序。\n\n   C++全局对象构造函数在这一时期执行、C++全局对象的析构函数在main之后执行。\n\n   _start是可执行文件程序初始化部分的入口。\n\n   因此ELF文件还定义可两种特殊段：\n\n   * .init 保存可执行指令。main调用之前，Glibc初始化部分安排执行此段代码。\n   * .fini 保存进程终止代码指令。main正常退出，Glibc安排执行此段代码。\n\n3. C++与ABI\n\n   ABI（Application Binary Interface）：二进制层面接口。符号修饰标准、变量的内存布局、函数调用方式等与可执行代码二进制兼容性相关的内容。\n\n   API（Application Programming Interface）：源代码层的接口。如POSIX\n\n   API相同不一定ABI相同。ABI不兼容会导致目标文件无法相互连接。硬件、编译语言、编译器、链接器、操作系统都会影响ABI，对于C的目标代码来说，下面几个方面会决定目标文件是否二级制兼容：\n\n   * 内置类型（inr float char）的大小和存储器放置方式（大小端、对齐方式）\n   * 组合类型 （struct、union、array）的存储方式和内存分布\n   * 外部符号与用户定义符号之间的命名方式和解析方式。如函数名func在c语言的目标文件中是否被解析成_func.\n   * 函数调用方式，如参数入栈顺序、返回值保存\n   * 堆栈分布方式\n   * 寄存器使用约定\n\n   类似还有很多内容，C++在C的基础上增添了很多内容，使其兼容更为不易\n\n   * 继承类体系的内存分布，如基类在继承类中的位置\n\n   * 指向成员函数的指针的内存分布，如何荣国成员函数的指针来调用成员函数。\n\n     ...\n\n   C++的二进制兼容性不好。不仅不同编译器不好，甚至一个编译器兼容性不好。C++ ABI标准一直没有统一，现在形成了微软VISUAL C++和GCC（Intel Itanium C++ ABI）为首的两大派系。\n\n\n#### 4.4 静态库链接\n\n程序会有输入输出，输入输出的可以是程序、人、另一台计算器。操作系统提供的**应用程序编程接口（API）**可进行输入。\n\n语言开发环境会附带语言库，库即是操作系统API的包装。如C的printf，此函数对字符串进行一些处理后，调用操作系统API。各个操作系统，调用API不同，在Linux，调用”write“，windows调用”WriteConsole“。同时，一些库函数也不需要调用API。\n\n一个静态库即一组目标文件的集合。如Linux中C的静态库libc；对于windows，常见的c库由IDE附带的运行库组成，一般由编异器厂提供，如Visual C++附带的C/C++运行库。\n\n对于一个helloworld!文件，本身编译为hello.o，然后还需要libc.a解压缩后得到的printf.o，以及printf.o所依赖的各种.o文件。collect2 是ld链接器的一个包装，调用链接器来完成链接，并对链接结果处理：收集与初始化相关的信息并且构造初始化结构。\n\n#### 4.5 连接过程控制\n\n*操作系统内核：从本质来说 他就是一个程序。比如Windows内核 ntoskrnl.exe就是常见的PE文件。*\n\n连接控制脚本\n\n控制链接器产生用户所需的文件的方法：\n\n- 命令行指定参数。比如ld的-o（指定名称），-e(指定入口函数)，-static（静态链接）-s（禁止链接器产生符号表）就属于这类\n- 链接指令放在目标文件里边。比如VISUAL C++会把参数放在PE目标文件.drectve段来传递参数。\n- 使用链接控制脚本。（*）\n\nld在链接时会默认链接脚本。\n\n```\n$ld -verbose\n$ld -T link.script\n```\n\n我们也可以自己写一个脚本，使用-T参数：\n\n*具体内容与语法可以查本书4.6.3 4.6.4*\n\nld链接脚本有专门的的语言\n\n#### 4.6 BFD库\n\n现代硬件软件平台繁多，包括cpu位数、字节序大小端、MMU有无、内存地址对齐与否… 种种差异导致编译器、链接器很难处理不同平台的目标文件。对于GCC、binutils等跨平台文件，统一接口很重要。\n\nBFD库（Binary File Descriptor library）就是一个GNU项目，目标在于通过统一接口处理不同目标文件格式。它将编译器、链接器本身同具体的目标文件格式隔离开来，一旦我们需要支持新的目标文件格式，只需要修改BFD。目前为止，BFD库支持大约25种处理器平台。\n\n\n\n# 第六章 可执行文件的装载与进程\n\n装载：可执行文件装载到内存。\n\n#### 6.1 进程虚拟地址空间\n\n1. *程序进程区别*：\n\n   * 程序（狭义为可执行文件）是一个静态概念，由预编译好的指令和数据集合的文件。\n   * 进程：动态概念，程序运行的过程。Runtime\n\n2. 虚拟空间\n\n   32位，一共4GB空间。64位，2^32*4GB。\n\n   以32位为例，一般会分配1GB给操作系统，3GB给程序使用空间。但是这个比例是可以改的。\n\n3. PAE\n\n   PAE(Physical Address Extension)：一种地址扩展方式。可以将32位扩展至36位地址线，Intel修改了页映射的方式，使得新的映射方式可访问更多的物理内存。\n\n   但是这是补救方式，真正解决办法还是使用64位处理器和操作系统。\n\n#### 6.2 装载方式\n\n**动态载入**：内存的大小是一定的，如果将指令、数据全部装入内存中，内存数量不够。经研究，程序运行是有局部性原理的，我们可将程序最常用的部分驻留在内存中，将不常用的数据的存放在磁盘，这是动态载入的原理。\n\n**覆盖装入（Overlay）** **页映射（Paging）**是两种典型动态装载方式。\n\n1. 覆盖装入\n\n   由程序员手动分割程序，然后编写一个小辅助代码管理模块何时应驻留内存何时被替换。\n\n2. 页映射\n\n   是虚拟存储机制的一部分。页一般是4096字节。\n\n   装载管理器即是现代的操作系统的存储管理器。\n\n   ![页映射与页装载](https://img.cetacis.dev/uploads/2020/02/11/Screen-Shot-2020-02-11-at-3.47.13-PM.png)\n\n   当物理内存满了之后，可通过FIFO（先入先出算法）也可通过LUR（最少使用算法）进行覆盖。\n\n   windows对PE文件的装载、Linux对ELF文件的装载都是这样完成的。\n\n#### 6.3 操作系统角度理解可执行文件装载\n\n1. 进程的建立\n\n   进程最关键特征在于它拥有独立的虚拟地址空间，这使它有别其他进程。一个程序被执行同时伴随一个新的进程的创建。上述过程开始于三件事：\n\n   * 创建独立的虚拟地址空间\n\n     虚拟空间由一组页映射函数将虚拟空间的各个页映射至相应的屋里空间，这一步实际上是创建映射函数所需要的相应数据结构，即**虚拟空间到物理内存的映射**\n\n   * 读取可执行文件头，建立虚拟空间和可执行文件的映射关系\n\n     建立**虚拟空间和可执行文件的映射关系**。即操作系统知道程序当前所需要的页在可执行文件中的哪一个位置。这一步是装载中最重要的一步。可执行文件也可称为image（映像文件）\n\n     VMA（Virtual Memory Area）虚拟内存区域\n\n     如下图，操作系统建立进程后，会在进程相应数据结构中设置一个.text段的VMA。\n\n     ![可执行文件与进程虚拟空间](https://img.cetacis.dev/uploads/2020/02/11/Screen-Shot-2020-02-11-at-4.15.58-PM.png)\n\n     \n\n   * 将CPU的指令寄存器设置成可执行文件的入口地址，启动运行\n\n     CPU执行跳转指令，跳转至可执行文件的入口地址。\n\n# 第七章 动态链接\n\n1. 动态链接（Dynamic Linking）：程序运行时链接。\n\n   解决问题：共享的目标文件多个副本浪费磁盘、内存的问题；更新困难的问题\n\n   缺点：新的模块与旧的模块不兼容，导致原有程序无法运行。称为”DLL Hell“；动态链接在每次装载时重新进行链接，会有相应的时间损失和性能损失。\n\n2. 程序可扩展性和兼容性\n\n   因为动态链接有在程序运行时动态地选择加载各个程序模块的特点，**插件（plug-in）**应运而生。\n\n   作用：（1）实现程序功能的扩展\n\n   ​\t\t\t（2）加强程序兼容性。动态地链接到由操作系统提供的动态链接库，这些动态链接库相当于在程序和操作系统增加了一个中间层，消除了程序对不同平台之间依赖的差异性。\n\n3. 动态链接的基本实现\n\n   主流操作系统支持动态链接：Linux的ELF动态链接文件称为动态共享对象（DSO，Dynamic Shared Objects），简称共享对象，以\".so\"为扩展名。windows系统中，动态链接文件称为**动态链接库（Dynamical Linking Library）**，他们就是我们平时常见的\".dll\"为扩展名的文件。\n\n   比如C语言库的运行库glibc，它的动态链接形式的版本保存在”/lib“目录下，文件名叫做”libc.so“。\n\n   程序被装载->系统的动态链接器将程序所需要的所有动态链接库（libc.so）装载到进程的地址空间，并且将程序中所有未决议的符号绑定到相应的动态链接库中，并进行重定位。\n\n4. 装载时重定位和地址无关代码是解决绝对地址引用问题的两个方法，装载时重定位的缺点是无法共享代码段，但运行速度快。地址无关代码缺点是运行速度慢，但可实现代码段在各个进程之间的共享。\n\n# 第八章 Linux共享库组织\n\n共享库和共享对象从文件结构看，没有区别，Linux下的共享库即是普通的ELF共享对象。\n\n1. 共享库的兼容性\n\n   基于动态链接的灵活性，开发者可以不断更新共享库版本。如libfoo.so的开发者更新新版的libfoo.so后，理论上我们只需要将新版替换旧版。\n\n   但是实际上共享库版本的更新可能导致接口的更改/删除。\n\n   因此，共享库更新分为：\n\n   * 兼容更新\n   * 不兼容更新 改变原有接口\n\n   这里讨论的接口是ABI，这里主要包括一些堆栈结构、符号命名、参数规则、数据结构的内存分布风规则。\n\n   ABI十分难以保持兼容，特别是C++，它支持诸如模板等一些高级特性，他们对于ABI的兼容影响很大。\n\n   尽量遵循下列原则：\n\n   ![注意事项](https://img.cetacis.dev/uploads/2020/02/11/Screen-Shot-2020-02-11-at-6.29.10-PM.png)\n\n2. 共享版本库的命名 libname.so.x.y.z\n\n   x是主版本号，不同的主版本号会不兼容\n\n   y是次版本号，新版保存原有所有接口，同时增加一些新的接口符号。\n\n   z是发布版本号，不添加接口，进行错误修正\n\n   SO-NAME 机制，libfoo.so.x.y.z的SO-NAME是libfoo.so.x，即只保存主版本号，并且产生软连接，使每一次y.z进行改变时，始终保持x不变的最新版。同时，如果主版本号升级，系统会产生新的SO_NAME，SO-NAME不同不会对已有的程序影响。\n\n   Linux提供了一个工具叫做”Idconfig“，当系统安装/更新一个共享库，他会遍历所有默认共享库目录(/usr/lib)，然后更新所有软；链接，指向最新的共享库。如果安装新的，则会为其创建相应的软连接\n\n3. 链接名\n\n   libname.so.x.y.z 中，name即为**链接名**。使用共享库时：\n\n   ```\n   -l name \n   ```\n\n   查找最新版本的”name“库\n\n   -lc 可以根据输出文件情况（静态/动态）选择适合版本的库\n\n   ld -static（静态链接）时，\"-lc\"会查找libc.a；\n\n   ld -Bdynamic(动态链接)时，\"-lc\"会查找最新版本的libc.so.x.y.z(默认)。\n\n","slug":"程序员的自我修养（二）静态链接，装载，动态链接与Linux共享文件","published":1,"updated":"2020-03-25T01:19:24.000Z","title":"程序员的自我修养（二）静态链接，装载，动态链接与Linux共享文件","_id":"ck849avan0006these8jg6962","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"第四章-静态链接\"><a href=\"#第四章-静态链接\" class=\"headerlink\" title=\"第四章 静态链接\"></a>第四章 静态链接</h1><h4 id=\"4-1-空间与地址分配\"><a href=\"#4-1-空间与地址分配\" class=\"headerlink\" title=\"4.1 空间与地址分配\"></a>4.1 空间与地址分配</h4><p>输出文件（可执行文件）的空间怎么分配给输入文件</p>\n<p><em>这里的空间分配可以指在可执行文件中空间的分配，也可指装载后的虚拟地址中的虚拟地址空间</em></p>\n<p><em>但是.data其实在可执行文件中是不存在的，它的分配空间的意义仅局限于虚拟地址空间</em></p>\n<p><em>事实上，我们谈空间分配只关注于虚拟地址空间的分配</em></p>\n<a id=\"more\"></a>\n\n<ol>\n<li><p>按序叠加</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/09/Screen-Shot-2020-02-09-at-11.20.35-PM.png\" alt=\"按序叠加\"></p>\n</li>\n</ol>\n<p>过于零散。浪费空间：x86硬件，段的装载地址和空间的对齐单位是页（4096字节），如果一个段长度只有1字节，也会占用4096字节</p>\n<ol start=\"2\">\n<li><p>相似段合并（常用）</p>\n<p>.text放在一起，.data放在一起，等。</p>\n<p>方法：两步链接 </p>\n<ul>\n<li><p>第一步 空间与地址分配 链接器获得所有输入文件的段长度，并且合并，建立映射关系。</p>\n</li>\n<li><p>第二步 符号解析与重定位 （核心）符号解析、<strong>重定位</strong>、调整代码地址</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ld a.o b.o -e main -o ab</span><br></pre></td></tr></table></figure>\n\n<p>-e main 表示将main作为程序入口，ld链接器默认入口为_start。</p>\n<p>-o ab 链接输出文件为ab 默认a.out </p>\n<p>*<em>VMA *</em>： Virtual Memory Layout 虚拟地址</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/10/Screen-Shot-2020-02-10-at-12.17.14-PM.png\" alt=\"目标文件、可执行文件、进程空间\"></p>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"4-2-符号解析与重定位\"><a href=\"#4-2-符号解析与重定位\" class=\"headerlink\" title=\"4.2 符号解析与重定位\"></a>4.2 符号解析与重定位</h4><ol>\n<li><p>重定位（链接关键）</p>\n<p>将目标文件反编译以后读文件会发现，一些符号（定义在其他文件中）的地址是00000或者其它</p>\n</li>\n</ol>\n<p>暂定的替代地址。链接后，重定位的入口都会被修正到正确的位置。</p>\n<ol start=\"2\">\n<li><p>重定位表</p>\n<p>ELF有一个段叫做重定位段（重定位表），用于描述如何修改相应段的内容。</p>\n<p>.text有.rel.text的重定位段。.data有.rel.data的重定位段。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ objdumo -r a.o</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/10/Screen-Shot-2020-02-10-at-2.58.53-PM.png\" alt=\"重定位表\"></p>\n</li>\n</ol>\n<p>   可以查看a.o需重定位的地方。每个要被重定位的地方叫<strong>relocation entry（重定位入口）</strong>。</p>\n<p>   <strong>偏移量（offset）</strong>表示该入口在要被重定位的段中的位置，0000001c和00000027是代码段中”mov“和”call“指令的地址</p>\n<p>   此表为代码段的重定位表。</p>\n<h4 id=\"4-3-C-相关问题\"><a href=\"#4-3-C-相关问题\" class=\"headerlink\" title=\"4.3 C++相关问题\"></a>4.3 C++相关问题</h4><ol>\n<li><p>重复代码消除</p>\n<ul>\n<li><p>代码级别链接</p>\n<p><strong>问题：</strong>C++编译器可产生很多重复代码，如模板（Templates）、外部关联函数（Extend Inline Function）、虚函数表（Virtual Function Table）。如模板，他在一个编译单元被实例化，再其他单元也被实例化，会产生重复代码。会造成空间浪费/地址出错/指令运行效率低。</p>\n<p><strong>解决方法：</strong>方法即将每个模板的实例化代码放在一个段。同一个模板的实例化代码会有相同的名字，因此在链接器连接时，相同的模板实例段会被合并入最后的代码段。这个机制被广泛运用。GCC编译器（Link Once）和VISUAL C++（COMDAT）</p>\n<p><strong>缺点：</strong>当相同名称的段拥有不同的内容，不同编译单元使用不同的编译器版本/优化选项，会使一个函数编译出来的代码有所不同，会随机选择其中一个副本作为连接输入并提供一个警告信息。</p>\n</li>\n</ul>\n<ul>\n<li><p>函数级别链接</p>\n<p><strong>问题：</strong>目前库/程序庞大，一个目标文件包含很多函数/变量。我们需要某目标文件的任意函数/变量，必须将它整个链接，将没用的函数同时链接，这样链接输出会很大。</p>\n<p><strong>解决方法：</strong>VISUAL C++提供函数界别链接。将每个函数保存到独立段，当链接器需要某函数，将其合并到输出文件，其他函数舍弃。可以减少输出文件长度。GCC提供相应机制：”-ffunction-sections“和”-fdata-sections”，将每个函数/变量分别保持在独立段中。</p>\n<p><strong>缺点：</strong>优化选项减慢编译/链接过程，链接器计算各个函数的依赖关系；目标函数的段数量增加，重定位过程因段的数目增加而复杂，目标文件因段增加而增大。</p>\n</li>\n</ul>\n</li>\n<li><p>全局构造与析构</p>\n<p>C/C++源代码层面上是从main开始，到main结束。实际上，main调用前，需初始化进程执行环境。如分配初始化、线程子程序。</p>\n<p>C++全局对象构造函数在这一时期执行、C++全局对象的析构函数在main之后执行。</p>\n<p>_start是可执行文件程序初始化部分的入口。</p>\n<p>因此ELF文件还定义可两种特殊段：</p>\n<ul>\n<li>.init 保存可执行指令。main调用之前，Glibc初始化部分安排执行此段代码。</li>\n<li>.fini 保存进程终止代码指令。main正常退出，Glibc安排执行此段代码。</li>\n</ul>\n</li>\n<li><p>C++与ABI</p>\n<p>ABI（Application Binary Interface）：二进制层面接口。符号修饰标准、变量的内存布局、函数调用方式等与可执行代码二进制兼容性相关的内容。</p>\n<p>API（Application Programming Interface）：源代码层的接口。如POSIX</p>\n<p>API相同不一定ABI相同。ABI不兼容会导致目标文件无法相互连接。硬件、编译语言、编译器、链接器、操作系统都会影响ABI，对于C的目标代码来说，下面几个方面会决定目标文件是否二级制兼容：</p>\n<ul>\n<li>内置类型（inr float char）的大小和存储器放置方式（大小端、对齐方式）</li>\n<li>组合类型 （struct、union、array）的存储方式和内存分布</li>\n<li>外部符号与用户定义符号之间的命名方式和解析方式。如函数名func在c语言的目标文件中是否被解析成_func.</li>\n<li>函数调用方式，如参数入栈顺序、返回值保存</li>\n<li>堆栈分布方式</li>\n<li>寄存器使用约定</li>\n</ul>\n<p>类似还有很多内容，C++在C的基础上增添了很多内容，使其兼容更为不易</p>\n<ul>\n<li><p>继承类体系的内存分布，如基类在继承类中的位置</p>\n</li>\n<li><p>指向成员函数的指针的内存分布，如何荣国成员函数的指针来调用成员函数。</p>\n<p>…</p>\n</li>\n</ul>\n<p>C++的二进制兼容性不好。不仅不同编译器不好，甚至一个编译器兼容性不好。C++ ABI标准一直没有统一，现在形成了微软VISUAL C++和GCC（Intel Itanium C++ ABI）为首的两大派系。</p>\n</li>\n</ol>\n<h4 id=\"4-4-静态库链接\"><a href=\"#4-4-静态库链接\" class=\"headerlink\" title=\"4.4 静态库链接\"></a>4.4 静态库链接</h4><p>程序会有输入输出，输入输出的可以是程序、人、另一台计算器。操作系统提供的<strong>应用程序编程接口（API）</strong>可进行输入。</p>\n<p>语言开发环境会附带语言库，库即是操作系统API的包装。如C的printf，此函数对字符串进行一些处理后，调用操作系统API。各个操作系统，调用API不同，在Linux，调用”write“，windows调用”WriteConsole“。同时，一些库函数也不需要调用API。</p>\n<p>一个静态库即一组目标文件的集合。如Linux中C的静态库libc；对于windows，常见的c库由IDE附带的运行库组成，一般由编异器厂提供，如Visual C++附带的C/C++运行库。</p>\n<p>对于一个helloworld!文件，本身编译为hello.o，然后还需要libc.a解压缩后得到的printf.o，以及printf.o所依赖的各种.o文件。collect2 是ld链接器的一个包装，调用链接器来完成链接，并对链接结果处理：收集与初始化相关的信息并且构造初始化结构。</p>\n<h4 id=\"4-5-连接过程控制\"><a href=\"#4-5-连接过程控制\" class=\"headerlink\" title=\"4.5 连接过程控制\"></a>4.5 连接过程控制</h4><p><em>操作系统内核：从本质来说 他就是一个程序。比如Windows内核 ntoskrnl.exe就是常见的PE文件。</em></p>\n<p>连接控制脚本</p>\n<p>控制链接器产生用户所需的文件的方法：</p>\n<ul>\n<li>命令行指定参数。比如ld的-o（指定名称），-e(指定入口函数)，-static（静态链接）-s（禁止链接器产生符号表）就属于这类</li>\n<li>链接指令放在目标文件里边。比如VISUAL C++会把参数放在PE目标文件.drectve段来传递参数。</li>\n<li>使用链接控制脚本。（*）</li>\n</ul>\n<p>ld在链接时会默认链接脚本。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ld -verbose</span><br><span class=\"line\">$ld -T link.script</span><br></pre></td></tr></table></figure>\n\n<p>我们也可以自己写一个脚本，使用-T参数：</p>\n<p><em>具体内容与语法可以查本书4.6.3 4.6.4</em></p>\n<p>ld链接脚本有专门的的语言</p>\n<h4 id=\"4-6-BFD库\"><a href=\"#4-6-BFD库\" class=\"headerlink\" title=\"4.6 BFD库\"></a>4.6 BFD库</h4><p>现代硬件软件平台繁多，包括cpu位数、字节序大小端、MMU有无、内存地址对齐与否… 种种差异导致编译器、链接器很难处理不同平台的目标文件。对于GCC、binutils等跨平台文件，统一接口很重要。</p>\n<p>BFD库（Binary File Descriptor library）就是一个GNU项目，目标在于通过统一接口处理不同目标文件格式。它将编译器、链接器本身同具体的目标文件格式隔离开来，一旦我们需要支持新的目标文件格式，只需要修改BFD。目前为止，BFD库支持大约25种处理器平台。</p>\n<h1 id=\"第六章-可执行文件的装载与进程\"><a href=\"#第六章-可执行文件的装载与进程\" class=\"headerlink\" title=\"第六章 可执行文件的装载与进程\"></a>第六章 可执行文件的装载与进程</h1><p>装载：可执行文件装载到内存。</p>\n<h4 id=\"6-1-进程虚拟地址空间\"><a href=\"#6-1-进程虚拟地址空间\" class=\"headerlink\" title=\"6.1 进程虚拟地址空间\"></a>6.1 进程虚拟地址空间</h4><ol>\n<li><p><em>程序进程区别</em>：</p>\n<ul>\n<li>程序（狭义为可执行文件）是一个静态概念，由预编译好的指令和数据集合的文件。</li>\n<li>进程：动态概念，程序运行的过程。Runtime</li>\n</ul>\n</li>\n<li><p>虚拟空间</p>\n<p>32位，一共4GB空间。64位，2^32*4GB。</p>\n<p>以32位为例，一般会分配1GB给操作系统，3GB给程序使用空间。但是这个比例是可以改的。</p>\n</li>\n<li><p>PAE</p>\n<p>PAE(Physical Address Extension)：一种地址扩展方式。可以将32位扩展至36位地址线，Intel修改了页映射的方式，使得新的映射方式可访问更多的物理内存。</p>\n<p>但是这是补救方式，真正解决办法还是使用64位处理器和操作系统。</p>\n</li>\n</ol>\n<h4 id=\"6-2-装载方式\"><a href=\"#6-2-装载方式\" class=\"headerlink\" title=\"6.2 装载方式\"></a>6.2 装载方式</h4><p><strong>动态载入</strong>：内存的大小是一定的，如果将指令、数据全部装入内存中，内存数量不够。经研究，程序运行是有局部性原理的，我们可将程序最常用的部分驻留在内存中，将不常用的数据的存放在磁盘，这是动态载入的原理。</p>\n<p><strong>覆盖装入（Overlay）</strong> <strong>页映射（Paging）</strong>是两种典型动态装载方式。</p>\n<ol>\n<li><p>覆盖装入</p>\n<p>由程序员手动分割程序，然后编写一个小辅助代码管理模块何时应驻留内存何时被替换。</p>\n</li>\n<li><p>页映射</p>\n<p>是虚拟存储机制的一部分。页一般是4096字节。</p>\n<p>装载管理器即是现代的操作系统的存储管理器。</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/11/Screen-Shot-2020-02-11-at-3.47.13-PM.png\" alt=\"页映射与页装载\"></p>\n<p>当物理内存满了之后，可通过FIFO（先入先出算法）也可通过LUR（最少使用算法）进行覆盖。</p>\n<p>windows对PE文件的装载、Linux对ELF文件的装载都是这样完成的。</p>\n</li>\n</ol>\n<h4 id=\"6-3-操作系统角度理解可执行文件装载\"><a href=\"#6-3-操作系统角度理解可执行文件装载\" class=\"headerlink\" title=\"6.3 操作系统角度理解可执行文件装载\"></a>6.3 操作系统角度理解可执行文件装载</h4><ol>\n<li><p>进程的建立</p>\n<p>进程最关键特征在于它拥有独立的虚拟地址空间，这使它有别其他进程。一个程序被执行同时伴随一个新的进程的创建。上述过程开始于三件事：</p>\n<ul>\n<li><p>创建独立的虚拟地址空间</p>\n<p>虚拟空间由一组页映射函数将虚拟空间的各个页映射至相应的屋里空间，这一步实际上是创建映射函数所需要的相应数据结构，即<strong>虚拟空间到物理内存的映射</strong></p>\n</li>\n<li><p>读取可执行文件头，建立虚拟空间和可执行文件的映射关系</p>\n<p>建立<strong>虚拟空间和可执行文件的映射关系</strong>。即操作系统知道程序当前所需要的页在可执行文件中的哪一个位置。这一步是装载中最重要的一步。可执行文件也可称为image（映像文件）</p>\n<p>VMA（Virtual Memory Area）虚拟内存区域</p>\n<p>如下图，操作系统建立进程后，会在进程相应数据结构中设置一个.text段的VMA。</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/11/Screen-Shot-2020-02-11-at-4.15.58-PM.png\" alt=\"可执行文件与进程虚拟空间\"></p>\n</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li><p>将CPU的指令寄存器设置成可执行文件的入口地址，启动运行</p>\n<p>CPU执行跳转指令，跳转至可执行文件的入口地址。</p>\n</li>\n</ul>\n<h1 id=\"第七章-动态链接\"><a href=\"#第七章-动态链接\" class=\"headerlink\" title=\"第七章 动态链接\"></a>第七章 动态链接</h1><ol>\n<li><p>动态链接（Dynamic Linking）：程序运行时链接。</p>\n<p>解决问题：共享的目标文件多个副本浪费磁盘、内存的问题；更新困难的问题</p>\n<p>缺点：新的模块与旧的模块不兼容，导致原有程序无法运行。称为”DLL Hell“；动态链接在每次装载时重新进行链接，会有相应的时间损失和性能损失。</p>\n</li>\n<li><p>程序可扩展性和兼容性</p>\n<p>因为动态链接有在程序运行时动态地选择加载各个程序模块的特点，<strong>插件（plug-in）</strong>应运而生。</p>\n<p>作用：（1）实现程序功能的扩展</p>\n<p>​            （2）加强程序兼容性。动态地链接到由操作系统提供的动态链接库，这些动态链接库相当于在程序和操作系统增加了一个中间层，消除了程序对不同平台之间依赖的差异性。</p>\n</li>\n<li><p>动态链接的基本实现</p>\n<p>主流操作系统支持动态链接：Linux的ELF动态链接文件称为动态共享对象（DSO，Dynamic Shared Objects），简称共享对象，以”.so”为扩展名。windows系统中，动态链接文件称为<strong>动态链接库（Dynamical Linking Library）</strong>，他们就是我们平时常见的”.dll”为扩展名的文件。</p>\n<p>比如C语言库的运行库glibc，它的动态链接形式的版本保存在”/lib“目录下，文件名叫做”libc.so“。</p>\n<p>程序被装载-&gt;系统的动态链接器将程序所需要的所有动态链接库（libc.so）装载到进程的地址空间，并且将程序中所有未决议的符号绑定到相应的动态链接库中，并进行重定位。</p>\n</li>\n<li><p>装载时重定位和地址无关代码是解决绝对地址引用问题的两个方法，装载时重定位的缺点是无法共享代码段，但运行速度快。地址无关代码缺点是运行速度慢，但可实现代码段在各个进程之间的共享。</p>\n</li>\n</ol>\n<h1 id=\"第八章-Linux共享库组织\"><a href=\"#第八章-Linux共享库组织\" class=\"headerlink\" title=\"第八章 Linux共享库组织\"></a>第八章 Linux共享库组织</h1><p>共享库和共享对象从文件结构看，没有区别，Linux下的共享库即是普通的ELF共享对象。</p>\n<ol>\n<li><p>共享库的兼容性</p>\n<p>基于动态链接的灵活性，开发者可以不断更新共享库版本。如libfoo.so的开发者更新新版的libfoo.so后，理论上我们只需要将新版替换旧版。</p>\n<p>但是实际上共享库版本的更新可能导致接口的更改/删除。</p>\n<p>因此，共享库更新分为：</p>\n<ul>\n<li>兼容更新</li>\n<li>不兼容更新 改变原有接口</li>\n</ul>\n<p>这里讨论的接口是ABI，这里主要包括一些堆栈结构、符号命名、参数规则、数据结构的内存分布风规则。</p>\n<p>ABI十分难以保持兼容，特别是C++，它支持诸如模板等一些高级特性，他们对于ABI的兼容影响很大。</p>\n<p>尽量遵循下列原则：</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/11/Screen-Shot-2020-02-11-at-6.29.10-PM.png\" alt=\"注意事项\"></p>\n</li>\n<li><p>共享版本库的命名 libname.so.x.y.z</p>\n<p>x是主版本号，不同的主版本号会不兼容</p>\n<p>y是次版本号，新版保存原有所有接口，同时增加一些新的接口符号。</p>\n<p>z是发布版本号，不添加接口，进行错误修正</p>\n<p>SO-NAME 机制，libfoo.so.x.y.z的SO-NAME是libfoo.so.x，即只保存主版本号，并且产生软连接，使每一次y.z进行改变时，始终保持x不变的最新版。同时，如果主版本号升级，系统会产生新的SO_NAME，SO-NAME不同不会对已有的程序影响。</p>\n<p>Linux提供了一个工具叫做”Idconfig“，当系统安装/更新一个共享库，他会遍历所有默认共享库目录(/usr/lib)，然后更新所有软；链接，指向最新的共享库。如果安装新的，则会为其创建相应的软连接</p>\n</li>\n<li><p>链接名</p>\n<p>libname.so.x.y.z 中，name即为<strong>链接名</strong>。使用共享库时：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-l name</span><br></pre></td></tr></table></figure>\n\n<p>查找最新版本的”name“库</p>\n<p>-lc 可以根据输出文件情况（静态/动态）选择适合版本的库</p>\n<p>ld -static（静态链接）时，”-lc”会查找libc.a；</p>\n<p>ld -Bdynamic(动态链接)时，”-lc”会查找最新版本的libc.so.x.y.z(默认)。</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h1 id=\"第四章-静态链接\"><a href=\"#第四章-静态链接\" class=\"headerlink\" title=\"第四章 静态链接\"></a>第四章 静态链接</h1><h4 id=\"4-1-空间与地址分配\"><a href=\"#4-1-空间与地址分配\" class=\"headerlink\" title=\"4.1 空间与地址分配\"></a>4.1 空间与地址分配</h4><p>输出文件（可执行文件）的空间怎么分配给输入文件</p>\n<p><em>这里的空间分配可以指在可执行文件中空间的分配，也可指装载后的虚拟地址中的虚拟地址空间</em></p>\n<p><em>但是.data其实在可执行文件中是不存在的，它的分配空间的意义仅局限于虚拟地址空间</em></p>\n<p><em>事实上，我们谈空间分配只关注于虚拟地址空间的分配</em></p>","more":"<ol>\n<li><p>按序叠加</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/09/Screen-Shot-2020-02-09-at-11.20.35-PM.png\" alt=\"按序叠加\"></p>\n</li>\n</ol>\n<p>过于零散。浪费空间：x86硬件，段的装载地址和空间的对齐单位是页（4096字节），如果一个段长度只有1字节，也会占用4096字节</p>\n<ol start=\"2\">\n<li><p>相似段合并（常用）</p>\n<p>.text放在一起，.data放在一起，等。</p>\n<p>方法：两步链接 </p>\n<ul>\n<li><p>第一步 空间与地址分配 链接器获得所有输入文件的段长度，并且合并，建立映射关系。</p>\n</li>\n<li><p>第二步 符号解析与重定位 （核心）符号解析、<strong>重定位</strong>、调整代码地址</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ld a.o b.o -e main -o ab</span><br></pre></td></tr></table></figure>\n\n<p>-e main 表示将main作为程序入口，ld链接器默认入口为_start。</p>\n<p>-o ab 链接输出文件为ab 默认a.out </p>\n<p>*<em>VMA *</em>： Virtual Memory Layout 虚拟地址</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/10/Screen-Shot-2020-02-10-at-12.17.14-PM.png\" alt=\"目标文件、可执行文件、进程空间\"></p>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"4-2-符号解析与重定位\"><a href=\"#4-2-符号解析与重定位\" class=\"headerlink\" title=\"4.2 符号解析与重定位\"></a>4.2 符号解析与重定位</h4><ol>\n<li><p>重定位（链接关键）</p>\n<p>将目标文件反编译以后读文件会发现，一些符号（定义在其他文件中）的地址是00000或者其它</p>\n</li>\n</ol>\n<p>暂定的替代地址。链接后，重定位的入口都会被修正到正确的位置。</p>\n<ol start=\"2\">\n<li><p>重定位表</p>\n<p>ELF有一个段叫做重定位段（重定位表），用于描述如何修改相应段的内容。</p>\n<p>.text有.rel.text的重定位段。.data有.rel.data的重定位段。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ objdumo -r a.o</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/10/Screen-Shot-2020-02-10-at-2.58.53-PM.png\" alt=\"重定位表\"></p>\n</li>\n</ol>\n<p>   可以查看a.o需重定位的地方。每个要被重定位的地方叫<strong>relocation entry（重定位入口）</strong>。</p>\n<p>   <strong>偏移量（offset）</strong>表示该入口在要被重定位的段中的位置，0000001c和00000027是代码段中”mov“和”call“指令的地址</p>\n<p>   此表为代码段的重定位表。</p>\n<h4 id=\"4-3-C-相关问题\"><a href=\"#4-3-C-相关问题\" class=\"headerlink\" title=\"4.3 C++相关问题\"></a>4.3 C++相关问题</h4><ol>\n<li><p>重复代码消除</p>\n<ul>\n<li><p>代码级别链接</p>\n<p><strong>问题：</strong>C++编译器可产生很多重复代码，如模板（Templates）、外部关联函数（Extend Inline Function）、虚函数表（Virtual Function Table）。如模板，他在一个编译单元被实例化，再其他单元也被实例化，会产生重复代码。会造成空间浪费/地址出错/指令运行效率低。</p>\n<p><strong>解决方法：</strong>方法即将每个模板的实例化代码放在一个段。同一个模板的实例化代码会有相同的名字，因此在链接器连接时，相同的模板实例段会被合并入最后的代码段。这个机制被广泛运用。GCC编译器（Link Once）和VISUAL C++（COMDAT）</p>\n<p><strong>缺点：</strong>当相同名称的段拥有不同的内容，不同编译单元使用不同的编译器版本/优化选项，会使一个函数编译出来的代码有所不同，会随机选择其中一个副本作为连接输入并提供一个警告信息。</p>\n</li>\n</ul>\n<ul>\n<li><p>函数级别链接</p>\n<p><strong>问题：</strong>目前库/程序庞大，一个目标文件包含很多函数/变量。我们需要某目标文件的任意函数/变量，必须将它整个链接，将没用的函数同时链接，这样链接输出会很大。</p>\n<p><strong>解决方法：</strong>VISUAL C++提供函数界别链接。将每个函数保存到独立段，当链接器需要某函数，将其合并到输出文件，其他函数舍弃。可以减少输出文件长度。GCC提供相应机制：”-ffunction-sections“和”-fdata-sections”，将每个函数/变量分别保持在独立段中。</p>\n<p><strong>缺点：</strong>优化选项减慢编译/链接过程，链接器计算各个函数的依赖关系；目标函数的段数量增加，重定位过程因段的数目增加而复杂，目标文件因段增加而增大。</p>\n</li>\n</ul>\n</li>\n<li><p>全局构造与析构</p>\n<p>C/C++源代码层面上是从main开始，到main结束。实际上，main调用前，需初始化进程执行环境。如分配初始化、线程子程序。</p>\n<p>C++全局对象构造函数在这一时期执行、C++全局对象的析构函数在main之后执行。</p>\n<p>_start是可执行文件程序初始化部分的入口。</p>\n<p>因此ELF文件还定义可两种特殊段：</p>\n<ul>\n<li>.init 保存可执行指令。main调用之前，Glibc初始化部分安排执行此段代码。</li>\n<li>.fini 保存进程终止代码指令。main正常退出，Glibc安排执行此段代码。</li>\n</ul>\n</li>\n<li><p>C++与ABI</p>\n<p>ABI（Application Binary Interface）：二进制层面接口。符号修饰标准、变量的内存布局、函数调用方式等与可执行代码二进制兼容性相关的内容。</p>\n<p>API（Application Programming Interface）：源代码层的接口。如POSIX</p>\n<p>API相同不一定ABI相同。ABI不兼容会导致目标文件无法相互连接。硬件、编译语言、编译器、链接器、操作系统都会影响ABI，对于C的目标代码来说，下面几个方面会决定目标文件是否二级制兼容：</p>\n<ul>\n<li>内置类型（inr float char）的大小和存储器放置方式（大小端、对齐方式）</li>\n<li>组合类型 （struct、union、array）的存储方式和内存分布</li>\n<li>外部符号与用户定义符号之间的命名方式和解析方式。如函数名func在c语言的目标文件中是否被解析成_func.</li>\n<li>函数调用方式，如参数入栈顺序、返回值保存</li>\n<li>堆栈分布方式</li>\n<li>寄存器使用约定</li>\n</ul>\n<p>类似还有很多内容，C++在C的基础上增添了很多内容，使其兼容更为不易</p>\n<ul>\n<li><p>继承类体系的内存分布，如基类在继承类中的位置</p>\n</li>\n<li><p>指向成员函数的指针的内存分布，如何荣国成员函数的指针来调用成员函数。</p>\n<p>…</p>\n</li>\n</ul>\n<p>C++的二进制兼容性不好。不仅不同编译器不好，甚至一个编译器兼容性不好。C++ ABI标准一直没有统一，现在形成了微软VISUAL C++和GCC（Intel Itanium C++ ABI）为首的两大派系。</p>\n</li>\n</ol>\n<h4 id=\"4-4-静态库链接\"><a href=\"#4-4-静态库链接\" class=\"headerlink\" title=\"4.4 静态库链接\"></a>4.4 静态库链接</h4><p>程序会有输入输出，输入输出的可以是程序、人、另一台计算器。操作系统提供的<strong>应用程序编程接口（API）</strong>可进行输入。</p>\n<p>语言开发环境会附带语言库，库即是操作系统API的包装。如C的printf，此函数对字符串进行一些处理后，调用操作系统API。各个操作系统，调用API不同，在Linux，调用”write“，windows调用”WriteConsole“。同时，一些库函数也不需要调用API。</p>\n<p>一个静态库即一组目标文件的集合。如Linux中C的静态库libc；对于windows，常见的c库由IDE附带的运行库组成，一般由编异器厂提供，如Visual C++附带的C/C++运行库。</p>\n<p>对于一个helloworld!文件，本身编译为hello.o，然后还需要libc.a解压缩后得到的printf.o，以及printf.o所依赖的各种.o文件。collect2 是ld链接器的一个包装，调用链接器来完成链接，并对链接结果处理：收集与初始化相关的信息并且构造初始化结构。</p>\n<h4 id=\"4-5-连接过程控制\"><a href=\"#4-5-连接过程控制\" class=\"headerlink\" title=\"4.5 连接过程控制\"></a>4.5 连接过程控制</h4><p><em>操作系统内核：从本质来说 他就是一个程序。比如Windows内核 ntoskrnl.exe就是常见的PE文件。</em></p>\n<p>连接控制脚本</p>\n<p>控制链接器产生用户所需的文件的方法：</p>\n<ul>\n<li>命令行指定参数。比如ld的-o（指定名称），-e(指定入口函数)，-static（静态链接）-s（禁止链接器产生符号表）就属于这类</li>\n<li>链接指令放在目标文件里边。比如VISUAL C++会把参数放在PE目标文件.drectve段来传递参数。</li>\n<li>使用链接控制脚本。（*）</li>\n</ul>\n<p>ld在链接时会默认链接脚本。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ld -verbose</span><br><span class=\"line\">$ld -T link.script</span><br></pre></td></tr></table></figure>\n\n<p>我们也可以自己写一个脚本，使用-T参数：</p>\n<p><em>具体内容与语法可以查本书4.6.3 4.6.4</em></p>\n<p>ld链接脚本有专门的的语言</p>\n<h4 id=\"4-6-BFD库\"><a href=\"#4-6-BFD库\" class=\"headerlink\" title=\"4.6 BFD库\"></a>4.6 BFD库</h4><p>现代硬件软件平台繁多，包括cpu位数、字节序大小端、MMU有无、内存地址对齐与否… 种种差异导致编译器、链接器很难处理不同平台的目标文件。对于GCC、binutils等跨平台文件，统一接口很重要。</p>\n<p>BFD库（Binary File Descriptor library）就是一个GNU项目，目标在于通过统一接口处理不同目标文件格式。它将编译器、链接器本身同具体的目标文件格式隔离开来，一旦我们需要支持新的目标文件格式，只需要修改BFD。目前为止，BFD库支持大约25种处理器平台。</p>\n<h1 id=\"第六章-可执行文件的装载与进程\"><a href=\"#第六章-可执行文件的装载与进程\" class=\"headerlink\" title=\"第六章 可执行文件的装载与进程\"></a>第六章 可执行文件的装载与进程</h1><p>装载：可执行文件装载到内存。</p>\n<h4 id=\"6-1-进程虚拟地址空间\"><a href=\"#6-1-进程虚拟地址空间\" class=\"headerlink\" title=\"6.1 进程虚拟地址空间\"></a>6.1 进程虚拟地址空间</h4><ol>\n<li><p><em>程序进程区别</em>：</p>\n<ul>\n<li>程序（狭义为可执行文件）是一个静态概念，由预编译好的指令和数据集合的文件。</li>\n<li>进程：动态概念，程序运行的过程。Runtime</li>\n</ul>\n</li>\n<li><p>虚拟空间</p>\n<p>32位，一共4GB空间。64位，2^32*4GB。</p>\n<p>以32位为例，一般会分配1GB给操作系统，3GB给程序使用空间。但是这个比例是可以改的。</p>\n</li>\n<li><p>PAE</p>\n<p>PAE(Physical Address Extension)：一种地址扩展方式。可以将32位扩展至36位地址线，Intel修改了页映射的方式，使得新的映射方式可访问更多的物理内存。</p>\n<p>但是这是补救方式，真正解决办法还是使用64位处理器和操作系统。</p>\n</li>\n</ol>\n<h4 id=\"6-2-装载方式\"><a href=\"#6-2-装载方式\" class=\"headerlink\" title=\"6.2 装载方式\"></a>6.2 装载方式</h4><p><strong>动态载入</strong>：内存的大小是一定的，如果将指令、数据全部装入内存中，内存数量不够。经研究，程序运行是有局部性原理的，我们可将程序最常用的部分驻留在内存中，将不常用的数据的存放在磁盘，这是动态载入的原理。</p>\n<p><strong>覆盖装入（Overlay）</strong> <strong>页映射（Paging）</strong>是两种典型动态装载方式。</p>\n<ol>\n<li><p>覆盖装入</p>\n<p>由程序员手动分割程序，然后编写一个小辅助代码管理模块何时应驻留内存何时被替换。</p>\n</li>\n<li><p>页映射</p>\n<p>是虚拟存储机制的一部分。页一般是4096字节。</p>\n<p>装载管理器即是现代的操作系统的存储管理器。</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/11/Screen-Shot-2020-02-11-at-3.47.13-PM.png\" alt=\"页映射与页装载\"></p>\n<p>当物理内存满了之后，可通过FIFO（先入先出算法）也可通过LUR（最少使用算法）进行覆盖。</p>\n<p>windows对PE文件的装载、Linux对ELF文件的装载都是这样完成的。</p>\n</li>\n</ol>\n<h4 id=\"6-3-操作系统角度理解可执行文件装载\"><a href=\"#6-3-操作系统角度理解可执行文件装载\" class=\"headerlink\" title=\"6.3 操作系统角度理解可执行文件装载\"></a>6.3 操作系统角度理解可执行文件装载</h4><ol>\n<li><p>进程的建立</p>\n<p>进程最关键特征在于它拥有独立的虚拟地址空间，这使它有别其他进程。一个程序被执行同时伴随一个新的进程的创建。上述过程开始于三件事：</p>\n<ul>\n<li><p>创建独立的虚拟地址空间</p>\n<p>虚拟空间由一组页映射函数将虚拟空间的各个页映射至相应的屋里空间，这一步实际上是创建映射函数所需要的相应数据结构，即<strong>虚拟空间到物理内存的映射</strong></p>\n</li>\n<li><p>读取可执行文件头，建立虚拟空间和可执行文件的映射关系</p>\n<p>建立<strong>虚拟空间和可执行文件的映射关系</strong>。即操作系统知道程序当前所需要的页在可执行文件中的哪一个位置。这一步是装载中最重要的一步。可执行文件也可称为image（映像文件）</p>\n<p>VMA（Virtual Memory Area）虚拟内存区域</p>\n<p>如下图，操作系统建立进程后，会在进程相应数据结构中设置一个.text段的VMA。</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/11/Screen-Shot-2020-02-11-at-4.15.58-PM.png\" alt=\"可执行文件与进程虚拟空间\"></p>\n</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li><p>将CPU的指令寄存器设置成可执行文件的入口地址，启动运行</p>\n<p>CPU执行跳转指令，跳转至可执行文件的入口地址。</p>\n</li>\n</ul>\n<h1 id=\"第七章-动态链接\"><a href=\"#第七章-动态链接\" class=\"headerlink\" title=\"第七章 动态链接\"></a>第七章 动态链接</h1><ol>\n<li><p>动态链接（Dynamic Linking）：程序运行时链接。</p>\n<p>解决问题：共享的目标文件多个副本浪费磁盘、内存的问题；更新困难的问题</p>\n<p>缺点：新的模块与旧的模块不兼容，导致原有程序无法运行。称为”DLL Hell“；动态链接在每次装载时重新进行链接，会有相应的时间损失和性能损失。</p>\n</li>\n<li><p>程序可扩展性和兼容性</p>\n<p>因为动态链接有在程序运行时动态地选择加载各个程序模块的特点，<strong>插件（plug-in）</strong>应运而生。</p>\n<p>作用：（1）实现程序功能的扩展</p>\n<p>​            （2）加强程序兼容性。动态地链接到由操作系统提供的动态链接库，这些动态链接库相当于在程序和操作系统增加了一个中间层，消除了程序对不同平台之间依赖的差异性。</p>\n</li>\n<li><p>动态链接的基本实现</p>\n<p>主流操作系统支持动态链接：Linux的ELF动态链接文件称为动态共享对象（DSO，Dynamic Shared Objects），简称共享对象，以”.so”为扩展名。windows系统中，动态链接文件称为<strong>动态链接库（Dynamical Linking Library）</strong>，他们就是我们平时常见的”.dll”为扩展名的文件。</p>\n<p>比如C语言库的运行库glibc，它的动态链接形式的版本保存在”/lib“目录下，文件名叫做”libc.so“。</p>\n<p>程序被装载-&gt;系统的动态链接器将程序所需要的所有动态链接库（libc.so）装载到进程的地址空间，并且将程序中所有未决议的符号绑定到相应的动态链接库中，并进行重定位。</p>\n</li>\n<li><p>装载时重定位和地址无关代码是解决绝对地址引用问题的两个方法，装载时重定位的缺点是无法共享代码段，但运行速度快。地址无关代码缺点是运行速度慢，但可实现代码段在各个进程之间的共享。</p>\n</li>\n</ol>\n<h1 id=\"第八章-Linux共享库组织\"><a href=\"#第八章-Linux共享库组织\" class=\"headerlink\" title=\"第八章 Linux共享库组织\"></a>第八章 Linux共享库组织</h1><p>共享库和共享对象从文件结构看，没有区别，Linux下的共享库即是普通的ELF共享对象。</p>\n<ol>\n<li><p>共享库的兼容性</p>\n<p>基于动态链接的灵活性，开发者可以不断更新共享库版本。如libfoo.so的开发者更新新版的libfoo.so后，理论上我们只需要将新版替换旧版。</p>\n<p>但是实际上共享库版本的更新可能导致接口的更改/删除。</p>\n<p>因此，共享库更新分为：</p>\n<ul>\n<li>兼容更新</li>\n<li>不兼容更新 改变原有接口</li>\n</ul>\n<p>这里讨论的接口是ABI，这里主要包括一些堆栈结构、符号命名、参数规则、数据结构的内存分布风规则。</p>\n<p>ABI十分难以保持兼容，特别是C++，它支持诸如模板等一些高级特性，他们对于ABI的兼容影响很大。</p>\n<p>尽量遵循下列原则：</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/11/Screen-Shot-2020-02-11-at-6.29.10-PM.png\" alt=\"注意事项\"></p>\n</li>\n<li><p>共享版本库的命名 libname.so.x.y.z</p>\n<p>x是主版本号，不同的主版本号会不兼容</p>\n<p>y是次版本号，新版保存原有所有接口，同时增加一些新的接口符号。</p>\n<p>z是发布版本号，不添加接口，进行错误修正</p>\n<p>SO-NAME 机制，libfoo.so.x.y.z的SO-NAME是libfoo.so.x，即只保存主版本号，并且产生软连接，使每一次y.z进行改变时，始终保持x不变的最新版。同时，如果主版本号升级，系统会产生新的SO_NAME，SO-NAME不同不会对已有的程序影响。</p>\n<p>Linux提供了一个工具叫做”Idconfig“，当系统安装/更新一个共享库，他会遍历所有默认共享库目录(/usr/lib)，然后更新所有软；链接，指向最新的共享库。如果安装新的，则会为其创建相应的软连接</p>\n</li>\n<li><p>链接名</p>\n<p>libname.so.x.y.z 中，name即为<strong>链接名</strong>。使用共享库时：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-l name</span><br></pre></td></tr></table></figure>\n\n<p>查找最新版本的”name“库</p>\n<p>-lc 可以根据输出文件情况（静态/动态）选择适合版本的库</p>\n<p>ld -static（静态链接）时，”-lc”会查找libc.a；</p>\n<p>ld -Bdynamic(动态链接)时，”-lc”会查找最新版本的libc.so.x.y.z(默认)。</p>\n</li>\n</ol>"},{"date":"2020-02-11T16:00:00.000Z","_content":"# 第十章 内存\n\n#### 10.1 内存布局\n\n- 内核\n- 用户空间\n  - 栈（stack）：用于维护函数调用的上下文。位于最高地址处分配，MB大小。\n  - 堆（heap）：容纳应用程序动态分配的内存区域，malloc或new分配的内存来自堆。在栈下方，几十到百兆。\n  - 可执行文件映象：装载器装载可执行文件的内存读取/映射到这里\n  - 保留区：内存中受保护禁止访问的内存区域总称\n  - 动态链接库映射区：映射装载的动态链接库\n<!-- more -->\n\n![Linux进程地址空间布局](https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-11.15.32-AM.png)\n\n#### 10.2 栈与调用惯例\n\n1. **stack 栈**\n\n   先进后出。i386下，栈顶指针是esp。\n\n   ![栈](https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-11.23.43-AM.png)\n\n1. 栈保存了了一个函数调用所需要维护的信息，被称为stack frame或者activate record。\n\n   因为寄存器在函数执行前和执行后的内容应该是相同的，所以设置栈来保存他们的内容，在函数结束后再pop出去。\n\n   stack frame包括如下内容：\n\n   - 函数的返回地址和参数\n   - 临时变量：非静态局部变量、编译器自动生成的其他临时变量\n   - 保存的上下文：函数调用前后需要保持不变的寄存区。\n\n1. **ebp寄存器**\n\n   ebp寄存器又称为frame pointer（帧指针）\n\n![img](https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-12.02.45-PM.png)\n\n1. 函数调用过程\n\n   - 将参数压栈，如果有参数未入栈，则用某些寄存器传递\n   - 当前指令的下一条指令入栈（返回地址）\n   - 跳转函数体\n   - Push ebp ebo入栈（old ebp）\n   - mov ebp,esp: ebp=esp （ebp指向esp，即ebp指向栈顶）\n   - 【可选】sub esp,xxx：在栈上分配xxx字节的临时空间\n   - 【可选】push xxxx: 如有必要，保存名为xxx寄存器（可重复多个）\n\n   *将ebppush是为了函数返回时能回复从前的ebp。之所以保存寄存器在于编译器要求某些寄存器调用前后保持不变，函数就在调用开始将寄存器值压如栈，结束取出*\n\n   - 【可选】pop xxx: 如之前push，则恢复保存过的寄存器（可重复多个）\n   - mov esp,ebp: 恢复esp同时回收局部变量空间\n   - pop ebp：从栈中恢复保存的ebp值\n   - ret：从栈中取得返回地址（下一条指令地址），并跳转。\n\n2. 分析具体函数\n\n   foo函数\n\n   ```\n   int foo(){\n     return 123;\n   }\n   ```\n\n   \n\n![foo函数汇编代码分析](https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-12.12.26-PM.png)\n\n1. 总结基本格式\n\n   ![i386标准函数进入退出指令序列](https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-12.14.46-PM.png)\n\n*regn 指的是n个寄存器*\n\n1. 调用惯例\n\n   内容：\n\n   - 函数参数的传递顺序和方式\n\n   - 栈的维护方式\n\n   - 名字修饰策略\n\n     ![常见调用惯例](https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-2.39.21-PM.png)\n\n#### 10.3 堆内存的管理\n\n1. 什么是堆\n\n   栈上数据在函数返回的时候会被释放掉，无法将数据传递到函数外部，全局变量没办法动态地生成，只有在编译的时候定义，堆在此时是好的选择。\n\n   堆是一块内存空间，占据虚拟空间的绝大部分，程序可以请求一块连续的内存自由地使用，在程序主动放弃前均有效。\n\n   ```\n   int main(){\n     char *p = (char*)malloc(1000);\n     free(p);\n   }\n   ```\n\n   堆空间一般由运行库管理，运行库使用堆的分配算法，杜绝地址的冲突。\n\n2. Linux进程堆管理\n\n   地址空间中除可执行文件、共享库等之外，剩余未分配空间均可用作堆空间。Linux提供了两种系统调用：\n\n   brk() 和 mmap()\n\n   brk()设置数据段（数据段和bbs）的结束地址\n\n   mmap()向系统申请一段虚拟地址空间，可映射到某个文件，当不映射到文件时，称这块空间为匿名（Anonymous）空间。作为堆空间。\n\n   ![img](https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-3.08.09-PM.png)\n\nProt/flags 设置空间权限和映射类型、最后两个用于文件映射指定文件描述符和文件偏移。\n\n![malloc的定义](https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-3.10.15-PM.png)\n\n*mmap()申请大小/地址为系统页整数倍，字节小请求使用mmap浪费空间*\n\n1. 分配算法\n   - 空闲链表法\n   - 位图\n   - 对象池\n\n# 十一章 运行库\n\n1. 入口函数\n\n   显然，函数不是从main开始运行的，当进入main函数时，已经有某些代码准备好main函数执行所需要的环境。并负责调用main函数。在main返回后，它会记录main函数的返回值，调用atexit注册函数，结束进程。\n\n   **入口函数**即是运行这些代码的函数，程序入口是一个程序初始化和结束的部分，是运行库的一部分。\n\n   典型程序运行步骤：\n\n   - 操作系统创建进程，控制权交予程序入口，入口往往是运行库的某入口函数。\n   - 入口函数对运行库、程序运行环境初始化，包括堆、I/O、线程等\n   - 初始化完成后，调用main。\n   - main完毕后，返回入口函数，入口函数清理，包括全局变量析构、堆销毁、关闭I/O等，进行系统调用结束进程。\n\n   入口函数有两种：glibc和MSVC的入口函数实现\n\n1. glibc入口函数\n\n   选取glibc最简单的静态作用于可执行文件\n\n   （1）glibc入口为_start， _strat由汇编实现，与平台无关。\n\n   ![img](https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-4.06.56-PM.png)\n\n   \n\n   最终调用了名为_libc_start_main的函数。开头7个压栈指令用于给函数传递参数。\n\n   - xor %ebp, %ebp 是将ebp清零，xor是操作数异或的意思，结果存在第一个操作数里。ebp设为零的目的是表明当前是程序的最外层函数。\n\n   - pop %esi\n\n     mov %esp, %ecx \n\n     在调用_start前，装载器会把用户的参数和环境变量压入栈，实际上栈顶元素是argc，其下是argv和环境变量的数组。pop前是虚线栈顶，pop后是实线栈顶。pop %esi是将argc存入了esi，mov %esp, %ecx 将栈顶地址（argv起始地址）传递给ecx。\n\n     ![img](https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-4.14.35-PM.png)\n\n   **环境变量**：*存在于系统中的一些公用数据，程序均可访问，例如系统搜索路径，当前os版本等。环境变量格式key = value 的字符串。c可用getenv获取。*\n\n   （2）实际执行代码是_libc_start_main，以下是 _libc_start_main的函数头部\n\n   ![img](https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-4.32.07-PM.png)\n\n   一共声明了七个参数。\n\n   - main由第一个参数传入，接着是argc，argv（ubp_av，包含环境变量表）。\n\n   - 外部还要穿入三个函数指针 init：main调用前的初始化工作。fini：main结束后的收尾工作。rtld_fini：和动态加载有关的收尾工作，rtld是runtime loader的缩写。\n\n   - stack_end表明了栈底地址\n\n   （3）实际执行代码是_libc_start_main\n\n   ![img](https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-5.18.37-PM.png)\n\n   下图是我们从_start源代码分析得到的栈布局，让  _environ指向环境变量数组\n\n   ![img](https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-5.20.46-PM.png)\n\n   ![img](https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-5.24.50-PM.png)\n\n   过滤后得到接下来重要函数\n\n   ![img](https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-5.26.35-PM.png)\n\n   _cxa _atexit是glibc的内部函数，等同atexit，用于将参数指定函数在main之后调用。所以fini和\n\n   rtld _fin均是在main结束后调用\n\n   接下来为_libc_start_main的末尾\n\n   ![img](https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-5.28.25-PM.png)\n\n   最后，看看exit的实现\n\n   ![img](https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-5.30.23-PM.png)\n\n1. 运行库与I/O\n\n   （1）I/O全称 Input/Output，输入输出。\n   \n   对于计算机来说，I/O代表了计算机与外界的交互。\n   \n   对于程序来说，I/O指代了程序与外界的交互，包括文件、管道、网络、命令行、信号。\n   \n   Linux/windows将各种具体输入输出概念（设备、磁盘文件、命令行）称为文件，文件是一个广义的概念。\n   \n   （2）句柄（handle）\n   \n   定义：FILE结构的指针可用于文件的操作，使用fopen/fwrite来对这个指针操作，进而作用于文件。在操作系统层面，文件操作也有类似于FILE的概念，在linux里叫做**文件描述符（File Descriptor）**，在windows中，称为**句柄（handle）**\n   \n   ![FILE/fd和内核对象](https://img.cetacis.dev/uploads/2020/02/13/Screen-Shot-2020-02-13-at-2.54.12-PM.png) \n   \n   打开文件表是一个指针数组，每一个元素指向一个内核的**打开文件对象（内核对象）**。fd是这个表的下表， 内核指针p为这个表的初试地址。用户打开一个文件，内核会生成一个打开文件对象（并在打开文件表中生成指针，指向这个打开文件对象），并且返回这个指针的下表fd。这个表在内核，用户不能直接访问到（因为不知道p），因此只能通过系统提供的函数（fwrite/fopen）来操作，保证了安全性。\n   \n   C中的FILE其实是与fd有一对一的关系，可以借FILE访问文件。\n   \n   Windows中的句柄和fd大同小异。不过他不是打开文件表的下标，而是下标经过线性变化的结果。\n\n#### 11.2 C/C++运行库\n\n1. CRT（C Runtime Library）\n\n   功能：\n\n   * 启动退出：入口函数和入口函数依赖的其他函数\n   * 标准函数：C语言标准规定的C语言标准库所拥有的的函数 C89C99\n   * I/O：I/O功能的封装和实现\n   * 堆：堆的封装、实现、初始化\n   * 语言实现：语言的特殊功能实现\n   * 调试\n\n2. C的标准库\n\n   * C标准库很轻量。如：\n\n   ![标准库](https://img.cetacis.dev/uploads/2020/02/13/Screen-Shot-2020-02-13-at-9.34.45-PM.png)\n\n   * glibc和MSVC CRT\n\n     C语言运行库从某种程度讲是C语言程序和不同操作系统平台之间的抽象层，将不同操作系统API抽象成相同库函数。\n\n     但是有的操作系统功能没有对应的标准CRT，所以我们不得不让C语言运行库直接调用操作系统API和其他库。Linux和windows平台下的两个主要C分别为glibc（GNU C Library）和MSVCRT（Microsoft Visual C Run-time）\n\n     glibc和Linux的关系：glibc原为GNU旗下的C标准库，GNU原定内核是HUR（微内核构架系统），但是Hurd开发缓慢，Linux因实用性风靡，代替Hurd称为GNU操作系统内核，因此glibc变成了Linux平台的C标准库。\n\n     glibc由头文件（stdio.h, stdlib.h，位于/usr/include）和二进制文件部分（C语言标准库，静态动态两个版本，动态位于/lib/libc.so.6，静态位于/usr/lib/libc.a）。此外，还有一些辅助运行的库。比如/usr/lib/crt1.o，/usr/lib/crti.o，/usr/lib/crtn.o。\n\n# 第十二章 系统调用\n\nLinux内核版本2.6.19总共319个系统调用。可以使用read系统调用实现用户输入。不过绕过了glibc，则glibc的文件机制没有了。\n\n#### 12.1 系统调用的弊端\n\n* 调用接口过于原始，没有进行包装，使用不便。\n\n* 操作系统之间的调用不兼容。（通过添加系统调用和程序之间的运行库解决）\n\n比如 C中fread库函数，Windows调用ReadFile这个API，Linux调用read这个系统调用。所以，都可以用CRT的fread来读。\n\n","source":"_posts/程序员的自我修养（三）内存分布，运行库与系统调用.md","raw":"---\ndate: 2020/2/12\ntags:\n- 自学笔记\n- 内存\n- 堆\n- 栈\n- 运行库\n- 系统调用\ncategories:\n- 操作系统\n- 程序员的自我修养\n---\n# 第十章 内存\n\n#### 10.1 内存布局\n\n- 内核\n- 用户空间\n  - 栈（stack）：用于维护函数调用的上下文。位于最高地址处分配，MB大小。\n  - 堆（heap）：容纳应用程序动态分配的内存区域，malloc或new分配的内存来自堆。在栈下方，几十到百兆。\n  - 可执行文件映象：装载器装载可执行文件的内存读取/映射到这里\n  - 保留区：内存中受保护禁止访问的内存区域总称\n  - 动态链接库映射区：映射装载的动态链接库\n<!-- more -->\n\n![Linux进程地址空间布局](https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-11.15.32-AM.png)\n\n#### 10.2 栈与调用惯例\n\n1. **stack 栈**\n\n   先进后出。i386下，栈顶指针是esp。\n\n   ![栈](https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-11.23.43-AM.png)\n\n1. 栈保存了了一个函数调用所需要维护的信息，被称为stack frame或者activate record。\n\n   因为寄存器在函数执行前和执行后的内容应该是相同的，所以设置栈来保存他们的内容，在函数结束后再pop出去。\n\n   stack frame包括如下内容：\n\n   - 函数的返回地址和参数\n   - 临时变量：非静态局部变量、编译器自动生成的其他临时变量\n   - 保存的上下文：函数调用前后需要保持不变的寄存区。\n\n1. **ebp寄存器**\n\n   ebp寄存器又称为frame pointer（帧指针）\n\n![img](https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-12.02.45-PM.png)\n\n1. 函数调用过程\n\n   - 将参数压栈，如果有参数未入栈，则用某些寄存器传递\n   - 当前指令的下一条指令入栈（返回地址）\n   - 跳转函数体\n   - Push ebp ebo入栈（old ebp）\n   - mov ebp,esp: ebp=esp （ebp指向esp，即ebp指向栈顶）\n   - 【可选】sub esp,xxx：在栈上分配xxx字节的临时空间\n   - 【可选】push xxxx: 如有必要，保存名为xxx寄存器（可重复多个）\n\n   *将ebppush是为了函数返回时能回复从前的ebp。之所以保存寄存器在于编译器要求某些寄存器调用前后保持不变，函数就在调用开始将寄存器值压如栈，结束取出*\n\n   - 【可选】pop xxx: 如之前push，则恢复保存过的寄存器（可重复多个）\n   - mov esp,ebp: 恢复esp同时回收局部变量空间\n   - pop ebp：从栈中恢复保存的ebp值\n   - ret：从栈中取得返回地址（下一条指令地址），并跳转。\n\n2. 分析具体函数\n\n   foo函数\n\n   ```\n   int foo(){\n     return 123;\n   }\n   ```\n\n   \n\n![foo函数汇编代码分析](https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-12.12.26-PM.png)\n\n1. 总结基本格式\n\n   ![i386标准函数进入退出指令序列](https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-12.14.46-PM.png)\n\n*regn 指的是n个寄存器*\n\n1. 调用惯例\n\n   内容：\n\n   - 函数参数的传递顺序和方式\n\n   - 栈的维护方式\n\n   - 名字修饰策略\n\n     ![常见调用惯例](https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-2.39.21-PM.png)\n\n#### 10.3 堆内存的管理\n\n1. 什么是堆\n\n   栈上数据在函数返回的时候会被释放掉，无法将数据传递到函数外部，全局变量没办法动态地生成，只有在编译的时候定义，堆在此时是好的选择。\n\n   堆是一块内存空间，占据虚拟空间的绝大部分，程序可以请求一块连续的内存自由地使用，在程序主动放弃前均有效。\n\n   ```\n   int main(){\n     char *p = (char*)malloc(1000);\n     free(p);\n   }\n   ```\n\n   堆空间一般由运行库管理，运行库使用堆的分配算法，杜绝地址的冲突。\n\n2. Linux进程堆管理\n\n   地址空间中除可执行文件、共享库等之外，剩余未分配空间均可用作堆空间。Linux提供了两种系统调用：\n\n   brk() 和 mmap()\n\n   brk()设置数据段（数据段和bbs）的结束地址\n\n   mmap()向系统申请一段虚拟地址空间，可映射到某个文件，当不映射到文件时，称这块空间为匿名（Anonymous）空间。作为堆空间。\n\n   ![img](https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-3.08.09-PM.png)\n\nProt/flags 设置空间权限和映射类型、最后两个用于文件映射指定文件描述符和文件偏移。\n\n![malloc的定义](https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-3.10.15-PM.png)\n\n*mmap()申请大小/地址为系统页整数倍，字节小请求使用mmap浪费空间*\n\n1. 分配算法\n   - 空闲链表法\n   - 位图\n   - 对象池\n\n# 十一章 运行库\n\n1. 入口函数\n\n   显然，函数不是从main开始运行的，当进入main函数时，已经有某些代码准备好main函数执行所需要的环境。并负责调用main函数。在main返回后，它会记录main函数的返回值，调用atexit注册函数，结束进程。\n\n   **入口函数**即是运行这些代码的函数，程序入口是一个程序初始化和结束的部分，是运行库的一部分。\n\n   典型程序运行步骤：\n\n   - 操作系统创建进程，控制权交予程序入口，入口往往是运行库的某入口函数。\n   - 入口函数对运行库、程序运行环境初始化，包括堆、I/O、线程等\n   - 初始化完成后，调用main。\n   - main完毕后，返回入口函数，入口函数清理，包括全局变量析构、堆销毁、关闭I/O等，进行系统调用结束进程。\n\n   入口函数有两种：glibc和MSVC的入口函数实现\n\n1. glibc入口函数\n\n   选取glibc最简单的静态作用于可执行文件\n\n   （1）glibc入口为_start， _strat由汇编实现，与平台无关。\n\n   ![img](https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-4.06.56-PM.png)\n\n   \n\n   最终调用了名为_libc_start_main的函数。开头7个压栈指令用于给函数传递参数。\n\n   - xor %ebp, %ebp 是将ebp清零，xor是操作数异或的意思，结果存在第一个操作数里。ebp设为零的目的是表明当前是程序的最外层函数。\n\n   - pop %esi\n\n     mov %esp, %ecx \n\n     在调用_start前，装载器会把用户的参数和环境变量压入栈，实际上栈顶元素是argc，其下是argv和环境变量的数组。pop前是虚线栈顶，pop后是实线栈顶。pop %esi是将argc存入了esi，mov %esp, %ecx 将栈顶地址（argv起始地址）传递给ecx。\n\n     ![img](https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-4.14.35-PM.png)\n\n   **环境变量**：*存在于系统中的一些公用数据，程序均可访问，例如系统搜索路径，当前os版本等。环境变量格式key = value 的字符串。c可用getenv获取。*\n\n   （2）实际执行代码是_libc_start_main，以下是 _libc_start_main的函数头部\n\n   ![img](https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-4.32.07-PM.png)\n\n   一共声明了七个参数。\n\n   - main由第一个参数传入，接着是argc，argv（ubp_av，包含环境变量表）。\n\n   - 外部还要穿入三个函数指针 init：main调用前的初始化工作。fini：main结束后的收尾工作。rtld_fini：和动态加载有关的收尾工作，rtld是runtime loader的缩写。\n\n   - stack_end表明了栈底地址\n\n   （3）实际执行代码是_libc_start_main\n\n   ![img](https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-5.18.37-PM.png)\n\n   下图是我们从_start源代码分析得到的栈布局，让  _environ指向环境变量数组\n\n   ![img](https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-5.20.46-PM.png)\n\n   ![img](https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-5.24.50-PM.png)\n\n   过滤后得到接下来重要函数\n\n   ![img](https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-5.26.35-PM.png)\n\n   _cxa _atexit是glibc的内部函数，等同atexit，用于将参数指定函数在main之后调用。所以fini和\n\n   rtld _fin均是在main结束后调用\n\n   接下来为_libc_start_main的末尾\n\n   ![img](https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-5.28.25-PM.png)\n\n   最后，看看exit的实现\n\n   ![img](https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-5.30.23-PM.png)\n\n1. 运行库与I/O\n\n   （1）I/O全称 Input/Output，输入输出。\n   \n   对于计算机来说，I/O代表了计算机与外界的交互。\n   \n   对于程序来说，I/O指代了程序与外界的交互，包括文件、管道、网络、命令行、信号。\n   \n   Linux/windows将各种具体输入输出概念（设备、磁盘文件、命令行）称为文件，文件是一个广义的概念。\n   \n   （2）句柄（handle）\n   \n   定义：FILE结构的指针可用于文件的操作，使用fopen/fwrite来对这个指针操作，进而作用于文件。在操作系统层面，文件操作也有类似于FILE的概念，在linux里叫做**文件描述符（File Descriptor）**，在windows中，称为**句柄（handle）**\n   \n   ![FILE/fd和内核对象](https://img.cetacis.dev/uploads/2020/02/13/Screen-Shot-2020-02-13-at-2.54.12-PM.png) \n   \n   打开文件表是一个指针数组，每一个元素指向一个内核的**打开文件对象（内核对象）**。fd是这个表的下表， 内核指针p为这个表的初试地址。用户打开一个文件，内核会生成一个打开文件对象（并在打开文件表中生成指针，指向这个打开文件对象），并且返回这个指针的下表fd。这个表在内核，用户不能直接访问到（因为不知道p），因此只能通过系统提供的函数（fwrite/fopen）来操作，保证了安全性。\n   \n   C中的FILE其实是与fd有一对一的关系，可以借FILE访问文件。\n   \n   Windows中的句柄和fd大同小异。不过他不是打开文件表的下标，而是下标经过线性变化的结果。\n\n#### 11.2 C/C++运行库\n\n1. CRT（C Runtime Library）\n\n   功能：\n\n   * 启动退出：入口函数和入口函数依赖的其他函数\n   * 标准函数：C语言标准规定的C语言标准库所拥有的的函数 C89C99\n   * I/O：I/O功能的封装和实现\n   * 堆：堆的封装、实现、初始化\n   * 语言实现：语言的特殊功能实现\n   * 调试\n\n2. C的标准库\n\n   * C标准库很轻量。如：\n\n   ![标准库](https://img.cetacis.dev/uploads/2020/02/13/Screen-Shot-2020-02-13-at-9.34.45-PM.png)\n\n   * glibc和MSVC CRT\n\n     C语言运行库从某种程度讲是C语言程序和不同操作系统平台之间的抽象层，将不同操作系统API抽象成相同库函数。\n\n     但是有的操作系统功能没有对应的标准CRT，所以我们不得不让C语言运行库直接调用操作系统API和其他库。Linux和windows平台下的两个主要C分别为glibc（GNU C Library）和MSVCRT（Microsoft Visual C Run-time）\n\n     glibc和Linux的关系：glibc原为GNU旗下的C标准库，GNU原定内核是HUR（微内核构架系统），但是Hurd开发缓慢，Linux因实用性风靡，代替Hurd称为GNU操作系统内核，因此glibc变成了Linux平台的C标准库。\n\n     glibc由头文件（stdio.h, stdlib.h，位于/usr/include）和二进制文件部分（C语言标准库，静态动态两个版本，动态位于/lib/libc.so.6，静态位于/usr/lib/libc.a）。此外，还有一些辅助运行的库。比如/usr/lib/crt1.o，/usr/lib/crti.o，/usr/lib/crtn.o。\n\n# 第十二章 系统调用\n\nLinux内核版本2.6.19总共319个系统调用。可以使用read系统调用实现用户输入。不过绕过了glibc，则glibc的文件机制没有了。\n\n#### 12.1 系统调用的弊端\n\n* 调用接口过于原始，没有进行包装，使用不便。\n\n* 操作系统之间的调用不兼容。（通过添加系统调用和程序之间的运行库解决）\n\n比如 C中fread库函数，Windows调用ReadFile这个API，Linux调用read这个系统调用。所以，都可以用CRT的fread来读。\n\n","slug":"程序员的自我修养（三）内存分布，运行库与系统调用","published":1,"updated":"2020-03-25T01:19:24.000Z","title":"程序员的自我修养（三）内存分布，运行库与系统调用","_id":"ck849avap0009thes23137m0x","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"第十章-内存\"><a href=\"#第十章-内存\" class=\"headerlink\" title=\"第十章 内存\"></a>第十章 内存</h1><h4 id=\"10-1-内存布局\"><a href=\"#10-1-内存布局\" class=\"headerlink\" title=\"10.1 内存布局\"></a>10.1 内存布局</h4><ul>\n<li>内核</li>\n<li>用户空间<ul>\n<li>栈（stack）：用于维护函数调用的上下文。位于最高地址处分配，MB大小。</li>\n<li>堆（heap）：容纳应用程序动态分配的内存区域，malloc或new分配的内存来自堆。在栈下方，几十到百兆。</li>\n<li>可执行文件映象：装载器装载可执行文件的内存读取/映射到这里</li>\n<li>保留区：内存中受保护禁止访问的内存区域总称</li>\n<li>动态链接库映射区：映射装载的动态链接库<a id=\"more\"></a>\n\n</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-11.15.32-AM.png\" alt=\"Linux进程地址空间布局\"></p>\n<h4 id=\"10-2-栈与调用惯例\"><a href=\"#10-2-栈与调用惯例\" class=\"headerlink\" title=\"10.2 栈与调用惯例\"></a>10.2 栈与调用惯例</h4><ol>\n<li><p><strong>stack 栈</strong></p>\n<p>先进后出。i386下，栈顶指针是esp。</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-11.23.43-AM.png\" alt=\"栈\"></p>\n</li>\n<li><p>栈保存了了一个函数调用所需要维护的信息，被称为stack frame或者activate record。</p>\n<p>因为寄存器在函数执行前和执行后的内容应该是相同的，所以设置栈来保存他们的内容，在函数结束后再pop出去。</p>\n<p>stack frame包括如下内容：</p>\n<ul>\n<li>函数的返回地址和参数</li>\n<li>临时变量：非静态局部变量、编译器自动生成的其他临时变量</li>\n<li>保存的上下文：函数调用前后需要保持不变的寄存区。</li>\n</ul>\n</li>\n<li><p><strong>ebp寄存器</strong></p>\n<p>ebp寄存器又称为frame pointer（帧指针）</p>\n</li>\n</ol>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-12.02.45-PM.png\" alt=\"img\"></p>\n<ol>\n<li><p>函数调用过程</p>\n<ul>\n<li>将参数压栈，如果有参数未入栈，则用某些寄存器传递</li>\n<li>当前指令的下一条指令入栈（返回地址）</li>\n<li>跳转函数体</li>\n<li>Push ebp ebo入栈（old ebp）</li>\n<li>mov ebp,esp: ebp=esp （ebp指向esp，即ebp指向栈顶）</li>\n<li>【可选】sub esp,xxx：在栈上分配xxx字节的临时空间</li>\n<li>【可选】push xxxx: 如有必要，保存名为xxx寄存器（可重复多个）</li>\n</ul>\n<p><em>将ebppush是为了函数返回时能回复从前的ebp。之所以保存寄存器在于编译器要求某些寄存器调用前后保持不变，函数就在调用开始将寄存器值压如栈，结束取出</em></p>\n<ul>\n<li>【可选】pop xxx: 如之前push，则恢复保存过的寄存器（可重复多个）</li>\n<li>mov esp,ebp: 恢复esp同时回收局部变量空间</li>\n<li>pop ebp：从栈中恢复保存的ebp值</li>\n<li>ret：从栈中取得返回地址（下一条指令地址），并跳转。</li>\n</ul>\n</li>\n<li><p>分析具体函数</p>\n<p>foo函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int foo()&#123;</span><br><span class=\"line\">  return 123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-12.12.26-PM.png\" alt=\"foo函数汇编代码分析\"></p>\n<ol>\n<li><p>总结基本格式</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-12.14.46-PM.png\" alt=\"i386标准函数进入退出指令序列\"></p>\n</li>\n</ol>\n<p><em>regn 指的是n个寄存器</em></p>\n<ol>\n<li><p>调用惯例</p>\n<p>内容：</p>\n<ul>\n<li><p>函数参数的传递顺序和方式</p>\n</li>\n<li><p>栈的维护方式</p>\n</li>\n<li><p>名字修饰策略</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-2.39.21-PM.png\" alt=\"常见调用惯例\"></p>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"10-3-堆内存的管理\"><a href=\"#10-3-堆内存的管理\" class=\"headerlink\" title=\"10.3 堆内存的管理\"></a>10.3 堆内存的管理</h4><ol>\n<li><p>什么是堆</p>\n<p>栈上数据在函数返回的时候会被释放掉，无法将数据传递到函数外部，全局变量没办法动态地生成，只有在编译的时候定义，堆在此时是好的选择。</p>\n<p>堆是一块内存空间，占据虚拟空间的绝大部分，程序可以请求一块连续的内存自由地使用，在程序主动放弃前均有效。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int main()&#123;</span><br><span class=\"line\">  char *p &#x3D; (char*)malloc(1000);</span><br><span class=\"line\">  free(p);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>堆空间一般由运行库管理，运行库使用堆的分配算法，杜绝地址的冲突。</p>\n</li>\n<li><p>Linux进程堆管理</p>\n<p>地址空间中除可执行文件、共享库等之外，剩余未分配空间均可用作堆空间。Linux提供了两种系统调用：</p>\n<p>brk() 和 mmap()</p>\n<p>brk()设置数据段（数据段和bbs）的结束地址</p>\n<p>mmap()向系统申请一段虚拟地址空间，可映射到某个文件，当不映射到文件时，称这块空间为匿名（Anonymous）空间。作为堆空间。</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-3.08.09-PM.png\" alt=\"img\"></p>\n</li>\n</ol>\n<p>Prot/flags 设置空间权限和映射类型、最后两个用于文件映射指定文件描述符和文件偏移。</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-3.10.15-PM.png\" alt=\"malloc的定义\"></p>\n<p><em>mmap()申请大小/地址为系统页整数倍，字节小请求使用mmap浪费空间</em></p>\n<ol>\n<li>分配算法<ul>\n<li>空闲链表法</li>\n<li>位图</li>\n<li>对象池</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"十一章-运行库\"><a href=\"#十一章-运行库\" class=\"headerlink\" title=\"十一章 运行库\"></a>十一章 运行库</h1><ol>\n<li><p>入口函数</p>\n<p>显然，函数不是从main开始运行的，当进入main函数时，已经有某些代码准备好main函数执行所需要的环境。并负责调用main函数。在main返回后，它会记录main函数的返回值，调用atexit注册函数，结束进程。</p>\n<p><strong>入口函数</strong>即是运行这些代码的函数，程序入口是一个程序初始化和结束的部分，是运行库的一部分。</p>\n<p>典型程序运行步骤：</p>\n<ul>\n<li>操作系统创建进程，控制权交予程序入口，入口往往是运行库的某入口函数。</li>\n<li>入口函数对运行库、程序运行环境初始化，包括堆、I/O、线程等</li>\n<li>初始化完成后，调用main。</li>\n<li>main完毕后，返回入口函数，入口函数清理，包括全局变量析构、堆销毁、关闭I/O等，进行系统调用结束进程。</li>\n</ul>\n<p>入口函数有两种：glibc和MSVC的入口函数实现</p>\n</li>\n<li><p>glibc入口函数</p>\n<p>选取glibc最简单的静态作用于可执行文件</p>\n<p>（1）glibc入口为_start， _strat由汇编实现，与平台无关。</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-4.06.56-PM.png\" alt=\"img\"></p>\n</li>\n</ol>\n<p>   最终调用了名为_libc_start_main的函数。开头7个压栈指令用于给函数传递参数。</p>\n<ul>\n<li><p>xor %ebp, %ebp 是将ebp清零，xor是操作数异或的意思，结果存在第一个操作数里。ebp设为零的目的是表明当前是程序的最外层函数。</p>\n</li>\n<li><p>pop %esi</p>\n<p>mov %esp, %ecx </p>\n<p>在调用_start前，装载器会把用户的参数和环境变量压入栈，实际上栈顶元素是argc，其下是argv和环境变量的数组。pop前是虚线栈顶，pop后是实线栈顶。pop %esi是将argc存入了esi，mov %esp, %ecx 将栈顶地址（argv起始地址）传递给ecx。</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-4.14.35-PM.png\" alt=\"img\"></p>\n</li>\n</ul>\n<p>   <strong>环境变量</strong>：<em>存在于系统中的一些公用数据，程序均可访问，例如系统搜索路径，当前os版本等。环境变量格式key = value 的字符串。c可用getenv获取。</em></p>\n<p>   （2）实际执行代码是_libc_start_main，以下是 _libc_start_main的函数头部</p>\n<p>   <img src=\"https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-4.32.07-PM.png\" alt=\"img\"></p>\n<p>   一共声明了七个参数。</p>\n<ul>\n<li><p>main由第一个参数传入，接着是argc，argv（ubp_av，包含环境变量表）。</p>\n</li>\n<li><p>外部还要穿入三个函数指针 init：main调用前的初始化工作。fini：main结束后的收尾工作。rtld_fini：和动态加载有关的收尾工作，rtld是runtime loader的缩写。</p>\n</li>\n<li><p>stack_end表明了栈底地址</p>\n<p>（3）实际执行代码是_libc_start_main</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-5.18.37-PM.png\" alt=\"img\"></p>\n<p>下图是我们从_start源代码分析得到的栈布局，让  _environ指向环境变量数组</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-5.20.46-PM.png\" alt=\"img\"></p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-5.24.50-PM.png\" alt=\"img\"></p>\n<p>过滤后得到接下来重要函数</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-5.26.35-PM.png\" alt=\"img\"></p>\n<p>_cxa _atexit是glibc的内部函数，等同atexit，用于将参数指定函数在main之后调用。所以fini和</p>\n<p>rtld _fin均是在main结束后调用</p>\n<p>接下来为_libc_start_main的末尾</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-5.28.25-PM.png\" alt=\"img\"></p>\n<p>最后，看看exit的实现</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-5.30.23-PM.png\" alt=\"img\"></p>\n</li>\n</ul>\n<ol>\n<li><p>运行库与I/O</p>\n<p>（1）I/O全称 Input/Output，输入输出。</p>\n<p>对于计算机来说，I/O代表了计算机与外界的交互。</p>\n<p>对于程序来说，I/O指代了程序与外界的交互，包括文件、管道、网络、命令行、信号。</p>\n<p>Linux/windows将各种具体输入输出概念（设备、磁盘文件、命令行）称为文件，文件是一个广义的概念。</p>\n<p>（2）句柄（handle）</p>\n<p>定义：FILE结构的指针可用于文件的操作，使用fopen/fwrite来对这个指针操作，进而作用于文件。在操作系统层面，文件操作也有类似于FILE的概念，在linux里叫做<strong>文件描述符（File Descriptor）</strong>，在windows中，称为<strong>句柄（handle）</strong></p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/13/Screen-Shot-2020-02-13-at-2.54.12-PM.png\" alt=\"FILE/fd和内核对象\"> </p>\n<p>打开文件表是一个指针数组，每一个元素指向一个内核的<strong>打开文件对象（内核对象）</strong>。fd是这个表的下表， 内核指针p为这个表的初试地址。用户打开一个文件，内核会生成一个打开文件对象（并在打开文件表中生成指针，指向这个打开文件对象），并且返回这个指针的下表fd。这个表在内核，用户不能直接访问到（因为不知道p），因此只能通过系统提供的函数（fwrite/fopen）来操作，保证了安全性。</p>\n<p>C中的FILE其实是与fd有一对一的关系，可以借FILE访问文件。</p>\n<p>Windows中的句柄和fd大同小异。不过他不是打开文件表的下标，而是下标经过线性变化的结果。</p>\n</li>\n</ol>\n<h4 id=\"11-2-C-C-运行库\"><a href=\"#11-2-C-C-运行库\" class=\"headerlink\" title=\"11.2 C/C++运行库\"></a>11.2 C/C++运行库</h4><ol>\n<li><p>CRT（C Runtime Library）</p>\n<p>功能：</p>\n<ul>\n<li>启动退出：入口函数和入口函数依赖的其他函数</li>\n<li>标准函数：C语言标准规定的C语言标准库所拥有的的函数 C89C99</li>\n<li>I/O：I/O功能的封装和实现</li>\n<li>堆：堆的封装、实现、初始化</li>\n<li>语言实现：语言的特殊功能实现</li>\n<li>调试</li>\n</ul>\n</li>\n<li><p>C的标准库</p>\n<ul>\n<li>C标准库很轻量。如：</li>\n</ul>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/13/Screen-Shot-2020-02-13-at-9.34.45-PM.png\" alt=\"标准库\"></p>\n<ul>\n<li><p>glibc和MSVC CRT</p>\n<p>C语言运行库从某种程度讲是C语言程序和不同操作系统平台之间的抽象层，将不同操作系统API抽象成相同库函数。</p>\n<p>但是有的操作系统功能没有对应的标准CRT，所以我们不得不让C语言运行库直接调用操作系统API和其他库。Linux和windows平台下的两个主要C分别为glibc（GNU C Library）和MSVCRT（Microsoft Visual C Run-time）</p>\n<p>glibc和Linux的关系：glibc原为GNU旗下的C标准库，GNU原定内核是HUR（微内核构架系统），但是Hurd开发缓慢，Linux因实用性风靡，代替Hurd称为GNU操作系统内核，因此glibc变成了Linux平台的C标准库。</p>\n<p>glibc由头文件（stdio.h, stdlib.h，位于/usr/include）和二进制文件部分（C语言标准库，静态动态两个版本，动态位于/lib/libc.so.6，静态位于/usr/lib/libc.a）。此外，还有一些辅助运行的库。比如/usr/lib/crt1.o，/usr/lib/crti.o，/usr/lib/crtn.o。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"第十二章-系统调用\"><a href=\"#第十二章-系统调用\" class=\"headerlink\" title=\"第十二章 系统调用\"></a>第十二章 系统调用</h1><p>Linux内核版本2.6.19总共319个系统调用。可以使用read系统调用实现用户输入。不过绕过了glibc，则glibc的文件机制没有了。</p>\n<h4 id=\"12-1-系统调用的弊端\"><a href=\"#12-1-系统调用的弊端\" class=\"headerlink\" title=\"12.1 系统调用的弊端\"></a>12.1 系统调用的弊端</h4><ul>\n<li><p>调用接口过于原始，没有进行包装，使用不便。</p>\n</li>\n<li><p>操作系统之间的调用不兼容。（通过添加系统调用和程序之间的运行库解决）</p>\n</li>\n</ul>\n<p>比如 C中fread库函数，Windows调用ReadFile这个API，Linux调用read这个系统调用。所以，都可以用CRT的fread来读。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"第十章-内存\"><a href=\"#第十章-内存\" class=\"headerlink\" title=\"第十章 内存\"></a>第十章 内存</h1><h4 id=\"10-1-内存布局\"><a href=\"#10-1-内存布局\" class=\"headerlink\" title=\"10.1 内存布局\"></a>10.1 内存布局</h4><ul>\n<li>内核</li>\n<li>用户空间<ul>\n<li>栈（stack）：用于维护函数调用的上下文。位于最高地址处分配，MB大小。</li>\n<li>堆（heap）：容纳应用程序动态分配的内存区域，malloc或new分配的内存来自堆。在栈下方，几十到百兆。</li>\n<li>可执行文件映象：装载器装载可执行文件的内存读取/映射到这里</li>\n<li>保留区：内存中受保护禁止访问的内存区域总称</li>\n<li>动态链接库映射区：映射装载的动态链接库","more":"</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-11.15.32-AM.png\" alt=\"Linux进程地址空间布局\"></p>\n<h4 id=\"10-2-栈与调用惯例\"><a href=\"#10-2-栈与调用惯例\" class=\"headerlink\" title=\"10.2 栈与调用惯例\"></a>10.2 栈与调用惯例</h4><ol>\n<li><p><strong>stack 栈</strong></p>\n<p>先进后出。i386下，栈顶指针是esp。</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-11.23.43-AM.png\" alt=\"栈\"></p>\n</li>\n<li><p>栈保存了了一个函数调用所需要维护的信息，被称为stack frame或者activate record。</p>\n<p>因为寄存器在函数执行前和执行后的内容应该是相同的，所以设置栈来保存他们的内容，在函数结束后再pop出去。</p>\n<p>stack frame包括如下内容：</p>\n<ul>\n<li>函数的返回地址和参数</li>\n<li>临时变量：非静态局部变量、编译器自动生成的其他临时变量</li>\n<li>保存的上下文：函数调用前后需要保持不变的寄存区。</li>\n</ul>\n</li>\n<li><p><strong>ebp寄存器</strong></p>\n<p>ebp寄存器又称为frame pointer（帧指针）</p>\n</li>\n</ol>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-12.02.45-PM.png\" alt=\"img\"></p>\n<ol>\n<li><p>函数调用过程</p>\n<ul>\n<li>将参数压栈，如果有参数未入栈，则用某些寄存器传递</li>\n<li>当前指令的下一条指令入栈（返回地址）</li>\n<li>跳转函数体</li>\n<li>Push ebp ebo入栈（old ebp）</li>\n<li>mov ebp,esp: ebp=esp （ebp指向esp，即ebp指向栈顶）</li>\n<li>【可选】sub esp,xxx：在栈上分配xxx字节的临时空间</li>\n<li>【可选】push xxxx: 如有必要，保存名为xxx寄存器（可重复多个）</li>\n</ul>\n<p><em>将ebppush是为了函数返回时能回复从前的ebp。之所以保存寄存器在于编译器要求某些寄存器调用前后保持不变，函数就在调用开始将寄存器值压如栈，结束取出</em></p>\n<ul>\n<li>【可选】pop xxx: 如之前push，则恢复保存过的寄存器（可重复多个）</li>\n<li>mov esp,ebp: 恢复esp同时回收局部变量空间</li>\n<li>pop ebp：从栈中恢复保存的ebp值</li>\n<li>ret：从栈中取得返回地址（下一条指令地址），并跳转。</li>\n</ul>\n</li>\n<li><p>分析具体函数</p>\n<p>foo函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int foo()&#123;</span><br><span class=\"line\">  return 123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-12.12.26-PM.png\" alt=\"foo函数汇编代码分析\"></p>\n<ol>\n<li><p>总结基本格式</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-12.14.46-PM.png\" alt=\"i386标准函数进入退出指令序列\"></p>\n</li>\n</ol>\n<p><em>regn 指的是n个寄存器</em></p>\n<ol>\n<li><p>调用惯例</p>\n<p>内容：</p>\n<ul>\n<li><p>函数参数的传递顺序和方式</p>\n</li>\n<li><p>栈的维护方式</p>\n</li>\n<li><p>名字修饰策略</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-2.39.21-PM.png\" alt=\"常见调用惯例\"></p>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"10-3-堆内存的管理\"><a href=\"#10-3-堆内存的管理\" class=\"headerlink\" title=\"10.3 堆内存的管理\"></a>10.3 堆内存的管理</h4><ol>\n<li><p>什么是堆</p>\n<p>栈上数据在函数返回的时候会被释放掉，无法将数据传递到函数外部，全局变量没办法动态地生成，只有在编译的时候定义，堆在此时是好的选择。</p>\n<p>堆是一块内存空间，占据虚拟空间的绝大部分，程序可以请求一块连续的内存自由地使用，在程序主动放弃前均有效。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int main()&#123;</span><br><span class=\"line\">  char *p &#x3D; (char*)malloc(1000);</span><br><span class=\"line\">  free(p);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>堆空间一般由运行库管理，运行库使用堆的分配算法，杜绝地址的冲突。</p>\n</li>\n<li><p>Linux进程堆管理</p>\n<p>地址空间中除可执行文件、共享库等之外，剩余未分配空间均可用作堆空间。Linux提供了两种系统调用：</p>\n<p>brk() 和 mmap()</p>\n<p>brk()设置数据段（数据段和bbs）的结束地址</p>\n<p>mmap()向系统申请一段虚拟地址空间，可映射到某个文件，当不映射到文件时，称这块空间为匿名（Anonymous）空间。作为堆空间。</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-3.08.09-PM.png\" alt=\"img\"></p>\n</li>\n</ol>\n<p>Prot/flags 设置空间权限和映射类型、最后两个用于文件映射指定文件描述符和文件偏移。</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-3.10.15-PM.png\" alt=\"malloc的定义\"></p>\n<p><em>mmap()申请大小/地址为系统页整数倍，字节小请求使用mmap浪费空间</em></p>\n<ol>\n<li>分配算法<ul>\n<li>空闲链表法</li>\n<li>位图</li>\n<li>对象池</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"十一章-运行库\"><a href=\"#十一章-运行库\" class=\"headerlink\" title=\"十一章 运行库\"></a>十一章 运行库</h1><ol>\n<li><p>入口函数</p>\n<p>显然，函数不是从main开始运行的，当进入main函数时，已经有某些代码准备好main函数执行所需要的环境。并负责调用main函数。在main返回后，它会记录main函数的返回值，调用atexit注册函数，结束进程。</p>\n<p><strong>入口函数</strong>即是运行这些代码的函数，程序入口是一个程序初始化和结束的部分，是运行库的一部分。</p>\n<p>典型程序运行步骤：</p>\n<ul>\n<li>操作系统创建进程，控制权交予程序入口，入口往往是运行库的某入口函数。</li>\n<li>入口函数对运行库、程序运行环境初始化，包括堆、I/O、线程等</li>\n<li>初始化完成后，调用main。</li>\n<li>main完毕后，返回入口函数，入口函数清理，包括全局变量析构、堆销毁、关闭I/O等，进行系统调用结束进程。</li>\n</ul>\n<p>入口函数有两种：glibc和MSVC的入口函数实现</p>\n</li>\n<li><p>glibc入口函数</p>\n<p>选取glibc最简单的静态作用于可执行文件</p>\n<p>（1）glibc入口为_start， _strat由汇编实现，与平台无关。</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-4.06.56-PM.png\" alt=\"img\"></p>\n</li>\n</ol>\n<p>   最终调用了名为_libc_start_main的函数。开头7个压栈指令用于给函数传递参数。</p>\n<ul>\n<li><p>xor %ebp, %ebp 是将ebp清零，xor是操作数异或的意思，结果存在第一个操作数里。ebp设为零的目的是表明当前是程序的最外层函数。</p>\n</li>\n<li><p>pop %esi</p>\n<p>mov %esp, %ecx </p>\n<p>在调用_start前，装载器会把用户的参数和环境变量压入栈，实际上栈顶元素是argc，其下是argv和环境变量的数组。pop前是虚线栈顶，pop后是实线栈顶。pop %esi是将argc存入了esi，mov %esp, %ecx 将栈顶地址（argv起始地址）传递给ecx。</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-4.14.35-PM.png\" alt=\"img\"></p>\n</li>\n</ul>\n<p>   <strong>环境变量</strong>：<em>存在于系统中的一些公用数据，程序均可访问，例如系统搜索路径，当前os版本等。环境变量格式key = value 的字符串。c可用getenv获取。</em></p>\n<p>   （2）实际执行代码是_libc_start_main，以下是 _libc_start_main的函数头部</p>\n<p>   <img src=\"https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-4.32.07-PM.png\" alt=\"img\"></p>\n<p>   一共声明了七个参数。</p>\n<ul>\n<li><p>main由第一个参数传入，接着是argc，argv（ubp_av，包含环境变量表）。</p>\n</li>\n<li><p>外部还要穿入三个函数指针 init：main调用前的初始化工作。fini：main结束后的收尾工作。rtld_fini：和动态加载有关的收尾工作，rtld是runtime loader的缩写。</p>\n</li>\n<li><p>stack_end表明了栈底地址</p>\n<p>（3）实际执行代码是_libc_start_main</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-5.18.37-PM.png\" alt=\"img\"></p>\n<p>下图是我们从_start源代码分析得到的栈布局，让  _environ指向环境变量数组</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-5.20.46-PM.png\" alt=\"img\"></p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-5.24.50-PM.png\" alt=\"img\"></p>\n<p>过滤后得到接下来重要函数</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-5.26.35-PM.png\" alt=\"img\"></p>\n<p>_cxa _atexit是glibc的内部函数，等同atexit，用于将参数指定函数在main之后调用。所以fini和</p>\n<p>rtld _fin均是在main结束后调用</p>\n<p>接下来为_libc_start_main的末尾</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-5.28.25-PM.png\" alt=\"img\"></p>\n<p>最后，看看exit的实现</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/12/Screen-Shot-2020-02-12-at-5.30.23-PM.png\" alt=\"img\"></p>\n</li>\n</ul>\n<ol>\n<li><p>运行库与I/O</p>\n<p>（1）I/O全称 Input/Output，输入输出。</p>\n<p>对于计算机来说，I/O代表了计算机与外界的交互。</p>\n<p>对于程序来说，I/O指代了程序与外界的交互，包括文件、管道、网络、命令行、信号。</p>\n<p>Linux/windows将各种具体输入输出概念（设备、磁盘文件、命令行）称为文件，文件是一个广义的概念。</p>\n<p>（2）句柄（handle）</p>\n<p>定义：FILE结构的指针可用于文件的操作，使用fopen/fwrite来对这个指针操作，进而作用于文件。在操作系统层面，文件操作也有类似于FILE的概念，在linux里叫做<strong>文件描述符（File Descriptor）</strong>，在windows中，称为<strong>句柄（handle）</strong></p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/13/Screen-Shot-2020-02-13-at-2.54.12-PM.png\" alt=\"FILE/fd和内核对象\"> </p>\n<p>打开文件表是一个指针数组，每一个元素指向一个内核的<strong>打开文件对象（内核对象）</strong>。fd是这个表的下表， 内核指针p为这个表的初试地址。用户打开一个文件，内核会生成一个打开文件对象（并在打开文件表中生成指针，指向这个打开文件对象），并且返回这个指针的下表fd。这个表在内核，用户不能直接访问到（因为不知道p），因此只能通过系统提供的函数（fwrite/fopen）来操作，保证了安全性。</p>\n<p>C中的FILE其实是与fd有一对一的关系，可以借FILE访问文件。</p>\n<p>Windows中的句柄和fd大同小异。不过他不是打开文件表的下标，而是下标经过线性变化的结果。</p>\n</li>\n</ol>\n<h4 id=\"11-2-C-C-运行库\"><a href=\"#11-2-C-C-运行库\" class=\"headerlink\" title=\"11.2 C/C++运行库\"></a>11.2 C/C++运行库</h4><ol>\n<li><p>CRT（C Runtime Library）</p>\n<p>功能：</p>\n<ul>\n<li>启动退出：入口函数和入口函数依赖的其他函数</li>\n<li>标准函数：C语言标准规定的C语言标准库所拥有的的函数 C89C99</li>\n<li>I/O：I/O功能的封装和实现</li>\n<li>堆：堆的封装、实现、初始化</li>\n<li>语言实现：语言的特殊功能实现</li>\n<li>调试</li>\n</ul>\n</li>\n<li><p>C的标准库</p>\n<ul>\n<li>C标准库很轻量。如：</li>\n</ul>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/13/Screen-Shot-2020-02-13-at-9.34.45-PM.png\" alt=\"标准库\"></p>\n<ul>\n<li><p>glibc和MSVC CRT</p>\n<p>C语言运行库从某种程度讲是C语言程序和不同操作系统平台之间的抽象层，将不同操作系统API抽象成相同库函数。</p>\n<p>但是有的操作系统功能没有对应的标准CRT，所以我们不得不让C语言运行库直接调用操作系统API和其他库。Linux和windows平台下的两个主要C分别为glibc（GNU C Library）和MSVCRT（Microsoft Visual C Run-time）</p>\n<p>glibc和Linux的关系：glibc原为GNU旗下的C标准库，GNU原定内核是HUR（微内核构架系统），但是Hurd开发缓慢，Linux因实用性风靡，代替Hurd称为GNU操作系统内核，因此glibc变成了Linux平台的C标准库。</p>\n<p>glibc由头文件（stdio.h, stdlib.h，位于/usr/include）和二进制文件部分（C语言标准库，静态动态两个版本，动态位于/lib/libc.so.6，静态位于/usr/lib/libc.a）。此外，还有一些辅助运行的库。比如/usr/lib/crt1.o，/usr/lib/crti.o，/usr/lib/crtn.o。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"第十二章-系统调用\"><a href=\"#第十二章-系统调用\" class=\"headerlink\" title=\"第十二章 系统调用\"></a>第十二章 系统调用</h1><p>Linux内核版本2.6.19总共319个系统调用。可以使用read系统调用实现用户输入。不过绕过了glibc，则glibc的文件机制没有了。</p>\n<h4 id=\"12-1-系统调用的弊端\"><a href=\"#12-1-系统调用的弊端\" class=\"headerlink\" title=\"12.1 系统调用的弊端\"></a>12.1 系统调用的弊端</h4><ul>\n<li><p>调用接口过于原始，没有进行包装，使用不便。</p>\n</li>\n<li><p>操作系统之间的调用不兼容。（通过添加系统调用和程序之间的运行库解决）</p>\n</li>\n</ul>\n<p>比如 C中fread库函数，Windows调用ReadFile这个API，Linux调用read这个系统调用。所以，都可以用CRT的fread来读。</p>"},{"date":"2020-02-03T16:00:00.000Z","_content":"### 第一章 计算机概念基础\n\n1.1 硬件基础\n\n1.2 软件基础\n<!-- more -->\n### 第二章 静态链接 ——编译和链接\n\n2.1 编译过程\n\n2.2  编译器\n\n2.3 链接器\n\n### 第三章  目标文件\n\n3.1 EFL文件格式\n\n3.2 EFL文件实例\n\n3.3 EFL 文件详细内容\n\n3.4 链接的接口——符号\n\n3.5 调试信息\n\n3.6 小结\n\n\n# 第一章 计算机概念基础\n\n## 1.1 硬件基础\n\n1. PC机： 兼容x86指令集的32位cpu的个人计算机\n\n2. 关键部件： 中央处理器CPU 内存 I/O控制芯片\n\n3. 芯片 \n\n   北桥芯片 设备高速交换数据：协调CPU、内存、高速图形设备\n\n   南桥芯片 处理低速设备：磁盘、USB、键盘、鼠标\n\n   南桥汇总后链接到北桥\n\n   20世纪90年代PC机采用PCI/ISA及南北桥设计的硬件构架。之后有发明了AGP, PCI Express等总线结构和相应控制芯片。\n4. SMP与多核\n\n   CPU的频率经历过一段时间的增加后到达了4GHz的天花板（工艺限制）。因此出现了多CPU计算器，常见的形势如 **对称多处理器** （SMP）。即多CPU在系统中所处地位和发挥功能相同且对称。\n\n   多CPU对运算速度的提升不是线性的，因为一个问题无法分解为若干不相干的子问题。常用情况：数据库，网络服务器，所以多处理器的成本很高。\n\n   **多核处理器**（Multi-core Processor）是对于SMP的简化。不同的处理器之间共享昂贵的缓存，成本较多处理器降低很多。\n\n## 1.2 软件基础\n\n1. 系统软件 \n\n   * 定义：管理计算机本身的软件\n\n   * 分类：平台性（操作系统内核、驱动程序、运行库）\n\n     ​\t\t\t程序开发（编译器、汇编器、连接器）\n\n   * 开发程序  应用程序  \n\n     ↓使用者\n\n     <应用程序编程接口（API）>\n\n     ↑提供者\n\n      运行库（Runtime Library）。比如Windows运行库提供windousAPI，Linux Glibc库提供POSIXAPI\n\n     ↓使用者\n\n     <系统调用接口(System call interface)>\n\n     ↑提供者\n\n     操作系统（Operating System Kernel） 提供软件中断。如Linux使用0x80号中断作为SCI\n\n     ↓使用者\n\n     <硬件规格(Hardware Specification)>\n\n2. 操作系统 Operating System\n\n   * 功能：1） 提供抽象接口\n\n     ​\t\t\t2） 管理硬件资源\n\n   * 操作系统会CPU分配方式：\n\n     CPU分配一直在发展，现在多为多任务（Multi-tasking）系统。所有的应用程序都以进程(Process)的方式运行（进程的总体目标是每个进程从逻辑上来看都可独占计算机资源）。CPU分配方式是抢占式（Preemptive），即在多个进程间快速切换。操作系统会将CPU资源分配给它所认为必要的进程。\n\n   * 设备驱动\n\n     操作系统直接控制硬件，比如向I/O端口0X1001写一个命令0X1111…… 这些表现在开发程序层面往往就是一个LineTo()函数，开发者不再需要直接写硬件的命令，而是通过层层接口将函数转化为机械指令。\n\n     操作系统将硬件抽象化成了概念。具体硬件细节是操作系统中的**硬件驱动（Device Driver）程序**来完成\n\n3. 程序在内存上的运行\n\n   * 存在问题：1）地址空间不隔离，可能会造成恶意溢出，改写其他程序。\n\n     ​\t\t\t\t\t2）内存使用效率低，当内存不够时，会有大量的数据换入换出，导致效率低下。\n\n     ​\t\t\t\t\t3）程序运行地址不正确，重定位出错。\n\n   * 解决方法：虚拟地址： 分段：通过映射（映射由操作系统完成），令超出部分非法，解决1，3。\n\n     ​\t\t\t\t\t\t\t\t\t\t分页：Intel系列处理器支持4KB/4MB的页大小，一般使用4KB，由操作系统决定。虚拟空间页为虚拟页，物理内存页为物理页，磁盘中页叫磁盘页。以页为单位存取交换数据方便，并且操作系统可以为页设置权限，保证安全。\n\n   * 虚拟地址的硬件实现  MMU（Memory Management Unit）\n\n     CPU --Virthal Address(虚拟地址)-->MMU--Physical address-->Physical Memory\n\n4. 线程\n\n   * 定义： 轻量级进程，程序执行流的最小单元。一个标准线程由线程ID、当前指针PC、寄存器集合和堆栈组成。一个进程由一到多个线程组成，各个线程共享程序内存空间。\n\n   * 多线程优点：多个操作并行，发挥计算机的计算能力，在数据共享方面的效率高很多。\n\n   * 线程调度：当线程数多于处理器数时，一个处理器会处理多于一个的线程，在处理器上切换不同的线程的行为称之为**线程调度（Thread Schedule）**。线程通常拥有三种状态：\n\n     * 运行 （可运行的时间叫做时间片）\n     * 就绪 线程可执行但cpu被占用\n     * 等待 线程等待某时间发生，无法执行\n\n   * 主流调度方法：\n\n     * 优先级调度：调整优先级以提高效率并且防止Starvation，一般给予等待时间长的进程更高的优先级，防止其被饿死。并且根据进入等待状态的频繁程度调整优先级，比如IO密集型线程会得到更高的优先级防止其他的进程被饿死。用户也可以调整优先级。\n     * 轮转法\n\n   * 可抢占线程：时间片用尽后进行线程调度，为当前主流。但是可能造成调度世纪不确定造成的问题。\n\n     不可抢占线程：只有线程主动放弃时间片或者试图等待时才会发成线程调度。\n\n   * 线程的安全性：因为数据在有时是共享的，可能造成数据在切换两个线程时产生错误。有一些API提供了原子化数据访问，但是有一些复杂的操作没有这样可直接调用的API。\n\n     * 解决方式：同步与锁；设置二元信号量；互斥量；临界区；条件变量\n\n# 第二章 静态链接——编译和链接\n\n## 2.1 编译过程\n\n1. 编译\n\n   ```\n   gcc hello.c  \n   ./a.out\n   ```\n\n   预处理(prepressing)， 编译(compilation)，汇编(assembly)，链接(linking)\n\n   ![编译过程](https://img.cetacis.dev/uploads/2020/02/06/Screen-Shot-2020-02-06-at-7.19.23-PM.png)\n\n2. 预编译\n\n   将hello.c 和 stdio.h 通过cpp预编译成.i\n\n   ```\n   $gcc -E hello.c -o hello.i\n   /\n   $cpp hello.c > hello.i\n   ```\n\n   \n\n   * 展开#define，处理#if #ifdef..，#include\n\n   * 删除注释\n\n   * 添加行号文件标识，便于编译器使用\n\n   * 保留#pragma，编译器使用\n\n     *我们可以通过查看预编译后文件来判断宏定义是否正确或头文件是否正确*\n\n1. \n\n3. 编译\n\n   词法分析、语法分析、语义分析、优化后生产相应的汇编代码文件\n\n   ```\n   $gcc -S hello.i -o hello.s\n   $ /usr/lin/gcc/i486-linux-gnu/4.1/cc1 hello.c\n   ```\n\n   得到汇编输出文件hello.s。cc1是对于c来说的，对于C++为cc1plus，Java是jc1\n\n   可将预编译和编译合并为一个步骤，使用cc1来完成这两个步骤\n\n4. 汇编\n\n   汇编器(as)：将汇编代码转变成机器指令。每一条汇编几乎对应一条机器指令。\n\n   ```\n   $as hello.s -o hello.o\n   /\n   $gcc -c hello.s -o hello.o\n   /\n   $gcc -c hello.c -o hello.o\n   ```\n\n5. 链接\n\n   将一大堆文件链接后才能得到可执行文件\"a.out\"\n\n## 2.2 编译器\n\n编译器：将高级语言翻译成机器语言。\n\n过程：扫描、语法分析、语义分析、源代码优化、代码生成、目标代码优化\n\n![编译过程](https://img.cetacis.dev/uploads/2020/02/06/Screen-Shot-2020-02-06-at-9.16.15-PM.png)\n\n1. 词法分析\n\n   scan时Finit State Machine(有限状态机)将源代码字符切割成Token(记号)并且分类（标识符放入符号表，数字字符串存放在文字表）。\n\n   **Token**：关键字，标识符，字面量（数字、字符串）和特殊符号（加、等）\n\n   lex程序：按照用户描述好的词法规则分割字符串。\n\n2. 语法分析\n\n   **Grammar Parser（语法分析器）**对Token分析，产生Syntax Tree（语法树），采用Context-free Grammar。\n\n   **Syntax Tree**是以expression为节点的树。\n\n   yacc（Yet Another Compiler Compiler）可根据用户给定的语法规则对输入记号序列进行解析，从而构建语法树。对于不同语言，编译器开发者只需改变语法规则。\n\n   *语法分析只完成了对表达式的语言层面的分析，但是无法判断语句的真正意义*\n\n3. 语义分析\n\n   **Semantic Analyzer（语义分析器）**：可以分析静态语义（Static Semantic），包括声明、类型的匹配，类型的转换。同时，动态语义（Dynamic Semantiv）只有在运行期才能确定。\n\n4. 中间语言生成\n\n   **Source Code Optimizer（源码级优化器）**：源码级别的一个优化过程。生成Intermediate Code（中间代码）。中间代码有很多类型，比较常见的是Three-address Code（三地址码）。\n\n   Intermediate code 将编译器分为前端和后端，之前所描述的部分为前端，之后则为后端。\n\n5. 编译器后端\n\n   后端包括：Code generator（代码生成器）和Target Code Optimizer（目标代码优化器）\n\n   Code generator转化成目标机器代码\n\n   Target Code Optimizer优化目标机器代码，选择合适的寻址方式、使用位移来代替乘法运算。\n\n6. conclusion\n\n   现在的编译器随着CPU的进化而变得复杂，比如GCC编译器几乎支持所有CPU平台。\n\n   生成了目标代码后，有一个问题：index和array的地址还没有确定。如果代码中有变量定义在其他模块，在最终运行时，他们都要在最终连接时才能确定。现在的编译器可将一个源代码文件编译成一个未连接的目标文件，然后由编译器最终将目标文件连接成可执行文件。\n\n## 2.3 链接器\n\n静态链接\n\n链接：将一些指令对其他符号地址的引用进行修正，包括地址空间分配、符号决议、重定位(Relocation)。\n\n![链接过程](https://img.cetacis.dev/uploads/2020/02/06/Screen-Shot-2020-02-06-at-10.54.56-PM.png)\n\n\n\n# 第三章 Object File（目标文件）\n\n \n\n![文件格式](https://img.cetacis.dev/uploads/2020/02/07/Screen-Shot-2020-02-07-at-7.23.06-PM.png)\n\n\n\n```\n$file foobar.o  //查看类型\n```\n\nEFL(Executable Linkable Format)： 可执行（目标）文件格式（Linex系统，windows是PE）\n\n目标文件：源代码编译后但是没有进行链接的中间文件，和可执行文件的内容结构相似，采用一种格式储存。\n\n## 3.1 EFL文件格式\n\n![可执行文件组成](https://img.cetacis.dev/uploads/2020/02/07/Screen-Shot-2020-02-07-at-7.43.09-PM.png)\n\n* 目标文件包含：编译后的机器指令代码、数据、连接时所需信息（符号表、调试信息、字符串）\n\n  存储形式：节（Section）/段（Segment）注：*余文皆为段*\n\n  * 文件头：文件属性、文件是否可执行、静态链接/动态链接及入口地址、目标硬件/操作系统。包含一个**段表**，描述文件中各个段的数组。\n\n    文件头后就是各个段的内容。\n\n  * 编译后的执行语句编译成机械代码：.text段\n\n  * 已初始化的全局变量局部变量静态变量：.data段\n\n  * 未初始化的全局变量/局部静态变量：.bss（默认为0，没必要在.data分配空间）（为未初始化的全局变量和局部静态变量的大小总和，无内容不占空间）\n\n* 程序源代码编译后被分为两种段：程序指令、程序数据。\n\n  代码段：程序指令。数据段，.bss：程序数据\n\n* 指令数据分离存储的意义：\n\n  * 数据rw- 指令r--\n  * cashe数据指令分离\n  * **指令共享**——节约空间\n\n## 3.2 EFL文件实例\n\n* **-c 代表只编译不链接**\n\n  ```\n  $gcc -c SimpleSection.c \n  ```\n\n  我们会得到一个SimpleSection.o的目标文件\n\n* 我们可以通过**objdump**查看object内部结构\n\n  ```\n  $objdump -h SimpleSection.o\n  ```\n\n  **-h** 代表将EFL文件各个段的信息打印，**-x**则会打印更多信息。\n\n  **readelf**是Linux的工具\n\n  ![目标文件EFL](https://img.cetacis.dev/uploads/2020/02/07/Screen-Shot-2020-02-07-at-8.20.24-PM.png)\n\n如图，除了基础的.text/.data/.bss，还有.rodata(只读数据段)，.comment(注释信息段)和.note.GNU-stack（堆栈提示段）。\n\n* 读这段object信息：\n\n  * size是段长度，File off是段的位置（偏移量）\n  * CONTENTS代表此段在文件中存在\n\n  他们在ELF中的结构如图：\n\n  ![SimpleSection.o](https://img.cetacis.dev/uploads/2020/02/07/Screen-Shot-2020-02-07-at-8.30.12-PM.png)\n\n* **size**指令：用来查看ELF文件各段长度\n\n  ![size](https://img.cetacis.dev/uploads/2020/02/07/Screen-Shot-2020-02-07-at-8.44.53-PM.png)\n\n## 3.3 ELF文件详细内容\n\n### 代码段\n\n**objdump**的**-s**参数可以将所有段的内容以16进制打印，**-d**可将所有包含指令的段反汇编\n\n我们可将objdump输出中关于代码段的内容提取，分析内容。\n\n![.text](https://img.cetacis.dev/uploads/2020/02/07/Screen-Shot-2020-02-07-at-8.49.58-PM.png)\n\nContents of section 是.text以16进制打印。最左为偏移量，中间四列是十六进制内容，最右一列是.text段的ASCII码。\n\n下面反汇编的结果，.text包含SimpleSection.c的func1()和main()指令。\n\n0x55对应push %ebp 0xc3对应ret\n\n### .data .rodata\n\n### .bss \n\n### others\n\n![ELF常见段](https://img.cetacis.dev/uploads/2020/02/07/Screen-Shot-2020-02-07-at-8.56.46-PM.png)\n\n### 文件头\n\n**readelf**可用于详细查看ELF文件\n\n**-h**查看文件头\n\n![文件头](https://img.cetacis.dev/uploads/2020/02/07/Screen-Shot-2020-02-07-at-9.02.15-PM.png)\n\nELF相关常数定义在“/usr/include/elf.h”\n\n如图所示：\n\n![elf.h](https://img.cetacis.dev/uploads/2020/02/07/Screen-Shot-2020-02-07-at-9.12.45-PM.png)\n\n![.elf文件意义](https://img.cetacis.dev/uploads/2020/02/07/Screen-Shot-2020-02-07-at-9.12.52-PM.png)\n\n![readelf输出结果与意义](https://img.cetacis.dev/uploads/2020/02/07/Screen-Shot-2020-02-07-at-9.12.56-PM.png)\n\n### e_ident \n\n* 魔数(magic)\n\n几乎所有可执行文件格式的最开始几个字节都是魔数。比如a.out开始是ox01 ox07等。\n\n作用：确定文件类型。操作系统在加载可执行文件时会确定魔数是否正确，否则拒绝加载。\n\n* 版本(Version) 最新1.2\n\n* 文件类型 e_type\n\n  ![e_type](https://img.cetacis.dev/uploads/2020/02/07/Screen-Shot-2020-02-07-at-9.17.54-PM.png)\n\n* 机械类型 e_machine\n\n  ![e_machine](https://img.cetacis.dev/uploads/2020/02/07/Screen-Shot-2020-02-07-at-9.20.48-PM.png)\n\n* 段表\n\n  保存段的基本属性（段名、段长度、文件偏移、读写权限、其他属性）\n\n  编译器、链接器、装载器依靠段表定位访问各段属性\n\n  查看方式：\n\n  * **objump -h**      #简要信息\n  * **readelf -S **       #详细信息\n\n  \n\n* 重定位表\n\n  .rel.text （相对位置定位表）\n\n* 字符串表\n\n  ![字符串表](https://img.cetacis.dev/uploads/2020/02/07/Screen-Shot-2020-02-07-at-9.30.54-PM.png)\n\n## 3.4 链接的接口——符号\n\n在连接中，函数和变量统称为**符号（Symbol）**，函数名和变量名就是**符号名（Symbol Name)**。\n\n每一个目标文件有一个对应的**符号表（Symbol Table）**。每一个符号都有一个相应的值，叫做**符号值（Symbol Value）**。对于变量、函数，符号值就是他们的地址。\n\n### 符号分类\n\n* 定义在本目标文件的全局符号，可被其他目标文件引用：main, func1, global_init_var\n* *定义在其他文件中的全局符号：printf\n* 段名 该段的起始地址：.text,.data\n* 局部符号，只在本编译单元可见：static_var, statoc_var2。这些局部符号对于链接没有作用。\n* 行号信息 目标文件指令与源代码代码行的对应关系。（可选）、\n\n1.2 重要，345对于其它目标文件不可见，在链接过程中无关紧要。\n\n**nm**可用来查看符号\n\n![查看符号](https://img.cetacis.dev/uploads/2020/02/07/Screen-Shot-2020-02-07-at-9.53.31-PM.png)\n\n### 符号表结构\n\n符号表是.**symtab**段\n\n![查看符号表](https://img.cetacis.dev/uploads/2020/02/07/Screen-Shot-2020-02-07-at-10.04.27-PM.png)\n\n### 特殊符号\n\n在使用ld链接器时，有一些可以直接声明引用的特殊符号，这些符号被定义在ld链接器的链接脚本中。\n\n![代表性特殊符号](https://img.cetacis.dev/uploads/2020/02/08/Screen-Shot-2020-02-08-at-10.10.34-PM.png)\n\n我们可以在程序中直接使用这些符号\n\n![在程序中直接使用符号](https://img.cetacis.dev/uploads/2020/02/08/Screen-Shot-2020-02-08-at-10.17.31-PM.png)\n\n\n\n### 符号修饰机制与函数签名\n\n不同的函数可能拥有相同姓名，但是他的其他信息，比如参数类型、所在类、函数名等不同，因此他们拥有不同的**函数签名（Function Signature）**。函数签名用于识别不同的函数。\n\n编译器、链接器处理符号时，使用某种**名称修改**的方法，每个还是签名对应一个**修改后名称**。即在C++源代码编译成目标文件时，会将函数和变量名称进行修饰，形成符号名。\n\n名称修改机制也用来防止静态变量名称冲突。比如main()和func()中都含有静态变量foo，区分这两个变量，就会分别修饰名称，产生不同的符号名。\n\n不同编译器的名称修改机制不同。\n\n### extern \"C\"\n\n```C++\nextern \"C\"{\n\tint func(int);\n\tint var;\n}\n```\n\nC++将花括号内部代码当做C。因此如图的静态变量会对符号进行C语言的变量修饰。一般VS平台下会在名称前加_，但是linux的gcc不会如此修饰。\n\n当我们声明一些C语言的函数和全局变量时，在C++的编译单元中，这些函数和全局变量的符号会不能被链接，extern \"C\"在C中不被支持，所以我们需要先判断本编译单元是那种语言。\n\n![extern ”C“的应用](https://img.cetacis.dev/uploads/2020/02/08/Screen-Shot-2020-02-08-at-10.42.04-PM.png)\n\n_cplusplus是一种C++中定义的宏，判断此宏是否被定义可用以判断此编译单元的类型是C++与否。\n\n### 强符号/弱符号\n\n1. 编译器默认函数/初始化后的全局变量为强符号，未初始化的全局变量为若符号。但是我们可以通过\n\n```\n__attribute__((weak)) weak2 = 2;\n__attribute__((weakref)) void foo();\n```\n\n![强符号/弱符号](https://img.cetacis.dev/uploads/2020/02/08/Screen-Shot-2020-02-08-at-11.11.54-PM.png)\n\n\n\n如图：weak,weak2 为弱符号、strong,main()为强符号。ext是外部变量的引用，非强非弱。\n\n2. **链接器选择多次定义符号的原则：**\n\n   (1)强不允许多次，否则报符号重复定义错误\n\n   (2)选强\n\n   (3)若都为弱，则选择占用最大的一个\n\n3. 弱符号和弱引用的应用\n\n   库中定义的弱符号可被用户定义的强符号覆盖，从而使程序使用自定义版本的库函数\n\n   程序可对某扩展功能模块的引用定义为弱引用，将扩展模块和程序链接在一起时，功能模块可正常使用。去掉这些模块也可正常连接，更利于程序功能的组合。\n\n   *还可以判断链接到多线程库或者单线程库*\n\n   gcc -lpthread可连接到多线程库\n\n## 3.5 调试信息\n\n现代编译器都支持源代码级别的调试。在gcc时加上-g参数，readelf发现object file里有很多\"debug\"段。\n\nELF采用DWARF的标准调试信息格式，microsoft也有对应的格式叫codeview。debug段在目标文件和可执行文件中占有很大空间，甚至大过代码和数据本身。当开发完程序并发布时，我们可以去掉无用的调试信息。\n\n```\n$strip foo\n```\n\n## 3.6 小结\n\n（1）深入了解object file的文件格式——ELF\n\n（文件头 段表 重定位表 字符串表 符号表 调试表 代码段 数据段等段）\n\n（2）可执行文件、目标文件、库。实际上都是一样基于段的文件或者文件的集合。源代码经编译，代码数据分类后存放在相应的段中，编译器（汇编器）将辅助性信息（符号、重定位信息）按照表的形式存放在目标文件里。表在一般情况下就是段。（调试表 === debug段）\n\n（3）目标文件需要进一步通过符号/重定位信息链接，形成可使用程序。 \n\n\n\n","source":"_posts/程序员的自我修养（一）操作系统、编译器、目标文件、链接器.md","raw":"---\ndate: 2020/2/4\ntags:\n- 自学笔记\n- 硬件基础\n- 操作系统\n- 编译器\n- 编译过程\n- 目标文件\n- 链接器\ncategories:\n- 操作系统\n- 程序员的自我修养\n---\n### 第一章 计算机概念基础\n\n1.1 硬件基础\n\n1.2 软件基础\n<!-- more -->\n### 第二章 静态链接 ——编译和链接\n\n2.1 编译过程\n\n2.2  编译器\n\n2.3 链接器\n\n### 第三章  目标文件\n\n3.1 EFL文件格式\n\n3.2 EFL文件实例\n\n3.3 EFL 文件详细内容\n\n3.4 链接的接口——符号\n\n3.5 调试信息\n\n3.6 小结\n\n\n# 第一章 计算机概念基础\n\n## 1.1 硬件基础\n\n1. PC机： 兼容x86指令集的32位cpu的个人计算机\n\n2. 关键部件： 中央处理器CPU 内存 I/O控制芯片\n\n3. 芯片 \n\n   北桥芯片 设备高速交换数据：协调CPU、内存、高速图形设备\n\n   南桥芯片 处理低速设备：磁盘、USB、键盘、鼠标\n\n   南桥汇总后链接到北桥\n\n   20世纪90年代PC机采用PCI/ISA及南北桥设计的硬件构架。之后有发明了AGP, PCI Express等总线结构和相应控制芯片。\n4. SMP与多核\n\n   CPU的频率经历过一段时间的增加后到达了4GHz的天花板（工艺限制）。因此出现了多CPU计算器，常见的形势如 **对称多处理器** （SMP）。即多CPU在系统中所处地位和发挥功能相同且对称。\n\n   多CPU对运算速度的提升不是线性的，因为一个问题无法分解为若干不相干的子问题。常用情况：数据库，网络服务器，所以多处理器的成本很高。\n\n   **多核处理器**（Multi-core Processor）是对于SMP的简化。不同的处理器之间共享昂贵的缓存，成本较多处理器降低很多。\n\n## 1.2 软件基础\n\n1. 系统软件 \n\n   * 定义：管理计算机本身的软件\n\n   * 分类：平台性（操作系统内核、驱动程序、运行库）\n\n     ​\t\t\t程序开发（编译器、汇编器、连接器）\n\n   * 开发程序  应用程序  \n\n     ↓使用者\n\n     <应用程序编程接口（API）>\n\n     ↑提供者\n\n      运行库（Runtime Library）。比如Windows运行库提供windousAPI，Linux Glibc库提供POSIXAPI\n\n     ↓使用者\n\n     <系统调用接口(System call interface)>\n\n     ↑提供者\n\n     操作系统（Operating System Kernel） 提供软件中断。如Linux使用0x80号中断作为SCI\n\n     ↓使用者\n\n     <硬件规格(Hardware Specification)>\n\n2. 操作系统 Operating System\n\n   * 功能：1） 提供抽象接口\n\n     ​\t\t\t2） 管理硬件资源\n\n   * 操作系统会CPU分配方式：\n\n     CPU分配一直在发展，现在多为多任务（Multi-tasking）系统。所有的应用程序都以进程(Process)的方式运行（进程的总体目标是每个进程从逻辑上来看都可独占计算机资源）。CPU分配方式是抢占式（Preemptive），即在多个进程间快速切换。操作系统会将CPU资源分配给它所认为必要的进程。\n\n   * 设备驱动\n\n     操作系统直接控制硬件，比如向I/O端口0X1001写一个命令0X1111…… 这些表现在开发程序层面往往就是一个LineTo()函数，开发者不再需要直接写硬件的命令，而是通过层层接口将函数转化为机械指令。\n\n     操作系统将硬件抽象化成了概念。具体硬件细节是操作系统中的**硬件驱动（Device Driver）程序**来完成\n\n3. 程序在内存上的运行\n\n   * 存在问题：1）地址空间不隔离，可能会造成恶意溢出，改写其他程序。\n\n     ​\t\t\t\t\t2）内存使用效率低，当内存不够时，会有大量的数据换入换出，导致效率低下。\n\n     ​\t\t\t\t\t3）程序运行地址不正确，重定位出错。\n\n   * 解决方法：虚拟地址： 分段：通过映射（映射由操作系统完成），令超出部分非法，解决1，3。\n\n     ​\t\t\t\t\t\t\t\t\t\t分页：Intel系列处理器支持4KB/4MB的页大小，一般使用4KB，由操作系统决定。虚拟空间页为虚拟页，物理内存页为物理页，磁盘中页叫磁盘页。以页为单位存取交换数据方便，并且操作系统可以为页设置权限，保证安全。\n\n   * 虚拟地址的硬件实现  MMU（Memory Management Unit）\n\n     CPU --Virthal Address(虚拟地址)-->MMU--Physical address-->Physical Memory\n\n4. 线程\n\n   * 定义： 轻量级进程，程序执行流的最小单元。一个标准线程由线程ID、当前指针PC、寄存器集合和堆栈组成。一个进程由一到多个线程组成，各个线程共享程序内存空间。\n\n   * 多线程优点：多个操作并行，发挥计算机的计算能力，在数据共享方面的效率高很多。\n\n   * 线程调度：当线程数多于处理器数时，一个处理器会处理多于一个的线程，在处理器上切换不同的线程的行为称之为**线程调度（Thread Schedule）**。线程通常拥有三种状态：\n\n     * 运行 （可运行的时间叫做时间片）\n     * 就绪 线程可执行但cpu被占用\n     * 等待 线程等待某时间发生，无法执行\n\n   * 主流调度方法：\n\n     * 优先级调度：调整优先级以提高效率并且防止Starvation，一般给予等待时间长的进程更高的优先级，防止其被饿死。并且根据进入等待状态的频繁程度调整优先级，比如IO密集型线程会得到更高的优先级防止其他的进程被饿死。用户也可以调整优先级。\n     * 轮转法\n\n   * 可抢占线程：时间片用尽后进行线程调度，为当前主流。但是可能造成调度世纪不确定造成的问题。\n\n     不可抢占线程：只有线程主动放弃时间片或者试图等待时才会发成线程调度。\n\n   * 线程的安全性：因为数据在有时是共享的，可能造成数据在切换两个线程时产生错误。有一些API提供了原子化数据访问，但是有一些复杂的操作没有这样可直接调用的API。\n\n     * 解决方式：同步与锁；设置二元信号量；互斥量；临界区；条件变量\n\n# 第二章 静态链接——编译和链接\n\n## 2.1 编译过程\n\n1. 编译\n\n   ```\n   gcc hello.c  \n   ./a.out\n   ```\n\n   预处理(prepressing)， 编译(compilation)，汇编(assembly)，链接(linking)\n\n   ![编译过程](https://img.cetacis.dev/uploads/2020/02/06/Screen-Shot-2020-02-06-at-7.19.23-PM.png)\n\n2. 预编译\n\n   将hello.c 和 stdio.h 通过cpp预编译成.i\n\n   ```\n   $gcc -E hello.c -o hello.i\n   /\n   $cpp hello.c > hello.i\n   ```\n\n   \n\n   * 展开#define，处理#if #ifdef..，#include\n\n   * 删除注释\n\n   * 添加行号文件标识，便于编译器使用\n\n   * 保留#pragma，编译器使用\n\n     *我们可以通过查看预编译后文件来判断宏定义是否正确或头文件是否正确*\n\n1. \n\n3. 编译\n\n   词法分析、语法分析、语义分析、优化后生产相应的汇编代码文件\n\n   ```\n   $gcc -S hello.i -o hello.s\n   $ /usr/lin/gcc/i486-linux-gnu/4.1/cc1 hello.c\n   ```\n\n   得到汇编输出文件hello.s。cc1是对于c来说的，对于C++为cc1plus，Java是jc1\n\n   可将预编译和编译合并为一个步骤，使用cc1来完成这两个步骤\n\n4. 汇编\n\n   汇编器(as)：将汇编代码转变成机器指令。每一条汇编几乎对应一条机器指令。\n\n   ```\n   $as hello.s -o hello.o\n   /\n   $gcc -c hello.s -o hello.o\n   /\n   $gcc -c hello.c -o hello.o\n   ```\n\n5. 链接\n\n   将一大堆文件链接后才能得到可执行文件\"a.out\"\n\n## 2.2 编译器\n\n编译器：将高级语言翻译成机器语言。\n\n过程：扫描、语法分析、语义分析、源代码优化、代码生成、目标代码优化\n\n![编译过程](https://img.cetacis.dev/uploads/2020/02/06/Screen-Shot-2020-02-06-at-9.16.15-PM.png)\n\n1. 词法分析\n\n   scan时Finit State Machine(有限状态机)将源代码字符切割成Token(记号)并且分类（标识符放入符号表，数字字符串存放在文字表）。\n\n   **Token**：关键字，标识符，字面量（数字、字符串）和特殊符号（加、等）\n\n   lex程序：按照用户描述好的词法规则分割字符串。\n\n2. 语法分析\n\n   **Grammar Parser（语法分析器）**对Token分析，产生Syntax Tree（语法树），采用Context-free Grammar。\n\n   **Syntax Tree**是以expression为节点的树。\n\n   yacc（Yet Another Compiler Compiler）可根据用户给定的语法规则对输入记号序列进行解析，从而构建语法树。对于不同语言，编译器开发者只需改变语法规则。\n\n   *语法分析只完成了对表达式的语言层面的分析，但是无法判断语句的真正意义*\n\n3. 语义分析\n\n   **Semantic Analyzer（语义分析器）**：可以分析静态语义（Static Semantic），包括声明、类型的匹配，类型的转换。同时，动态语义（Dynamic Semantiv）只有在运行期才能确定。\n\n4. 中间语言生成\n\n   **Source Code Optimizer（源码级优化器）**：源码级别的一个优化过程。生成Intermediate Code（中间代码）。中间代码有很多类型，比较常见的是Three-address Code（三地址码）。\n\n   Intermediate code 将编译器分为前端和后端，之前所描述的部分为前端，之后则为后端。\n\n5. 编译器后端\n\n   后端包括：Code generator（代码生成器）和Target Code Optimizer（目标代码优化器）\n\n   Code generator转化成目标机器代码\n\n   Target Code Optimizer优化目标机器代码，选择合适的寻址方式、使用位移来代替乘法运算。\n\n6. conclusion\n\n   现在的编译器随着CPU的进化而变得复杂，比如GCC编译器几乎支持所有CPU平台。\n\n   生成了目标代码后，有一个问题：index和array的地址还没有确定。如果代码中有变量定义在其他模块，在最终运行时，他们都要在最终连接时才能确定。现在的编译器可将一个源代码文件编译成一个未连接的目标文件，然后由编译器最终将目标文件连接成可执行文件。\n\n## 2.3 链接器\n\n静态链接\n\n链接：将一些指令对其他符号地址的引用进行修正，包括地址空间分配、符号决议、重定位(Relocation)。\n\n![链接过程](https://img.cetacis.dev/uploads/2020/02/06/Screen-Shot-2020-02-06-at-10.54.56-PM.png)\n\n\n\n# 第三章 Object File（目标文件）\n\n \n\n![文件格式](https://img.cetacis.dev/uploads/2020/02/07/Screen-Shot-2020-02-07-at-7.23.06-PM.png)\n\n\n\n```\n$file foobar.o  //查看类型\n```\n\nEFL(Executable Linkable Format)： 可执行（目标）文件格式（Linex系统，windows是PE）\n\n目标文件：源代码编译后但是没有进行链接的中间文件，和可执行文件的内容结构相似，采用一种格式储存。\n\n## 3.1 EFL文件格式\n\n![可执行文件组成](https://img.cetacis.dev/uploads/2020/02/07/Screen-Shot-2020-02-07-at-7.43.09-PM.png)\n\n* 目标文件包含：编译后的机器指令代码、数据、连接时所需信息（符号表、调试信息、字符串）\n\n  存储形式：节（Section）/段（Segment）注：*余文皆为段*\n\n  * 文件头：文件属性、文件是否可执行、静态链接/动态链接及入口地址、目标硬件/操作系统。包含一个**段表**，描述文件中各个段的数组。\n\n    文件头后就是各个段的内容。\n\n  * 编译后的执行语句编译成机械代码：.text段\n\n  * 已初始化的全局变量局部变量静态变量：.data段\n\n  * 未初始化的全局变量/局部静态变量：.bss（默认为0，没必要在.data分配空间）（为未初始化的全局变量和局部静态变量的大小总和，无内容不占空间）\n\n* 程序源代码编译后被分为两种段：程序指令、程序数据。\n\n  代码段：程序指令。数据段，.bss：程序数据\n\n* 指令数据分离存储的意义：\n\n  * 数据rw- 指令r--\n  * cashe数据指令分离\n  * **指令共享**——节约空间\n\n## 3.2 EFL文件实例\n\n* **-c 代表只编译不链接**\n\n  ```\n  $gcc -c SimpleSection.c \n  ```\n\n  我们会得到一个SimpleSection.o的目标文件\n\n* 我们可以通过**objdump**查看object内部结构\n\n  ```\n  $objdump -h SimpleSection.o\n  ```\n\n  **-h** 代表将EFL文件各个段的信息打印，**-x**则会打印更多信息。\n\n  **readelf**是Linux的工具\n\n  ![目标文件EFL](https://img.cetacis.dev/uploads/2020/02/07/Screen-Shot-2020-02-07-at-8.20.24-PM.png)\n\n如图，除了基础的.text/.data/.bss，还有.rodata(只读数据段)，.comment(注释信息段)和.note.GNU-stack（堆栈提示段）。\n\n* 读这段object信息：\n\n  * size是段长度，File off是段的位置（偏移量）\n  * CONTENTS代表此段在文件中存在\n\n  他们在ELF中的结构如图：\n\n  ![SimpleSection.o](https://img.cetacis.dev/uploads/2020/02/07/Screen-Shot-2020-02-07-at-8.30.12-PM.png)\n\n* **size**指令：用来查看ELF文件各段长度\n\n  ![size](https://img.cetacis.dev/uploads/2020/02/07/Screen-Shot-2020-02-07-at-8.44.53-PM.png)\n\n## 3.3 ELF文件详细内容\n\n### 代码段\n\n**objdump**的**-s**参数可以将所有段的内容以16进制打印，**-d**可将所有包含指令的段反汇编\n\n我们可将objdump输出中关于代码段的内容提取，分析内容。\n\n![.text](https://img.cetacis.dev/uploads/2020/02/07/Screen-Shot-2020-02-07-at-8.49.58-PM.png)\n\nContents of section 是.text以16进制打印。最左为偏移量，中间四列是十六进制内容，最右一列是.text段的ASCII码。\n\n下面反汇编的结果，.text包含SimpleSection.c的func1()和main()指令。\n\n0x55对应push %ebp 0xc3对应ret\n\n### .data .rodata\n\n### .bss \n\n### others\n\n![ELF常见段](https://img.cetacis.dev/uploads/2020/02/07/Screen-Shot-2020-02-07-at-8.56.46-PM.png)\n\n### 文件头\n\n**readelf**可用于详细查看ELF文件\n\n**-h**查看文件头\n\n![文件头](https://img.cetacis.dev/uploads/2020/02/07/Screen-Shot-2020-02-07-at-9.02.15-PM.png)\n\nELF相关常数定义在“/usr/include/elf.h”\n\n如图所示：\n\n![elf.h](https://img.cetacis.dev/uploads/2020/02/07/Screen-Shot-2020-02-07-at-9.12.45-PM.png)\n\n![.elf文件意义](https://img.cetacis.dev/uploads/2020/02/07/Screen-Shot-2020-02-07-at-9.12.52-PM.png)\n\n![readelf输出结果与意义](https://img.cetacis.dev/uploads/2020/02/07/Screen-Shot-2020-02-07-at-9.12.56-PM.png)\n\n### e_ident \n\n* 魔数(magic)\n\n几乎所有可执行文件格式的最开始几个字节都是魔数。比如a.out开始是ox01 ox07等。\n\n作用：确定文件类型。操作系统在加载可执行文件时会确定魔数是否正确，否则拒绝加载。\n\n* 版本(Version) 最新1.2\n\n* 文件类型 e_type\n\n  ![e_type](https://img.cetacis.dev/uploads/2020/02/07/Screen-Shot-2020-02-07-at-9.17.54-PM.png)\n\n* 机械类型 e_machine\n\n  ![e_machine](https://img.cetacis.dev/uploads/2020/02/07/Screen-Shot-2020-02-07-at-9.20.48-PM.png)\n\n* 段表\n\n  保存段的基本属性（段名、段长度、文件偏移、读写权限、其他属性）\n\n  编译器、链接器、装载器依靠段表定位访问各段属性\n\n  查看方式：\n\n  * **objump -h**      #简要信息\n  * **readelf -S **       #详细信息\n\n  \n\n* 重定位表\n\n  .rel.text （相对位置定位表）\n\n* 字符串表\n\n  ![字符串表](https://img.cetacis.dev/uploads/2020/02/07/Screen-Shot-2020-02-07-at-9.30.54-PM.png)\n\n## 3.4 链接的接口——符号\n\n在连接中，函数和变量统称为**符号（Symbol）**，函数名和变量名就是**符号名（Symbol Name)**。\n\n每一个目标文件有一个对应的**符号表（Symbol Table）**。每一个符号都有一个相应的值，叫做**符号值（Symbol Value）**。对于变量、函数，符号值就是他们的地址。\n\n### 符号分类\n\n* 定义在本目标文件的全局符号，可被其他目标文件引用：main, func1, global_init_var\n* *定义在其他文件中的全局符号：printf\n* 段名 该段的起始地址：.text,.data\n* 局部符号，只在本编译单元可见：static_var, statoc_var2。这些局部符号对于链接没有作用。\n* 行号信息 目标文件指令与源代码代码行的对应关系。（可选）、\n\n1.2 重要，345对于其它目标文件不可见，在链接过程中无关紧要。\n\n**nm**可用来查看符号\n\n![查看符号](https://img.cetacis.dev/uploads/2020/02/07/Screen-Shot-2020-02-07-at-9.53.31-PM.png)\n\n### 符号表结构\n\n符号表是.**symtab**段\n\n![查看符号表](https://img.cetacis.dev/uploads/2020/02/07/Screen-Shot-2020-02-07-at-10.04.27-PM.png)\n\n### 特殊符号\n\n在使用ld链接器时，有一些可以直接声明引用的特殊符号，这些符号被定义在ld链接器的链接脚本中。\n\n![代表性特殊符号](https://img.cetacis.dev/uploads/2020/02/08/Screen-Shot-2020-02-08-at-10.10.34-PM.png)\n\n我们可以在程序中直接使用这些符号\n\n![在程序中直接使用符号](https://img.cetacis.dev/uploads/2020/02/08/Screen-Shot-2020-02-08-at-10.17.31-PM.png)\n\n\n\n### 符号修饰机制与函数签名\n\n不同的函数可能拥有相同姓名，但是他的其他信息，比如参数类型、所在类、函数名等不同，因此他们拥有不同的**函数签名（Function Signature）**。函数签名用于识别不同的函数。\n\n编译器、链接器处理符号时，使用某种**名称修改**的方法，每个还是签名对应一个**修改后名称**。即在C++源代码编译成目标文件时，会将函数和变量名称进行修饰，形成符号名。\n\n名称修改机制也用来防止静态变量名称冲突。比如main()和func()中都含有静态变量foo，区分这两个变量，就会分别修饰名称，产生不同的符号名。\n\n不同编译器的名称修改机制不同。\n\n### extern \"C\"\n\n```C++\nextern \"C\"{\n\tint func(int);\n\tint var;\n}\n```\n\nC++将花括号内部代码当做C。因此如图的静态变量会对符号进行C语言的变量修饰。一般VS平台下会在名称前加_，但是linux的gcc不会如此修饰。\n\n当我们声明一些C语言的函数和全局变量时，在C++的编译单元中，这些函数和全局变量的符号会不能被链接，extern \"C\"在C中不被支持，所以我们需要先判断本编译单元是那种语言。\n\n![extern ”C“的应用](https://img.cetacis.dev/uploads/2020/02/08/Screen-Shot-2020-02-08-at-10.42.04-PM.png)\n\n_cplusplus是一种C++中定义的宏，判断此宏是否被定义可用以判断此编译单元的类型是C++与否。\n\n### 强符号/弱符号\n\n1. 编译器默认函数/初始化后的全局变量为强符号，未初始化的全局变量为若符号。但是我们可以通过\n\n```\n__attribute__((weak)) weak2 = 2;\n__attribute__((weakref)) void foo();\n```\n\n![强符号/弱符号](https://img.cetacis.dev/uploads/2020/02/08/Screen-Shot-2020-02-08-at-11.11.54-PM.png)\n\n\n\n如图：weak,weak2 为弱符号、strong,main()为强符号。ext是外部变量的引用，非强非弱。\n\n2. **链接器选择多次定义符号的原则：**\n\n   (1)强不允许多次，否则报符号重复定义错误\n\n   (2)选强\n\n   (3)若都为弱，则选择占用最大的一个\n\n3. 弱符号和弱引用的应用\n\n   库中定义的弱符号可被用户定义的强符号覆盖，从而使程序使用自定义版本的库函数\n\n   程序可对某扩展功能模块的引用定义为弱引用，将扩展模块和程序链接在一起时，功能模块可正常使用。去掉这些模块也可正常连接，更利于程序功能的组合。\n\n   *还可以判断链接到多线程库或者单线程库*\n\n   gcc -lpthread可连接到多线程库\n\n## 3.5 调试信息\n\n现代编译器都支持源代码级别的调试。在gcc时加上-g参数，readelf发现object file里有很多\"debug\"段。\n\nELF采用DWARF的标准调试信息格式，microsoft也有对应的格式叫codeview。debug段在目标文件和可执行文件中占有很大空间，甚至大过代码和数据本身。当开发完程序并发布时，我们可以去掉无用的调试信息。\n\n```\n$strip foo\n```\n\n## 3.6 小结\n\n（1）深入了解object file的文件格式——ELF\n\n（文件头 段表 重定位表 字符串表 符号表 调试表 代码段 数据段等段）\n\n（2）可执行文件、目标文件、库。实际上都是一样基于段的文件或者文件的集合。源代码经编译，代码数据分类后存放在相应的段中，编译器（汇编器）将辅助性信息（符号、重定位信息）按照表的形式存放在目标文件里。表在一般情况下就是段。（调试表 === debug段）\n\n（3）目标文件需要进一步通过符号/重定位信息链接，形成可使用程序。 \n\n\n\n","slug":"程序员的自我修养（一）操作系统、编译器、目标文件、链接器","published":1,"updated":"2020-03-25T01:37:21.000Z","title":"程序员的自我修养（一）操作系统、编译器、目标文件、链接器","_id":"ck849avaq000athesfk5l69r8","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"第一章-计算机概念基础\"><a href=\"#第一章-计算机概念基础\" class=\"headerlink\" title=\"第一章 计算机概念基础\"></a>第一章 计算机概念基础</h3><p>1.1 硬件基础</p>\n<p>1.2 软件基础</p>\n<a id=\"more\"></a>\n<h3 id=\"第二章-静态链接-——编译和链接\"><a href=\"#第二章-静态链接-——编译和链接\" class=\"headerlink\" title=\"第二章 静态链接 ——编译和链接\"></a>第二章 静态链接 ——编译和链接</h3><p>2.1 编译过程</p>\n<p>2.2  编译器</p>\n<p>2.3 链接器</p>\n<h3 id=\"第三章-目标文件\"><a href=\"#第三章-目标文件\" class=\"headerlink\" title=\"第三章  目标文件\"></a>第三章  目标文件</h3><p>3.1 EFL文件格式</p>\n<p>3.2 EFL文件实例</p>\n<p>3.3 EFL 文件详细内容</p>\n<p>3.4 链接的接口——符号</p>\n<p>3.5 调试信息</p>\n<p>3.6 小结</p>\n<h1 id=\"第一章-计算机概念基础-1\"><a href=\"#第一章-计算机概念基础-1\" class=\"headerlink\" title=\"第一章 计算机概念基础\"></a>第一章 计算机概念基础</h1><h2 id=\"1-1-硬件基础\"><a href=\"#1-1-硬件基础\" class=\"headerlink\" title=\"1.1 硬件基础\"></a>1.1 硬件基础</h2><ol>\n<li><p>PC机： 兼容x86指令集的32位cpu的个人计算机</p>\n</li>\n<li><p>关键部件： 中央处理器CPU 内存 I/O控制芯片</p>\n</li>\n<li><p>芯片 </p>\n<p>北桥芯片 设备高速交换数据：协调CPU、内存、高速图形设备</p>\n<p>南桥芯片 处理低速设备：磁盘、USB、键盘、鼠标</p>\n<p>南桥汇总后链接到北桥</p>\n<p>20世纪90年代PC机采用PCI/ISA及南北桥设计的硬件构架。之后有发明了AGP, PCI Express等总线结构和相应控制芯片。</p>\n</li>\n<li><p>SMP与多核</p>\n<p>CPU的频率经历过一段时间的增加后到达了4GHz的天花板（工艺限制）。因此出现了多CPU计算器，常见的形势如 <strong>对称多处理器</strong> （SMP）。即多CPU在系统中所处地位和发挥功能相同且对称。</p>\n<p>多CPU对运算速度的提升不是线性的，因为一个问题无法分解为若干不相干的子问题。常用情况：数据库，网络服务器，所以多处理器的成本很高。</p>\n<p><strong>多核处理器</strong>（Multi-core Processor）是对于SMP的简化。不同的处理器之间共享昂贵的缓存，成本较多处理器降低很多。</p>\n</li>\n</ol>\n<h2 id=\"1-2-软件基础\"><a href=\"#1-2-软件基础\" class=\"headerlink\" title=\"1.2 软件基础\"></a>1.2 软件基础</h2><ol>\n<li><p>系统软件 </p>\n<ul>\n<li><p>定义：管理计算机本身的软件</p>\n</li>\n<li><p>分类：平台性（操作系统内核、驱动程序、运行库）</p>\n<p>​            程序开发（编译器、汇编器、连接器）</p>\n</li>\n<li><p>开发程序  应用程序  </p>\n<p>↓使用者</p>\n<p>&lt;应用程序编程接口（API）&gt;</p>\n<p>↑提供者</p>\n<p> 运行库（Runtime Library）。比如Windows运行库提供windousAPI，Linux Glibc库提供POSIXAPI</p>\n<p>↓使用者</p>\n<p>&lt;系统调用接口(System call interface)&gt;</p>\n<p>↑提供者</p>\n<p>操作系统（Operating System Kernel） 提供软件中断。如Linux使用0x80号中断作为SCI</p>\n<p>↓使用者</p>\n<p>&lt;硬件规格(Hardware Specification)&gt;</p>\n</li>\n</ul>\n</li>\n<li><p>操作系统 Operating System</p>\n<ul>\n<li><p>功能：1） 提供抽象接口</p>\n<p>​            2） 管理硬件资源</p>\n</li>\n<li><p>操作系统会CPU分配方式：</p>\n<p>CPU分配一直在发展，现在多为多任务（Multi-tasking）系统。所有的应用程序都以进程(Process)的方式运行（进程的总体目标是每个进程从逻辑上来看都可独占计算机资源）。CPU分配方式是抢占式（Preemptive），即在多个进程间快速切换。操作系统会将CPU资源分配给它所认为必要的进程。</p>\n</li>\n<li><p>设备驱动</p>\n<p>操作系统直接控制硬件，比如向I/O端口0X1001写一个命令0X1111…… 这些表现在开发程序层面往往就是一个LineTo()函数，开发者不再需要直接写硬件的命令，而是通过层层接口将函数转化为机械指令。</p>\n<p>操作系统将硬件抽象化成了概念。具体硬件细节是操作系统中的<strong>硬件驱动（Device Driver）程序</strong>来完成</p>\n</li>\n</ul>\n</li>\n<li><p>程序在内存上的运行</p>\n<ul>\n<li><p>存在问题：1）地址空间不隔离，可能会造成恶意溢出，改写其他程序。</p>\n<p>​                    2）内存使用效率低，当内存不够时，会有大量的数据换入换出，导致效率低下。</p>\n<p>​                    3）程序运行地址不正确，重定位出错。</p>\n</li>\n<li><p>解决方法：虚拟地址： 分段：通过映射（映射由操作系统完成），令超出部分非法，解决1，3。</p>\n<p>​                                        分页：Intel系列处理器支持4KB/4MB的页大小，一般使用4KB，由操作系统决定。虚拟空间页为虚拟页，物理内存页为物理页，磁盘中页叫磁盘页。以页为单位存取交换数据方便，并且操作系统可以为页设置权限，保证安全。</p>\n</li>\n<li><p>虚拟地址的硬件实现  MMU（Memory Management Unit）</p>\n<p>CPU –Virthal Address(虚拟地址)–&gt;MMU–Physical address–&gt;Physical Memory</p>\n</li>\n</ul>\n</li>\n<li><p>线程</p>\n<ul>\n<li><p>定义： 轻量级进程，程序执行流的最小单元。一个标准线程由线程ID、当前指针PC、寄存器集合和堆栈组成。一个进程由一到多个线程组成，各个线程共享程序内存空间。</p>\n</li>\n<li><p>多线程优点：多个操作并行，发挥计算机的计算能力，在数据共享方面的效率高很多。</p>\n</li>\n<li><p>线程调度：当线程数多于处理器数时，一个处理器会处理多于一个的线程，在处理器上切换不同的线程的行为称之为<strong>线程调度（Thread Schedule）</strong>。线程通常拥有三种状态：</p>\n<ul>\n<li>运行 （可运行的时间叫做时间片）</li>\n<li>就绪 线程可执行但cpu被占用</li>\n<li>等待 线程等待某时间发生，无法执行</li>\n</ul>\n</li>\n<li><p>主流调度方法：</p>\n<ul>\n<li>优先级调度：调整优先级以提高效率并且防止Starvation，一般给予等待时间长的进程更高的优先级，防止其被饿死。并且根据进入等待状态的频繁程度调整优先级，比如IO密集型线程会得到更高的优先级防止其他的进程被饿死。用户也可以调整优先级。</li>\n<li>轮转法</li>\n</ul>\n</li>\n<li><p>可抢占线程：时间片用尽后进行线程调度，为当前主流。但是可能造成调度世纪不确定造成的问题。</p>\n<p>不可抢占线程：只有线程主动放弃时间片或者试图等待时才会发成线程调度。</p>\n</li>\n<li><p>线程的安全性：因为数据在有时是共享的，可能造成数据在切换两个线程时产生错误。有一些API提供了原子化数据访问，但是有一些复杂的操作没有这样可直接调用的API。</p>\n<ul>\n<li>解决方式：同步与锁；设置二元信号量；互斥量；临界区；条件变量</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"第二章-静态链接——编译和链接\"><a href=\"#第二章-静态链接——编译和链接\" class=\"headerlink\" title=\"第二章 静态链接——编译和链接\"></a>第二章 静态链接——编译和链接</h1><h2 id=\"2-1-编译过程\"><a href=\"#2-1-编译过程\" class=\"headerlink\" title=\"2.1 编译过程\"></a>2.1 编译过程</h2><ol>\n<li><p>编译</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcc hello.c  </span><br><span class=\"line\">.&#x2F;a.out</span><br></pre></td></tr></table></figure>\n\n<p>预处理(prepressing)， 编译(compilation)，汇编(assembly)，链接(linking)</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/06/Screen-Shot-2020-02-06-at-7.19.23-PM.png\" alt=\"编译过程\"></p>\n</li>\n<li><p>预编译</p>\n<p>将hello.c 和 stdio.h 通过cpp预编译成.i</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$gcc -E hello.c -o hello.i</span><br><span class=\"line\">&#x2F;</span><br><span class=\"line\">$cpp hello.c &gt; hello.i</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<ul>\n<li><p>展开#define，处理#if #ifdef..，#include</p>\n</li>\n<li><p>删除注释</p>\n</li>\n<li><p>添加行号文件标识，便于编译器使用</p>\n</li>\n<li><p>保留#pragma，编译器使用</p>\n<p><em>我们可以通过查看预编译后文件来判断宏定义是否正确或头文件是否正确</em></p>\n</li>\n</ul>\n<ol>\n<li></li>\n<li><p>编译</p>\n<p>词法分析、语法分析、语义分析、优化后生产相应的汇编代码文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$gcc -S hello.i -o hello.s</span><br><span class=\"line\">$ &#x2F;usr&#x2F;lin&#x2F;gcc&#x2F;i486-linux-gnu&#x2F;4.1&#x2F;cc1 hello.c</span><br></pre></td></tr></table></figure>\n\n<p>得到汇编输出文件hello.s。cc1是对于c来说的，对于C++为cc1plus，Java是jc1</p>\n<p>可将预编译和编译合并为一个步骤，使用cc1来完成这两个步骤</p>\n</li>\n<li><p>汇编</p>\n<p>汇编器(as)：将汇编代码转变成机器指令。每一条汇编几乎对应一条机器指令。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$as hello.s -o hello.o</span><br><span class=\"line\">&#x2F;</span><br><span class=\"line\">$gcc -c hello.s -o hello.o</span><br><span class=\"line\">&#x2F;</span><br><span class=\"line\">$gcc -c hello.c -o hello.o</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>链接</p>\n<p>将一大堆文件链接后才能得到可执行文件”a.out”</p>\n</li>\n</ol>\n<h2 id=\"2-2-编译器\"><a href=\"#2-2-编译器\" class=\"headerlink\" title=\"2.2 编译器\"></a>2.2 编译器</h2><p>编译器：将高级语言翻译成机器语言。</p>\n<p>过程：扫描、语法分析、语义分析、源代码优化、代码生成、目标代码优化</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/06/Screen-Shot-2020-02-06-at-9.16.15-PM.png\" alt=\"编译过程\"></p>\n<ol>\n<li><p>词法分析</p>\n<p>scan时Finit State Machine(有限状态机)将源代码字符切割成Token(记号)并且分类（标识符放入符号表，数字字符串存放在文字表）。</p>\n<p><strong>Token</strong>：关键字，标识符，字面量（数字、字符串）和特殊符号（加、等）</p>\n<p>lex程序：按照用户描述好的词法规则分割字符串。</p>\n</li>\n<li><p>语法分析</p>\n<p><strong>Grammar Parser（语法分析器）</strong>对Token分析，产生Syntax Tree（语法树），采用Context-free Grammar。</p>\n<p><strong>Syntax Tree</strong>是以expression为节点的树。</p>\n<p>yacc（Yet Another Compiler Compiler）可根据用户给定的语法规则对输入记号序列进行解析，从而构建语法树。对于不同语言，编译器开发者只需改变语法规则。</p>\n<p><em>语法分析只完成了对表达式的语言层面的分析，但是无法判断语句的真正意义</em></p>\n</li>\n<li><p>语义分析</p>\n<p><strong>Semantic Analyzer（语义分析器）</strong>：可以分析静态语义（Static Semantic），包括声明、类型的匹配，类型的转换。同时，动态语义（Dynamic Semantiv）只有在运行期才能确定。</p>\n</li>\n<li><p>中间语言生成</p>\n<p><strong>Source Code Optimizer（源码级优化器）</strong>：源码级别的一个优化过程。生成Intermediate Code（中间代码）。中间代码有很多类型，比较常见的是Three-address Code（三地址码）。</p>\n<p>Intermediate code 将编译器分为前端和后端，之前所描述的部分为前端，之后则为后端。</p>\n</li>\n<li><p>编译器后端</p>\n<p>后端包括：Code generator（代码生成器）和Target Code Optimizer（目标代码优化器）</p>\n<p>Code generator转化成目标机器代码</p>\n<p>Target Code Optimizer优化目标机器代码，选择合适的寻址方式、使用位移来代替乘法运算。</p>\n</li>\n<li><p>conclusion</p>\n<p>现在的编译器随着CPU的进化而变得复杂，比如GCC编译器几乎支持所有CPU平台。</p>\n<p>生成了目标代码后，有一个问题：index和array的地址还没有确定。如果代码中有变量定义在其他模块，在最终运行时，他们都要在最终连接时才能确定。现在的编译器可将一个源代码文件编译成一个未连接的目标文件，然后由编译器最终将目标文件连接成可执行文件。</p>\n</li>\n</ol>\n<h2 id=\"2-3-链接器\"><a href=\"#2-3-链接器\" class=\"headerlink\" title=\"2.3 链接器\"></a>2.3 链接器</h2><p>静态链接</p>\n<p>链接：将一些指令对其他符号地址的引用进行修正，包括地址空间分配、符号决议、重定位(Relocation)。</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/06/Screen-Shot-2020-02-06-at-10.54.56-PM.png\" alt=\"链接过程\"></p>\n<h1 id=\"第三章-Object-File（目标文件）\"><a href=\"#第三章-Object-File（目标文件）\" class=\"headerlink\" title=\"第三章 Object File（目标文件）\"></a>第三章 Object File（目标文件）</h1><p><img src=\"https://img.cetacis.dev/uploads/2020/02/07/Screen-Shot-2020-02-07-at-7.23.06-PM.png\" alt=\"文件格式\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$file foobar.o  &#x2F;&#x2F;查看类型</span><br></pre></td></tr></table></figure>\n\n<p>EFL(Executable Linkable Format)： 可执行（目标）文件格式（Linex系统，windows是PE）</p>\n<p>目标文件：源代码编译后但是没有进行链接的中间文件，和可执行文件的内容结构相似，采用一种格式储存。</p>\n<h2 id=\"3-1-EFL文件格式\"><a href=\"#3-1-EFL文件格式\" class=\"headerlink\" title=\"3.1 EFL文件格式\"></a>3.1 EFL文件格式</h2><p><img src=\"https://img.cetacis.dev/uploads/2020/02/07/Screen-Shot-2020-02-07-at-7.43.09-PM.png\" alt=\"可执行文件组成\"></p>\n<ul>\n<li><p>目标文件包含：编译后的机器指令代码、数据、连接时所需信息（符号表、调试信息、字符串）</p>\n<p>存储形式：节（Section）/段（Segment）注：<em>余文皆为段</em></p>\n<ul>\n<li><p>文件头：文件属性、文件是否可执行、静态链接/动态链接及入口地址、目标硬件/操作系统。包含一个<strong>段表</strong>，描述文件中各个段的数组。</p>\n<p>文件头后就是各个段的内容。</p>\n</li>\n<li><p>编译后的执行语句编译成机械代码：.text段</p>\n</li>\n<li><p>已初始化的全局变量局部变量静态变量：.data段</p>\n</li>\n<li><p>未初始化的全局变量/局部静态变量：.bss（默认为0，没必要在.data分配空间）（为未初始化的全局变量和局部静态变量的大小总和，无内容不占空间）</p>\n</li>\n</ul>\n</li>\n<li><p>程序源代码编译后被分为两种段：程序指令、程序数据。</p>\n<p>代码段：程序指令。数据段，.bss：程序数据</p>\n</li>\n<li><p>指令数据分离存储的意义：</p>\n<ul>\n<li>数据rw- 指令r–</li>\n<li>cashe数据指令分离</li>\n<li><strong>指令共享</strong>——节约空间</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3-2-EFL文件实例\"><a href=\"#3-2-EFL文件实例\" class=\"headerlink\" title=\"3.2 EFL文件实例\"></a>3.2 EFL文件实例</h2><ul>\n<li><p><strong>-c 代表只编译不链接</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$gcc -c SimpleSection.c</span><br></pre></td></tr></table></figure>\n\n<p>我们会得到一个SimpleSection.o的目标文件</p>\n</li>\n<li><p>我们可以通过<strong>objdump</strong>查看object内部结构</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$objdump -h SimpleSection.o</span><br></pre></td></tr></table></figure>\n\n<p><strong>-h</strong> 代表将EFL文件各个段的信息打印，<strong>-x</strong>则会打印更多信息。</p>\n<p><strong>readelf</strong>是Linux的工具</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/07/Screen-Shot-2020-02-07-at-8.20.24-PM.png\" alt=\"目标文件EFL\"></p>\n</li>\n</ul>\n<p>如图，除了基础的.text/.data/.bss，还有.rodata(只读数据段)，.comment(注释信息段)和.note.GNU-stack（堆栈提示段）。</p>\n<ul>\n<li><p>读这段object信息：</p>\n<ul>\n<li>size是段长度，File off是段的位置（偏移量）</li>\n<li>CONTENTS代表此段在文件中存在</li>\n</ul>\n<p>他们在ELF中的结构如图：</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/07/Screen-Shot-2020-02-07-at-8.30.12-PM.png\" alt=\"SimpleSection.o\"></p>\n</li>\n<li><p><strong>size</strong>指令：用来查看ELF文件各段长度</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/07/Screen-Shot-2020-02-07-at-8.44.53-PM.png\" alt=\"size\"></p>\n</li>\n</ul>\n<h2 id=\"3-3-ELF文件详细内容\"><a href=\"#3-3-ELF文件详细内容\" class=\"headerlink\" title=\"3.3 ELF文件详细内容\"></a>3.3 ELF文件详细内容</h2><h3 id=\"代码段\"><a href=\"#代码段\" class=\"headerlink\" title=\"代码段\"></a>代码段</h3><p><strong>objdump</strong>的<strong>-s</strong>参数可以将所有段的内容以16进制打印，<strong>-d</strong>可将所有包含指令的段反汇编</p>\n<p>我们可将objdump输出中关于代码段的内容提取，分析内容。</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/07/Screen-Shot-2020-02-07-at-8.49.58-PM.png\" alt=\".text\"></p>\n<p>Contents of section 是.text以16进制打印。最左为偏移量，中间四列是十六进制内容，最右一列是.text段的ASCII码。</p>\n<p>下面反汇编的结果，.text包含SimpleSection.c的func1()和main()指令。</p>\n<p>0x55对应push %ebp 0xc3对应ret</p>\n<h3 id=\"data-rodata\"><a href=\"#data-rodata\" class=\"headerlink\" title=\".data .rodata\"></a>.data .rodata</h3><h3 id=\"bss\"><a href=\"#bss\" class=\"headerlink\" title=\".bss\"></a>.bss</h3><h3 id=\"others\"><a href=\"#others\" class=\"headerlink\" title=\"others\"></a>others</h3><p><img src=\"https://img.cetacis.dev/uploads/2020/02/07/Screen-Shot-2020-02-07-at-8.56.46-PM.png\" alt=\"ELF常见段\"></p>\n<h3 id=\"文件头\"><a href=\"#文件头\" class=\"headerlink\" title=\"文件头\"></a>文件头</h3><p><strong>readelf</strong>可用于详细查看ELF文件</p>\n<p><strong>-h</strong>查看文件头</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/07/Screen-Shot-2020-02-07-at-9.02.15-PM.png\" alt=\"文件头\"></p>\n<p>ELF相关常数定义在“/usr/include/elf.h”</p>\n<p>如图所示：</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/07/Screen-Shot-2020-02-07-at-9.12.45-PM.png\" alt=\"elf.h\"></p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/07/Screen-Shot-2020-02-07-at-9.12.52-PM.png\" alt=\".elf文件意义\"></p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/07/Screen-Shot-2020-02-07-at-9.12.56-PM.png\" alt=\"readelf输出结果与意义\"></p>\n<h3 id=\"e-ident\"><a href=\"#e-ident\" class=\"headerlink\" title=\"e_ident\"></a>e_ident</h3><ul>\n<li>魔数(magic)</li>\n</ul>\n<p>几乎所有可执行文件格式的最开始几个字节都是魔数。比如a.out开始是ox01 ox07等。</p>\n<p>作用：确定文件类型。操作系统在加载可执行文件时会确定魔数是否正确，否则拒绝加载。</p>\n<ul>\n<li><p>版本(Version) 最新1.2</p>\n</li>\n<li><p>文件类型 e_type</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/07/Screen-Shot-2020-02-07-at-9.17.54-PM.png\" alt=\"e_type\"></p>\n</li>\n<li><p>机械类型 e_machine</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/07/Screen-Shot-2020-02-07-at-9.20.48-PM.png\" alt=\"e_machine\"></p>\n</li>\n<li><p>段表</p>\n<p>保存段的基本属性（段名、段长度、文件偏移、读写权限、其他属性）</p>\n<p>编译器、链接器、装载器依靠段表定位访问各段属性</p>\n<p>查看方式：</p>\n<ul>\n<li><strong>objump -h</strong>      #简要信息</li>\n<li>*<em>readelf -S *</em>       #详细信息</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>重定位表</p>\n<p>.rel.text （相对位置定位表）</p>\n</li>\n<li><p>字符串表</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/07/Screen-Shot-2020-02-07-at-9.30.54-PM.png\" alt=\"字符串表\"></p>\n</li>\n</ul>\n<h2 id=\"3-4-链接的接口——符号\"><a href=\"#3-4-链接的接口——符号\" class=\"headerlink\" title=\"3.4 链接的接口——符号\"></a>3.4 链接的接口——符号</h2><p>在连接中，函数和变量统称为<strong>符号（Symbol）</strong>，函数名和变量名就是<strong>符号名（Symbol Name)</strong>。</p>\n<p>每一个目标文件有一个对应的<strong>符号表（Symbol Table）</strong>。每一个符号都有一个相应的值，叫做<strong>符号值（Symbol Value）</strong>。对于变量、函数，符号值就是他们的地址。</p>\n<h3 id=\"符号分类\"><a href=\"#符号分类\" class=\"headerlink\" title=\"符号分类\"></a>符号分类</h3><ul>\n<li>定义在本目标文件的全局符号，可被其他目标文件引用：main, func1, global_init_var</li>\n<li>*定义在其他文件中的全局符号：printf</li>\n<li>段名 该段的起始地址：.text,.data</li>\n<li>局部符号，只在本编译单元可见：static_var, statoc_var2。这些局部符号对于链接没有作用。</li>\n<li>行号信息 目标文件指令与源代码代码行的对应关系。（可选）、</li>\n</ul>\n<p>1.2 重要，345对于其它目标文件不可见，在链接过程中无关紧要。</p>\n<p><strong>nm</strong>可用来查看符号</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/07/Screen-Shot-2020-02-07-at-9.53.31-PM.png\" alt=\"查看符号\"></p>\n<h3 id=\"符号表结构\"><a href=\"#符号表结构\" class=\"headerlink\" title=\"符号表结构\"></a>符号表结构</h3><p>符号表是.<strong>symtab</strong>段</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/07/Screen-Shot-2020-02-07-at-10.04.27-PM.png\" alt=\"查看符号表\"></p>\n<h3 id=\"特殊符号\"><a href=\"#特殊符号\" class=\"headerlink\" title=\"特殊符号\"></a>特殊符号</h3><p>在使用ld链接器时，有一些可以直接声明引用的特殊符号，这些符号被定义在ld链接器的链接脚本中。</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/08/Screen-Shot-2020-02-08-at-10.10.34-PM.png\" alt=\"代表性特殊符号\"></p>\n<p>我们可以在程序中直接使用这些符号</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/08/Screen-Shot-2020-02-08-at-10.17.31-PM.png\" alt=\"在程序中直接使用符号\"></p>\n<h3 id=\"符号修饰机制与函数签名\"><a href=\"#符号修饰机制与函数签名\" class=\"headerlink\" title=\"符号修饰机制与函数签名\"></a>符号修饰机制与函数签名</h3><p>不同的函数可能拥有相同姓名，但是他的其他信息，比如参数类型、所在类、函数名等不同，因此他们拥有不同的<strong>函数签名（Function Signature）</strong>。函数签名用于识别不同的函数。</p>\n<p>编译器、链接器处理符号时，使用某种<strong>名称修改</strong>的方法，每个还是签名对应一个<strong>修改后名称</strong>。即在C++源代码编译成目标文件时，会将函数和变量名称进行修饰，形成符号名。</p>\n<p>名称修改机制也用来防止静态变量名称冲突。比如main()和func()中都含有静态变量foo，区分这两个变量，就会分别修饰名称，产生不同的符号名。</p>\n<p>不同编译器的名称修改机制不同。</p>\n<h3 id=\"extern-“C”\"><a href=\"#extern-“C”\" class=\"headerlink\" title=\"extern “C”\"></a>extern “C”</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">\"C\"</span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span></span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> var;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>C++将花括号内部代码当做C。因此如图的静态变量会对符号进行C语言的变量修饰。一般VS平台下会在名称前加_，但是linux的gcc不会如此修饰。</p>\n<p>当我们声明一些C语言的函数和全局变量时，在C++的编译单元中，这些函数和全局变量的符号会不能被链接，extern “C”在C中不被支持，所以我们需要先判断本编译单元是那种语言。</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/08/Screen-Shot-2020-02-08-at-10.42.04-PM.png\" alt=\"extern ”C“的应用\"></p>\n<p>_cplusplus是一种C++中定义的宏，判断此宏是否被定义可用以判断此编译单元的类型是C++与否。</p>\n<h3 id=\"强符号-弱符号\"><a href=\"#强符号-弱符号\" class=\"headerlink\" title=\"强符号/弱符号\"></a>强符号/弱符号</h3><ol>\n<li>编译器默认函数/初始化后的全局变量为强符号，未初始化的全局变量为若符号。但是我们可以通过</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__attribute__((weak)) weak2 &#x3D; 2;</span><br><span class=\"line\">__attribute__((weakref)) void foo();</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/08/Screen-Shot-2020-02-08-at-11.11.54-PM.png\" alt=\"强符号/弱符号\"></p>\n<p>如图：weak,weak2 为弱符号、strong,main()为强符号。ext是外部变量的引用，非强非弱。</p>\n<ol start=\"2\">\n<li><p><strong>链接器选择多次定义符号的原则：</strong></p>\n<p>(1)强不允许多次，否则报符号重复定义错误</p>\n<p>(2)选强</p>\n<p>(3)若都为弱，则选择占用最大的一个</p>\n</li>\n<li><p>弱符号和弱引用的应用</p>\n<p>库中定义的弱符号可被用户定义的强符号覆盖，从而使程序使用自定义版本的库函数</p>\n<p>程序可对某扩展功能模块的引用定义为弱引用，将扩展模块和程序链接在一起时，功能模块可正常使用。去掉这些模块也可正常连接，更利于程序功能的组合。</p>\n<p><em>还可以判断链接到多线程库或者单线程库</em></p>\n<p>gcc -lpthread可连接到多线程库</p>\n</li>\n</ol>\n<h2 id=\"3-5-调试信息\"><a href=\"#3-5-调试信息\" class=\"headerlink\" title=\"3.5 调试信息\"></a>3.5 调试信息</h2><p>现代编译器都支持源代码级别的调试。在gcc时加上-g参数，readelf发现object file里有很多”debug”段。</p>\n<p>ELF采用DWARF的标准调试信息格式，microsoft也有对应的格式叫codeview。debug段在目标文件和可执行文件中占有很大空间，甚至大过代码和数据本身。当开发完程序并发布时，我们可以去掉无用的调试信息。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$strip foo</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-6-小结\"><a href=\"#3-6-小结\" class=\"headerlink\" title=\"3.6 小结\"></a>3.6 小结</h2><p>（1）深入了解object file的文件格式——ELF</p>\n<p>（文件头 段表 重定位表 字符串表 符号表 调试表 代码段 数据段等段）</p>\n<p>（2）可执行文件、目标文件、库。实际上都是一样基于段的文件或者文件的集合。源代码经编译，代码数据分类后存放在相应的段中，编译器（汇编器）将辅助性信息（符号、重定位信息）按照表的形式存放在目标文件里。表在一般情况下就是段。（调试表 === debug段）</p>\n<p>（3）目标文件需要进一步通过符号/重定位信息链接，形成可使用程序。 </p>\n","site":{"data":{}},"excerpt":"<h3 id=\"第一章-计算机概念基础\"><a href=\"#第一章-计算机概念基础\" class=\"headerlink\" title=\"第一章 计算机概念基础\"></a>第一章 计算机概念基础</h3><p>1.1 硬件基础</p>\n<p>1.2 软件基础</p>","more":"<h3 id=\"第二章-静态链接-——编译和链接\"><a href=\"#第二章-静态链接-——编译和链接\" class=\"headerlink\" title=\"第二章 静态链接 ——编译和链接\"></a>第二章 静态链接 ——编译和链接</h3><p>2.1 编译过程</p>\n<p>2.2  编译器</p>\n<p>2.3 链接器</p>\n<h3 id=\"第三章-目标文件\"><a href=\"#第三章-目标文件\" class=\"headerlink\" title=\"第三章  目标文件\"></a>第三章  目标文件</h3><p>3.1 EFL文件格式</p>\n<p>3.2 EFL文件实例</p>\n<p>3.3 EFL 文件详细内容</p>\n<p>3.4 链接的接口——符号</p>\n<p>3.5 调试信息</p>\n<p>3.6 小结</p>\n<h1 id=\"第一章-计算机概念基础-1\"><a href=\"#第一章-计算机概念基础-1\" class=\"headerlink\" title=\"第一章 计算机概念基础\"></a>第一章 计算机概念基础</h1><h2 id=\"1-1-硬件基础\"><a href=\"#1-1-硬件基础\" class=\"headerlink\" title=\"1.1 硬件基础\"></a>1.1 硬件基础</h2><ol>\n<li><p>PC机： 兼容x86指令集的32位cpu的个人计算机</p>\n</li>\n<li><p>关键部件： 中央处理器CPU 内存 I/O控制芯片</p>\n</li>\n<li><p>芯片 </p>\n<p>北桥芯片 设备高速交换数据：协调CPU、内存、高速图形设备</p>\n<p>南桥芯片 处理低速设备：磁盘、USB、键盘、鼠标</p>\n<p>南桥汇总后链接到北桥</p>\n<p>20世纪90年代PC机采用PCI/ISA及南北桥设计的硬件构架。之后有发明了AGP, PCI Express等总线结构和相应控制芯片。</p>\n</li>\n<li><p>SMP与多核</p>\n<p>CPU的频率经历过一段时间的增加后到达了4GHz的天花板（工艺限制）。因此出现了多CPU计算器，常见的形势如 <strong>对称多处理器</strong> （SMP）。即多CPU在系统中所处地位和发挥功能相同且对称。</p>\n<p>多CPU对运算速度的提升不是线性的，因为一个问题无法分解为若干不相干的子问题。常用情况：数据库，网络服务器，所以多处理器的成本很高。</p>\n<p><strong>多核处理器</strong>（Multi-core Processor）是对于SMP的简化。不同的处理器之间共享昂贵的缓存，成本较多处理器降低很多。</p>\n</li>\n</ol>\n<h2 id=\"1-2-软件基础\"><a href=\"#1-2-软件基础\" class=\"headerlink\" title=\"1.2 软件基础\"></a>1.2 软件基础</h2><ol>\n<li><p>系统软件 </p>\n<ul>\n<li><p>定义：管理计算机本身的软件</p>\n</li>\n<li><p>分类：平台性（操作系统内核、驱动程序、运行库）</p>\n<p>​            程序开发（编译器、汇编器、连接器）</p>\n</li>\n<li><p>开发程序  应用程序  </p>\n<p>↓使用者</p>\n<p>&lt;应用程序编程接口（API）&gt;</p>\n<p>↑提供者</p>\n<p> 运行库（Runtime Library）。比如Windows运行库提供windousAPI，Linux Glibc库提供POSIXAPI</p>\n<p>↓使用者</p>\n<p>&lt;系统调用接口(System call interface)&gt;</p>\n<p>↑提供者</p>\n<p>操作系统（Operating System Kernel） 提供软件中断。如Linux使用0x80号中断作为SCI</p>\n<p>↓使用者</p>\n<p>&lt;硬件规格(Hardware Specification)&gt;</p>\n</li>\n</ul>\n</li>\n<li><p>操作系统 Operating System</p>\n<ul>\n<li><p>功能：1） 提供抽象接口</p>\n<p>​            2） 管理硬件资源</p>\n</li>\n<li><p>操作系统会CPU分配方式：</p>\n<p>CPU分配一直在发展，现在多为多任务（Multi-tasking）系统。所有的应用程序都以进程(Process)的方式运行（进程的总体目标是每个进程从逻辑上来看都可独占计算机资源）。CPU分配方式是抢占式（Preemptive），即在多个进程间快速切换。操作系统会将CPU资源分配给它所认为必要的进程。</p>\n</li>\n<li><p>设备驱动</p>\n<p>操作系统直接控制硬件，比如向I/O端口0X1001写一个命令0X1111…… 这些表现在开发程序层面往往就是一个LineTo()函数，开发者不再需要直接写硬件的命令，而是通过层层接口将函数转化为机械指令。</p>\n<p>操作系统将硬件抽象化成了概念。具体硬件细节是操作系统中的<strong>硬件驱动（Device Driver）程序</strong>来完成</p>\n</li>\n</ul>\n</li>\n<li><p>程序在内存上的运行</p>\n<ul>\n<li><p>存在问题：1）地址空间不隔离，可能会造成恶意溢出，改写其他程序。</p>\n<p>​                    2）内存使用效率低，当内存不够时，会有大量的数据换入换出，导致效率低下。</p>\n<p>​                    3）程序运行地址不正确，重定位出错。</p>\n</li>\n<li><p>解决方法：虚拟地址： 分段：通过映射（映射由操作系统完成），令超出部分非法，解决1，3。</p>\n<p>​                                        分页：Intel系列处理器支持4KB/4MB的页大小，一般使用4KB，由操作系统决定。虚拟空间页为虚拟页，物理内存页为物理页，磁盘中页叫磁盘页。以页为单位存取交换数据方便，并且操作系统可以为页设置权限，保证安全。</p>\n</li>\n<li><p>虚拟地址的硬件实现  MMU（Memory Management Unit）</p>\n<p>CPU –Virthal Address(虚拟地址)–&gt;MMU–Physical address–&gt;Physical Memory</p>\n</li>\n</ul>\n</li>\n<li><p>线程</p>\n<ul>\n<li><p>定义： 轻量级进程，程序执行流的最小单元。一个标准线程由线程ID、当前指针PC、寄存器集合和堆栈组成。一个进程由一到多个线程组成，各个线程共享程序内存空间。</p>\n</li>\n<li><p>多线程优点：多个操作并行，发挥计算机的计算能力，在数据共享方面的效率高很多。</p>\n</li>\n<li><p>线程调度：当线程数多于处理器数时，一个处理器会处理多于一个的线程，在处理器上切换不同的线程的行为称之为<strong>线程调度（Thread Schedule）</strong>。线程通常拥有三种状态：</p>\n<ul>\n<li>运行 （可运行的时间叫做时间片）</li>\n<li>就绪 线程可执行但cpu被占用</li>\n<li>等待 线程等待某时间发生，无法执行</li>\n</ul>\n</li>\n<li><p>主流调度方法：</p>\n<ul>\n<li>优先级调度：调整优先级以提高效率并且防止Starvation，一般给予等待时间长的进程更高的优先级，防止其被饿死。并且根据进入等待状态的频繁程度调整优先级，比如IO密集型线程会得到更高的优先级防止其他的进程被饿死。用户也可以调整优先级。</li>\n<li>轮转法</li>\n</ul>\n</li>\n<li><p>可抢占线程：时间片用尽后进行线程调度，为当前主流。但是可能造成调度世纪不确定造成的问题。</p>\n<p>不可抢占线程：只有线程主动放弃时间片或者试图等待时才会发成线程调度。</p>\n</li>\n<li><p>线程的安全性：因为数据在有时是共享的，可能造成数据在切换两个线程时产生错误。有一些API提供了原子化数据访问，但是有一些复杂的操作没有这样可直接调用的API。</p>\n<ul>\n<li>解决方式：同步与锁；设置二元信号量；互斥量；临界区；条件变量</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"第二章-静态链接——编译和链接\"><a href=\"#第二章-静态链接——编译和链接\" class=\"headerlink\" title=\"第二章 静态链接——编译和链接\"></a>第二章 静态链接——编译和链接</h1><h2 id=\"2-1-编译过程\"><a href=\"#2-1-编译过程\" class=\"headerlink\" title=\"2.1 编译过程\"></a>2.1 编译过程</h2><ol>\n<li><p>编译</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcc hello.c  </span><br><span class=\"line\">.&#x2F;a.out</span><br></pre></td></tr></table></figure>\n\n<p>预处理(prepressing)， 编译(compilation)，汇编(assembly)，链接(linking)</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/06/Screen-Shot-2020-02-06-at-7.19.23-PM.png\" alt=\"编译过程\"></p>\n</li>\n<li><p>预编译</p>\n<p>将hello.c 和 stdio.h 通过cpp预编译成.i</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$gcc -E hello.c -o hello.i</span><br><span class=\"line\">&#x2F;</span><br><span class=\"line\">$cpp hello.c &gt; hello.i</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<ul>\n<li><p>展开#define，处理#if #ifdef..，#include</p>\n</li>\n<li><p>删除注释</p>\n</li>\n<li><p>添加行号文件标识，便于编译器使用</p>\n</li>\n<li><p>保留#pragma，编译器使用</p>\n<p><em>我们可以通过查看预编译后文件来判断宏定义是否正确或头文件是否正确</em></p>\n</li>\n</ul>\n<ol>\n<li></li>\n<li><p>编译</p>\n<p>词法分析、语法分析、语义分析、优化后生产相应的汇编代码文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$gcc -S hello.i -o hello.s</span><br><span class=\"line\">$ &#x2F;usr&#x2F;lin&#x2F;gcc&#x2F;i486-linux-gnu&#x2F;4.1&#x2F;cc1 hello.c</span><br></pre></td></tr></table></figure>\n\n<p>得到汇编输出文件hello.s。cc1是对于c来说的，对于C++为cc1plus，Java是jc1</p>\n<p>可将预编译和编译合并为一个步骤，使用cc1来完成这两个步骤</p>\n</li>\n<li><p>汇编</p>\n<p>汇编器(as)：将汇编代码转变成机器指令。每一条汇编几乎对应一条机器指令。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$as hello.s -o hello.o</span><br><span class=\"line\">&#x2F;</span><br><span class=\"line\">$gcc -c hello.s -o hello.o</span><br><span class=\"line\">&#x2F;</span><br><span class=\"line\">$gcc -c hello.c -o hello.o</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>链接</p>\n<p>将一大堆文件链接后才能得到可执行文件”a.out”</p>\n</li>\n</ol>\n<h2 id=\"2-2-编译器\"><a href=\"#2-2-编译器\" class=\"headerlink\" title=\"2.2 编译器\"></a>2.2 编译器</h2><p>编译器：将高级语言翻译成机器语言。</p>\n<p>过程：扫描、语法分析、语义分析、源代码优化、代码生成、目标代码优化</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/06/Screen-Shot-2020-02-06-at-9.16.15-PM.png\" alt=\"编译过程\"></p>\n<ol>\n<li><p>词法分析</p>\n<p>scan时Finit State Machine(有限状态机)将源代码字符切割成Token(记号)并且分类（标识符放入符号表，数字字符串存放在文字表）。</p>\n<p><strong>Token</strong>：关键字，标识符，字面量（数字、字符串）和特殊符号（加、等）</p>\n<p>lex程序：按照用户描述好的词法规则分割字符串。</p>\n</li>\n<li><p>语法分析</p>\n<p><strong>Grammar Parser（语法分析器）</strong>对Token分析，产生Syntax Tree（语法树），采用Context-free Grammar。</p>\n<p><strong>Syntax Tree</strong>是以expression为节点的树。</p>\n<p>yacc（Yet Another Compiler Compiler）可根据用户给定的语法规则对输入记号序列进行解析，从而构建语法树。对于不同语言，编译器开发者只需改变语法规则。</p>\n<p><em>语法分析只完成了对表达式的语言层面的分析，但是无法判断语句的真正意义</em></p>\n</li>\n<li><p>语义分析</p>\n<p><strong>Semantic Analyzer（语义分析器）</strong>：可以分析静态语义（Static Semantic），包括声明、类型的匹配，类型的转换。同时，动态语义（Dynamic Semantiv）只有在运行期才能确定。</p>\n</li>\n<li><p>中间语言生成</p>\n<p><strong>Source Code Optimizer（源码级优化器）</strong>：源码级别的一个优化过程。生成Intermediate Code（中间代码）。中间代码有很多类型，比较常见的是Three-address Code（三地址码）。</p>\n<p>Intermediate code 将编译器分为前端和后端，之前所描述的部分为前端，之后则为后端。</p>\n</li>\n<li><p>编译器后端</p>\n<p>后端包括：Code generator（代码生成器）和Target Code Optimizer（目标代码优化器）</p>\n<p>Code generator转化成目标机器代码</p>\n<p>Target Code Optimizer优化目标机器代码，选择合适的寻址方式、使用位移来代替乘法运算。</p>\n</li>\n<li><p>conclusion</p>\n<p>现在的编译器随着CPU的进化而变得复杂，比如GCC编译器几乎支持所有CPU平台。</p>\n<p>生成了目标代码后，有一个问题：index和array的地址还没有确定。如果代码中有变量定义在其他模块，在最终运行时，他们都要在最终连接时才能确定。现在的编译器可将一个源代码文件编译成一个未连接的目标文件，然后由编译器最终将目标文件连接成可执行文件。</p>\n</li>\n</ol>\n<h2 id=\"2-3-链接器\"><a href=\"#2-3-链接器\" class=\"headerlink\" title=\"2.3 链接器\"></a>2.3 链接器</h2><p>静态链接</p>\n<p>链接：将一些指令对其他符号地址的引用进行修正，包括地址空间分配、符号决议、重定位(Relocation)。</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/06/Screen-Shot-2020-02-06-at-10.54.56-PM.png\" alt=\"链接过程\"></p>\n<h1 id=\"第三章-Object-File（目标文件）\"><a href=\"#第三章-Object-File（目标文件）\" class=\"headerlink\" title=\"第三章 Object File（目标文件）\"></a>第三章 Object File（目标文件）</h1><p><img src=\"https://img.cetacis.dev/uploads/2020/02/07/Screen-Shot-2020-02-07-at-7.23.06-PM.png\" alt=\"文件格式\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$file foobar.o  &#x2F;&#x2F;查看类型</span><br></pre></td></tr></table></figure>\n\n<p>EFL(Executable Linkable Format)： 可执行（目标）文件格式（Linex系统，windows是PE）</p>\n<p>目标文件：源代码编译后但是没有进行链接的中间文件，和可执行文件的内容结构相似，采用一种格式储存。</p>\n<h2 id=\"3-1-EFL文件格式\"><a href=\"#3-1-EFL文件格式\" class=\"headerlink\" title=\"3.1 EFL文件格式\"></a>3.1 EFL文件格式</h2><p><img src=\"https://img.cetacis.dev/uploads/2020/02/07/Screen-Shot-2020-02-07-at-7.43.09-PM.png\" alt=\"可执行文件组成\"></p>\n<ul>\n<li><p>目标文件包含：编译后的机器指令代码、数据、连接时所需信息（符号表、调试信息、字符串）</p>\n<p>存储形式：节（Section）/段（Segment）注：<em>余文皆为段</em></p>\n<ul>\n<li><p>文件头：文件属性、文件是否可执行、静态链接/动态链接及入口地址、目标硬件/操作系统。包含一个<strong>段表</strong>，描述文件中各个段的数组。</p>\n<p>文件头后就是各个段的内容。</p>\n</li>\n<li><p>编译后的执行语句编译成机械代码：.text段</p>\n</li>\n<li><p>已初始化的全局变量局部变量静态变量：.data段</p>\n</li>\n<li><p>未初始化的全局变量/局部静态变量：.bss（默认为0，没必要在.data分配空间）（为未初始化的全局变量和局部静态变量的大小总和，无内容不占空间）</p>\n</li>\n</ul>\n</li>\n<li><p>程序源代码编译后被分为两种段：程序指令、程序数据。</p>\n<p>代码段：程序指令。数据段，.bss：程序数据</p>\n</li>\n<li><p>指令数据分离存储的意义：</p>\n<ul>\n<li>数据rw- 指令r–</li>\n<li>cashe数据指令分离</li>\n<li><strong>指令共享</strong>——节约空间</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3-2-EFL文件实例\"><a href=\"#3-2-EFL文件实例\" class=\"headerlink\" title=\"3.2 EFL文件实例\"></a>3.2 EFL文件实例</h2><ul>\n<li><p><strong>-c 代表只编译不链接</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$gcc -c SimpleSection.c</span><br></pre></td></tr></table></figure>\n\n<p>我们会得到一个SimpleSection.o的目标文件</p>\n</li>\n<li><p>我们可以通过<strong>objdump</strong>查看object内部结构</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$objdump -h SimpleSection.o</span><br></pre></td></tr></table></figure>\n\n<p><strong>-h</strong> 代表将EFL文件各个段的信息打印，<strong>-x</strong>则会打印更多信息。</p>\n<p><strong>readelf</strong>是Linux的工具</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/07/Screen-Shot-2020-02-07-at-8.20.24-PM.png\" alt=\"目标文件EFL\"></p>\n</li>\n</ul>\n<p>如图，除了基础的.text/.data/.bss，还有.rodata(只读数据段)，.comment(注释信息段)和.note.GNU-stack（堆栈提示段）。</p>\n<ul>\n<li><p>读这段object信息：</p>\n<ul>\n<li>size是段长度，File off是段的位置（偏移量）</li>\n<li>CONTENTS代表此段在文件中存在</li>\n</ul>\n<p>他们在ELF中的结构如图：</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/07/Screen-Shot-2020-02-07-at-8.30.12-PM.png\" alt=\"SimpleSection.o\"></p>\n</li>\n<li><p><strong>size</strong>指令：用来查看ELF文件各段长度</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/07/Screen-Shot-2020-02-07-at-8.44.53-PM.png\" alt=\"size\"></p>\n</li>\n</ul>\n<h2 id=\"3-3-ELF文件详细内容\"><a href=\"#3-3-ELF文件详细内容\" class=\"headerlink\" title=\"3.3 ELF文件详细内容\"></a>3.3 ELF文件详细内容</h2><h3 id=\"代码段\"><a href=\"#代码段\" class=\"headerlink\" title=\"代码段\"></a>代码段</h3><p><strong>objdump</strong>的<strong>-s</strong>参数可以将所有段的内容以16进制打印，<strong>-d</strong>可将所有包含指令的段反汇编</p>\n<p>我们可将objdump输出中关于代码段的内容提取，分析内容。</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/07/Screen-Shot-2020-02-07-at-8.49.58-PM.png\" alt=\".text\"></p>\n<p>Contents of section 是.text以16进制打印。最左为偏移量，中间四列是十六进制内容，最右一列是.text段的ASCII码。</p>\n<p>下面反汇编的结果，.text包含SimpleSection.c的func1()和main()指令。</p>\n<p>0x55对应push %ebp 0xc3对应ret</p>\n<h3 id=\"data-rodata\"><a href=\"#data-rodata\" class=\"headerlink\" title=\".data .rodata\"></a>.data .rodata</h3><h3 id=\"bss\"><a href=\"#bss\" class=\"headerlink\" title=\".bss\"></a>.bss</h3><h3 id=\"others\"><a href=\"#others\" class=\"headerlink\" title=\"others\"></a>others</h3><p><img src=\"https://img.cetacis.dev/uploads/2020/02/07/Screen-Shot-2020-02-07-at-8.56.46-PM.png\" alt=\"ELF常见段\"></p>\n<h3 id=\"文件头\"><a href=\"#文件头\" class=\"headerlink\" title=\"文件头\"></a>文件头</h3><p><strong>readelf</strong>可用于详细查看ELF文件</p>\n<p><strong>-h</strong>查看文件头</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/07/Screen-Shot-2020-02-07-at-9.02.15-PM.png\" alt=\"文件头\"></p>\n<p>ELF相关常数定义在“/usr/include/elf.h”</p>\n<p>如图所示：</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/07/Screen-Shot-2020-02-07-at-9.12.45-PM.png\" alt=\"elf.h\"></p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/07/Screen-Shot-2020-02-07-at-9.12.52-PM.png\" alt=\".elf文件意义\"></p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/07/Screen-Shot-2020-02-07-at-9.12.56-PM.png\" alt=\"readelf输出结果与意义\"></p>\n<h3 id=\"e-ident\"><a href=\"#e-ident\" class=\"headerlink\" title=\"e_ident\"></a>e_ident</h3><ul>\n<li>魔数(magic)</li>\n</ul>\n<p>几乎所有可执行文件格式的最开始几个字节都是魔数。比如a.out开始是ox01 ox07等。</p>\n<p>作用：确定文件类型。操作系统在加载可执行文件时会确定魔数是否正确，否则拒绝加载。</p>\n<ul>\n<li><p>版本(Version) 最新1.2</p>\n</li>\n<li><p>文件类型 e_type</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/07/Screen-Shot-2020-02-07-at-9.17.54-PM.png\" alt=\"e_type\"></p>\n</li>\n<li><p>机械类型 e_machine</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/07/Screen-Shot-2020-02-07-at-9.20.48-PM.png\" alt=\"e_machine\"></p>\n</li>\n<li><p>段表</p>\n<p>保存段的基本属性（段名、段长度、文件偏移、读写权限、其他属性）</p>\n<p>编译器、链接器、装载器依靠段表定位访问各段属性</p>\n<p>查看方式：</p>\n<ul>\n<li><strong>objump -h</strong>      #简要信息</li>\n<li>*<em>readelf -S *</em>       #详细信息</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>重定位表</p>\n<p>.rel.text （相对位置定位表）</p>\n</li>\n<li><p>字符串表</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/07/Screen-Shot-2020-02-07-at-9.30.54-PM.png\" alt=\"字符串表\"></p>\n</li>\n</ul>\n<h2 id=\"3-4-链接的接口——符号\"><a href=\"#3-4-链接的接口——符号\" class=\"headerlink\" title=\"3.4 链接的接口——符号\"></a>3.4 链接的接口——符号</h2><p>在连接中，函数和变量统称为<strong>符号（Symbol）</strong>，函数名和变量名就是<strong>符号名（Symbol Name)</strong>。</p>\n<p>每一个目标文件有一个对应的<strong>符号表（Symbol Table）</strong>。每一个符号都有一个相应的值，叫做<strong>符号值（Symbol Value）</strong>。对于变量、函数，符号值就是他们的地址。</p>\n<h3 id=\"符号分类\"><a href=\"#符号分类\" class=\"headerlink\" title=\"符号分类\"></a>符号分类</h3><ul>\n<li>定义在本目标文件的全局符号，可被其他目标文件引用：main, func1, global_init_var</li>\n<li>*定义在其他文件中的全局符号：printf</li>\n<li>段名 该段的起始地址：.text,.data</li>\n<li>局部符号，只在本编译单元可见：static_var, statoc_var2。这些局部符号对于链接没有作用。</li>\n<li>行号信息 目标文件指令与源代码代码行的对应关系。（可选）、</li>\n</ul>\n<p>1.2 重要，345对于其它目标文件不可见，在链接过程中无关紧要。</p>\n<p><strong>nm</strong>可用来查看符号</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/07/Screen-Shot-2020-02-07-at-9.53.31-PM.png\" alt=\"查看符号\"></p>\n<h3 id=\"符号表结构\"><a href=\"#符号表结构\" class=\"headerlink\" title=\"符号表结构\"></a>符号表结构</h3><p>符号表是.<strong>symtab</strong>段</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/07/Screen-Shot-2020-02-07-at-10.04.27-PM.png\" alt=\"查看符号表\"></p>\n<h3 id=\"特殊符号\"><a href=\"#特殊符号\" class=\"headerlink\" title=\"特殊符号\"></a>特殊符号</h3><p>在使用ld链接器时，有一些可以直接声明引用的特殊符号，这些符号被定义在ld链接器的链接脚本中。</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/08/Screen-Shot-2020-02-08-at-10.10.34-PM.png\" alt=\"代表性特殊符号\"></p>\n<p>我们可以在程序中直接使用这些符号</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/08/Screen-Shot-2020-02-08-at-10.17.31-PM.png\" alt=\"在程序中直接使用符号\"></p>\n<h3 id=\"符号修饰机制与函数签名\"><a href=\"#符号修饰机制与函数签名\" class=\"headerlink\" title=\"符号修饰机制与函数签名\"></a>符号修饰机制与函数签名</h3><p>不同的函数可能拥有相同姓名，但是他的其他信息，比如参数类型、所在类、函数名等不同，因此他们拥有不同的<strong>函数签名（Function Signature）</strong>。函数签名用于识别不同的函数。</p>\n<p>编译器、链接器处理符号时，使用某种<strong>名称修改</strong>的方法，每个还是签名对应一个<strong>修改后名称</strong>。即在C++源代码编译成目标文件时，会将函数和变量名称进行修饰，形成符号名。</p>\n<p>名称修改机制也用来防止静态变量名称冲突。比如main()和func()中都含有静态变量foo，区分这两个变量，就会分别修饰名称，产生不同的符号名。</p>\n<p>不同编译器的名称修改机制不同。</p>\n<h3 id=\"extern-“C”\"><a href=\"#extern-“C”\" class=\"headerlink\" title=\"extern “C”\"></a>extern “C”</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">\"C\"</span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span></span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> var;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>C++将花括号内部代码当做C。因此如图的静态变量会对符号进行C语言的变量修饰。一般VS平台下会在名称前加_，但是linux的gcc不会如此修饰。</p>\n<p>当我们声明一些C语言的函数和全局变量时，在C++的编译单元中，这些函数和全局变量的符号会不能被链接，extern “C”在C中不被支持，所以我们需要先判断本编译单元是那种语言。</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/08/Screen-Shot-2020-02-08-at-10.42.04-PM.png\" alt=\"extern ”C“的应用\"></p>\n<p>_cplusplus是一种C++中定义的宏，判断此宏是否被定义可用以判断此编译单元的类型是C++与否。</p>\n<h3 id=\"强符号-弱符号\"><a href=\"#强符号-弱符号\" class=\"headerlink\" title=\"强符号/弱符号\"></a>强符号/弱符号</h3><ol>\n<li>编译器默认函数/初始化后的全局变量为强符号，未初始化的全局变量为若符号。但是我们可以通过</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__attribute__((weak)) weak2 &#x3D; 2;</span><br><span class=\"line\">__attribute__((weakref)) void foo();</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/08/Screen-Shot-2020-02-08-at-11.11.54-PM.png\" alt=\"强符号/弱符号\"></p>\n<p>如图：weak,weak2 为弱符号、strong,main()为强符号。ext是外部变量的引用，非强非弱。</p>\n<ol start=\"2\">\n<li><p><strong>链接器选择多次定义符号的原则：</strong></p>\n<p>(1)强不允许多次，否则报符号重复定义错误</p>\n<p>(2)选强</p>\n<p>(3)若都为弱，则选择占用最大的一个</p>\n</li>\n<li><p>弱符号和弱引用的应用</p>\n<p>库中定义的弱符号可被用户定义的强符号覆盖，从而使程序使用自定义版本的库函数</p>\n<p>程序可对某扩展功能模块的引用定义为弱引用，将扩展模块和程序链接在一起时，功能模块可正常使用。去掉这些模块也可正常连接，更利于程序功能的组合。</p>\n<p><em>还可以判断链接到多线程库或者单线程库</em></p>\n<p>gcc -lpthread可连接到多线程库</p>\n</li>\n</ol>\n<h2 id=\"3-5-调试信息\"><a href=\"#3-5-调试信息\" class=\"headerlink\" title=\"3.5 调试信息\"></a>3.5 调试信息</h2><p>现代编译器都支持源代码级别的调试。在gcc时加上-g参数，readelf发现object file里有很多”debug”段。</p>\n<p>ELF采用DWARF的标准调试信息格式，microsoft也有对应的格式叫codeview。debug段在目标文件和可执行文件中占有很大空间，甚至大过代码和数据本身。当开发完程序并发布时，我们可以去掉无用的调试信息。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$strip foo</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-6-小结\"><a href=\"#3-6-小结\" class=\"headerlink\" title=\"3.6 小结\"></a>3.6 小结</h2><p>（1）深入了解object file的文件格式——ELF</p>\n<p>（文件头 段表 重定位表 字符串表 符号表 调试表 代码段 数据段等段）</p>\n<p>（2）可执行文件、目标文件、库。实际上都是一样基于段的文件或者文件的集合。源代码经编译，代码数据分类后存放在相应的段中，编译器（汇编器）将辅助性信息（符号、重定位信息）按照表的形式存放在目标文件里。表在一般情况下就是段。（调试表 === debug段）</p>\n<p>（3）目标文件需要进一步通过符号/重定位信息链接，形成可使用程序。 </p>"},{"date":"2020-03-17T16:00:00.000Z","_content":"#### unity 实例\n\n**1. 引擎基于场景管理**\n\n场景节点管理：gameobject 添加 component\n\n基于工程文件的Assets：sound，3d meshes，textures，animaton，script，sprite，prefabs\n\n**hierarchy**\n\n**inspector **  transform light\n\n**2. 基本操作：**\n\n• 关联，通过鼠标拖\n• 创建预制件，Drag the Block from the Hierarchy panel into the Project\n\npanel to turn it into a Prefab\n<!-- more -->\n• 图像可以直接drag到project中作为素材(有时候不行，则右键点击asset， 到folder中查看，然后把图像拷贝到这个目录)，如果再拖动该图片到场 景中物体，则系统(自动产生材质，并关联到物体上)\n\n• 与脚本中的属性对应(可以拖动预制件或者产生终结点到脚本属性框)\n\n **3. 例一**\n\n![debug上面输出于console](https://img.cetacis.dev/uploads/big/5e1069240ca7098bf0d0faf5086712eb.png)\n\nstart()在开端运行，update()在每帧更新\n\n```c++\nvoid OnGUI () {\nGUI.Label(new Rect(30, 30, 100, 100), \"Hello World!\"); }\n```\n\n在scene中显示\n\n**4. 例二**\n\n表盘制作\n\n\n\n## 5. 场景管理\n\n场景管理架构\n\n* 场景的数据结构\n\n* 场景中的节点 \n\n* 包围盒 \n\n* 视锥裁剪 \n\n* 碰撞检测 \n\n* 混合排序\n\n*  多类型节点\n\n### 5.1 场景数据结构\n\ndata ： mesh, texture, character, sound ...\n\nData structure: array, list, tree, greaph ...\n\n我们的选择一般是树\n\n![](https://img.cetacis.dev/uploads/big/bcf01cfdbefbb7986eb25d5f92ec9ed4.png)\n\n**场景树的特点：**\n\n* 父子树的等级类型鲜明\n* 单一父节点，多子节点\n* 不能出现循环：子节点重新连到父节点\n* 数据包装在节点中\n* 子节点会受到父节点的影响。\n\n#### 5.2 功能节点\n\n![](https://img.cetacis.dev/uploads/big/c68db53c7f7c11240266fc0c5a9338b1.png)\n\n还有不同类型节点，比如switch节点：切换已有节点的状态\n\n#### 5.3 包围盒\n\n**定义**：用一个简单数据结构去表达对象的尺寸和位置。\n\n**类型**：包围立方体 包围球 包围不规则几何体\n\n包围立方体分类：\n\n* AABB包围盒（轴关联包围盒）：\n\n  ​\t平行于世界坐标系，与轴关联。方便计算但是贴合度不好","source":"_posts/数字娱乐架构上课笔记.md","raw":"---\ndate: 2020/3/18\ntags:\n- 上课笔记\n- unity\ncategories:\n- 游戏及图形学\n- 数字媒体架构上课笔记\n---\n#### unity 实例\n\n**1. 引擎基于场景管理**\n\n场景节点管理：gameobject 添加 component\n\n基于工程文件的Assets：sound，3d meshes，textures，animaton，script，sprite，prefabs\n\n**hierarchy**\n\n**inspector **  transform light\n\n**2. 基本操作：**\n\n• 关联，通过鼠标拖\n• 创建预制件，Drag the Block from the Hierarchy panel into the Project\n\npanel to turn it into a Prefab\n<!-- more -->\n• 图像可以直接drag到project中作为素材(有时候不行，则右键点击asset， 到folder中查看，然后把图像拷贝到这个目录)，如果再拖动该图片到场 景中物体，则系统(自动产生材质，并关联到物体上)\n\n• 与脚本中的属性对应(可以拖动预制件或者产生终结点到脚本属性框)\n\n **3. 例一**\n\n![debug上面输出于console](https://img.cetacis.dev/uploads/big/5e1069240ca7098bf0d0faf5086712eb.png)\n\nstart()在开端运行，update()在每帧更新\n\n```c++\nvoid OnGUI () {\nGUI.Label(new Rect(30, 30, 100, 100), \"Hello World!\"); }\n```\n\n在scene中显示\n\n**4. 例二**\n\n表盘制作\n\n\n\n## 5. 场景管理\n\n场景管理架构\n\n* 场景的数据结构\n\n* 场景中的节点 \n\n* 包围盒 \n\n* 视锥裁剪 \n\n* 碰撞检测 \n\n* 混合排序\n\n*  多类型节点\n\n### 5.1 场景数据结构\n\ndata ： mesh, texture, character, sound ...\n\nData structure: array, list, tree, greaph ...\n\n我们的选择一般是树\n\n![](https://img.cetacis.dev/uploads/big/bcf01cfdbefbb7986eb25d5f92ec9ed4.png)\n\n**场景树的特点：**\n\n* 父子树的等级类型鲜明\n* 单一父节点，多子节点\n* 不能出现循环：子节点重新连到父节点\n* 数据包装在节点中\n* 子节点会受到父节点的影响。\n\n#### 5.2 功能节点\n\n![](https://img.cetacis.dev/uploads/big/c68db53c7f7c11240266fc0c5a9338b1.png)\n\n还有不同类型节点，比如switch节点：切换已有节点的状态\n\n#### 5.3 包围盒\n\n**定义**：用一个简单数据结构去表达对象的尺寸和位置。\n\n**类型**：包围立方体 包围球 包围不规则几何体\n\n包围立方体分类：\n\n* AABB包围盒（轴关联包围盒）：\n\n  ​\t平行于世界坐标系，与轴关联。方便计算但是贴合度不好","slug":"数字娱乐架构上课笔记","published":1,"updated":"2020-03-25T01:38:28.000Z","title":"数字娱乐架构上课笔记","_id":"ck849avar000ethesg7jz7nfq","comments":1,"layout":"post","photos":[],"link":"","content":"<h4 id=\"unity-实例\"><a href=\"#unity-实例\" class=\"headerlink\" title=\"unity 实例\"></a>unity 实例</h4><p><strong>1. 引擎基于场景管理</strong></p>\n<p>场景节点管理：gameobject 添加 component</p>\n<p>基于工程文件的Assets：sound，3d meshes，textures，animaton，script，sprite，prefabs</p>\n<p><strong>hierarchy</strong></p>\n<p>*<em>inspector *</em>  transform light</p>\n<p><strong>2. 基本操作：</strong></p>\n<p>• 关联，通过鼠标拖<br>• 创建预制件，Drag the Block from the Hierarchy panel into the Project</p>\n<p>panel to turn it into a Prefab</p>\n<a id=\"more\"></a>\n<p>• 图像可以直接drag到project中作为素材(有时候不行，则右键点击asset， 到folder中查看，然后把图像拷贝到这个目录)，如果再拖动该图片到场 景中物体，则系统(自动产生材质，并关联到物体上)</p>\n<p>• 与脚本中的属性对应(可以拖动预制件或者产生终结点到脚本属性框)</p>\n<p> <strong>3. 例一</strong></p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/5e1069240ca7098bf0d0faf5086712eb.png\" alt=\"debug上面输出于console\"></p>\n<p>start()在开端运行，update()在每帧更新</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">OnGUI</span> <span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">GUI.Label(<span class=\"keyword\">new</span> Rect(<span class=\"number\">30</span>, <span class=\"number\">30</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>), <span class=\"string\">\"Hello World!\"</span>); &#125;</span><br></pre></td></tr></table></figure>\n\n<p>在scene中显示</p>\n<p><strong>4. 例二</strong></p>\n<p>表盘制作</p>\n<h2 id=\"5-场景管理\"><a href=\"#5-场景管理\" class=\"headerlink\" title=\"5. 场景管理\"></a>5. 场景管理</h2><p>场景管理架构</p>\n<ul>\n<li><p>场景的数据结构</p>\n</li>\n<li><p>场景中的节点 </p>\n</li>\n<li><p>包围盒 </p>\n</li>\n<li><p>视锥裁剪 </p>\n</li>\n<li><p>碰撞检测 </p>\n</li>\n<li><p>混合排序</p>\n</li>\n<li><p>多类型节点</p>\n</li>\n</ul>\n<h3 id=\"5-1-场景数据结构\"><a href=\"#5-1-场景数据结构\" class=\"headerlink\" title=\"5.1 场景数据结构\"></a>5.1 场景数据结构</h3><p>data ： mesh, texture, character, sound …</p>\n<p>Data structure: array, list, tree, greaph …</p>\n<p>我们的选择一般是树</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/bcf01cfdbefbb7986eb25d5f92ec9ed4.png\" alt=\"\"></p>\n<p><strong>场景树的特点：</strong></p>\n<ul>\n<li>父子树的等级类型鲜明</li>\n<li>单一父节点，多子节点</li>\n<li>不能出现循环：子节点重新连到父节点</li>\n<li>数据包装在节点中</li>\n<li>子节点会受到父节点的影响。</li>\n</ul>\n<h4 id=\"5-2-功能节点\"><a href=\"#5-2-功能节点\" class=\"headerlink\" title=\"5.2 功能节点\"></a>5.2 功能节点</h4><p><img src=\"https://img.cetacis.dev/uploads/big/c68db53c7f7c11240266fc0c5a9338b1.png\" alt=\"\"></p>\n<p>还有不同类型节点，比如switch节点：切换已有节点的状态</p>\n<h4 id=\"5-3-包围盒\"><a href=\"#5-3-包围盒\" class=\"headerlink\" title=\"5.3 包围盒\"></a>5.3 包围盒</h4><p><strong>定义</strong>：用一个简单数据结构去表达对象的尺寸和位置。</p>\n<p><strong>类型</strong>：包围立方体 包围球 包围不规则几何体</p>\n<p>包围立方体分类：</p>\n<ul>\n<li><p>AABB包围盒（轴关联包围盒）：</p>\n<p>​    平行于世界坐标系，与轴关联。方便计算但是贴合度不好</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h4 id=\"unity-实例\"><a href=\"#unity-实例\" class=\"headerlink\" title=\"unity 实例\"></a>unity 实例</h4><p><strong>1. 引擎基于场景管理</strong></p>\n<p>场景节点管理：gameobject 添加 component</p>\n<p>基于工程文件的Assets：sound，3d meshes，textures，animaton，script，sprite，prefabs</p>\n<p><strong>hierarchy</strong></p>\n<p>*<em>inspector *</em>  transform light</p>\n<p><strong>2. 基本操作：</strong></p>\n<p>• 关联，通过鼠标拖<br>• 创建预制件，Drag the Block from the Hierarchy panel into the Project</p>\n<p>panel to turn it into a Prefab</p>","more":"<p>• 图像可以直接drag到project中作为素材(有时候不行，则右键点击asset， 到folder中查看，然后把图像拷贝到这个目录)，如果再拖动该图片到场 景中物体，则系统(自动产生材质，并关联到物体上)</p>\n<p>• 与脚本中的属性对应(可以拖动预制件或者产生终结点到脚本属性框)</p>\n<p> <strong>3. 例一</strong></p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/5e1069240ca7098bf0d0faf5086712eb.png\" alt=\"debug上面输出于console\"></p>\n<p>start()在开端运行，update()在每帧更新</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">OnGUI</span> <span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">GUI.Label(<span class=\"keyword\">new</span> Rect(<span class=\"number\">30</span>, <span class=\"number\">30</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>), <span class=\"string\">\"Hello World!\"</span>); &#125;</span><br></pre></td></tr></table></figure>\n\n<p>在scene中显示</p>\n<p><strong>4. 例二</strong></p>\n<p>表盘制作</p>\n<h2 id=\"5-场景管理\"><a href=\"#5-场景管理\" class=\"headerlink\" title=\"5. 场景管理\"></a>5. 场景管理</h2><p>场景管理架构</p>\n<ul>\n<li><p>场景的数据结构</p>\n</li>\n<li><p>场景中的节点 </p>\n</li>\n<li><p>包围盒 </p>\n</li>\n<li><p>视锥裁剪 </p>\n</li>\n<li><p>碰撞检测 </p>\n</li>\n<li><p>混合排序</p>\n</li>\n<li><p>多类型节点</p>\n</li>\n</ul>\n<h3 id=\"5-1-场景数据结构\"><a href=\"#5-1-场景数据结构\" class=\"headerlink\" title=\"5.1 场景数据结构\"></a>5.1 场景数据结构</h3><p>data ： mesh, texture, character, sound …</p>\n<p>Data structure: array, list, tree, greaph …</p>\n<p>我们的选择一般是树</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/bcf01cfdbefbb7986eb25d5f92ec9ed4.png\" alt=\"\"></p>\n<p><strong>场景树的特点：</strong></p>\n<ul>\n<li>父子树的等级类型鲜明</li>\n<li>单一父节点，多子节点</li>\n<li>不能出现循环：子节点重新连到父节点</li>\n<li>数据包装在节点中</li>\n<li>子节点会受到父节点的影响。</li>\n</ul>\n<h4 id=\"5-2-功能节点\"><a href=\"#5-2-功能节点\" class=\"headerlink\" title=\"5.2 功能节点\"></a>5.2 功能节点</h4><p><img src=\"https://img.cetacis.dev/uploads/big/c68db53c7f7c11240266fc0c5a9338b1.png\" alt=\"\"></p>\n<p>还有不同类型节点，比如switch节点：切换已有节点的状态</p>\n<h4 id=\"5-3-包围盒\"><a href=\"#5-3-包围盒\" class=\"headerlink\" title=\"5.3 包围盒\"></a>5.3 包围盒</h4><p><strong>定义</strong>：用一个简单数据结构去表达对象的尺寸和位置。</p>\n<p><strong>类型</strong>：包围立方体 包围球 包围不规则几何体</p>\n<p>包围立方体分类：</p>\n<ul>\n<li><p>AABB包围盒（轴关联包围盒）：</p>\n<p>​    平行于世界坐标系，与轴关联。方便计算但是贴合度不好</p>\n</li>\n</ul>"},{"date":"2020-02-03T16:00:00.000Z","_content":"### Nginx\n\n1. 轻量级，采用 C 进行编写，同样的 web 服务，会占用更少的内存及资源\n2. 抗并发，nginx 以 epoll and kqueue 作为开发模型，处理请求是异步非阻塞的，负载能力比 apache 高很多，而 apache 则是阻塞型的。在高并发下 nginx 能保持低资源低消耗高性能 ，而 apache 在 PHP 处理慢或者前端压力很大的情况下，很容易出现进程数飙升，从而拒绝服务的现象。\n3. nginx 处理静态文件好，静态处理性能比 apache 高三倍以上\n4. nginx 的设计高度模块化，编写模块相对简单\n<!-- more -->\n5. nginx 配置简洁，正则配置让很多事情变得简单，而且改完配置能使用 -t 测试配置有没有问题，apache 配置复杂 ，重启的时候发现配置出错了，会很崩溃\n6. nginx 作为负载均衡服务器，支持 7 层负载均衡\n7. nginx 本身就是一个反向代理服务器，而且可以作为非常优秀的邮件代理服务器\n8. 启动特别容易, 并且几乎可以做到 7*24 不间断运行，即使运行数个月也不需要重新启动，还能够不间断服务的情况下进行软件版本的升级\n9. 社区活跃，各种高性能模块出品迅速\n\n### Apache\n\n1. apache 的 rewrite 比 nginx 强大，在 rewrite 频繁的情况下，用 apache\n2. apache 发展到现在，模块超多，基本想到的都可以找到\n3. apache 更为成熟，少 bug ，nginx 的 bug 相对较多\n4. apache 超稳定\n5. apache 对 PHP 支持比较简单，nginx 需要配合其他后端用\n6. apache 在处理动态请求有优势，nginx 在这方面是鸡肋，一般动态请求要 apache 去做，nginx 适合静态和反向。\n7. apache 仍然是目前的主流，拥有丰富的特性，成熟的技术和开发社区\n\n### 总结\n\n两者最核心的区别在于 apache 是同步多进程模型，一个连接对应一个进程，而 nginx 是异步的，多个连接（万级别）可以对应一个进程\n\n一般来说，需要性能的 web 服务，用 nginx 。如果不需要性能只求稳定，更考虑 apache ，后者的各种功能模块实现得比前者，例如 ssl 的模块就比前者好，可配置项多。epoll(freebsd 上是 kqueue ) 网络 IO 模型是 nginx 处理性能高的根本理由，但并不是所有的情况下都是 epoll 大获全胜的，如果本身提供静态服务的就只有寥寥几个文件，apache 的 select 模型或许比 epoll 更高性能。当然，这只是根据网络 IO 模型的原理作的一个假设，真正的应用还是需要实测了再说的。\n\n## 更为通用的方案是，前端 nginx 抗并发，后端 apache 集群，配合起来会更好。\n\nApache中, 当不加配置的时候, 对于PHP脚本, AcceptPathInfo是默认接受的\nnginx默认不支持PathInfo，需要修改配置\n\n[网络设置基础](http://anata.me/2018/05/09/写给前端小白看的linux部署基础知识/)\n\n\n\n","source":"_posts/nginx&apache.md","raw":"---\ndate: 2020/2/4\ntags:\n- 计算机网络\n- 代理\ncategories:\n- 计算机网络\n- nginx & apache\n---\n### Nginx\n\n1. 轻量级，采用 C 进行编写，同样的 web 服务，会占用更少的内存及资源\n2. 抗并发，nginx 以 epoll and kqueue 作为开发模型，处理请求是异步非阻塞的，负载能力比 apache 高很多，而 apache 则是阻塞型的。在高并发下 nginx 能保持低资源低消耗高性能 ，而 apache 在 PHP 处理慢或者前端压力很大的情况下，很容易出现进程数飙升，从而拒绝服务的现象。\n3. nginx 处理静态文件好，静态处理性能比 apache 高三倍以上\n4. nginx 的设计高度模块化，编写模块相对简单\n<!-- more -->\n5. nginx 配置简洁，正则配置让很多事情变得简单，而且改完配置能使用 -t 测试配置有没有问题，apache 配置复杂 ，重启的时候发现配置出错了，会很崩溃\n6. nginx 作为负载均衡服务器，支持 7 层负载均衡\n7. nginx 本身就是一个反向代理服务器，而且可以作为非常优秀的邮件代理服务器\n8. 启动特别容易, 并且几乎可以做到 7*24 不间断运行，即使运行数个月也不需要重新启动，还能够不间断服务的情况下进行软件版本的升级\n9. 社区活跃，各种高性能模块出品迅速\n\n### Apache\n\n1. apache 的 rewrite 比 nginx 强大，在 rewrite 频繁的情况下，用 apache\n2. apache 发展到现在，模块超多，基本想到的都可以找到\n3. apache 更为成熟，少 bug ，nginx 的 bug 相对较多\n4. apache 超稳定\n5. apache 对 PHP 支持比较简单，nginx 需要配合其他后端用\n6. apache 在处理动态请求有优势，nginx 在这方面是鸡肋，一般动态请求要 apache 去做，nginx 适合静态和反向。\n7. apache 仍然是目前的主流，拥有丰富的特性，成熟的技术和开发社区\n\n### 总结\n\n两者最核心的区别在于 apache 是同步多进程模型，一个连接对应一个进程，而 nginx 是异步的，多个连接（万级别）可以对应一个进程\n\n一般来说，需要性能的 web 服务，用 nginx 。如果不需要性能只求稳定，更考虑 apache ，后者的各种功能模块实现得比前者，例如 ssl 的模块就比前者好，可配置项多。epoll(freebsd 上是 kqueue ) 网络 IO 模型是 nginx 处理性能高的根本理由，但并不是所有的情况下都是 epoll 大获全胜的，如果本身提供静态服务的就只有寥寥几个文件，apache 的 select 模型或许比 epoll 更高性能。当然，这只是根据网络 IO 模型的原理作的一个假设，真正的应用还是需要实测了再说的。\n\n## 更为通用的方案是，前端 nginx 抗并发，后端 apache 集群，配合起来会更好。\n\nApache中, 当不加配置的时候, 对于PHP脚本, AcceptPathInfo是默认接受的\nnginx默认不支持PathInfo，需要修改配置\n\n[网络设置基础](http://anata.me/2018/05/09/写给前端小白看的linux部署基础知识/)\n\n\n\n","slug":"nginx-apache","published":1,"updated":"2020-03-27T15:04:39.000Z","title":"nginx-apache","comments":1,"layout":"post","photos":[],"link":"","_id":"ck985a7770000slqg9sbp9xme","content":"<h3 id=\"Nginx\"><a href=\"#Nginx\" class=\"headerlink\" title=\"Nginx\"></a>Nginx</h3><ol>\n<li>轻量级，采用 C 进行编写，同样的 web 服务，会占用更少的内存及资源</li>\n<li>抗并发，nginx 以 epoll and kqueue 作为开发模型，处理请求是异步非阻塞的，负载能力比 apache 高很多，而 apache 则是阻塞型的。在高并发下 nginx 能保持低资源低消耗高性能 ，而 apache 在 PHP 处理慢或者前端压力很大的情况下，很容易出现进程数飙升，从而拒绝服务的现象。</li>\n<li>nginx 处理静态文件好，静态处理性能比 apache 高三倍以上</li>\n<li>nginx 的设计高度模块化，编写模块相对简单<a id=\"more\"></a></li>\n<li>nginx 配置简洁，正则配置让很多事情变得简单，而且改完配置能使用 -t 测试配置有没有问题，apache 配置复杂 ，重启的时候发现配置出错了，会很崩溃</li>\n<li>nginx 作为负载均衡服务器，支持 7 层负载均衡</li>\n<li>nginx 本身就是一个反向代理服务器，而且可以作为非常优秀的邮件代理服务器</li>\n<li>启动特别容易, 并且几乎可以做到 7*24 不间断运行，即使运行数个月也不需要重新启动，还能够不间断服务的情况下进行软件版本的升级</li>\n<li>社区活跃，各种高性能模块出品迅速</li>\n</ol>\n<h3 id=\"Apache\"><a href=\"#Apache\" class=\"headerlink\" title=\"Apache\"></a>Apache</h3><ol>\n<li>apache 的 rewrite 比 nginx 强大，在 rewrite 频繁的情况下，用 apache</li>\n<li>apache 发展到现在，模块超多，基本想到的都可以找到</li>\n<li>apache 更为成熟，少 bug ，nginx 的 bug 相对较多</li>\n<li>apache 超稳定</li>\n<li>apache 对 PHP 支持比较简单，nginx 需要配合其他后端用</li>\n<li>apache 在处理动态请求有优势，nginx 在这方面是鸡肋，一般动态请求要 apache 去做，nginx 适合静态和反向。</li>\n<li>apache 仍然是目前的主流，拥有丰富的特性，成熟的技术和开发社区</li>\n</ol>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>两者最核心的区别在于 apache 是同步多进程模型，一个连接对应一个进程，而 nginx 是异步的，多个连接（万级别）可以对应一个进程</p>\n<p>一般来说，需要性能的 web 服务，用 nginx 。如果不需要性能只求稳定，更考虑 apache ，后者的各种功能模块实现得比前者，例如 ssl 的模块就比前者好，可配置项多。epoll(freebsd 上是 kqueue ) 网络 IO 模型是 nginx 处理性能高的根本理由，但并不是所有的情况下都是 epoll 大获全胜的，如果本身提供静态服务的就只有寥寥几个文件，apache 的 select 模型或许比 epoll 更高性能。当然，这只是根据网络 IO 模型的原理作的一个假设，真正的应用还是需要实测了再说的。</p>\n<h2 id=\"更为通用的方案是，前端-nginx-抗并发，后端-apache-集群，配合起来会更好。\"><a href=\"#更为通用的方案是，前端-nginx-抗并发，后端-apache-集群，配合起来会更好。\" class=\"headerlink\" title=\"更为通用的方案是，前端 nginx 抗并发，后端 apache 集群，配合起来会更好。\"></a>更为通用的方案是，前端 nginx 抗并发，后端 apache 集群，配合起来会更好。</h2><p>Apache中, 当不加配置的时候, 对于PHP脚本, AcceptPathInfo是默认接受的<br>nginx默认不支持PathInfo，需要修改配置</p>\n<p><a href=\"http://anata.me/2018/05/09/写给前端小白看的linux部署基础知识/\" target=\"_blank\" rel=\"noopener\">网络设置基础</a></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"Nginx\"><a href=\"#Nginx\" class=\"headerlink\" title=\"Nginx\"></a>Nginx</h3><ol>\n<li>轻量级，采用 C 进行编写，同样的 web 服务，会占用更少的内存及资源</li>\n<li>抗并发，nginx 以 epoll and kqueue 作为开发模型，处理请求是异步非阻塞的，负载能力比 apache 高很多，而 apache 则是阻塞型的。在高并发下 nginx 能保持低资源低消耗高性能 ，而 apache 在 PHP 处理慢或者前端压力很大的情况下，很容易出现进程数飙升，从而拒绝服务的现象。</li>\n<li>nginx 处理静态文件好，静态处理性能比 apache 高三倍以上</li>\n<li>nginx 的设计高度模块化，编写模块相对简单","more":"</li>\n<li>nginx 配置简洁，正则配置让很多事情变得简单，而且改完配置能使用 -t 测试配置有没有问题，apache 配置复杂 ，重启的时候发现配置出错了，会很崩溃</li>\n<li>nginx 作为负载均衡服务器，支持 7 层负载均衡</li>\n<li>nginx 本身就是一个反向代理服务器，而且可以作为非常优秀的邮件代理服务器</li>\n<li>启动特别容易, 并且几乎可以做到 7*24 不间断运行，即使运行数个月也不需要重新启动，还能够不间断服务的情况下进行软件版本的升级</li>\n<li>社区活跃，各种高性能模块出品迅速</li>\n</ol>\n<h3 id=\"Apache\"><a href=\"#Apache\" class=\"headerlink\" title=\"Apache\"></a>Apache</h3><ol>\n<li>apache 的 rewrite 比 nginx 强大，在 rewrite 频繁的情况下，用 apache</li>\n<li>apache 发展到现在，模块超多，基本想到的都可以找到</li>\n<li>apache 更为成熟，少 bug ，nginx 的 bug 相对较多</li>\n<li>apache 超稳定</li>\n<li>apache 对 PHP 支持比较简单，nginx 需要配合其他后端用</li>\n<li>apache 在处理动态请求有优势，nginx 在这方面是鸡肋，一般动态请求要 apache 去做，nginx 适合静态和反向。</li>\n<li>apache 仍然是目前的主流，拥有丰富的特性，成熟的技术和开发社区</li>\n</ol>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>两者最核心的区别在于 apache 是同步多进程模型，一个连接对应一个进程，而 nginx 是异步的，多个连接（万级别）可以对应一个进程</p>\n<p>一般来说，需要性能的 web 服务，用 nginx 。如果不需要性能只求稳定，更考虑 apache ，后者的各种功能模块实现得比前者，例如 ssl 的模块就比前者好，可配置项多。epoll(freebsd 上是 kqueue ) 网络 IO 模型是 nginx 处理性能高的根本理由，但并不是所有的情况下都是 epoll 大获全胜的，如果本身提供静态服务的就只有寥寥几个文件，apache 的 select 模型或许比 epoll 更高性能。当然，这只是根据网络 IO 模型的原理作的一个假设，真正的应用还是需要实测了再说的。</p>\n<h2 id=\"更为通用的方案是，前端-nginx-抗并发，后端-apache-集群，配合起来会更好。\"><a href=\"#更为通用的方案是，前端-nginx-抗并发，后端-apache-集群，配合起来会更好。\" class=\"headerlink\" title=\"更为通用的方案是，前端 nginx 抗并发，后端 apache 集群，配合起来会更好。\"></a>更为通用的方案是，前端 nginx 抗并发，后端 apache 集群，配合起来会更好。</h2><p>Apache中, 当不加配置的时候, 对于PHP脚本, AcceptPathInfo是默认接受的<br>nginx默认不支持PathInfo，需要修改配置</p>\n<p><a href=\"http://anata.me/2018/05/09/写给前端小白看的linux部署基础知识/\" target=\"_blank\" rel=\"noopener\">网络设置基础</a></p>"},{"date":"2020-04-07T16:00:00.000Z","_content":"## Stack view (get the Auto layout contraints)\n\nlibrary ->stackview (horizontal/vertegal doesen't matter\n\n* drag the elements into the stackview and change the ***Aligment*** and ***Distribution*** in the property bar.  \n\nwe can use the stack view to manage many elements and their layout.\n\n*change the **backgroud** of button to give it texture*\n\n* add ***horizantally in container*** and ***vertically in container***\n\n  ![](https://img.cetacis.dev/uploads/big/bef4430bb6422d782a0f03e1e5cb6ad9.png)\n\n  \n\n*everything have to have constrains*\n\n* when we use the imageview to set the background, we'd uncheck the ***constraint margins*** and set the 0 to the ***view***(not the safe area). \n\n  Set the ***Content Mode*** to Aspect fill.\n\n* ***Content Compression Resistance Priority***: decide the priority of whether the picture will be compressed (default for 750)\n\n![resistance for priority](https://img.cetacis.dev/uploads/big/dc59c99442768426ad4f8bffc968975a.png)\n\n​\t***Content Hugging Priority***: the same when the zone is too big.\n\n<!-- more -->\n\n## Vary layout\n\n* when change the iphone to the horizontal, maybe them will be a strange issure\n\n  ```\n  an internal error occured\n  ```\n\n  So, **Save the project **before the change and after the issure, project->clean the build folder, then alt+Q to quit xcode and relaunch it.\n\n* Making the exiting stack view and an laber(or other elements) to be a new stackview is possible. And xcode can make them be oriented. \n\n**The button is near the Add constrains button**\n\n* add the certain constrains to the certain device. \n\n![](https://img.cetacis.dev/uploads/big/6f6cdb5be94afdba4d1c01d511771bc5.png)\n\nSize class : wC hC ; wC hR; wR hR (C: compact R:regular)\n\n### **vary  for traits** \n\nthe in the certain size class's stack view's Spacing, click the + and add the variation.\n\n* when want to link to element, hold the ***control*** and the element and make a blue line link to the other element\n\n![](https://img.cetacis.dev/uploads/big/888c8a380b4d5b34df6dc089ad3b9a03.png)\n\n* Lable should link to other elements in three or four directions and the other element should have higher hugging prority the lable so that only the lable will be stretch to fill up any remaining space.\n\n## Swift\n\n### basic\n\nlet: constant  var: variable\n\n```swift\nvar i = 32 \nvar i:Int = 32\nvar u:Int? // optionals\nvar g = abs(-1) // absolute value\nvar h = ceil(1.8)  // get the top number\nvar i = floor(1.4)  //get the bottom number\nvar j = sqrt(36)  // Square root\nvar k = pow(2,4) //square\n```\n\n```swift\nfunc myFunction(name:String, age:Int) { \n\tprint(\"Here's \\(name), age \\(age)\")\n}\n\nfunc addFourTo(number:Int) -> Int {\n\treturn number + 4\n}\n```\n\n```swift\nimport UIKit\n\nclass Spaceship {\n    \n    var fuelLevel = 100\n    var name = \"\"\n    \n    func cruise() {\n        // Code to initiate cruising\n        print(\"Cruising is initiated for \\(name)\")\n    }\n    \n    func thrust() {\n        // Code to initiate rocket thrusters\n        print(\"Rocket thrusters initiated for \\(name)\")\n    }\n    \n}\n\nvar myShip:Spaceship = Spaceship()\nmyShip.name = \"Tom\"\nprint(myShip.name)\nprint(myShip.fuelLevel)\n\n```\n\n```swift\nimport UIKit\n\nlet x = 4\nlet y = 6\n\nif (x >= 11 || y == 6) && x + y == 10{\n    print(\"Hello\")\n}\nelse if x > 5 {\n    print(\"Good afternoon\")\n}\nelse if x <= 2 {\n    \n}\nelse if x != 2 {\n    \n}\nelse {\n    \n}\n\nimport UIKit\n\nfunc vowelDetector (str:String) -> Bool {\n    \n    if str.contains(\"a\") ||\n        str.contains(\"e\") ||\n        str.contains(\"i\") ||\n        str.contains(\"o\") ||\n        str.contains(\"u\") {\n        \n        return true\n    }\n    else {\n        return false\n    }\n    \n    \n}\n\nprint (vowelDetector(str: \"hello\"))\nprint (vowelDetector(str: \"sync\"))\n```\n\n#### [Array](https://developer.apple.com/documentation/swift/array)\n\n#### **optionals**  可nil可object\n\nnil is like none \n\noptional 存在是因為swift要求開發者必須規定一個變量是否為可nil變量，如果聲明了一個optioanl變量，我們必須在調用他的時候驗證這個是否是nil。驗證方法有兩種：\n\n```swift\nvar myInt:Int? // 聲明optionals \nstring\nif myInt !=  nil{\n  print(str!)// ！表示輸出str的內容，否則會輸出Oprional(myInt)\n}\nif myInt == nil{\n  //show the wrong message\n}\n// 2. optional binding \nif let realint = str{\n  print(realint)\n}//當str == nil，什麼都不輸出。當str != nil 輸出string\n```\n\n也有不需要驗證的方法, ! 告訴xcode聲明的變量可能是nil也可能是object，但是這個行為是不安全的。這種變量不是optional，但是可以存儲nil。\n\n```swift\nvar str:String!\nstr = nil\nprint(str)\n```\n\n#### Dictionary\n\n* Key word 是optional 輸出對應的data時應該考慮驗證optional\n\n![](https://img.cetacis.dev/uploads/big/9310c9a8fdefaad1f911c5a082f43367.png)\n\n![](https://img.cetacis.dev/uploads/big/4b93703ed1a4428a89c34bbbc6fce4f9.png)\n\n**LOOP**\n\n![](https://img.cetacis.dev/uploads/big/d134398bd729fe1960acdbddbfba0a66.png)\n\n**隨機生成數列** \n\n* for _ \n* Arc4random_uniform\n\n![隨機生成數列](https://img.cetacis.dev/uploads/big/4fcdf201e3264267e3355c353bc91efc.png)\n\n**while loop1**\n\n![while生成無重複數列](https://img.cetacis.dev/uploads/big/ef122ebd9bbcbd6a09d0e7c66f1bbccd.png)\n\n**while loop 2 **\n\n```swift\nwhile ..{}\n```\n\n\n\n\n\n### inherit\n\n![整體的繼承層次](https://img.cetacis.dev/uploads/big/21a22ee715d2cc1cde94d1d47e19b387.png)\n\n## ViewControler.swift\n\n### 將elements hook到.swift中，綁定action/outlet\n\n\n\ncontrol+drag = blue line  IB outlet\n\nAnd we can enter the viewDigLoad to change the properties of Outlet\n\n![](https://img.cetacis.dev/uploads/big/cdf7c03eefed1f31d82dd0a3a5d6ceeb.png)\n\n![change the information](https://img.cetacis.dev/uploads/big/999fed4da9ebbc9421fe065bbe546f7f.png)\n\nAnd the button can be link to action. The type of the connection is Action  （IB Action）\n\n![給elemnet創建action：touch up inside可以改成其他的觸發事件](https://img.cetacis.dev/uploads/big/93d405ab9e4002a032ede3b3f4b21d69.png)\n\n![](https://img.cetacis.dev/uploads/big/e8ece4ca49579b1cc0c725492ceb1f43.png)\n\n## Ueser Interaction\n\n![IB Action](https://img.cetacis.dev/uploads/big/e96bbd072a11b4dc4a3649bb74b8b9e7.png)\n\n###  ***random***\n\n如果想讓左右的牌同時變並且隨機出現不同的點數，可以採用隨機數。\n\n![隨機數](https://img.cetacis.dev/uploads/big/3b33e11f8ae4ca31a55e65812d2a0fcb.png)\n\n## buildup actual combat\n\n### MVC\n\nview : User use \n\nController: between view and model\n\nModel: data and logic\n\ndatabase ——model——model——view\n\n優點：可複用性；代碼簡潔條理清晰\n\nToryboard : view\n\nViewController.swift : controller\n\n### 1. 在storyboard中建立collectionview 拖入素材照片並設置collection view cell 的identity 為CardCell custom class 為 CardCollectionViewCell\n\n此遊戲橫向，不可縱向 因此取消勾選portrait\n\n![規定橫向](https://img.cetacis.dev/uploads/big/4728bbb5766920205583b5e352b81b48.png)\n\n這個將屏幕分成一個一個cell，規定位置時與safe area關聯，這樣可以防止重要的元素被遮擋。\n\n根據asset的大小調整cell的大小\n\n![](https://img.cetacis.dev/uploads/big/d21da7b6d76fc0a2373ecb7ee3287a6b.png)\n\n可以給這裡的conllection View Cell 起個名字，把它當做模板。\n\n![](https://img.cetacis.dev/uploads/big/e240e8c9028c2a2ce742831a907f9b13.png)\n\n### 2. 创建CardModel.swift (創建新的卡牌array), Card.swift（存放card 的數據結構）\n\n创建CardModel.swift (創建新的卡牌array), Card.swift（存放card 的數據結構）\n\n```swift\nCardModel.swift\nimport Foundation\n\nclass CardModel{\n    func getCards()->[Card]{\n        //Declare an array to store generated cards\n        var generatedCardsArray = [Card]()\n        var unique = [UInt32]()\n       \n        \n        //Randomly generate pairs of cards\n        repeat{\n            let random = arc4random_uniform(13)+1\n            if unique.contains(random){\n                continue\n            }\n            unique.append(random)\n            let card1 = Card()\n            card1.imageName = \"card\\(random)\"\n            generatedCardsArray.append(card1)\n            let card2 = Card()\n            card2.imageName = \"card\\(random)\"\n            generatedCardsArray.append(card2)\n            //print(random)\n        }while generatedCardsArray.count<16\n        \n        //Randomize the array\n        \n        //Return the array\n        return generatedCardsArray\n        \n    }\n}\n```\n\n```swift\nCard.swift\n\nimport Foundation\n\nclass Card{\n    var imageName = \"\"\n    var isFlipped = false\n    var isMatched = false \n}\n```\n\n\n\n然后初始化cardarray\n\n![在viewcontrol中調用](https://img.cetacis.dev/uploads/big/19198b70a3b531275c431dcd97c4febe.png)\n\n### 3. 協議操作\n\n#### protocol and delegate\n\n\n\n在viewcontrol.swift中，我們知道可以通過viewcontrol.swift 改變 view，但這個交流是單向的，即viewcontrol可以向view傳遞信息，但是如果view想要請求得來自viewcontrol的信息（比如通過代碼來直接佈局view，或者在用戶拖動屏幕時，view會請求更新，但是他並不知道viewcontrol類的存在，我們需要解決這個問題），則只能通過 protocol（協議）和delegate（代理）\n\n*代理个人理解是一种设计模式,OC中代理的模式是通过Protocol来实现的,指的是让其他类去实现遵守的协议中的方法.在本类中再调用这个方法,从而达到代理的目的. 比如A这个类想有一个方法,但是不想去实现这个方法,那么就找到B,B去实现A的这个方法,然后A再调用这个方法,这样A就成功的委托B去实现方法,达到代理的目的.*\n\n我們知道 label, text,button 都是ui kidds classes，他們遵守一些協議，即擁有一些協議方法和協議屬性（可以理解成在專門的類中實現的方法和屬性），我們可以在viewcontrol中調用這些方法，以此來修改 label，button等。\n\n![](https://img.cetacis.dev/uploads/big/ea8a7c1bc297f3086bd189a04f296e15.png)\n\n相反的，button，text都不知道viewcontrol的存在。\n\n#### An analogy\n\n警察 需要調用不同車輛處理對應事件 他向警局申請，警局派出特定車輛\n\n警察不知道警局是誰在回應他，但是他只要告訴電話裡的那一端的人事件對應的代號，警局就可以發出特定的車輛。這個代號就存在協議中，而警局就相當於代理（delegate），相當於警察想要完成的事情（調用車輛），讓警局完成。\n\n換一種更接近代碼語言的類比，officer想要調用method A() , 而method A()的實現在代理類中實現，officer之所以可以直接請求method A() （或者說officer之所以知道代理中有這個類，是因為在協議中標明了應該有類和屬性）\n\n如下\n\n![](https://img.cetacis.dev/uploads/big/1e6e3a49a31208a1814a66d810c27e14.png)\n\n![](https://img.cetacis.dev/uploads/big/351641441be0afba4059c2580aa1cf97.png)\n\n#### 举一个工程中的例子\n\n將一個collection hook 到viewcontrol中。得到：\n\n```swift\n@IBOutlet weak var mycollectionView: UICollectionView!\n```\n\n我們知道，collection存在在UICollectionView這個類中。這個類遵守某個定義好的協議。當我們點進這個類的簡介，我們可以看到他所處的協議和代理的方式。datasource用來獲得數據，delegate用於事件相應等方法。\n\n![](https://img.cetacis.dev/uploads/big/159367c6cad4afc1a2c21b0e67c3dc33.png)\n\n再點入某個協議，可以得知這個協議中規定的方法。\n\n在工程中，我們常常將viewController當做我們的代理類以及數據來源類，來實現協議中規定的方法和數據。使用者類本身的定義是在庫函數中（即collectionview），但是實例化則是在viewcontroller中（@IBOutlet weak var mycollectionView: UICollectionView!），實例化成mycollectionView後，給使用者類中定義的協議delegate和dataSource賦值（即使用者類所在的協議會在使用者類中被實例化為delegate和dataSource，通過賦值給代理類可以完成連接。類似於之前警察警局例子中的o.radio = b）。這個時候，代理類中就可以定義會自動執行的函數啦（我還沒想明白為什麼會自動執行這些函數，為什麼沒有沒有mycollection.XXX這樣的，但是這個函數定義的本身就很奇怪，先用吧）\n\n*”使用者類“ （我自己啟的名字，我覺得將他比作協議的使用者比較合適）*\n\n```swift\nimport UIKit\n\nclass ViewController: UIViewController, UITableViewDelegate, UITableViewDataSource {\n    \n    @IBOutlet weak var myTableView: UITableView!\n    let dataArray = [\"bird\", \"dog\", \"cat\", \"turtle\", \"bear\"]\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        \n        myTableView.delegate = self\n        myTableView.dataSource = self\n        \n    }\n\n    override func didReceiveMemoryWarning() {\n        super.didReceiveMemoryWarning()\n        // Dispose of any resources that can be recreated.\n    }\n\n    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {\n        \n        return dataArray.count\n    }\n    \n    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n        \n        // Get the data for this row\n        let rowData = dataArray[indexPath.row]\n        \n        // Get a cell to display\n        let cell = tableView.dequeueReusableCell(withIdentifier: \"BasicCell\", for: indexPath)\n        cell.textLabel?.text = rowData\n        \n        // Return the cell\n        return cell\n    }\n\n}\n```\n\n#### 本cardgame中的協議操作\n\n```swift\n\nimport UIKit\n\nclass ViewController: UIViewController,UICollectionViewDataSource,UICollectionViewDelegate {\n    var model = CardModel()\n    var cardArray = [Card]()\n    @IBOutlet weak var collectionView: UICollectionView!\n    \n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        // Do any additional setup after loading the view.\n        collectionView.delegate = self;\n        collectionView.dataSource = self;\n        \n        cardArray = model.getCards()\n    }\n    \n    //COLLECTIONVIEW ask it's delegate to calculate the sums of items in the collection\n    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {\n        return cardArray.count;\n    }\n    \n    //ask the datasource for the new data for actually for each individual cell that need to be dispalyed\n    // cell for item in that indexPath\n    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {\n        let cell = collectionView.dequeueReusableCell(withReuseIdentifier: \"CardCell\", for: indexPath)as! CardCollectionViewCell;\n        // use the exiting cell to repeat called by identity\n        return cell;\n    }\n    \n    func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {\n        \n        //when tap on the certain cell\n    }\n\n}\n\n\n```\n\n\n\n\n\n如果需要定義一個底層的class 用swift file；反之，用cocoa\n\n\n\n特定的標識在注釋裡可以在整體函數預覽時可見 \n\n\n\n```swift\n// TODO: \n// MARK: \n```\n\n\n\neditor ->structure->In-dent 可以自動糾正格式\n\n### tip debug\n\npo double check the certain value and properties in the project \n\n![debug](https://img.cetacis.dev/uploads/big/c4d211865b0b189909dda4c6b0a7576c.png)\n\n![可以給斷點設置觸發條件](https://img.cetacis.dev/uploads/big/ad95a71e728913a09e3bdc094174ef31.png)\n\n擁有可視化層次\n\n![擁有可視化層次](https://img.cetacis.dev/uploads/big/d84587ccd9cf579db4d0df09548e215e.png)\n\n在檢查code之前先檢查ui\n\n\n\n接着之前的工程。现在总结一下之前要做的\n\n* 在storyborad里建立collectionview 然后拖进两个image。将其cardcell确定custom class= CardCollectionViewCell和identify = CardCell。（cardcell是CardCollectionViewCell的一个实例）\n* 建立card.swift(card的数据结构)和cardModel.swift(返回card array)\n* 在viewcontroller中，进行协议的操作（具体如上）\n* 建立CardCollectionViewCell.swift对于设定的custom class进行操作\n\n### 4. 建立CardCollectionViewCell.swift对于设定的custom class进行操作\n\n#### custom class\n\n\n\n創建cocoa touch class \n\n![img](https://img.cetacis.dev/uploads/big/09a957c8fb1a982b3bd6ae64f042e938.png)\n\n將cardcell的custom class修改成cardcollectionviewcell。這樣就可以在ccvc里用code控制cell中的圖片了\n\n![img](https://img.cetacis.dev/uploads/big/3f883a8305b30cd8de923f4c9fbe896b.png)\n\n將image hook到ccvc中，就可以控制了\n\n我们设置这个class 叫做 CardCollectionViewCell ，他是UICollectionViewCell的子类 ，将frontImage和backImagine hook进来\n\n*小tip： func name(_ type parameter){} 中的_ 代表形式參數是可缺省的*\n\n```swift\n// CardCollecionViewCell.swift \nimport UIKit\n\nclass CardCollectionViewCell: UICollectionViewCell {\n    \n    @IBOutlet weak var frontImageView: UIImageView!\n    \n    @IBOutlet weak var backImageView: UIImageView!\n    \n    var card:Card?\n    \n    func setCard(_ card:Card){\n        self.card = card\n        frontImageView.image = UIImage(named: card.imageName)\n        // we have to call the setCard method for each of cells\n        \n    }\n    func flip(){\n        \n    }\n    func flipback(){\n        \n    }\n    \n }\n\n```\n\n所以，viewcontroller(){}中協議方法的返回應該是CardCollectionViewCell類型。\n\n```swift\n//viewcontroller.swift\nimport UIKit\n\nclass ViewController: UIViewController,UICollectionViewDataSource,UICollectionViewDelegate {\n    var model = CardModel()\n    var cardArray = [Card]()\n    @IBOutlet weak var collectionView: UICollectionView!\n    \n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        // Do any additional setup after loading the view.\n        collectionView.delegate = self;\n        collectionView.dataSource = self;\n        \n        cardArray = model.getCards()\n    }\n    \n    //COLLECTIONVIEW ask it's delegate to calculate the sums of items in the collection\n    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {\n        return cardArray.count;\n    }\n    \n    //ask the datasource for the new data for actually for each individual cell that need to be dispalyed\n    // cell for item in that indexPath\n    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {\n        \n        // get a cardcollectionviewcell object\n        let cell = collectionView.dequeueReusableCell(withReuseIdentifier: \"CardCell\", for: indexPath)as! CardCollectionViewCell;\n        \n       //get the card that the collectionview is trying to display\n        let card = cardArray[indexPath.row]\n        \n        //set the card for the cell\n        cell.setCard(card)\n        \n        return cell;\n    }\n    \n    func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {\n        \n        //when tap on the certain cell\n    }\n\n}\n\n\n```\n\n現在已經實現了每一個cell都有了自己的圖畫（根據生成的cardarray）\n\n現在要定義flip的方法 \n\n在CardCollectionViewCell.swift中加上\n\n```swift\nfunc flip(){\n        UIView.transition(from: backImageView, to: frontImageView, duration: 0.3, options: [.transitionFlipFromLeft,.showHideTransitionViews], completion: nil)\n    }\n```\n\n並且修改viewController.swift 的didSelectItemAt函數\n\n```swift\n\n    func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {\n        // get the cell which is clicked\n        let cell = collectionView.cellForItem(at: indexPath) as! CardCollectionViewCell\n        \n        \n        // get the card which is clicker\n        let card = cardArray[indexPath.row]\n            \n      \t//flip the card\n        if card.isFlipped == false{\n            cell.flip()\n        }else{\n            cell.flipback()\n        }\n       \n        //when tap on the certain cell\n    }\n\n}\n```\n\n現在運行後便可以正常翻轉了，但是這時候當我們翻轉後，將屏幕下拉，等到拉回去的時候，就會發現翻開的不是原來那兩個了。這是因為每次出現這樣的情況，我們的setCard的func會重置，抹去之前的印記。\n\n修改CardCollectionViewCell.swift中的set\n\n```swift\n  func setCard(_ card:Card){\n        self.card = card\n        frontImageView.image = UIImage(named: card.imageName)\n        // we have to call the setCard method for each of cells\n        \n        //determine if the card is in a flipped up state or flipped down state.\n        if card.isFlipped == true{\n            //Make sure the frontview is on top\n            UIView.transition(from: backImageView, to: frontImageView, duration: 0.3, options: [.transitionFlipFromLeft,.showHideTransitionViews], completion: nil)\n        }else{\n            // make sure the backview is on top\n            UIView.transition(from: frontImageView, to: backImageView, duration: 0.3, options: [.transitionFlipFromLeft,.showHideTransitionViews], completion: nil)\n        }\n        \n    }\n\n```\n\n### 5. Game Logic and optinization\n\n可以使牌正常地翻轉，初始化、動畫和事件已經綁定完成，接下來就要控制遊戲邏輯了。\n\n在每次翻到牌時，調用checkForMatch()，因此需要修改didSelectItemAt()\n\n```swift\n   func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {\n        // get the cell which is clicked\n        let cell = collectionView.cellForItem(at: indexPath) as! CardCollectionViewCell\n        \n        \n        // get the card which is clicker\n        let card = cardArray[indexPath.row]\n        \n        if card.isFlipped == false{\n            cell.flip()\n            card.isFlipped = true\n            \n            if firstFlippedCardIndex == nil{\n                firstFlippedCardIndex = indexPath\n            }else{\n                // TODO: the flipped card is the second card, we will use the game logic\n              checkForMatch(indexPath)\n            }\n        }\n        //when tap on the certain cell\n    }\n```\n\n\n\n检查翻到牌时是否匹配\n\n```swift\nvc.swift\n    var firstFlippedCardIndex : IndexPath?\n// MARK: Game logic methods.\n    func checkForMatch(_ secondFlippedCardIndex:IndexPath){\n        //Get two cells\n        let cellOne = collectionView.cellForItem(at: firstFlippedCardIndex!) as? CardCollectionViewCell\n        let cellTwo = collectionView.cellForItem(at: secondFlippedCardIndex) as? CardCollectionViewCell\n        \n        //Get two cards\n        let cardOne = cardArray[firstFlippedCardIndex!.row];\n        let cardTwo = cardArray[secondFlippedCardIndex.row];\n        \n        //Compeare the two card\n        if cardOne.imageName == cardTwo.imageName{\n            //matched\n            //set the status of the cards\n            cardOne.isMatched = true\n            cardTwo.isMatched = true\n            //remove the cards\n            cellOne?.remove()\n            cellTwo?.remove()\n            \n        }else{\n            cardOne.isFlipped = false\n            cardTwo.isFlipped = false\n            cellOne?.flipback()\n            cellTwo?.flipback()\n        }\n        firstFlippedCardIndex = nil\n    }\n```\n\n这里的remove() 实在ccvc.swift中定義得\n\n```swift\nfunc remove() {\n        frontImageView.alpha = 0\n        backImageView.alpha = 0\n        \n    }\n```\n\n这个时候会发现，因为flipback没有停留时间，如果一样，会立即消失，如果不同，则会立即返回，现在我们需要暂时的停顿。修改ccvc.swift的flipback函数\n\n```swift\nfunc flipback(){\n        DispatchQueue.main.asyncAfter(deadline: DispatchTime.now()+0.3){\n            UIView.transition(from: self.frontImageView, to: self.backImageView, duration: 0.3, options: [.transitionFlipFromLeft,.showHideTransitionViews], completion: nil)}\n    }\n    \n```\n\n同时消失快我们可以通过改变remove()来解决（添加动画）\n\n```swift\nfunc remove() {\n        \n        backImageView.alpha = 0\n        \n        UIView.animate(withDuration: 0.3, delay: 0.5, options: .curveEaseOut, animations:\n            {self.frontImageView.alpha = 0}, completion: nil)\n        \n    }\n```\n\n这时候还有一个问题，当纸牌翻消失，他并不是真的消失，他只是将alpha通道调为0，cell还在，所以再次点击还是会执行flip操作。因此我们应该给didSelectItemAt执行加一个条件，就是\n\ncard.isFlipped == false && card.isMatched == false\n\n```swift\n func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {\n        // get the cell which is clicked\n        let cell = collectionView.cellForItem(at: indexPath) as! CardCollectionViewCell\n        \n        \n        // get the card which is clicker\n        let card = cardArray[indexPath.row]\n        \n        if card.isFlipped == false && card.isMatched == false{\n            cell.flip()\n            card.isFlipped = true\n            \n            if firstFlippedCardIndex == nil{\n                firstFlippedCardIndex = indexPath\n            }else{\n               checkForMatch(indexPath)\n            }\n        }\n        //when tap on the certain cell\n    }\n```\n\n并且，我们的setcard执行也需要这样的条件，当这个被翻开或者已经匹配过 就不会进行setcard操作了.同時，當card.isMatched == false 時，我們要注意不能讓這些alpha=0的被重用，導致未匹配的卡消失。\n\n```swift\nfunc setCard(_ card:Card){\n        self.card = card\n        frontImageView.image = UIImage(named: card.imageName)\n        // we have to call the setCard method for each of cells\n        if card.isMatched == true{\n            backImageView.alpha = 0\n            frontImageView.alpha = 0\n          \treturn\n        }else{\n          backImageView.alpha = 1\n          frontImageView.alpha = 1\n        }\n        //determine if the card is in a flipped up state or flipped down state.\n        if card.isFlipped == true{\n            //Make sure the frontview is on top\n            UIView.transition(from: backImageView, to: frontImageView, duration: 0.3, options: [.transitionFlipFromLeft,.showHideTransitionViews], completion: nil)\n        }else{\n            // make sure the backview is on top\n            UIView.transition(from: frontImageView, to: backImageView, duration: 0.3, options: [.transitionFlipFromLeft,.showHideTransitionViews], completion: nil)\n        }\n        \n    }\n```\n\n當cardOne滑出屏幕，他的index會丟失，因此我們應該當cardOne == nill 重新調用 index\n\n","source":"_posts/DevelopForIos(1).md","raw":"---\n\ndate: 2020/4/8\ntags:\n- ios\ncategories:\n- development\n- ios\n---\n## Stack view (get the Auto layout contraints)\n\nlibrary ->stackview (horizontal/vertegal doesen't matter\n\n* drag the elements into the stackview and change the ***Aligment*** and ***Distribution*** in the property bar.  \n\nwe can use the stack view to manage many elements and their layout.\n\n*change the **backgroud** of button to give it texture*\n\n* add ***horizantally in container*** and ***vertically in container***\n\n  ![](https://img.cetacis.dev/uploads/big/bef4430bb6422d782a0f03e1e5cb6ad9.png)\n\n  \n\n*everything have to have constrains*\n\n* when we use the imageview to set the background, we'd uncheck the ***constraint margins*** and set the 0 to the ***view***(not the safe area). \n\n  Set the ***Content Mode*** to Aspect fill.\n\n* ***Content Compression Resistance Priority***: decide the priority of whether the picture will be compressed (default for 750)\n\n![resistance for priority](https://img.cetacis.dev/uploads/big/dc59c99442768426ad4f8bffc968975a.png)\n\n​\t***Content Hugging Priority***: the same when the zone is too big.\n\n<!-- more -->\n\n## Vary layout\n\n* when change the iphone to the horizontal, maybe them will be a strange issure\n\n  ```\n  an internal error occured\n  ```\n\n  So, **Save the project **before the change and after the issure, project->clean the build folder, then alt+Q to quit xcode and relaunch it.\n\n* Making the exiting stack view and an laber(or other elements) to be a new stackview is possible. And xcode can make them be oriented. \n\n**The button is near the Add constrains button**\n\n* add the certain constrains to the certain device. \n\n![](https://img.cetacis.dev/uploads/big/6f6cdb5be94afdba4d1c01d511771bc5.png)\n\nSize class : wC hC ; wC hR; wR hR (C: compact R:regular)\n\n### **vary  for traits** \n\nthe in the certain size class's stack view's Spacing, click the + and add the variation.\n\n* when want to link to element, hold the ***control*** and the element and make a blue line link to the other element\n\n![](https://img.cetacis.dev/uploads/big/888c8a380b4d5b34df6dc089ad3b9a03.png)\n\n* Lable should link to other elements in three or four directions and the other element should have higher hugging prority the lable so that only the lable will be stretch to fill up any remaining space.\n\n## Swift\n\n### basic\n\nlet: constant  var: variable\n\n```swift\nvar i = 32 \nvar i:Int = 32\nvar u:Int? // optionals\nvar g = abs(-1) // absolute value\nvar h = ceil(1.8)  // get the top number\nvar i = floor(1.4)  //get the bottom number\nvar j = sqrt(36)  // Square root\nvar k = pow(2,4) //square\n```\n\n```swift\nfunc myFunction(name:String, age:Int) { \n\tprint(\"Here's \\(name), age \\(age)\")\n}\n\nfunc addFourTo(number:Int) -> Int {\n\treturn number + 4\n}\n```\n\n```swift\nimport UIKit\n\nclass Spaceship {\n    \n    var fuelLevel = 100\n    var name = \"\"\n    \n    func cruise() {\n        // Code to initiate cruising\n        print(\"Cruising is initiated for \\(name)\")\n    }\n    \n    func thrust() {\n        // Code to initiate rocket thrusters\n        print(\"Rocket thrusters initiated for \\(name)\")\n    }\n    \n}\n\nvar myShip:Spaceship = Spaceship()\nmyShip.name = \"Tom\"\nprint(myShip.name)\nprint(myShip.fuelLevel)\n\n```\n\n```swift\nimport UIKit\n\nlet x = 4\nlet y = 6\n\nif (x >= 11 || y == 6) && x + y == 10{\n    print(\"Hello\")\n}\nelse if x > 5 {\n    print(\"Good afternoon\")\n}\nelse if x <= 2 {\n    \n}\nelse if x != 2 {\n    \n}\nelse {\n    \n}\n\nimport UIKit\n\nfunc vowelDetector (str:String) -> Bool {\n    \n    if str.contains(\"a\") ||\n        str.contains(\"e\") ||\n        str.contains(\"i\") ||\n        str.contains(\"o\") ||\n        str.contains(\"u\") {\n        \n        return true\n    }\n    else {\n        return false\n    }\n    \n    \n}\n\nprint (vowelDetector(str: \"hello\"))\nprint (vowelDetector(str: \"sync\"))\n```\n\n#### [Array](https://developer.apple.com/documentation/swift/array)\n\n#### **optionals**  可nil可object\n\nnil is like none \n\noptional 存在是因為swift要求開發者必須規定一個變量是否為可nil變量，如果聲明了一個optioanl變量，我們必須在調用他的時候驗證這個是否是nil。驗證方法有兩種：\n\n```swift\nvar myInt:Int? // 聲明optionals \nstring\nif myInt !=  nil{\n  print(str!)// ！表示輸出str的內容，否則會輸出Oprional(myInt)\n}\nif myInt == nil{\n  //show the wrong message\n}\n// 2. optional binding \nif let realint = str{\n  print(realint)\n}//當str == nil，什麼都不輸出。當str != nil 輸出string\n```\n\n也有不需要驗證的方法, ! 告訴xcode聲明的變量可能是nil也可能是object，但是這個行為是不安全的。這種變量不是optional，但是可以存儲nil。\n\n```swift\nvar str:String!\nstr = nil\nprint(str)\n```\n\n#### Dictionary\n\n* Key word 是optional 輸出對應的data時應該考慮驗證optional\n\n![](https://img.cetacis.dev/uploads/big/9310c9a8fdefaad1f911c5a082f43367.png)\n\n![](https://img.cetacis.dev/uploads/big/4b93703ed1a4428a89c34bbbc6fce4f9.png)\n\n**LOOP**\n\n![](https://img.cetacis.dev/uploads/big/d134398bd729fe1960acdbddbfba0a66.png)\n\n**隨機生成數列** \n\n* for _ \n* Arc4random_uniform\n\n![隨機生成數列](https://img.cetacis.dev/uploads/big/4fcdf201e3264267e3355c353bc91efc.png)\n\n**while loop1**\n\n![while生成無重複數列](https://img.cetacis.dev/uploads/big/ef122ebd9bbcbd6a09d0e7c66f1bbccd.png)\n\n**while loop 2 **\n\n```swift\nwhile ..{}\n```\n\n\n\n\n\n### inherit\n\n![整體的繼承層次](https://img.cetacis.dev/uploads/big/21a22ee715d2cc1cde94d1d47e19b387.png)\n\n## ViewControler.swift\n\n### 將elements hook到.swift中，綁定action/outlet\n\n\n\ncontrol+drag = blue line  IB outlet\n\nAnd we can enter the viewDigLoad to change the properties of Outlet\n\n![](https://img.cetacis.dev/uploads/big/cdf7c03eefed1f31d82dd0a3a5d6ceeb.png)\n\n![change the information](https://img.cetacis.dev/uploads/big/999fed4da9ebbc9421fe065bbe546f7f.png)\n\nAnd the button can be link to action. The type of the connection is Action  （IB Action）\n\n![給elemnet創建action：touch up inside可以改成其他的觸發事件](https://img.cetacis.dev/uploads/big/93d405ab9e4002a032ede3b3f4b21d69.png)\n\n![](https://img.cetacis.dev/uploads/big/e8ece4ca49579b1cc0c725492ceb1f43.png)\n\n## Ueser Interaction\n\n![IB Action](https://img.cetacis.dev/uploads/big/e96bbd072a11b4dc4a3649bb74b8b9e7.png)\n\n###  ***random***\n\n如果想讓左右的牌同時變並且隨機出現不同的點數，可以採用隨機數。\n\n![隨機數](https://img.cetacis.dev/uploads/big/3b33e11f8ae4ca31a55e65812d2a0fcb.png)\n\n## buildup actual combat\n\n### MVC\n\nview : User use \n\nController: between view and model\n\nModel: data and logic\n\ndatabase ——model——model——view\n\n優點：可複用性；代碼簡潔條理清晰\n\nToryboard : view\n\nViewController.swift : controller\n\n### 1. 在storyboard中建立collectionview 拖入素材照片並設置collection view cell 的identity 為CardCell custom class 為 CardCollectionViewCell\n\n此遊戲橫向，不可縱向 因此取消勾選portrait\n\n![規定橫向](https://img.cetacis.dev/uploads/big/4728bbb5766920205583b5e352b81b48.png)\n\n這個將屏幕分成一個一個cell，規定位置時與safe area關聯，這樣可以防止重要的元素被遮擋。\n\n根據asset的大小調整cell的大小\n\n![](https://img.cetacis.dev/uploads/big/d21da7b6d76fc0a2373ecb7ee3287a6b.png)\n\n可以給這裡的conllection View Cell 起個名字，把它當做模板。\n\n![](https://img.cetacis.dev/uploads/big/e240e8c9028c2a2ce742831a907f9b13.png)\n\n### 2. 创建CardModel.swift (創建新的卡牌array), Card.swift（存放card 的數據結構）\n\n创建CardModel.swift (創建新的卡牌array), Card.swift（存放card 的數據結構）\n\n```swift\nCardModel.swift\nimport Foundation\n\nclass CardModel{\n    func getCards()->[Card]{\n        //Declare an array to store generated cards\n        var generatedCardsArray = [Card]()\n        var unique = [UInt32]()\n       \n        \n        //Randomly generate pairs of cards\n        repeat{\n            let random = arc4random_uniform(13)+1\n            if unique.contains(random){\n                continue\n            }\n            unique.append(random)\n            let card1 = Card()\n            card1.imageName = \"card\\(random)\"\n            generatedCardsArray.append(card1)\n            let card2 = Card()\n            card2.imageName = \"card\\(random)\"\n            generatedCardsArray.append(card2)\n            //print(random)\n        }while generatedCardsArray.count<16\n        \n        //Randomize the array\n        \n        //Return the array\n        return generatedCardsArray\n        \n    }\n}\n```\n\n```swift\nCard.swift\n\nimport Foundation\n\nclass Card{\n    var imageName = \"\"\n    var isFlipped = false\n    var isMatched = false \n}\n```\n\n\n\n然后初始化cardarray\n\n![在viewcontrol中調用](https://img.cetacis.dev/uploads/big/19198b70a3b531275c431dcd97c4febe.png)\n\n### 3. 協議操作\n\n#### protocol and delegate\n\n\n\n在viewcontrol.swift中，我們知道可以通過viewcontrol.swift 改變 view，但這個交流是單向的，即viewcontrol可以向view傳遞信息，但是如果view想要請求得來自viewcontrol的信息（比如通過代碼來直接佈局view，或者在用戶拖動屏幕時，view會請求更新，但是他並不知道viewcontrol類的存在，我們需要解決這個問題），則只能通過 protocol（協議）和delegate（代理）\n\n*代理个人理解是一种设计模式,OC中代理的模式是通过Protocol来实现的,指的是让其他类去实现遵守的协议中的方法.在本类中再调用这个方法,从而达到代理的目的. 比如A这个类想有一个方法,但是不想去实现这个方法,那么就找到B,B去实现A的这个方法,然后A再调用这个方法,这样A就成功的委托B去实现方法,达到代理的目的.*\n\n我們知道 label, text,button 都是ui kidds classes，他們遵守一些協議，即擁有一些協議方法和協議屬性（可以理解成在專門的類中實現的方法和屬性），我們可以在viewcontrol中調用這些方法，以此來修改 label，button等。\n\n![](https://img.cetacis.dev/uploads/big/ea8a7c1bc297f3086bd189a04f296e15.png)\n\n相反的，button，text都不知道viewcontrol的存在。\n\n#### An analogy\n\n警察 需要調用不同車輛處理對應事件 他向警局申請，警局派出特定車輛\n\n警察不知道警局是誰在回應他，但是他只要告訴電話裡的那一端的人事件對應的代號，警局就可以發出特定的車輛。這個代號就存在協議中，而警局就相當於代理（delegate），相當於警察想要完成的事情（調用車輛），讓警局完成。\n\n換一種更接近代碼語言的類比，officer想要調用method A() , 而method A()的實現在代理類中實現，officer之所以可以直接請求method A() （或者說officer之所以知道代理中有這個類，是因為在協議中標明了應該有類和屬性）\n\n如下\n\n![](https://img.cetacis.dev/uploads/big/1e6e3a49a31208a1814a66d810c27e14.png)\n\n![](https://img.cetacis.dev/uploads/big/351641441be0afba4059c2580aa1cf97.png)\n\n#### 举一个工程中的例子\n\n將一個collection hook 到viewcontrol中。得到：\n\n```swift\n@IBOutlet weak var mycollectionView: UICollectionView!\n```\n\n我們知道，collection存在在UICollectionView這個類中。這個類遵守某個定義好的協議。當我們點進這個類的簡介，我們可以看到他所處的協議和代理的方式。datasource用來獲得數據，delegate用於事件相應等方法。\n\n![](https://img.cetacis.dev/uploads/big/159367c6cad4afc1a2c21b0e67c3dc33.png)\n\n再點入某個協議，可以得知這個協議中規定的方法。\n\n在工程中，我們常常將viewController當做我們的代理類以及數據來源類，來實現協議中規定的方法和數據。使用者類本身的定義是在庫函數中（即collectionview），但是實例化則是在viewcontroller中（@IBOutlet weak var mycollectionView: UICollectionView!），實例化成mycollectionView後，給使用者類中定義的協議delegate和dataSource賦值（即使用者類所在的協議會在使用者類中被實例化為delegate和dataSource，通過賦值給代理類可以完成連接。類似於之前警察警局例子中的o.radio = b）。這個時候，代理類中就可以定義會自動執行的函數啦（我還沒想明白為什麼會自動執行這些函數，為什麼沒有沒有mycollection.XXX這樣的，但是這個函數定義的本身就很奇怪，先用吧）\n\n*”使用者類“ （我自己啟的名字，我覺得將他比作協議的使用者比較合適）*\n\n```swift\nimport UIKit\n\nclass ViewController: UIViewController, UITableViewDelegate, UITableViewDataSource {\n    \n    @IBOutlet weak var myTableView: UITableView!\n    let dataArray = [\"bird\", \"dog\", \"cat\", \"turtle\", \"bear\"]\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        \n        myTableView.delegate = self\n        myTableView.dataSource = self\n        \n    }\n\n    override func didReceiveMemoryWarning() {\n        super.didReceiveMemoryWarning()\n        // Dispose of any resources that can be recreated.\n    }\n\n    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {\n        \n        return dataArray.count\n    }\n    \n    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n        \n        // Get the data for this row\n        let rowData = dataArray[indexPath.row]\n        \n        // Get a cell to display\n        let cell = tableView.dequeueReusableCell(withIdentifier: \"BasicCell\", for: indexPath)\n        cell.textLabel?.text = rowData\n        \n        // Return the cell\n        return cell\n    }\n\n}\n```\n\n#### 本cardgame中的協議操作\n\n```swift\n\nimport UIKit\n\nclass ViewController: UIViewController,UICollectionViewDataSource,UICollectionViewDelegate {\n    var model = CardModel()\n    var cardArray = [Card]()\n    @IBOutlet weak var collectionView: UICollectionView!\n    \n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        // Do any additional setup after loading the view.\n        collectionView.delegate = self;\n        collectionView.dataSource = self;\n        \n        cardArray = model.getCards()\n    }\n    \n    //COLLECTIONVIEW ask it's delegate to calculate the sums of items in the collection\n    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {\n        return cardArray.count;\n    }\n    \n    //ask the datasource for the new data for actually for each individual cell that need to be dispalyed\n    // cell for item in that indexPath\n    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {\n        let cell = collectionView.dequeueReusableCell(withReuseIdentifier: \"CardCell\", for: indexPath)as! CardCollectionViewCell;\n        // use the exiting cell to repeat called by identity\n        return cell;\n    }\n    \n    func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {\n        \n        //when tap on the certain cell\n    }\n\n}\n\n\n```\n\n\n\n\n\n如果需要定義一個底層的class 用swift file；反之，用cocoa\n\n\n\n特定的標識在注釋裡可以在整體函數預覽時可見 \n\n\n\n```swift\n// TODO: \n// MARK: \n```\n\n\n\neditor ->structure->In-dent 可以自動糾正格式\n\n### tip debug\n\npo double check the certain value and properties in the project \n\n![debug](https://img.cetacis.dev/uploads/big/c4d211865b0b189909dda4c6b0a7576c.png)\n\n![可以給斷點設置觸發條件](https://img.cetacis.dev/uploads/big/ad95a71e728913a09e3bdc094174ef31.png)\n\n擁有可視化層次\n\n![擁有可視化層次](https://img.cetacis.dev/uploads/big/d84587ccd9cf579db4d0df09548e215e.png)\n\n在檢查code之前先檢查ui\n\n\n\n接着之前的工程。现在总结一下之前要做的\n\n* 在storyborad里建立collectionview 然后拖进两个image。将其cardcell确定custom class= CardCollectionViewCell和identify = CardCell。（cardcell是CardCollectionViewCell的一个实例）\n* 建立card.swift(card的数据结构)和cardModel.swift(返回card array)\n* 在viewcontroller中，进行协议的操作（具体如上）\n* 建立CardCollectionViewCell.swift对于设定的custom class进行操作\n\n### 4. 建立CardCollectionViewCell.swift对于设定的custom class进行操作\n\n#### custom class\n\n\n\n創建cocoa touch class \n\n![img](https://img.cetacis.dev/uploads/big/09a957c8fb1a982b3bd6ae64f042e938.png)\n\n將cardcell的custom class修改成cardcollectionviewcell。這樣就可以在ccvc里用code控制cell中的圖片了\n\n![img](https://img.cetacis.dev/uploads/big/3f883a8305b30cd8de923f4c9fbe896b.png)\n\n將image hook到ccvc中，就可以控制了\n\n我们设置这个class 叫做 CardCollectionViewCell ，他是UICollectionViewCell的子类 ，将frontImage和backImagine hook进来\n\n*小tip： func name(_ type parameter){} 中的_ 代表形式參數是可缺省的*\n\n```swift\n// CardCollecionViewCell.swift \nimport UIKit\n\nclass CardCollectionViewCell: UICollectionViewCell {\n    \n    @IBOutlet weak var frontImageView: UIImageView!\n    \n    @IBOutlet weak var backImageView: UIImageView!\n    \n    var card:Card?\n    \n    func setCard(_ card:Card){\n        self.card = card\n        frontImageView.image = UIImage(named: card.imageName)\n        // we have to call the setCard method for each of cells\n        \n    }\n    func flip(){\n        \n    }\n    func flipback(){\n        \n    }\n    \n }\n\n```\n\n所以，viewcontroller(){}中協議方法的返回應該是CardCollectionViewCell類型。\n\n```swift\n//viewcontroller.swift\nimport UIKit\n\nclass ViewController: UIViewController,UICollectionViewDataSource,UICollectionViewDelegate {\n    var model = CardModel()\n    var cardArray = [Card]()\n    @IBOutlet weak var collectionView: UICollectionView!\n    \n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        // Do any additional setup after loading the view.\n        collectionView.delegate = self;\n        collectionView.dataSource = self;\n        \n        cardArray = model.getCards()\n    }\n    \n    //COLLECTIONVIEW ask it's delegate to calculate the sums of items in the collection\n    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {\n        return cardArray.count;\n    }\n    \n    //ask the datasource for the new data for actually for each individual cell that need to be dispalyed\n    // cell for item in that indexPath\n    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {\n        \n        // get a cardcollectionviewcell object\n        let cell = collectionView.dequeueReusableCell(withReuseIdentifier: \"CardCell\", for: indexPath)as! CardCollectionViewCell;\n        \n       //get the card that the collectionview is trying to display\n        let card = cardArray[indexPath.row]\n        \n        //set the card for the cell\n        cell.setCard(card)\n        \n        return cell;\n    }\n    \n    func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {\n        \n        //when tap on the certain cell\n    }\n\n}\n\n\n```\n\n現在已經實現了每一個cell都有了自己的圖畫（根據生成的cardarray）\n\n現在要定義flip的方法 \n\n在CardCollectionViewCell.swift中加上\n\n```swift\nfunc flip(){\n        UIView.transition(from: backImageView, to: frontImageView, duration: 0.3, options: [.transitionFlipFromLeft,.showHideTransitionViews], completion: nil)\n    }\n```\n\n並且修改viewController.swift 的didSelectItemAt函數\n\n```swift\n\n    func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {\n        // get the cell which is clicked\n        let cell = collectionView.cellForItem(at: indexPath) as! CardCollectionViewCell\n        \n        \n        // get the card which is clicker\n        let card = cardArray[indexPath.row]\n            \n      \t//flip the card\n        if card.isFlipped == false{\n            cell.flip()\n        }else{\n            cell.flipback()\n        }\n       \n        //when tap on the certain cell\n    }\n\n}\n```\n\n現在運行後便可以正常翻轉了，但是這時候當我們翻轉後，將屏幕下拉，等到拉回去的時候，就會發現翻開的不是原來那兩個了。這是因為每次出現這樣的情況，我們的setCard的func會重置，抹去之前的印記。\n\n修改CardCollectionViewCell.swift中的set\n\n```swift\n  func setCard(_ card:Card){\n        self.card = card\n        frontImageView.image = UIImage(named: card.imageName)\n        // we have to call the setCard method for each of cells\n        \n        //determine if the card is in a flipped up state or flipped down state.\n        if card.isFlipped == true{\n            //Make sure the frontview is on top\n            UIView.transition(from: backImageView, to: frontImageView, duration: 0.3, options: [.transitionFlipFromLeft,.showHideTransitionViews], completion: nil)\n        }else{\n            // make sure the backview is on top\n            UIView.transition(from: frontImageView, to: backImageView, duration: 0.3, options: [.transitionFlipFromLeft,.showHideTransitionViews], completion: nil)\n        }\n        \n    }\n\n```\n\n### 5. Game Logic and optinization\n\n可以使牌正常地翻轉，初始化、動畫和事件已經綁定完成，接下來就要控制遊戲邏輯了。\n\n在每次翻到牌時，調用checkForMatch()，因此需要修改didSelectItemAt()\n\n```swift\n   func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {\n        // get the cell which is clicked\n        let cell = collectionView.cellForItem(at: indexPath) as! CardCollectionViewCell\n        \n        \n        // get the card which is clicker\n        let card = cardArray[indexPath.row]\n        \n        if card.isFlipped == false{\n            cell.flip()\n            card.isFlipped = true\n            \n            if firstFlippedCardIndex == nil{\n                firstFlippedCardIndex = indexPath\n            }else{\n                // TODO: the flipped card is the second card, we will use the game logic\n              checkForMatch(indexPath)\n            }\n        }\n        //when tap on the certain cell\n    }\n```\n\n\n\n检查翻到牌时是否匹配\n\n```swift\nvc.swift\n    var firstFlippedCardIndex : IndexPath?\n// MARK: Game logic methods.\n    func checkForMatch(_ secondFlippedCardIndex:IndexPath){\n        //Get two cells\n        let cellOne = collectionView.cellForItem(at: firstFlippedCardIndex!) as? CardCollectionViewCell\n        let cellTwo = collectionView.cellForItem(at: secondFlippedCardIndex) as? CardCollectionViewCell\n        \n        //Get two cards\n        let cardOne = cardArray[firstFlippedCardIndex!.row];\n        let cardTwo = cardArray[secondFlippedCardIndex.row];\n        \n        //Compeare the two card\n        if cardOne.imageName == cardTwo.imageName{\n            //matched\n            //set the status of the cards\n            cardOne.isMatched = true\n            cardTwo.isMatched = true\n            //remove the cards\n            cellOne?.remove()\n            cellTwo?.remove()\n            \n        }else{\n            cardOne.isFlipped = false\n            cardTwo.isFlipped = false\n            cellOne?.flipback()\n            cellTwo?.flipback()\n        }\n        firstFlippedCardIndex = nil\n    }\n```\n\n这里的remove() 实在ccvc.swift中定義得\n\n```swift\nfunc remove() {\n        frontImageView.alpha = 0\n        backImageView.alpha = 0\n        \n    }\n```\n\n这个时候会发现，因为flipback没有停留时间，如果一样，会立即消失，如果不同，则会立即返回，现在我们需要暂时的停顿。修改ccvc.swift的flipback函数\n\n```swift\nfunc flipback(){\n        DispatchQueue.main.asyncAfter(deadline: DispatchTime.now()+0.3){\n            UIView.transition(from: self.frontImageView, to: self.backImageView, duration: 0.3, options: [.transitionFlipFromLeft,.showHideTransitionViews], completion: nil)}\n    }\n    \n```\n\n同时消失快我们可以通过改变remove()来解决（添加动画）\n\n```swift\nfunc remove() {\n        \n        backImageView.alpha = 0\n        \n        UIView.animate(withDuration: 0.3, delay: 0.5, options: .curveEaseOut, animations:\n            {self.frontImageView.alpha = 0}, completion: nil)\n        \n    }\n```\n\n这时候还有一个问题，当纸牌翻消失，他并不是真的消失，他只是将alpha通道调为0，cell还在，所以再次点击还是会执行flip操作。因此我们应该给didSelectItemAt执行加一个条件，就是\n\ncard.isFlipped == false && card.isMatched == false\n\n```swift\n func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {\n        // get the cell which is clicked\n        let cell = collectionView.cellForItem(at: indexPath) as! CardCollectionViewCell\n        \n        \n        // get the card which is clicker\n        let card = cardArray[indexPath.row]\n        \n        if card.isFlipped == false && card.isMatched == false{\n            cell.flip()\n            card.isFlipped = true\n            \n            if firstFlippedCardIndex == nil{\n                firstFlippedCardIndex = indexPath\n            }else{\n               checkForMatch(indexPath)\n            }\n        }\n        //when tap on the certain cell\n    }\n```\n\n并且，我们的setcard执行也需要这样的条件，当这个被翻开或者已经匹配过 就不会进行setcard操作了.同時，當card.isMatched == false 時，我們要注意不能讓這些alpha=0的被重用，導致未匹配的卡消失。\n\n```swift\nfunc setCard(_ card:Card){\n        self.card = card\n        frontImageView.image = UIImage(named: card.imageName)\n        // we have to call the setCard method for each of cells\n        if card.isMatched == true{\n            backImageView.alpha = 0\n            frontImageView.alpha = 0\n          \treturn\n        }else{\n          backImageView.alpha = 1\n          frontImageView.alpha = 1\n        }\n        //determine if the card is in a flipped up state or flipped down state.\n        if card.isFlipped == true{\n            //Make sure the frontview is on top\n            UIView.transition(from: backImageView, to: frontImageView, duration: 0.3, options: [.transitionFlipFromLeft,.showHideTransitionViews], completion: nil)\n        }else{\n            // make sure the backview is on top\n            UIView.transition(from: frontImageView, to: backImageView, duration: 0.3, options: [.transitionFlipFromLeft,.showHideTransitionViews], completion: nil)\n        }\n        \n    }\n```\n\n當cardOne滑出屏幕，他的index會丟失，因此我們應該當cardOne == nill 重新調用 index\n\n","slug":"DevelopForIos-1","published":1,"updated":"2020-04-12T04:25:15.000Z","title":"DevelopForIos-1","comments":1,"layout":"post","photos":[],"link":"","_id":"ck985a77h0001slqgh9lyecxj","content":"<h2 id=\"Stack-view-get-the-Auto-layout-contraints\"><a href=\"#Stack-view-get-the-Auto-layout-contraints\" class=\"headerlink\" title=\"Stack view (get the Auto layout contraints)\"></a>Stack view (get the Auto layout contraints)</h2><p>library -&gt;stackview (horizontal/vertegal doesen’t matter</p>\n<ul>\n<li>drag the elements into the stackview and change the <strong><em>Aligment</em></strong> and <strong><em>Distribution</em></strong> in the property bar.  </li>\n</ul>\n<p>we can use the stack view to manage many elements and their layout.</p>\n<p><em>change the <strong>backgroud</strong> of button to give it texture</em></p>\n<ul>\n<li><p>add <strong><em>horizantally in container</em></strong> and <strong><em>vertically in container</em></strong></p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/bef4430bb6422d782a0f03e1e5cb6ad9.png\" alt=\"\"></p>\n</li>\n</ul>\n<p><em>everything have to have constrains</em></p>\n<ul>\n<li><p>when we use the imageview to set the background, we’d uncheck the <strong><em>constraint margins</em></strong> and set the 0 to the <strong><em>view</em></strong>(not the safe area). </p>\n<p>Set the <strong><em>Content Mode</em></strong> to Aspect fill.</p>\n</li>\n<li><p><strong><em>Content Compression Resistance Priority</em></strong>: decide the priority of whether the picture will be compressed (default for 750)</p>\n</li>\n</ul>\n<p><img src=\"https://img.cetacis.dev/uploads/big/dc59c99442768426ad4f8bffc968975a.png\" alt=\"resistance for priority\"></p>\n<p>​    <strong><em>Content Hugging Priority</em></strong>: the same when the zone is too big.</p>\n<a id=\"more\"></a>\n\n<h2 id=\"Vary-layout\"><a href=\"#Vary-layout\" class=\"headerlink\" title=\"Vary layout\"></a>Vary layout</h2><ul>\n<li><p>when change the iphone to the horizontal, maybe them will be a strange issure</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">an internal error occured</span><br></pre></td></tr></table></figure>\n\n<p>So, *<em>Save the project *</em>before the change and after the issure, project-&gt;clean the build folder, then alt+Q to quit xcode and relaunch it.</p>\n</li>\n<li><p>Making the exiting stack view and an laber(or other elements) to be a new stackview is possible. And xcode can make them be oriented. </p>\n</li>\n</ul>\n<p><strong>The button is near the Add constrains button</strong></p>\n<ul>\n<li>add the certain constrains to the certain device. </li>\n</ul>\n<p><img src=\"https://img.cetacis.dev/uploads/big/6f6cdb5be94afdba4d1c01d511771bc5.png\" alt=\"\"></p>\n<p>Size class : wC hC ; wC hR; wR hR (C: compact R:regular)</p>\n<h3 id=\"vary-for-traits\"><a href=\"#vary-for-traits\" class=\"headerlink\" title=\"vary  for traits\"></a><strong>vary  for traits</strong></h3><p>the in the certain size class’s stack view’s Spacing, click the + and add the variation.</p>\n<ul>\n<li>when want to link to element, hold the <strong><em>control</em></strong> and the element and make a blue line link to the other element</li>\n</ul>\n<p><img src=\"https://img.cetacis.dev/uploads/big/888c8a380b4d5b34df6dc089ad3b9a03.png\" alt=\"\"></p>\n<ul>\n<li>Lable should link to other elements in three or four directions and the other element should have higher hugging prority the lable so that only the lable will be stretch to fill up any remaining space.</li>\n</ul>\n<h2 id=\"Swift\"><a href=\"#Swift\" class=\"headerlink\" title=\"Swift\"></a>Swift</h2><h3 id=\"basic\"><a href=\"#basic\" class=\"headerlink\" title=\"basic\"></a>basic</h3><p>let: constant  var: variable</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> i = <span class=\"number\">32</span> </span><br><span class=\"line\"><span class=\"keyword\">var</span> i:<span class=\"type\">Int</span> = <span class=\"number\">32</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> u:<span class=\"type\">Int?</span> <span class=\"comment\">// optionals</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> g = <span class=\"built_in\">abs</span>(-<span class=\"number\">1</span>) <span class=\"comment\">// absolute value</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> h = ceil(<span class=\"number\">1.8</span>)  <span class=\"comment\">// get the top number</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> i = floor(<span class=\"number\">1.4</span>)  <span class=\"comment\">//get the bottom number</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> j = sqrt(<span class=\"number\">36</span>)  <span class=\"comment\">// Square root</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> k = pow(<span class=\"number\">2</span>,<span class=\"number\">4</span>) <span class=\"comment\">//square</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">myFunction</span><span class=\"params\">(name:String, age:Int)</span></span> &#123; </span><br><span class=\"line\">\t<span class=\"built_in\">print</span>(<span class=\"string\">\"Here's \\(name), age \\(age)\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">addFourTo</span><span class=\"params\">(number:Int)</span></span> -&gt; <span class=\"type\">Int</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> number + <span class=\"number\">4</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> UIKit</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Spaceship</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">var</span> fuelLevel = <span class=\"number\">100</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> name = <span class=\"string\">\"\"</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">cruise</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Code to initiate cruising</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"Cruising is initiated for \\(name)\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">thrust</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Code to initiate rocket thrusters</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"Rocket thrusters initiated for \\(name)\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> myShip:<span class=\"type\">Spaceship</span> = <span class=\"type\">Spaceship</span>()</span><br><span class=\"line\">myShip.name = <span class=\"string\">\"Tom\"</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(myShip.name)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(myShip.fuelLevel)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> UIKit</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> y = <span class=\"number\">6</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (x &gt;= <span class=\"number\">11</span> || y == <span class=\"number\">6</span>) &amp;&amp; x + y == <span class=\"number\">10</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Hello\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span> x &gt; <span class=\"number\">5</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Good afternoon\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span> x &lt;= <span class=\"number\">2</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span> x != <span class=\"number\">2</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> UIKit</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">vowelDetector</span> <span class=\"params\">(str:String)</span></span> -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> str.<span class=\"built_in\">contains</span>(<span class=\"string\">\"a\"</span>) ||</span><br><span class=\"line\">        str.<span class=\"built_in\">contains</span>(<span class=\"string\">\"e\"</span>) ||</span><br><span class=\"line\">        str.<span class=\"built_in\">contains</span>(<span class=\"string\">\"i\"</span>) ||</span><br><span class=\"line\">        str.<span class=\"built_in\">contains</span>(<span class=\"string\">\"o\"</span>) ||</span><br><span class=\"line\">        str.<span class=\"built_in\">contains</span>(<span class=\"string\">\"u\"</span>) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span> (vowelDetector(str: <span class=\"string\">\"hello\"</span>))</span><br><span class=\"line\"><span class=\"built_in\">print</span> (vowelDetector(str: <span class=\"string\">\"sync\"</span>))</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Array\"><a href=\"#Array\" class=\"headerlink\" title=\"Array\"></a><a href=\"https://developer.apple.com/documentation/swift/array\" target=\"_blank\" rel=\"noopener\">Array</a></h4><h4 id=\"optionals-可nil可object\"><a href=\"#optionals-可nil可object\" class=\"headerlink\" title=\"optionals  可nil可object\"></a><strong>optionals</strong>  可nil可object</h4><p>nil is like none </p>\n<p>optional 存在是因為swift要求開發者必須規定一個變量是否為可nil變量，如果聲明了一個optioanl變量，我們必須在調用他的時候驗證這個是否是nil。驗證方法有兩種：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myInt:<span class=\"type\">Int?</span> <span class=\"comment\">// 聲明optionals </span></span><br><span class=\"line\">string</span><br><span class=\"line\"><span class=\"keyword\">if</span> myInt !=  <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(str!)<span class=\"comment\">// ！表示輸出str的內容，否則會輸出Oprional(myInt)</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> myInt == <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//show the wrong message</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 2. optional binding </span></span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> realint = str&#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(realint)</span><br><span class=\"line\">&#125;<span class=\"comment\">//當str == nil，什麼都不輸出。當str != nil 輸出string</span></span><br></pre></td></tr></table></figure>\n\n<p>也有不需要驗證的方法, ! 告訴xcode聲明的變量可能是nil也可能是object，但是這個行為是不安全的。這種變量不是optional，但是可以存儲nil。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str:<span class=\"type\">String!</span></span><br><span class=\"line\">str = <span class=\"literal\">nil</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(str)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Dictionary\"><a href=\"#Dictionary\" class=\"headerlink\" title=\"Dictionary\"></a>Dictionary</h4><ul>\n<li>Key word 是optional 輸出對應的data時應該考慮驗證optional</li>\n</ul>\n<p><img src=\"https://img.cetacis.dev/uploads/big/9310c9a8fdefaad1f911c5a082f43367.png\" alt=\"\"></p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/4b93703ed1a4428a89c34bbbc6fce4f9.png\" alt=\"\"></p>\n<p><strong>LOOP</strong></p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/d134398bd729fe1960acdbddbfba0a66.png\" alt=\"\"></p>\n<p><strong>隨機生成數列</strong> </p>\n<ul>\n<li>for _ </li>\n<li>Arc4random_uniform</li>\n</ul>\n<p><img src=\"https://img.cetacis.dev/uploads/big/4fcdf201e3264267e3355c353bc91efc.png\" alt=\"隨機生成數列\"></p>\n<p><strong>while loop1</strong></p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/ef122ebd9bbcbd6a09d0e7c66f1bbccd.png\" alt=\"while生成無重複數列\"></p>\n<p>*<em>while loop 2 *</em></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> ..&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"inherit\"><a href=\"#inherit\" class=\"headerlink\" title=\"inherit\"></a>inherit</h3><p><img src=\"https://img.cetacis.dev/uploads/big/21a22ee715d2cc1cde94d1d47e19b387.png\" alt=\"整體的繼承層次\"></p>\n<h2 id=\"ViewControler-swift\"><a href=\"#ViewControler-swift\" class=\"headerlink\" title=\"ViewControler.swift\"></a>ViewControler.swift</h2><h3 id=\"將elements-hook到-swift中，綁定action-outlet\"><a href=\"#將elements-hook到-swift中，綁定action-outlet\" class=\"headerlink\" title=\"將elements hook到.swift中，綁定action/outlet\"></a>將elements hook到.swift中，綁定action/outlet</h3><p>control+drag = blue line  IB outlet</p>\n<p>And we can enter the viewDigLoad to change the properties of Outlet</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/cdf7c03eefed1f31d82dd0a3a5d6ceeb.png\" alt=\"\"></p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/999fed4da9ebbc9421fe065bbe546f7f.png\" alt=\"change the information\"></p>\n<p>And the button can be link to action. The type of the connection is Action  （IB Action）</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/93d405ab9e4002a032ede3b3f4b21d69.png\" alt=\"給elemnet創建action：touch up inside可以改成其他的觸發事件\"></p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/e8ece4ca49579b1cc0c725492ceb1f43.png\" alt=\"\"></p>\n<h2 id=\"Ueser-Interaction\"><a href=\"#Ueser-Interaction\" class=\"headerlink\" title=\"Ueser Interaction\"></a>Ueser Interaction</h2><p><img src=\"https://img.cetacis.dev/uploads/big/e96bbd072a11b4dc4a3649bb74b8b9e7.png\" alt=\"IB Action\"></p>\n<h3 id=\"random\"><a href=\"#random\" class=\"headerlink\" title=\"random\"></a><strong><em>random</em></strong></h3><p>如果想讓左右的牌同時變並且隨機出現不同的點數，可以採用隨機數。</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/3b33e11f8ae4ca31a55e65812d2a0fcb.png\" alt=\"隨機數\"></p>\n<h2 id=\"buildup-actual-combat\"><a href=\"#buildup-actual-combat\" class=\"headerlink\" title=\"buildup actual combat\"></a>buildup actual combat</h2><h3 id=\"MVC\"><a href=\"#MVC\" class=\"headerlink\" title=\"MVC\"></a>MVC</h3><p>view : User use </p>\n<p>Controller: between view and model</p>\n<p>Model: data and logic</p>\n<p>database ——model——model——view</p>\n<p>優點：可複用性；代碼簡潔條理清晰</p>\n<p>Toryboard : view</p>\n<p>ViewController.swift : controller</p>\n<h3 id=\"1-在storyboard中建立collectionview-拖入素材照片並設置collection-view-cell-的identity-為CardCell-custom-class-為-CardCollectionViewCell\"><a href=\"#1-在storyboard中建立collectionview-拖入素材照片並設置collection-view-cell-的identity-為CardCell-custom-class-為-CardCollectionViewCell\" class=\"headerlink\" title=\"1. 在storyboard中建立collectionview 拖入素材照片並設置collection view cell 的identity 為CardCell custom class 為 CardCollectionViewCell\"></a>1. 在storyboard中建立collectionview 拖入素材照片並設置collection view cell 的identity 為CardCell custom class 為 CardCollectionViewCell</h3><p>此遊戲橫向，不可縱向 因此取消勾選portrait</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/4728bbb5766920205583b5e352b81b48.png\" alt=\"規定橫向\"></p>\n<p>這個將屏幕分成一個一個cell，規定位置時與safe area關聯，這樣可以防止重要的元素被遮擋。</p>\n<p>根據asset的大小調整cell的大小</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/d21da7b6d76fc0a2373ecb7ee3287a6b.png\" alt=\"\"></p>\n<p>可以給這裡的conllection View Cell 起個名字，把它當做模板。</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/e240e8c9028c2a2ce742831a907f9b13.png\" alt=\"\"></p>\n<h3 id=\"2-创建CardModel-swift-創建新的卡牌array-Card-swift（存放card-的數據結構）\"><a href=\"#2-创建CardModel-swift-創建新的卡牌array-Card-swift（存放card-的數據結構）\" class=\"headerlink\" title=\"2. 创建CardModel.swift (創建新的卡牌array), Card.swift（存放card 的數據結構）\"></a>2. 创建CardModel.swift (創建新的卡牌array), Card.swift（存放card 的數據結構）</h3><p>创建CardModel.swift (創建新的卡牌array), Card.swift（存放card 的數據結構）</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">CardModel</span>.swift</span><br><span class=\"line\"><span class=\"keyword\">import</span> Foundation</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CardModel</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">getCards</span><span class=\"params\">()</span></span>-&gt;[<span class=\"type\">Card</span>]&#123;</span><br><span class=\"line\">        <span class=\"comment\">//Declare an array to store generated cards</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> generatedCardsArray = [<span class=\"type\">Card</span>]()</span><br><span class=\"line\">        <span class=\"keyword\">var</span> unique = [<span class=\"type\">UInt32</span>]()</span><br><span class=\"line\">       </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//Randomly generate pairs of cards</span></span><br><span class=\"line\">        <span class=\"keyword\">repeat</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> random = arc4random_uniform(<span class=\"number\">13</span>)+<span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> unique.<span class=\"built_in\">contains</span>(random)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            unique.append(random)</span><br><span class=\"line\">            <span class=\"keyword\">let</span> card1 = <span class=\"type\">Card</span>()</span><br><span class=\"line\">            card1.imageName = <span class=\"string\">\"card\\(random)\"</span></span><br><span class=\"line\">            generatedCardsArray.append(card1)</span><br><span class=\"line\">            <span class=\"keyword\">let</span> card2 = <span class=\"type\">Card</span>()</span><br><span class=\"line\">            card2.imageName = <span class=\"string\">\"card\\(random)\"</span></span><br><span class=\"line\">            generatedCardsArray.append(card2)</span><br><span class=\"line\">            <span class=\"comment\">//print(random)</span></span><br><span class=\"line\">        &#125;<span class=\"keyword\">while</span> generatedCardsArray.<span class=\"built_in\">count</span>&lt;<span class=\"number\">16</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//Randomize the array</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//Return the array</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> generatedCardsArray</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Card</span>.swift</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> Foundation</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Card</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> imageName = <span class=\"string\">\"\"</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> isFlipped = <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> isMatched = <span class=\"literal\">false</span> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>然后初始化cardarray</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/19198b70a3b531275c431dcd97c4febe.png\" alt=\"在viewcontrol中調用\"></p>\n<h3 id=\"3-協議操作\"><a href=\"#3-協議操作\" class=\"headerlink\" title=\"3. 協議操作\"></a>3. 協議操作</h3><h4 id=\"protocol-and-delegate\"><a href=\"#protocol-and-delegate\" class=\"headerlink\" title=\"protocol and delegate\"></a>protocol and delegate</h4><p>在viewcontrol.swift中，我們知道可以通過viewcontrol.swift 改變 view，但這個交流是單向的，即viewcontrol可以向view傳遞信息，但是如果view想要請求得來自viewcontrol的信息（比如通過代碼來直接佈局view，或者在用戶拖動屏幕時，view會請求更新，但是他並不知道viewcontrol類的存在，我們需要解決這個問題），則只能通過 protocol（協議）和delegate（代理）</p>\n<p><em>代理个人理解是一种设计模式,OC中代理的模式是通过Protocol来实现的,指的是让其他类去实现遵守的协议中的方法.在本类中再调用这个方法,从而达到代理的目的. 比如A这个类想有一个方法,但是不想去实现这个方法,那么就找到B,B去实现A的这个方法,然后A再调用这个方法,这样A就成功的委托B去实现方法,达到代理的目的.</em></p>\n<p>我們知道 label, text,button 都是ui kidds classes，他們遵守一些協議，即擁有一些協議方法和協議屬性（可以理解成在專門的類中實現的方法和屬性），我們可以在viewcontrol中調用這些方法，以此來修改 label，button等。</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/ea8a7c1bc297f3086bd189a04f296e15.png\" alt=\"\"></p>\n<p>相反的，button，text都不知道viewcontrol的存在。</p>\n<h4 id=\"An-analogy\"><a href=\"#An-analogy\" class=\"headerlink\" title=\"An analogy\"></a>An analogy</h4><p>警察 需要調用不同車輛處理對應事件 他向警局申請，警局派出特定車輛</p>\n<p>警察不知道警局是誰在回應他，但是他只要告訴電話裡的那一端的人事件對應的代號，警局就可以發出特定的車輛。這個代號就存在協議中，而警局就相當於代理（delegate），相當於警察想要完成的事情（調用車輛），讓警局完成。</p>\n<p>換一種更接近代碼語言的類比，officer想要調用method A() , 而method A()的實現在代理類中實現，officer之所以可以直接請求method A() （或者說officer之所以知道代理中有這個類，是因為在協議中標明了應該有類和屬性）</p>\n<p>如下</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/1e6e3a49a31208a1814a66d810c27e14.png\" alt=\"\"></p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/351641441be0afba4059c2580aa1cf97.png\" alt=\"\"></p>\n<h4 id=\"举一个工程中的例子\"><a href=\"#举一个工程中的例子\" class=\"headerlink\" title=\"举一个工程中的例子\"></a>举一个工程中的例子</h4><p>將一個collection hook 到viewcontrol中。得到：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@IBOutlet</span> <span class=\"keyword\">weak</span> <span class=\"keyword\">var</span> mycollectionView: <span class=\"type\">UICollectionView!</span></span><br></pre></td></tr></table></figure>\n\n<p>我們知道，collection存在在UICollectionView這個類中。這個類遵守某個定義好的協議。當我們點進這個類的簡介，我們可以看到他所處的協議和代理的方式。datasource用來獲得數據，delegate用於事件相應等方法。</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/159367c6cad4afc1a2c21b0e67c3dc33.png\" alt=\"\"></p>\n<p>再點入某個協議，可以得知這個協議中規定的方法。</p>\n<p>在工程中，我們常常將viewController當做我們的代理類以及數據來源類，來實現協議中規定的方法和數據。使用者類本身的定義是在庫函數中（即collectionview），但是實例化則是在viewcontroller中（@IBOutlet weak var mycollectionView: UICollectionView!），實例化成mycollectionView後，給使用者類中定義的協議delegate和dataSource賦值（即使用者類所在的協議會在使用者類中被實例化為delegate和dataSource，通過賦值給代理類可以完成連接。類似於之前警察警局例子中的o.radio = b）。這個時候，代理類中就可以定義會自動執行的函數啦（我還沒想明白為什麼會自動執行這些函數，為什麼沒有沒有mycollection.XXX這樣的，但是這個函數定義的本身就很奇怪，先用吧）</p>\n<p><em>”使用者類“ （我自己啟的名字，我覺得將他比作協議的使用者比較合適）</em></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> UIKit</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewController</span>: <span class=\"title\">UIViewController</span>, <span class=\"title\">UITableViewDelegate</span>, <span class=\"title\">UITableViewDataSource</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@IBOutlet</span> <span class=\"keyword\">weak</span> <span class=\"keyword\">var</span> myTableView: <span class=\"type\">UITableView!</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> dataArray = [<span class=\"string\">\"bird\"</span>, <span class=\"string\">\"dog\"</span>, <span class=\"string\">\"cat\"</span>, <span class=\"string\">\"turtle\"</span>, <span class=\"string\">\"bear\"</span>]</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewDidLoad</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.viewDidLoad()</span><br><span class=\"line\">        </span><br><span class=\"line\">        myTableView.delegate = <span class=\"keyword\">self</span></span><br><span class=\"line\">        myTableView.dataSource = <span class=\"keyword\">self</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">didReceiveMemoryWarning</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.didReceiveMemoryWarning()</span><br><span class=\"line\">        <span class=\"comment\">// Dispose of any resources that can be recreated.</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">tableView</span><span class=\"params\">(<span class=\"number\">_</span> tableView: UITableView, numberOfRowsInSection section: Int)</span></span> -&gt; <span class=\"type\">Int</span> &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dataArray.<span class=\"built_in\">count</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">tableView</span><span class=\"params\">(<span class=\"number\">_</span> tableView: UITableView, cellForRowAt indexPath: IndexPath)</span></span> -&gt; <span class=\"type\">UITableViewCell</span> &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// Get the data for this row</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> rowData = dataArray[indexPath.row]</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// Get a cell to display</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> cell = tableView.dequeueReusableCell(withIdentifier: <span class=\"string\">\"BasicCell\"</span>, <span class=\"keyword\">for</span>: indexPath)</span><br><span class=\"line\">        cell.textLabel?.text = rowData</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// Return the cell</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> cell</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"本cardgame中的協議操作\"><a href=\"#本cardgame中的協議操作\" class=\"headerlink\" title=\"本cardgame中的協議操作\"></a>本cardgame中的協議操作</h4><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> UIKit</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewController</span>: <span class=\"title\">UIViewController</span>,<span class=\"title\">UICollectionViewDataSource</span>,<span class=\"title\">UICollectionViewDelegate</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> model = <span class=\"type\">CardModel</span>()</span><br><span class=\"line\">    <span class=\"keyword\">var</span> cardArray = [<span class=\"type\">Card</span>]()</span><br><span class=\"line\">    <span class=\"meta\">@IBOutlet</span> <span class=\"keyword\">weak</span> <span class=\"keyword\">var</span> collectionView: <span class=\"type\">UICollectionView!</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewDidLoad</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.viewDidLoad()</span><br><span class=\"line\">        <span class=\"comment\">// Do any additional setup after loading the view.</span></span><br><span class=\"line\">        collectionView.delegate = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">        collectionView.dataSource = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        cardArray = model.getCards()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//COLLECTIONVIEW ask it's delegate to calculate the sums of items in the collection</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">collectionView</span><span class=\"params\">(<span class=\"number\">_</span> collectionView: UICollectionView, numberOfItemsInSection section: Int)</span></span> -&gt; <span class=\"type\">Int</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cardArray.<span class=\"built_in\">count</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//ask the datasource for the new data for actually for each individual cell that need to be dispalyed</span></span><br><span class=\"line\">    <span class=\"comment\">// cell for item in that indexPath</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">collectionView</span><span class=\"params\">(<span class=\"number\">_</span> collectionView: UICollectionView, cellForItemAt indexPath: IndexPath)</span></span> -&gt; <span class=\"type\">UICollectionViewCell</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> cell = collectionView.dequeueReusableCell(withReuseIdentifier: <span class=\"string\">\"CardCell\"</span>, <span class=\"keyword\">for</span>: indexPath)<span class=\"keyword\">as</span>! <span class=\"type\">CardCollectionViewCell</span>;</span><br><span class=\"line\">        <span class=\"comment\">// use the exiting cell to repeat called by identity</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> cell;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">collectionView</span><span class=\"params\">(<span class=\"number\">_</span> collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath)</span></span> &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//when tap on the certain cell</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<p>如果需要定義一個底層的class 用swift file；反之，用cocoa</p>\n<p>特定的標識在注釋裡可以在整體函數預覽時可見 </p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// <span class=\"doctag\">TODO:</span> </span></span><br><span class=\"line\"><span class=\"comment\">// MARK:</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>editor -&gt;structure-&gt;In-dent 可以自動糾正格式</p>\n<h3 id=\"tip-debug\"><a href=\"#tip-debug\" class=\"headerlink\" title=\"tip debug\"></a>tip debug</h3><p>po double check the certain value and properties in the project </p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/c4d211865b0b189909dda4c6b0a7576c.png\" alt=\"debug\"></p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/ad95a71e728913a09e3bdc094174ef31.png\" alt=\"可以給斷點設置觸發條件\"></p>\n<p>擁有可視化層次</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/d84587ccd9cf579db4d0df09548e215e.png\" alt=\"擁有可視化層次\"></p>\n<p>在檢查code之前先檢查ui</p>\n<p>接着之前的工程。现在总结一下之前要做的</p>\n<ul>\n<li>在storyborad里建立collectionview 然后拖进两个image。将其cardcell确定custom class= CardCollectionViewCell和identify = CardCell。（cardcell是CardCollectionViewCell的一个实例）</li>\n<li>建立card.swift(card的数据结构)和cardModel.swift(返回card array)</li>\n<li>在viewcontroller中，进行协议的操作（具体如上）</li>\n<li>建立CardCollectionViewCell.swift对于设定的custom class进行操作</li>\n</ul>\n<h3 id=\"4-建立CardCollectionViewCell-swift对于设定的custom-class进行操作\"><a href=\"#4-建立CardCollectionViewCell-swift对于设定的custom-class进行操作\" class=\"headerlink\" title=\"4. 建立CardCollectionViewCell.swift对于设定的custom class进行操作\"></a>4. 建立CardCollectionViewCell.swift对于设定的custom class进行操作</h3><h4 id=\"custom-class\"><a href=\"#custom-class\" class=\"headerlink\" title=\"custom class\"></a>custom class</h4><p>創建cocoa touch class </p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/09a957c8fb1a982b3bd6ae64f042e938.png\" alt=\"img\"></p>\n<p>將cardcell的custom class修改成cardcollectionviewcell。這樣就可以在ccvc里用code控制cell中的圖片了</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/3f883a8305b30cd8de923f4c9fbe896b.png\" alt=\"img\"></p>\n<p>將image hook到ccvc中，就可以控制了</p>\n<p>我们设置这个class 叫做 CardCollectionViewCell ，他是UICollectionViewCell的子类 ，将frontImage和backImagine hook进来</p>\n<p><em>小tip： func name(_ type parameter){} 中的_ 代表形式參數是可缺省的</em></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// CardCollecionViewCell.swift </span></span><br><span class=\"line\"><span class=\"keyword\">import</span> UIKit</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CardCollectionViewCell</span>: <span class=\"title\">UICollectionViewCell</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@IBOutlet</span> <span class=\"keyword\">weak</span> <span class=\"keyword\">var</span> frontImageView: <span class=\"type\">UIImageView!</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@IBOutlet</span> <span class=\"keyword\">weak</span> <span class=\"keyword\">var</span> backImageView: <span class=\"type\">UIImageView!</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">var</span> card:<span class=\"type\">Card?</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">setCard</span><span class=\"params\">(<span class=\"number\">_</span> card:Card)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.card = card</span><br><span class=\"line\">        frontImageView.image = <span class=\"type\">UIImage</span>(named: card.imageName)</span><br><span class=\"line\">        <span class=\"comment\">// we have to call the setCard method for each of cells</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">flip</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">flipback</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>所以，viewcontroller(){}中協議方法的返回應該是CardCollectionViewCell類型。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//viewcontroller.swift</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> UIKit</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewController</span>: <span class=\"title\">UIViewController</span>,<span class=\"title\">UICollectionViewDataSource</span>,<span class=\"title\">UICollectionViewDelegate</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> model = <span class=\"type\">CardModel</span>()</span><br><span class=\"line\">    <span class=\"keyword\">var</span> cardArray = [<span class=\"type\">Card</span>]()</span><br><span class=\"line\">    <span class=\"meta\">@IBOutlet</span> <span class=\"keyword\">weak</span> <span class=\"keyword\">var</span> collectionView: <span class=\"type\">UICollectionView!</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewDidLoad</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.viewDidLoad()</span><br><span class=\"line\">        <span class=\"comment\">// Do any additional setup after loading the view.</span></span><br><span class=\"line\">        collectionView.delegate = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">        collectionView.dataSource = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        cardArray = model.getCards()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//COLLECTIONVIEW ask it's delegate to calculate the sums of items in the collection</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">collectionView</span><span class=\"params\">(<span class=\"number\">_</span> collectionView: UICollectionView, numberOfItemsInSection section: Int)</span></span> -&gt; <span class=\"type\">Int</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cardArray.<span class=\"built_in\">count</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//ask the datasource for the new data for actually for each individual cell that need to be dispalyed</span></span><br><span class=\"line\">    <span class=\"comment\">// cell for item in that indexPath</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">collectionView</span><span class=\"params\">(<span class=\"number\">_</span> collectionView: UICollectionView, cellForItemAt indexPath: IndexPath)</span></span> -&gt; <span class=\"type\">UICollectionViewCell</span> &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// get a cardcollectionviewcell object</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> cell = collectionView.dequeueReusableCell(withReuseIdentifier: <span class=\"string\">\"CardCell\"</span>, <span class=\"keyword\">for</span>: indexPath)<span class=\"keyword\">as</span>! <span class=\"type\">CardCollectionViewCell</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">       <span class=\"comment\">//get the card that the collectionview is trying to display</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> card = cardArray[indexPath.row]</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//set the card for the cell</span></span><br><span class=\"line\">        cell.setCard(card)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> cell;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">collectionView</span><span class=\"params\">(<span class=\"number\">_</span> collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath)</span></span> &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//when tap on the certain cell</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>現在已經實現了每一個cell都有了自己的圖畫（根據生成的cardarray）</p>\n<p>現在要定義flip的方法 </p>\n<p>在CardCollectionViewCell.swift中加上</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">flip</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"type\">UIView</span>.transition(from: backImageView, to: frontImageView, duration: <span class=\"number\">0.3</span>, options: [.transitionFlipFromLeft,.showHideTransitionViews], completion: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>並且修改viewController.swift 的didSelectItemAt函數</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">collectionView</span><span class=\"params\">(<span class=\"number\">_</span> collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// get the cell which is clicked</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> cell = collectionView.cellForItem(at: indexPath) <span class=\"keyword\">as</span>! <span class=\"type\">CardCollectionViewCell</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// get the card which is clicker</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> card = cardArray[indexPath.row]</span><br><span class=\"line\">            </span><br><span class=\"line\">      \t<span class=\"comment\">//flip the card</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> card.isFlipped == <span class=\"literal\">false</span>&#123;</span><br><span class=\"line\">            cell.flip()</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            cell.flipback()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">       </span><br><span class=\"line\">        <span class=\"comment\">//when tap on the certain cell</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>現在運行後便可以正常翻轉了，但是這時候當我們翻轉後，將屏幕下拉，等到拉回去的時候，就會發現翻開的不是原來那兩個了。這是因為每次出現這樣的情況，我們的setCard的func會重置，抹去之前的印記。</p>\n<p>修改CardCollectionViewCell.swift中的set</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">setCard</span><span class=\"params\">(<span class=\"number\">_</span> card:Card)</span></span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">self</span>.card = card</span><br><span class=\"line\">      frontImageView.image = <span class=\"type\">UIImage</span>(named: card.imageName)</span><br><span class=\"line\">      <span class=\"comment\">// we have to call the setCard method for each of cells</span></span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">//determine if the card is in a flipped up state or flipped down state.</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> card.isFlipped == <span class=\"literal\">true</span>&#123;</span><br><span class=\"line\">          <span class=\"comment\">//Make sure the frontview is on top</span></span><br><span class=\"line\">          <span class=\"type\">UIView</span>.transition(from: backImageView, to: frontImageView, duration: <span class=\"number\">0.3</span>, options: [.transitionFlipFromLeft,.showHideTransitionViews], completion: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">      &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">          <span class=\"comment\">// make sure the backview is on top</span></span><br><span class=\"line\">          <span class=\"type\">UIView</span>.transition(from: frontImageView, to: backImageView, duration: <span class=\"number\">0.3</span>, options: [.transitionFlipFromLeft,.showHideTransitionViews], completion: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-Game-Logic-and-optinization\"><a href=\"#5-Game-Logic-and-optinization\" class=\"headerlink\" title=\"5. Game Logic and optinization\"></a>5. Game Logic and optinization</h3><p>可以使牌正常地翻轉，初始化、動畫和事件已經綁定完成，接下來就要控制遊戲邏輯了。</p>\n<p>在每次翻到牌時，調用checkForMatch()，因此需要修改didSelectItemAt()</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">collectionView</span><span class=\"params\">(<span class=\"number\">_</span> collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath)</span></span> &#123;</span><br><span class=\"line\">     <span class=\"comment\">// get the cell which is clicked</span></span><br><span class=\"line\">     <span class=\"keyword\">let</span> cell = collectionView.cellForItem(at: indexPath) <span class=\"keyword\">as</span>! <span class=\"type\">CardCollectionViewCell</span></span><br><span class=\"line\">     </span><br><span class=\"line\">     </span><br><span class=\"line\">     <span class=\"comment\">// get the card which is clicker</span></span><br><span class=\"line\">     <span class=\"keyword\">let</span> card = cardArray[indexPath.row]</span><br><span class=\"line\">     </span><br><span class=\"line\">     <span class=\"keyword\">if</span> card.isFlipped == <span class=\"literal\">false</span>&#123;</span><br><span class=\"line\">         cell.flip()</span><br><span class=\"line\">         card.isFlipped = <span class=\"literal\">true</span></span><br><span class=\"line\">         </span><br><span class=\"line\">         <span class=\"keyword\">if</span> firstFlippedCardIndex == <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">             firstFlippedCardIndex = indexPath</span><br><span class=\"line\">         &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">             <span class=\"comment\">// <span class=\"doctag\">TODO:</span> the flipped card is the second card, we will use the game logic</span></span><br><span class=\"line\">           checkForMatch(indexPath)</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"comment\">//when tap on the certain cell</span></span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>检查翻到牌时是否匹配</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vc.swift</span><br><span class=\"line\">    <span class=\"keyword\">var</span> firstFlippedCardIndex : <span class=\"type\">IndexPath?</span></span><br><span class=\"line\"><span class=\"comment\">// MARK: Game logic methods.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">checkForMatch</span><span class=\"params\">(<span class=\"number\">_</span> secondFlippedCardIndex:IndexPath)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//Get two cells</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> cellOne = collectionView.cellForItem(at: firstFlippedCardIndex!) <span class=\"keyword\">as</span>? <span class=\"type\">CardCollectionViewCell</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> cellTwo = collectionView.cellForItem(at: secondFlippedCardIndex) <span class=\"keyword\">as</span>? <span class=\"type\">CardCollectionViewCell</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//Get two cards</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> cardOne = cardArray[firstFlippedCardIndex!.row];</span><br><span class=\"line\">        <span class=\"keyword\">let</span> cardTwo = cardArray[secondFlippedCardIndex.row];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//Compeare the two card</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> cardOne.imageName == cardTwo.imageName&#123;</span><br><span class=\"line\">            <span class=\"comment\">//matched</span></span><br><span class=\"line\">            <span class=\"comment\">//set the status of the cards</span></span><br><span class=\"line\">            cardOne.isMatched = <span class=\"literal\">true</span></span><br><span class=\"line\">            cardTwo.isMatched = <span class=\"literal\">true</span></span><br><span class=\"line\">            <span class=\"comment\">//remove the cards</span></span><br><span class=\"line\">            cellOne?.remove()</span><br><span class=\"line\">            cellTwo?.remove()</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            cardOne.isFlipped = <span class=\"literal\">false</span></span><br><span class=\"line\">            cardTwo.isFlipped = <span class=\"literal\">false</span></span><br><span class=\"line\">            cellOne?.flipback()</span><br><span class=\"line\">            cellTwo?.flipback()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        firstFlippedCardIndex = <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里的remove() 实在ccvc.swift中定義得</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">remove</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        frontImageView.alpha = <span class=\"number\">0</span></span><br><span class=\"line\">        backImageView.alpha = <span class=\"number\">0</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个时候会发现，因为flipback没有停留时间，如果一样，会立即消失，如果不同，则会立即返回，现在我们需要暂时的停顿。修改ccvc.swift的flipback函数</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">flipback</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"type\">DispatchQueue</span>.main.asyncAfter(deadline: <span class=\"type\">DispatchTime</span>.now()+<span class=\"number\">0.3</span>)&#123;</span><br><span class=\"line\">            <span class=\"type\">UIView</span>.transition(from: <span class=\"keyword\">self</span>.frontImageView, to: <span class=\"keyword\">self</span>.backImageView, duration: <span class=\"number\">0.3</span>, options: [.transitionFlipFromLeft,.showHideTransitionViews], completion: <span class=\"literal\">nil</span>)&#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>同时消失快我们可以通过改变remove()来解决（添加动画）</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">remove</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        backImageView.alpha = <span class=\"number\">0</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"type\">UIView</span>.animate(withDuration: <span class=\"number\">0.3</span>, delay: <span class=\"number\">0.5</span>, options: .curveEaseOut, animations:</span><br><span class=\"line\">            &#123;<span class=\"keyword\">self</span>.frontImageView.alpha = <span class=\"number\">0</span>&#125;, completion: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这时候还有一个问题，当纸牌翻消失，他并不是真的消失，他只是将alpha通道调为0，cell还在，所以再次点击还是会执行flip操作。因此我们应该给didSelectItemAt执行加一个条件，就是</p>\n<p>card.isFlipped == false &amp;&amp; card.isMatched == false</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">collectionView</span><span class=\"params\">(<span class=\"number\">_</span> collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath)</span></span> &#123;</span><br><span class=\"line\">       <span class=\"comment\">// get the cell which is clicked</span></span><br><span class=\"line\">       <span class=\"keyword\">let</span> cell = collectionView.cellForItem(at: indexPath) <span class=\"keyword\">as</span>! <span class=\"type\">CardCollectionViewCell</span></span><br><span class=\"line\">       </span><br><span class=\"line\">       </span><br><span class=\"line\">       <span class=\"comment\">// get the card which is clicker</span></span><br><span class=\"line\">       <span class=\"keyword\">let</span> card = cardArray[indexPath.row]</span><br><span class=\"line\">       </span><br><span class=\"line\">       <span class=\"keyword\">if</span> card.isFlipped == <span class=\"literal\">false</span> &amp;&amp; card.isMatched == <span class=\"literal\">false</span>&#123;</span><br><span class=\"line\">           cell.flip()</span><br><span class=\"line\">           card.isFlipped = <span class=\"literal\">true</span></span><br><span class=\"line\">           </span><br><span class=\"line\">           <span class=\"keyword\">if</span> firstFlippedCardIndex == <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">               firstFlippedCardIndex = indexPath</span><br><span class=\"line\">           &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">              checkForMatch(indexPath)</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"comment\">//when tap on the certain cell</span></span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>并且，我们的setcard执行也需要这样的条件，当这个被翻开或者已经匹配过 就不会进行setcard操作了.同時，當card.isMatched == false 時，我們要注意不能讓這些alpha=0的被重用，導致未匹配的卡消失。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">setCard</span><span class=\"params\">(<span class=\"number\">_</span> card:Card)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.card = card</span><br><span class=\"line\">        frontImageView.image = <span class=\"type\">UIImage</span>(named: card.imageName)</span><br><span class=\"line\">        <span class=\"comment\">// we have to call the setCard method for each of cells</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> card.isMatched == <span class=\"literal\">true</span>&#123;</span><br><span class=\"line\">            backImageView.alpha = <span class=\"number\">0</span></span><br><span class=\"line\">            frontImageView.alpha = <span class=\"number\">0</span></span><br><span class=\"line\">          \t<span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">          backImageView.alpha = <span class=\"number\">1</span></span><br><span class=\"line\">          frontImageView.alpha = <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//determine if the card is in a flipped up state or flipped down state.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> card.isFlipped == <span class=\"literal\">true</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">//Make sure the frontview is on top</span></span><br><span class=\"line\">            <span class=\"type\">UIView</span>.transition(from: backImageView, to: frontImageView, duration: <span class=\"number\">0.3</span>, options: [.transitionFlipFromLeft,.showHideTransitionViews], completion: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// make sure the backview is on top</span></span><br><span class=\"line\">            <span class=\"type\">UIView</span>.transition(from: frontImageView, to: backImageView, duration: <span class=\"number\">0.3</span>, options: [.transitionFlipFromLeft,.showHideTransitionViews], completion: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>當cardOne滑出屏幕，他的index會丟失，因此我們應該當cardOne == nill 重新調用 index</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"Stack-view-get-the-Auto-layout-contraints\"><a href=\"#Stack-view-get-the-Auto-layout-contraints\" class=\"headerlink\" title=\"Stack view (get the Auto layout contraints)\"></a>Stack view (get the Auto layout contraints)</h2><p>library -&gt;stackview (horizontal/vertegal doesen’t matter</p>\n<ul>\n<li>drag the elements into the stackview and change the <strong><em>Aligment</em></strong> and <strong><em>Distribution</em></strong> in the property bar.  </li>\n</ul>\n<p>we can use the stack view to manage many elements and their layout.</p>\n<p><em>change the <strong>backgroud</strong> of button to give it texture</em></p>\n<ul>\n<li><p>add <strong><em>horizantally in container</em></strong> and <strong><em>vertically in container</em></strong></p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/bef4430bb6422d782a0f03e1e5cb6ad9.png\" alt=\"\"></p>\n</li>\n</ul>\n<p><em>everything have to have constrains</em></p>\n<ul>\n<li><p>when we use the imageview to set the background, we’d uncheck the <strong><em>constraint margins</em></strong> and set the 0 to the <strong><em>view</em></strong>(not the safe area). </p>\n<p>Set the <strong><em>Content Mode</em></strong> to Aspect fill.</p>\n</li>\n<li><p><strong><em>Content Compression Resistance Priority</em></strong>: decide the priority of whether the picture will be compressed (default for 750)</p>\n</li>\n</ul>\n<p><img src=\"https://img.cetacis.dev/uploads/big/dc59c99442768426ad4f8bffc968975a.png\" alt=\"resistance for priority\"></p>\n<p>​    <strong><em>Content Hugging Priority</em></strong>: the same when the zone is too big.</p>","more":"<h2 id=\"Vary-layout\"><a href=\"#Vary-layout\" class=\"headerlink\" title=\"Vary layout\"></a>Vary layout</h2><ul>\n<li><p>when change the iphone to the horizontal, maybe them will be a strange issure</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">an internal error occured</span><br></pre></td></tr></table></figure>\n\n<p>So, *<em>Save the project *</em>before the change and after the issure, project-&gt;clean the build folder, then alt+Q to quit xcode and relaunch it.</p>\n</li>\n<li><p>Making the exiting stack view and an laber(or other elements) to be a new stackview is possible. And xcode can make them be oriented. </p>\n</li>\n</ul>\n<p><strong>The button is near the Add constrains button</strong></p>\n<ul>\n<li>add the certain constrains to the certain device. </li>\n</ul>\n<p><img src=\"https://img.cetacis.dev/uploads/big/6f6cdb5be94afdba4d1c01d511771bc5.png\" alt=\"\"></p>\n<p>Size class : wC hC ; wC hR; wR hR (C: compact R:regular)</p>\n<h3 id=\"vary-for-traits\"><a href=\"#vary-for-traits\" class=\"headerlink\" title=\"vary  for traits\"></a><strong>vary  for traits</strong></h3><p>the in the certain size class’s stack view’s Spacing, click the + and add the variation.</p>\n<ul>\n<li>when want to link to element, hold the <strong><em>control</em></strong> and the element and make a blue line link to the other element</li>\n</ul>\n<p><img src=\"https://img.cetacis.dev/uploads/big/888c8a380b4d5b34df6dc089ad3b9a03.png\" alt=\"\"></p>\n<ul>\n<li>Lable should link to other elements in three or four directions and the other element should have higher hugging prority the lable so that only the lable will be stretch to fill up any remaining space.</li>\n</ul>\n<h2 id=\"Swift\"><a href=\"#Swift\" class=\"headerlink\" title=\"Swift\"></a>Swift</h2><h3 id=\"basic\"><a href=\"#basic\" class=\"headerlink\" title=\"basic\"></a>basic</h3><p>let: constant  var: variable</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> i = <span class=\"number\">32</span> </span><br><span class=\"line\"><span class=\"keyword\">var</span> i:<span class=\"type\">Int</span> = <span class=\"number\">32</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> u:<span class=\"type\">Int?</span> <span class=\"comment\">// optionals</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> g = <span class=\"built_in\">abs</span>(-<span class=\"number\">1</span>) <span class=\"comment\">// absolute value</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> h = ceil(<span class=\"number\">1.8</span>)  <span class=\"comment\">// get the top number</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> i = floor(<span class=\"number\">1.4</span>)  <span class=\"comment\">//get the bottom number</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> j = sqrt(<span class=\"number\">36</span>)  <span class=\"comment\">// Square root</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> k = pow(<span class=\"number\">2</span>,<span class=\"number\">4</span>) <span class=\"comment\">//square</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">myFunction</span><span class=\"params\">(name:String, age:Int)</span></span> &#123; </span><br><span class=\"line\">\t<span class=\"built_in\">print</span>(<span class=\"string\">\"Here's \\(name), age \\(age)\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">addFourTo</span><span class=\"params\">(number:Int)</span></span> -&gt; <span class=\"type\">Int</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> number + <span class=\"number\">4</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> UIKit</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Spaceship</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">var</span> fuelLevel = <span class=\"number\">100</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> name = <span class=\"string\">\"\"</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">cruise</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Code to initiate cruising</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"Cruising is initiated for \\(name)\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">thrust</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Code to initiate rocket thrusters</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"Rocket thrusters initiated for \\(name)\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> myShip:<span class=\"type\">Spaceship</span> = <span class=\"type\">Spaceship</span>()</span><br><span class=\"line\">myShip.name = <span class=\"string\">\"Tom\"</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(myShip.name)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(myShip.fuelLevel)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> UIKit</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> y = <span class=\"number\">6</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (x &gt;= <span class=\"number\">11</span> || y == <span class=\"number\">6</span>) &amp;&amp; x + y == <span class=\"number\">10</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Hello\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span> x &gt; <span class=\"number\">5</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Good afternoon\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span> x &lt;= <span class=\"number\">2</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span> x != <span class=\"number\">2</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> UIKit</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">vowelDetector</span> <span class=\"params\">(str:String)</span></span> -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> str.<span class=\"built_in\">contains</span>(<span class=\"string\">\"a\"</span>) ||</span><br><span class=\"line\">        str.<span class=\"built_in\">contains</span>(<span class=\"string\">\"e\"</span>) ||</span><br><span class=\"line\">        str.<span class=\"built_in\">contains</span>(<span class=\"string\">\"i\"</span>) ||</span><br><span class=\"line\">        str.<span class=\"built_in\">contains</span>(<span class=\"string\">\"o\"</span>) ||</span><br><span class=\"line\">        str.<span class=\"built_in\">contains</span>(<span class=\"string\">\"u\"</span>) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span> (vowelDetector(str: <span class=\"string\">\"hello\"</span>))</span><br><span class=\"line\"><span class=\"built_in\">print</span> (vowelDetector(str: <span class=\"string\">\"sync\"</span>))</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Array\"><a href=\"#Array\" class=\"headerlink\" title=\"Array\"></a><a href=\"https://developer.apple.com/documentation/swift/array\" target=\"_blank\" rel=\"noopener\">Array</a></h4><h4 id=\"optionals-可nil可object\"><a href=\"#optionals-可nil可object\" class=\"headerlink\" title=\"optionals  可nil可object\"></a><strong>optionals</strong>  可nil可object</h4><p>nil is like none </p>\n<p>optional 存在是因為swift要求開發者必須規定一個變量是否為可nil變量，如果聲明了一個optioanl變量，我們必須在調用他的時候驗證這個是否是nil。驗證方法有兩種：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myInt:<span class=\"type\">Int?</span> <span class=\"comment\">// 聲明optionals </span></span><br><span class=\"line\">string</span><br><span class=\"line\"><span class=\"keyword\">if</span> myInt !=  <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(str!)<span class=\"comment\">// ！表示輸出str的內容，否則會輸出Oprional(myInt)</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> myInt == <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//show the wrong message</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 2. optional binding </span></span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> realint = str&#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(realint)</span><br><span class=\"line\">&#125;<span class=\"comment\">//當str == nil，什麼都不輸出。當str != nil 輸出string</span></span><br></pre></td></tr></table></figure>\n\n<p>也有不需要驗證的方法, ! 告訴xcode聲明的變量可能是nil也可能是object，但是這個行為是不安全的。這種變量不是optional，但是可以存儲nil。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str:<span class=\"type\">String!</span></span><br><span class=\"line\">str = <span class=\"literal\">nil</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(str)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Dictionary\"><a href=\"#Dictionary\" class=\"headerlink\" title=\"Dictionary\"></a>Dictionary</h4><ul>\n<li>Key word 是optional 輸出對應的data時應該考慮驗證optional</li>\n</ul>\n<p><img src=\"https://img.cetacis.dev/uploads/big/9310c9a8fdefaad1f911c5a082f43367.png\" alt=\"\"></p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/4b93703ed1a4428a89c34bbbc6fce4f9.png\" alt=\"\"></p>\n<p><strong>LOOP</strong></p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/d134398bd729fe1960acdbddbfba0a66.png\" alt=\"\"></p>\n<p><strong>隨機生成數列</strong> </p>\n<ul>\n<li>for _ </li>\n<li>Arc4random_uniform</li>\n</ul>\n<p><img src=\"https://img.cetacis.dev/uploads/big/4fcdf201e3264267e3355c353bc91efc.png\" alt=\"隨機生成數列\"></p>\n<p><strong>while loop1</strong></p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/ef122ebd9bbcbd6a09d0e7c66f1bbccd.png\" alt=\"while生成無重複數列\"></p>\n<p>*<em>while loop 2 *</em></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> ..&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"inherit\"><a href=\"#inherit\" class=\"headerlink\" title=\"inherit\"></a>inherit</h3><p><img src=\"https://img.cetacis.dev/uploads/big/21a22ee715d2cc1cde94d1d47e19b387.png\" alt=\"整體的繼承層次\"></p>\n<h2 id=\"ViewControler-swift\"><a href=\"#ViewControler-swift\" class=\"headerlink\" title=\"ViewControler.swift\"></a>ViewControler.swift</h2><h3 id=\"將elements-hook到-swift中，綁定action-outlet\"><a href=\"#將elements-hook到-swift中，綁定action-outlet\" class=\"headerlink\" title=\"將elements hook到.swift中，綁定action/outlet\"></a>將elements hook到.swift中，綁定action/outlet</h3><p>control+drag = blue line  IB outlet</p>\n<p>And we can enter the viewDigLoad to change the properties of Outlet</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/cdf7c03eefed1f31d82dd0a3a5d6ceeb.png\" alt=\"\"></p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/999fed4da9ebbc9421fe065bbe546f7f.png\" alt=\"change the information\"></p>\n<p>And the button can be link to action. The type of the connection is Action  （IB Action）</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/93d405ab9e4002a032ede3b3f4b21d69.png\" alt=\"給elemnet創建action：touch up inside可以改成其他的觸發事件\"></p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/e8ece4ca49579b1cc0c725492ceb1f43.png\" alt=\"\"></p>\n<h2 id=\"Ueser-Interaction\"><a href=\"#Ueser-Interaction\" class=\"headerlink\" title=\"Ueser Interaction\"></a>Ueser Interaction</h2><p><img src=\"https://img.cetacis.dev/uploads/big/e96bbd072a11b4dc4a3649bb74b8b9e7.png\" alt=\"IB Action\"></p>\n<h3 id=\"random\"><a href=\"#random\" class=\"headerlink\" title=\"random\"></a><strong><em>random</em></strong></h3><p>如果想讓左右的牌同時變並且隨機出現不同的點數，可以採用隨機數。</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/3b33e11f8ae4ca31a55e65812d2a0fcb.png\" alt=\"隨機數\"></p>\n<h2 id=\"buildup-actual-combat\"><a href=\"#buildup-actual-combat\" class=\"headerlink\" title=\"buildup actual combat\"></a>buildup actual combat</h2><h3 id=\"MVC\"><a href=\"#MVC\" class=\"headerlink\" title=\"MVC\"></a>MVC</h3><p>view : User use </p>\n<p>Controller: between view and model</p>\n<p>Model: data and logic</p>\n<p>database ——model——model——view</p>\n<p>優點：可複用性；代碼簡潔條理清晰</p>\n<p>Toryboard : view</p>\n<p>ViewController.swift : controller</p>\n<h3 id=\"1-在storyboard中建立collectionview-拖入素材照片並設置collection-view-cell-的identity-為CardCell-custom-class-為-CardCollectionViewCell\"><a href=\"#1-在storyboard中建立collectionview-拖入素材照片並設置collection-view-cell-的identity-為CardCell-custom-class-為-CardCollectionViewCell\" class=\"headerlink\" title=\"1. 在storyboard中建立collectionview 拖入素材照片並設置collection view cell 的identity 為CardCell custom class 為 CardCollectionViewCell\"></a>1. 在storyboard中建立collectionview 拖入素材照片並設置collection view cell 的identity 為CardCell custom class 為 CardCollectionViewCell</h3><p>此遊戲橫向，不可縱向 因此取消勾選portrait</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/4728bbb5766920205583b5e352b81b48.png\" alt=\"規定橫向\"></p>\n<p>這個將屏幕分成一個一個cell，規定位置時與safe area關聯，這樣可以防止重要的元素被遮擋。</p>\n<p>根據asset的大小調整cell的大小</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/d21da7b6d76fc0a2373ecb7ee3287a6b.png\" alt=\"\"></p>\n<p>可以給這裡的conllection View Cell 起個名字，把它當做模板。</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/e240e8c9028c2a2ce742831a907f9b13.png\" alt=\"\"></p>\n<h3 id=\"2-创建CardModel-swift-創建新的卡牌array-Card-swift（存放card-的數據結構）\"><a href=\"#2-创建CardModel-swift-創建新的卡牌array-Card-swift（存放card-的數據結構）\" class=\"headerlink\" title=\"2. 创建CardModel.swift (創建新的卡牌array), Card.swift（存放card 的數據結構）\"></a>2. 创建CardModel.swift (創建新的卡牌array), Card.swift（存放card 的數據結構）</h3><p>创建CardModel.swift (創建新的卡牌array), Card.swift（存放card 的數據結構）</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">CardModel</span>.swift</span><br><span class=\"line\"><span class=\"keyword\">import</span> Foundation</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CardModel</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">getCards</span><span class=\"params\">()</span></span>-&gt;[<span class=\"type\">Card</span>]&#123;</span><br><span class=\"line\">        <span class=\"comment\">//Declare an array to store generated cards</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> generatedCardsArray = [<span class=\"type\">Card</span>]()</span><br><span class=\"line\">        <span class=\"keyword\">var</span> unique = [<span class=\"type\">UInt32</span>]()</span><br><span class=\"line\">       </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//Randomly generate pairs of cards</span></span><br><span class=\"line\">        <span class=\"keyword\">repeat</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> random = arc4random_uniform(<span class=\"number\">13</span>)+<span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> unique.<span class=\"built_in\">contains</span>(random)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            unique.append(random)</span><br><span class=\"line\">            <span class=\"keyword\">let</span> card1 = <span class=\"type\">Card</span>()</span><br><span class=\"line\">            card1.imageName = <span class=\"string\">\"card\\(random)\"</span></span><br><span class=\"line\">            generatedCardsArray.append(card1)</span><br><span class=\"line\">            <span class=\"keyword\">let</span> card2 = <span class=\"type\">Card</span>()</span><br><span class=\"line\">            card2.imageName = <span class=\"string\">\"card\\(random)\"</span></span><br><span class=\"line\">            generatedCardsArray.append(card2)</span><br><span class=\"line\">            <span class=\"comment\">//print(random)</span></span><br><span class=\"line\">        &#125;<span class=\"keyword\">while</span> generatedCardsArray.<span class=\"built_in\">count</span>&lt;<span class=\"number\">16</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//Randomize the array</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//Return the array</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> generatedCardsArray</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Card</span>.swift</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> Foundation</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Card</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> imageName = <span class=\"string\">\"\"</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> isFlipped = <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> isMatched = <span class=\"literal\">false</span> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>然后初始化cardarray</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/19198b70a3b531275c431dcd97c4febe.png\" alt=\"在viewcontrol中調用\"></p>\n<h3 id=\"3-協議操作\"><a href=\"#3-協議操作\" class=\"headerlink\" title=\"3. 協議操作\"></a>3. 協議操作</h3><h4 id=\"protocol-and-delegate\"><a href=\"#protocol-and-delegate\" class=\"headerlink\" title=\"protocol and delegate\"></a>protocol and delegate</h4><p>在viewcontrol.swift中，我們知道可以通過viewcontrol.swift 改變 view，但這個交流是單向的，即viewcontrol可以向view傳遞信息，但是如果view想要請求得來自viewcontrol的信息（比如通過代碼來直接佈局view，或者在用戶拖動屏幕時，view會請求更新，但是他並不知道viewcontrol類的存在，我們需要解決這個問題），則只能通過 protocol（協議）和delegate（代理）</p>\n<p><em>代理个人理解是一种设计模式,OC中代理的模式是通过Protocol来实现的,指的是让其他类去实现遵守的协议中的方法.在本类中再调用这个方法,从而达到代理的目的. 比如A这个类想有一个方法,但是不想去实现这个方法,那么就找到B,B去实现A的这个方法,然后A再调用这个方法,这样A就成功的委托B去实现方法,达到代理的目的.</em></p>\n<p>我們知道 label, text,button 都是ui kidds classes，他們遵守一些協議，即擁有一些協議方法和協議屬性（可以理解成在專門的類中實現的方法和屬性），我們可以在viewcontrol中調用這些方法，以此來修改 label，button等。</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/ea8a7c1bc297f3086bd189a04f296e15.png\" alt=\"\"></p>\n<p>相反的，button，text都不知道viewcontrol的存在。</p>\n<h4 id=\"An-analogy\"><a href=\"#An-analogy\" class=\"headerlink\" title=\"An analogy\"></a>An analogy</h4><p>警察 需要調用不同車輛處理對應事件 他向警局申請，警局派出特定車輛</p>\n<p>警察不知道警局是誰在回應他，但是他只要告訴電話裡的那一端的人事件對應的代號，警局就可以發出特定的車輛。這個代號就存在協議中，而警局就相當於代理（delegate），相當於警察想要完成的事情（調用車輛），讓警局完成。</p>\n<p>換一種更接近代碼語言的類比，officer想要調用method A() , 而method A()的實現在代理類中實現，officer之所以可以直接請求method A() （或者說officer之所以知道代理中有這個類，是因為在協議中標明了應該有類和屬性）</p>\n<p>如下</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/1e6e3a49a31208a1814a66d810c27e14.png\" alt=\"\"></p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/351641441be0afba4059c2580aa1cf97.png\" alt=\"\"></p>\n<h4 id=\"举一个工程中的例子\"><a href=\"#举一个工程中的例子\" class=\"headerlink\" title=\"举一个工程中的例子\"></a>举一个工程中的例子</h4><p>將一個collection hook 到viewcontrol中。得到：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@IBOutlet</span> <span class=\"keyword\">weak</span> <span class=\"keyword\">var</span> mycollectionView: <span class=\"type\">UICollectionView!</span></span><br></pre></td></tr></table></figure>\n\n<p>我們知道，collection存在在UICollectionView這個類中。這個類遵守某個定義好的協議。當我們點進這個類的簡介，我們可以看到他所處的協議和代理的方式。datasource用來獲得數據，delegate用於事件相應等方法。</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/159367c6cad4afc1a2c21b0e67c3dc33.png\" alt=\"\"></p>\n<p>再點入某個協議，可以得知這個協議中規定的方法。</p>\n<p>在工程中，我們常常將viewController當做我們的代理類以及數據來源類，來實現協議中規定的方法和數據。使用者類本身的定義是在庫函數中（即collectionview），但是實例化則是在viewcontroller中（@IBOutlet weak var mycollectionView: UICollectionView!），實例化成mycollectionView後，給使用者類中定義的協議delegate和dataSource賦值（即使用者類所在的協議會在使用者類中被實例化為delegate和dataSource，通過賦值給代理類可以完成連接。類似於之前警察警局例子中的o.radio = b）。這個時候，代理類中就可以定義會自動執行的函數啦（我還沒想明白為什麼會自動執行這些函數，為什麼沒有沒有mycollection.XXX這樣的，但是這個函數定義的本身就很奇怪，先用吧）</p>\n<p><em>”使用者類“ （我自己啟的名字，我覺得將他比作協議的使用者比較合適）</em></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> UIKit</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewController</span>: <span class=\"title\">UIViewController</span>, <span class=\"title\">UITableViewDelegate</span>, <span class=\"title\">UITableViewDataSource</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@IBOutlet</span> <span class=\"keyword\">weak</span> <span class=\"keyword\">var</span> myTableView: <span class=\"type\">UITableView!</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> dataArray = [<span class=\"string\">\"bird\"</span>, <span class=\"string\">\"dog\"</span>, <span class=\"string\">\"cat\"</span>, <span class=\"string\">\"turtle\"</span>, <span class=\"string\">\"bear\"</span>]</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewDidLoad</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.viewDidLoad()</span><br><span class=\"line\">        </span><br><span class=\"line\">        myTableView.delegate = <span class=\"keyword\">self</span></span><br><span class=\"line\">        myTableView.dataSource = <span class=\"keyword\">self</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">didReceiveMemoryWarning</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.didReceiveMemoryWarning()</span><br><span class=\"line\">        <span class=\"comment\">// Dispose of any resources that can be recreated.</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">tableView</span><span class=\"params\">(<span class=\"number\">_</span> tableView: UITableView, numberOfRowsInSection section: Int)</span></span> -&gt; <span class=\"type\">Int</span> &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dataArray.<span class=\"built_in\">count</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">tableView</span><span class=\"params\">(<span class=\"number\">_</span> tableView: UITableView, cellForRowAt indexPath: IndexPath)</span></span> -&gt; <span class=\"type\">UITableViewCell</span> &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// Get the data for this row</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> rowData = dataArray[indexPath.row]</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// Get a cell to display</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> cell = tableView.dequeueReusableCell(withIdentifier: <span class=\"string\">\"BasicCell\"</span>, <span class=\"keyword\">for</span>: indexPath)</span><br><span class=\"line\">        cell.textLabel?.text = rowData</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// Return the cell</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> cell</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"本cardgame中的協議操作\"><a href=\"#本cardgame中的協議操作\" class=\"headerlink\" title=\"本cardgame中的協議操作\"></a>本cardgame中的協議操作</h4><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> UIKit</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewController</span>: <span class=\"title\">UIViewController</span>,<span class=\"title\">UICollectionViewDataSource</span>,<span class=\"title\">UICollectionViewDelegate</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> model = <span class=\"type\">CardModel</span>()</span><br><span class=\"line\">    <span class=\"keyword\">var</span> cardArray = [<span class=\"type\">Card</span>]()</span><br><span class=\"line\">    <span class=\"meta\">@IBOutlet</span> <span class=\"keyword\">weak</span> <span class=\"keyword\">var</span> collectionView: <span class=\"type\">UICollectionView!</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewDidLoad</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.viewDidLoad()</span><br><span class=\"line\">        <span class=\"comment\">// Do any additional setup after loading the view.</span></span><br><span class=\"line\">        collectionView.delegate = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">        collectionView.dataSource = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        cardArray = model.getCards()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//COLLECTIONVIEW ask it's delegate to calculate the sums of items in the collection</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">collectionView</span><span class=\"params\">(<span class=\"number\">_</span> collectionView: UICollectionView, numberOfItemsInSection section: Int)</span></span> -&gt; <span class=\"type\">Int</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cardArray.<span class=\"built_in\">count</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//ask the datasource for the new data for actually for each individual cell that need to be dispalyed</span></span><br><span class=\"line\">    <span class=\"comment\">// cell for item in that indexPath</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">collectionView</span><span class=\"params\">(<span class=\"number\">_</span> collectionView: UICollectionView, cellForItemAt indexPath: IndexPath)</span></span> -&gt; <span class=\"type\">UICollectionViewCell</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> cell = collectionView.dequeueReusableCell(withReuseIdentifier: <span class=\"string\">\"CardCell\"</span>, <span class=\"keyword\">for</span>: indexPath)<span class=\"keyword\">as</span>! <span class=\"type\">CardCollectionViewCell</span>;</span><br><span class=\"line\">        <span class=\"comment\">// use the exiting cell to repeat called by identity</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> cell;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">collectionView</span><span class=\"params\">(<span class=\"number\">_</span> collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath)</span></span> &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//when tap on the certain cell</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<p>如果需要定義一個底層的class 用swift file；反之，用cocoa</p>\n<p>特定的標識在注釋裡可以在整體函數預覽時可見 </p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// <span class=\"doctag\">TODO:</span> </span></span><br><span class=\"line\"><span class=\"comment\">// MARK:</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>editor -&gt;structure-&gt;In-dent 可以自動糾正格式</p>\n<h3 id=\"tip-debug\"><a href=\"#tip-debug\" class=\"headerlink\" title=\"tip debug\"></a>tip debug</h3><p>po double check the certain value and properties in the project </p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/c4d211865b0b189909dda4c6b0a7576c.png\" alt=\"debug\"></p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/ad95a71e728913a09e3bdc094174ef31.png\" alt=\"可以給斷點設置觸發條件\"></p>\n<p>擁有可視化層次</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/d84587ccd9cf579db4d0df09548e215e.png\" alt=\"擁有可視化層次\"></p>\n<p>在檢查code之前先檢查ui</p>\n<p>接着之前的工程。现在总结一下之前要做的</p>\n<ul>\n<li>在storyborad里建立collectionview 然后拖进两个image。将其cardcell确定custom class= CardCollectionViewCell和identify = CardCell。（cardcell是CardCollectionViewCell的一个实例）</li>\n<li>建立card.swift(card的数据结构)和cardModel.swift(返回card array)</li>\n<li>在viewcontroller中，进行协议的操作（具体如上）</li>\n<li>建立CardCollectionViewCell.swift对于设定的custom class进行操作</li>\n</ul>\n<h3 id=\"4-建立CardCollectionViewCell-swift对于设定的custom-class进行操作\"><a href=\"#4-建立CardCollectionViewCell-swift对于设定的custom-class进行操作\" class=\"headerlink\" title=\"4. 建立CardCollectionViewCell.swift对于设定的custom class进行操作\"></a>4. 建立CardCollectionViewCell.swift对于设定的custom class进行操作</h3><h4 id=\"custom-class\"><a href=\"#custom-class\" class=\"headerlink\" title=\"custom class\"></a>custom class</h4><p>創建cocoa touch class </p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/09a957c8fb1a982b3bd6ae64f042e938.png\" alt=\"img\"></p>\n<p>將cardcell的custom class修改成cardcollectionviewcell。這樣就可以在ccvc里用code控制cell中的圖片了</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/3f883a8305b30cd8de923f4c9fbe896b.png\" alt=\"img\"></p>\n<p>將image hook到ccvc中，就可以控制了</p>\n<p>我们设置这个class 叫做 CardCollectionViewCell ，他是UICollectionViewCell的子类 ，将frontImage和backImagine hook进来</p>\n<p><em>小tip： func name(_ type parameter){} 中的_ 代表形式參數是可缺省的</em></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// CardCollecionViewCell.swift </span></span><br><span class=\"line\"><span class=\"keyword\">import</span> UIKit</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CardCollectionViewCell</span>: <span class=\"title\">UICollectionViewCell</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@IBOutlet</span> <span class=\"keyword\">weak</span> <span class=\"keyword\">var</span> frontImageView: <span class=\"type\">UIImageView!</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@IBOutlet</span> <span class=\"keyword\">weak</span> <span class=\"keyword\">var</span> backImageView: <span class=\"type\">UIImageView!</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">var</span> card:<span class=\"type\">Card?</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">setCard</span><span class=\"params\">(<span class=\"number\">_</span> card:Card)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.card = card</span><br><span class=\"line\">        frontImageView.image = <span class=\"type\">UIImage</span>(named: card.imageName)</span><br><span class=\"line\">        <span class=\"comment\">// we have to call the setCard method for each of cells</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">flip</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">flipback</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>所以，viewcontroller(){}中協議方法的返回應該是CardCollectionViewCell類型。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//viewcontroller.swift</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> UIKit</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewController</span>: <span class=\"title\">UIViewController</span>,<span class=\"title\">UICollectionViewDataSource</span>,<span class=\"title\">UICollectionViewDelegate</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> model = <span class=\"type\">CardModel</span>()</span><br><span class=\"line\">    <span class=\"keyword\">var</span> cardArray = [<span class=\"type\">Card</span>]()</span><br><span class=\"line\">    <span class=\"meta\">@IBOutlet</span> <span class=\"keyword\">weak</span> <span class=\"keyword\">var</span> collectionView: <span class=\"type\">UICollectionView!</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewDidLoad</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.viewDidLoad()</span><br><span class=\"line\">        <span class=\"comment\">// Do any additional setup after loading the view.</span></span><br><span class=\"line\">        collectionView.delegate = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">        collectionView.dataSource = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        cardArray = model.getCards()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//COLLECTIONVIEW ask it's delegate to calculate the sums of items in the collection</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">collectionView</span><span class=\"params\">(<span class=\"number\">_</span> collectionView: UICollectionView, numberOfItemsInSection section: Int)</span></span> -&gt; <span class=\"type\">Int</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cardArray.<span class=\"built_in\">count</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//ask the datasource for the new data for actually for each individual cell that need to be dispalyed</span></span><br><span class=\"line\">    <span class=\"comment\">// cell for item in that indexPath</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">collectionView</span><span class=\"params\">(<span class=\"number\">_</span> collectionView: UICollectionView, cellForItemAt indexPath: IndexPath)</span></span> -&gt; <span class=\"type\">UICollectionViewCell</span> &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// get a cardcollectionviewcell object</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> cell = collectionView.dequeueReusableCell(withReuseIdentifier: <span class=\"string\">\"CardCell\"</span>, <span class=\"keyword\">for</span>: indexPath)<span class=\"keyword\">as</span>! <span class=\"type\">CardCollectionViewCell</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">       <span class=\"comment\">//get the card that the collectionview is trying to display</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> card = cardArray[indexPath.row]</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//set the card for the cell</span></span><br><span class=\"line\">        cell.setCard(card)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> cell;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">collectionView</span><span class=\"params\">(<span class=\"number\">_</span> collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath)</span></span> &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//when tap on the certain cell</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>現在已經實現了每一個cell都有了自己的圖畫（根據生成的cardarray）</p>\n<p>現在要定義flip的方法 </p>\n<p>在CardCollectionViewCell.swift中加上</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">flip</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"type\">UIView</span>.transition(from: backImageView, to: frontImageView, duration: <span class=\"number\">0.3</span>, options: [.transitionFlipFromLeft,.showHideTransitionViews], completion: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>並且修改viewController.swift 的didSelectItemAt函數</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">collectionView</span><span class=\"params\">(<span class=\"number\">_</span> collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// get the cell which is clicked</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> cell = collectionView.cellForItem(at: indexPath) <span class=\"keyword\">as</span>! <span class=\"type\">CardCollectionViewCell</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// get the card which is clicker</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> card = cardArray[indexPath.row]</span><br><span class=\"line\">            </span><br><span class=\"line\">      \t<span class=\"comment\">//flip the card</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> card.isFlipped == <span class=\"literal\">false</span>&#123;</span><br><span class=\"line\">            cell.flip()</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            cell.flipback()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">       </span><br><span class=\"line\">        <span class=\"comment\">//when tap on the certain cell</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>現在運行後便可以正常翻轉了，但是這時候當我們翻轉後，將屏幕下拉，等到拉回去的時候，就會發現翻開的不是原來那兩個了。這是因為每次出現這樣的情況，我們的setCard的func會重置，抹去之前的印記。</p>\n<p>修改CardCollectionViewCell.swift中的set</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">setCard</span><span class=\"params\">(<span class=\"number\">_</span> card:Card)</span></span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">self</span>.card = card</span><br><span class=\"line\">      frontImageView.image = <span class=\"type\">UIImage</span>(named: card.imageName)</span><br><span class=\"line\">      <span class=\"comment\">// we have to call the setCard method for each of cells</span></span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">//determine if the card is in a flipped up state or flipped down state.</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> card.isFlipped == <span class=\"literal\">true</span>&#123;</span><br><span class=\"line\">          <span class=\"comment\">//Make sure the frontview is on top</span></span><br><span class=\"line\">          <span class=\"type\">UIView</span>.transition(from: backImageView, to: frontImageView, duration: <span class=\"number\">0.3</span>, options: [.transitionFlipFromLeft,.showHideTransitionViews], completion: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">      &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">          <span class=\"comment\">// make sure the backview is on top</span></span><br><span class=\"line\">          <span class=\"type\">UIView</span>.transition(from: frontImageView, to: backImageView, duration: <span class=\"number\">0.3</span>, options: [.transitionFlipFromLeft,.showHideTransitionViews], completion: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-Game-Logic-and-optinization\"><a href=\"#5-Game-Logic-and-optinization\" class=\"headerlink\" title=\"5. Game Logic and optinization\"></a>5. Game Logic and optinization</h3><p>可以使牌正常地翻轉，初始化、動畫和事件已經綁定完成，接下來就要控制遊戲邏輯了。</p>\n<p>在每次翻到牌時，調用checkForMatch()，因此需要修改didSelectItemAt()</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">collectionView</span><span class=\"params\">(<span class=\"number\">_</span> collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath)</span></span> &#123;</span><br><span class=\"line\">     <span class=\"comment\">// get the cell which is clicked</span></span><br><span class=\"line\">     <span class=\"keyword\">let</span> cell = collectionView.cellForItem(at: indexPath) <span class=\"keyword\">as</span>! <span class=\"type\">CardCollectionViewCell</span></span><br><span class=\"line\">     </span><br><span class=\"line\">     </span><br><span class=\"line\">     <span class=\"comment\">// get the card which is clicker</span></span><br><span class=\"line\">     <span class=\"keyword\">let</span> card = cardArray[indexPath.row]</span><br><span class=\"line\">     </span><br><span class=\"line\">     <span class=\"keyword\">if</span> card.isFlipped == <span class=\"literal\">false</span>&#123;</span><br><span class=\"line\">         cell.flip()</span><br><span class=\"line\">         card.isFlipped = <span class=\"literal\">true</span></span><br><span class=\"line\">         </span><br><span class=\"line\">         <span class=\"keyword\">if</span> firstFlippedCardIndex == <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">             firstFlippedCardIndex = indexPath</span><br><span class=\"line\">         &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">             <span class=\"comment\">// <span class=\"doctag\">TODO:</span> the flipped card is the second card, we will use the game logic</span></span><br><span class=\"line\">           checkForMatch(indexPath)</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"comment\">//when tap on the certain cell</span></span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>检查翻到牌时是否匹配</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vc.swift</span><br><span class=\"line\">    <span class=\"keyword\">var</span> firstFlippedCardIndex : <span class=\"type\">IndexPath?</span></span><br><span class=\"line\"><span class=\"comment\">// MARK: Game logic methods.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">checkForMatch</span><span class=\"params\">(<span class=\"number\">_</span> secondFlippedCardIndex:IndexPath)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//Get two cells</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> cellOne = collectionView.cellForItem(at: firstFlippedCardIndex!) <span class=\"keyword\">as</span>? <span class=\"type\">CardCollectionViewCell</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> cellTwo = collectionView.cellForItem(at: secondFlippedCardIndex) <span class=\"keyword\">as</span>? <span class=\"type\">CardCollectionViewCell</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//Get two cards</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> cardOne = cardArray[firstFlippedCardIndex!.row];</span><br><span class=\"line\">        <span class=\"keyword\">let</span> cardTwo = cardArray[secondFlippedCardIndex.row];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//Compeare the two card</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> cardOne.imageName == cardTwo.imageName&#123;</span><br><span class=\"line\">            <span class=\"comment\">//matched</span></span><br><span class=\"line\">            <span class=\"comment\">//set the status of the cards</span></span><br><span class=\"line\">            cardOne.isMatched = <span class=\"literal\">true</span></span><br><span class=\"line\">            cardTwo.isMatched = <span class=\"literal\">true</span></span><br><span class=\"line\">            <span class=\"comment\">//remove the cards</span></span><br><span class=\"line\">            cellOne?.remove()</span><br><span class=\"line\">            cellTwo?.remove()</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            cardOne.isFlipped = <span class=\"literal\">false</span></span><br><span class=\"line\">            cardTwo.isFlipped = <span class=\"literal\">false</span></span><br><span class=\"line\">            cellOne?.flipback()</span><br><span class=\"line\">            cellTwo?.flipback()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        firstFlippedCardIndex = <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里的remove() 实在ccvc.swift中定義得</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">remove</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        frontImageView.alpha = <span class=\"number\">0</span></span><br><span class=\"line\">        backImageView.alpha = <span class=\"number\">0</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个时候会发现，因为flipback没有停留时间，如果一样，会立即消失，如果不同，则会立即返回，现在我们需要暂时的停顿。修改ccvc.swift的flipback函数</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">flipback</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"type\">DispatchQueue</span>.main.asyncAfter(deadline: <span class=\"type\">DispatchTime</span>.now()+<span class=\"number\">0.3</span>)&#123;</span><br><span class=\"line\">            <span class=\"type\">UIView</span>.transition(from: <span class=\"keyword\">self</span>.frontImageView, to: <span class=\"keyword\">self</span>.backImageView, duration: <span class=\"number\">0.3</span>, options: [.transitionFlipFromLeft,.showHideTransitionViews], completion: <span class=\"literal\">nil</span>)&#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>同时消失快我们可以通过改变remove()来解决（添加动画）</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">remove</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        backImageView.alpha = <span class=\"number\">0</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"type\">UIView</span>.animate(withDuration: <span class=\"number\">0.3</span>, delay: <span class=\"number\">0.5</span>, options: .curveEaseOut, animations:</span><br><span class=\"line\">            &#123;<span class=\"keyword\">self</span>.frontImageView.alpha = <span class=\"number\">0</span>&#125;, completion: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这时候还有一个问题，当纸牌翻消失，他并不是真的消失，他只是将alpha通道调为0，cell还在，所以再次点击还是会执行flip操作。因此我们应该给didSelectItemAt执行加一个条件，就是</p>\n<p>card.isFlipped == false &amp;&amp; card.isMatched == false</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">collectionView</span><span class=\"params\">(<span class=\"number\">_</span> collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath)</span></span> &#123;</span><br><span class=\"line\">       <span class=\"comment\">// get the cell which is clicked</span></span><br><span class=\"line\">       <span class=\"keyword\">let</span> cell = collectionView.cellForItem(at: indexPath) <span class=\"keyword\">as</span>! <span class=\"type\">CardCollectionViewCell</span></span><br><span class=\"line\">       </span><br><span class=\"line\">       </span><br><span class=\"line\">       <span class=\"comment\">// get the card which is clicker</span></span><br><span class=\"line\">       <span class=\"keyword\">let</span> card = cardArray[indexPath.row]</span><br><span class=\"line\">       </span><br><span class=\"line\">       <span class=\"keyword\">if</span> card.isFlipped == <span class=\"literal\">false</span> &amp;&amp; card.isMatched == <span class=\"literal\">false</span>&#123;</span><br><span class=\"line\">           cell.flip()</span><br><span class=\"line\">           card.isFlipped = <span class=\"literal\">true</span></span><br><span class=\"line\">           </span><br><span class=\"line\">           <span class=\"keyword\">if</span> firstFlippedCardIndex == <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">               firstFlippedCardIndex = indexPath</span><br><span class=\"line\">           &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">              checkForMatch(indexPath)</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"comment\">//when tap on the certain cell</span></span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>并且，我们的setcard执行也需要这样的条件，当这个被翻开或者已经匹配过 就不会进行setcard操作了.同時，當card.isMatched == false 時，我們要注意不能讓這些alpha=0的被重用，導致未匹配的卡消失。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">setCard</span><span class=\"params\">(<span class=\"number\">_</span> card:Card)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.card = card</span><br><span class=\"line\">        frontImageView.image = <span class=\"type\">UIImage</span>(named: card.imageName)</span><br><span class=\"line\">        <span class=\"comment\">// we have to call the setCard method for each of cells</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> card.isMatched == <span class=\"literal\">true</span>&#123;</span><br><span class=\"line\">            backImageView.alpha = <span class=\"number\">0</span></span><br><span class=\"line\">            frontImageView.alpha = <span class=\"number\">0</span></span><br><span class=\"line\">          \t<span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">          backImageView.alpha = <span class=\"number\">1</span></span><br><span class=\"line\">          frontImageView.alpha = <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//determine if the card is in a flipped up state or flipped down state.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> card.isFlipped == <span class=\"literal\">true</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">//Make sure the frontview is on top</span></span><br><span class=\"line\">            <span class=\"type\">UIView</span>.transition(from: backImageView, to: frontImageView, duration: <span class=\"number\">0.3</span>, options: [.transitionFlipFromLeft,.showHideTransitionViews], completion: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// make sure the backview is on top</span></span><br><span class=\"line\">            <span class=\"type\">UIView</span>.transition(from: frontImageView, to: backImageView, duration: <span class=\"number\">0.3</span>, options: [.transitionFlipFromLeft,.showHideTransitionViews], completion: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>當cardOne滑出屏幕，他的index會丟失，因此我們應該當cardOne == nill 重新調用 index</p>"},{"date":"2020-03-24T16:00:00.000Z","_content":"\n# 第七章 光照模型s\n\n重点\n\n1. 光源\n2. 基本光照模型（反射\n3. 投射模型\n\n## 7.1 光源\n\n### 7.1.1 光源分类\n\n**点光源 ** 适用于：比对象小的光源 离场景不是太近的大光源\n\n**无穷远光源** 放射方向一致平行\n\n### 7.1.2 辐射强度衰减（局部光源）\n\n![辐射强弱衰减公式](https://img.cetacis.dev/uploads/big/1fdcfaa11d17849f9e9367fc6397b965.png)\n\n用户可以调整系数a0，a1和a2的值以得到场景中不同的光照效果\n<!-- more -->\n### 7.1.3 方向光源和投射效果\n\n方向光源 – 对象位于光源的方向范围𝜃𝑙 内才能得到光照\n\nVlight – 光源方向的单位向量\n\nVobj – 光源位置到一个对象位置 的方向向量\n\n![](https://img.cetacis.dev/uploads/big/b6ec516eb1051a7df41c10720296fd3d.png)\n\n\n\n![](https://img.cetacis.dev/uploads/big/c6694a745d69ebdfb354e2b28d2952a7.png)\n\n### 7.1.4 角强度衰减\n\n沿着圆锥轴光强最大，离开时强度减弱\n\n方向光源角强度衰减函数: ($\\alpha$l - 衰减指数)\n\n![](https://img.cetacis.dev/uploads/big/1557b85bf8df80fe0734c2fb6ce94255.png)\n\n## 7.2 基本光照模型（反射）\n\n反射：漫反射 镜面反射\n\n环境光：场景中各个表 面的反射光生成的光照效果\n\n###  7.2.1 漫反射\n\n理想漫反射体 – 入射光在各个方向以相 同强度发散而与观察者位置无关\n\n#### 1.**朗伯余弦定理**\n\n在与对象表面法向量夹角为𝜙𝑁 方向上，每个面积为dA的平面单位所 发散的光线与cos𝜙𝑁 成正比\n\n#### 2. **漫反射系数**\n\n假设每一表面都按照理想漫反射体对待，则可确定将要按漫反射 发散的入射光部分的每一个表面设定一个参数kd，该参数称为漫 反射系数\n\nkd在0-1之间 强反射表面1.0 能吸收大部分入射光的表面 0\n\n####3. **环境光漫反射**\n\nI anbdiff = kd * Ia\n\nIa即背景光\n\n#### 4. **光源漫反射**\n\n当强度为Il的光源照射一个表面时，从该光 源来的入射光总量依赖于表面与光源的相对 方向\n\n与表面相交的光线数量与该表面投影到入射 光方向的面积成正比\n\n一个强度为I(l)的光源的入射光总量:\n\n![光源漫反射](https://img.cetacis.dev/uploads/big/49c2b91638dbeee51cee963d81576792.png)\n\n$cos\\alpha$算法：N · L\n\n![漫反射公式](https://img.cetacis.dev/uploads/big/4a9707ec9798e0699611e001c228453a.png)\n\n向量L 的算法：\n\n![向量L 的算法](https://img.cetacis.dev/uploads/big/537c02af96b767ae95dd840d89136d88.png)\n\n### 7.2.2 镜面反射\n\n镜面反射:在光滑表面上看到的 高光\n\n镜面反射是由接近镜面反射角的 一个汇聚区域内，入射光的全部 或绝大部分成为反射光所导致的\n\n理想的反射体 – V与R的夹角为0， 仅当V与R重合时才能观察到反 射光（一般考虑非理想）\n\n#### 非理想反射体\n\n 反射方向分布在向量R周围的有 限范围内\n\n较光滑表面的镜面反射范围较小，粗糙的对象表面有较大的反射范 围\n\n#### Phong 镜面反射模型\n\nPhong镜面反射模型 – 镜面反射光强度与𝑐𝑜𝑠𝑛𝑠 𝜙成正比\n\n![Phong镜面反射模型](https://img.cetacis.dev/uploads/big/8d7c8af4e669020b9b925a6c70ad1dd9.png)\n\nNs :镜面反射参数 由镜面表面材质决定，光滑ns打，粗糙ns小。\n\n![](https://img.cetacis.dev/uploads/big/14c20471921ac45b6af7196439b04f17.png)\n\n𝜙为V与R之间夹角 cos𝜙 = 𝑽 ∙ 𝑹 带入反射模型\n\n![](https://img.cetacis.dev/uploads/big/72f787e580d4a578087689c90e909a93.png)\n\n**R的计算方法：**\n\n1. 精确计算\n\n   ![](https://img.cetacis.dev/uploads/big/f48f8a7c00866196e501cf27b205b512.png)\n\n2. 简便计算（有误差\n\n![](https://img.cetacis.dev/uploads/big/c659311520ba265464c2b8dee7c84ab5.png)\n\n若观察者与光源离对象表面足够远，且V与L均为常量，则面 上所有点的H也为常量\n\n#### 漫反射镜面反射合并\n\n![单点](https://img.cetacis.dev/uploads/big/5cc88b2d86fe9b8796c2ee8c447809c6.png)\n\n![多点](https://img.cetacis.dev/uploads/big/69d338f3debaf5af31d42b40e5c40e25.png)\n\n## 7.3 透射光\n\n![](https://img.cetacis.dev/uploads/big/abebeaf3cbe28c8cc944353303806331.png)\n\nItrans是到达该点背后的光强\n\n## 7.4全局光照光线跟踪法\n\n全局光照算法\n\n### 7.4.1 概念\n\n从视点出发做经过图像平面上每个像素的光线并射回场景中，以此为基础计算表面的明暗效果\n\n![](https://img.cetacis.dev/uploads/big/5c23bcbda93c41022d88aaff152b40f2.png)\n\n跟踪光线在场景中的反射和折射，并且计算他们对光强的作用\n\n### 7.4.2 优缺点\n\n优点：真实 缺点：计算量大，视点/场景有变化就要重新计算\n\n### 7.4.3 光线跟踪树\n\n停止条件：无相交或者到达最大深度\n\n![](https://img.cetacis.dev/uploads/big/00b4baf553f9e213b47de8d1f8bd3ab1.png)\n\n### 7.4.4 求交计算\n\n![](https://img.cetacis.dev/uploads/big/8423922f57f9c61fe1cd9b35f60182ba.png)\n\n简化计算：\n\n光线与多面体求交：多用包围盒求交。也可以多层包围球减少计算量\n\n空间分割法：立方体分割\n\n## 7.5 纹理\n\n### 7.5.1 纹理映射\n\n**概念** 纹 理模式映射到对象表面上\n\n**种类** 2d 3d\n\n#### 2d映射\n\n1. 平面映射\n\n   将某坐标抛弃，其余两个定位一张素材图\n\n2. 圆柱体包裹\n\n   用一个形状将物体包裹\n\n3. 球体包裹\n\n4. 盒状素材\n\n#### 3d映射\n\n通过点(x,y,z)直接计算纹理颜色，不再使用map shape。即使用函数。\n\n### 7.5.2 凹凸映射\n\n凹凸映射 – 使用扰动函数并在光照模型计算中使用扰动法向量；\n\n通过修改物体表面法向量来 影响表面阴影的计算\n\n令P(u,v)表示一个参数曲面上的点 N = Pu X Pv （关于u,v的偏导数\n\n增加一个小的扰动函数(凹凸函数)b，在表面法向量𝑛 = 𝑵 |𝑵|方向上增加凹凸效果:\n\nP'（u,v） =  P（u,v）+ b(u,v)n\n\n# 第八章 关节动画\n\n1. 层次结构建模\n2. 正向运动学\n3. 逆向运动学\n\n## 8.1 层次结构建模\n\n### 8.1.1 基本概念\n\n关节 如果两个刚体互相连接且能够发生相对运动，则这两个刚 体的关联部分称为关节（=旋转关节 滑动关节）\n\n关节链 – 将一系列一次相连的刚体通过关节连接而成的开链\n\n链杆 – 关节链中每一段刚体\n\n基结点 – 关节链的起点\n\n末端影响器 – 关节链的自由末端(End effector)\n\n关节链结构的自由度 – 完全确定关节链结构状态所需的独立变量 个数\n\n状态空间： 所有可能的空间\n\n状态向量：状态空间中的向量\n\n关节链结构的自由度 – 完全确定关节链结构状态所需的独立变量 个数\n\n### 8.1.2 基于层次建模的数据结构\n\n•弧线–关节  •节点–链接杆\n\n### 8.1.3 正向运动学\n\n","source":"_posts/图形学-上课笔记.md","raw":"---\ndate: 2020/3/25\ntags:\n- 上课笔记\n- 进程\ncategories:\n- 游戏及图形学\n- 图形学\n---\n\n# 第七章 光照模型s\n\n重点\n\n1. 光源\n2. 基本光照模型（反射\n3. 投射模型\n\n## 7.1 光源\n\n### 7.1.1 光源分类\n\n**点光源 ** 适用于：比对象小的光源 离场景不是太近的大光源\n\n**无穷远光源** 放射方向一致平行\n\n### 7.1.2 辐射强度衰减（局部光源）\n\n![辐射强弱衰减公式](https://img.cetacis.dev/uploads/big/1fdcfaa11d17849f9e9367fc6397b965.png)\n\n用户可以调整系数a0，a1和a2的值以得到场景中不同的光照效果\n<!-- more -->\n### 7.1.3 方向光源和投射效果\n\n方向光源 – 对象位于光源的方向范围𝜃𝑙 内才能得到光照\n\nVlight – 光源方向的单位向量\n\nVobj – 光源位置到一个对象位置 的方向向量\n\n![](https://img.cetacis.dev/uploads/big/b6ec516eb1051a7df41c10720296fd3d.png)\n\n\n\n![](https://img.cetacis.dev/uploads/big/c6694a745d69ebdfb354e2b28d2952a7.png)\n\n### 7.1.4 角强度衰减\n\n沿着圆锥轴光强最大，离开时强度减弱\n\n方向光源角强度衰减函数: ($\\alpha$l - 衰减指数)\n\n![](https://img.cetacis.dev/uploads/big/1557b85bf8df80fe0734c2fb6ce94255.png)\n\n## 7.2 基本光照模型（反射）\n\n反射：漫反射 镜面反射\n\n环境光：场景中各个表 面的反射光生成的光照效果\n\n###  7.2.1 漫反射\n\n理想漫反射体 – 入射光在各个方向以相 同强度发散而与观察者位置无关\n\n#### 1.**朗伯余弦定理**\n\n在与对象表面法向量夹角为𝜙𝑁 方向上，每个面积为dA的平面单位所 发散的光线与cos𝜙𝑁 成正比\n\n#### 2. **漫反射系数**\n\n假设每一表面都按照理想漫反射体对待，则可确定将要按漫反射 发散的入射光部分的每一个表面设定一个参数kd，该参数称为漫 反射系数\n\nkd在0-1之间 强反射表面1.0 能吸收大部分入射光的表面 0\n\n####3. **环境光漫反射**\n\nI anbdiff = kd * Ia\n\nIa即背景光\n\n#### 4. **光源漫反射**\n\n当强度为Il的光源照射一个表面时，从该光 源来的入射光总量依赖于表面与光源的相对 方向\n\n与表面相交的光线数量与该表面投影到入射 光方向的面积成正比\n\n一个强度为I(l)的光源的入射光总量:\n\n![光源漫反射](https://img.cetacis.dev/uploads/big/49c2b91638dbeee51cee963d81576792.png)\n\n$cos\\alpha$算法：N · L\n\n![漫反射公式](https://img.cetacis.dev/uploads/big/4a9707ec9798e0699611e001c228453a.png)\n\n向量L 的算法：\n\n![向量L 的算法](https://img.cetacis.dev/uploads/big/537c02af96b767ae95dd840d89136d88.png)\n\n### 7.2.2 镜面反射\n\n镜面反射:在光滑表面上看到的 高光\n\n镜面反射是由接近镜面反射角的 一个汇聚区域内，入射光的全部 或绝大部分成为反射光所导致的\n\n理想的反射体 – V与R的夹角为0， 仅当V与R重合时才能观察到反 射光（一般考虑非理想）\n\n#### 非理想反射体\n\n 反射方向分布在向量R周围的有 限范围内\n\n较光滑表面的镜面反射范围较小，粗糙的对象表面有较大的反射范 围\n\n#### Phong 镜面反射模型\n\nPhong镜面反射模型 – 镜面反射光强度与𝑐𝑜𝑠𝑛𝑠 𝜙成正比\n\n![Phong镜面反射模型](https://img.cetacis.dev/uploads/big/8d7c8af4e669020b9b925a6c70ad1dd9.png)\n\nNs :镜面反射参数 由镜面表面材质决定，光滑ns打，粗糙ns小。\n\n![](https://img.cetacis.dev/uploads/big/14c20471921ac45b6af7196439b04f17.png)\n\n𝜙为V与R之间夹角 cos𝜙 = 𝑽 ∙ 𝑹 带入反射模型\n\n![](https://img.cetacis.dev/uploads/big/72f787e580d4a578087689c90e909a93.png)\n\n**R的计算方法：**\n\n1. 精确计算\n\n   ![](https://img.cetacis.dev/uploads/big/f48f8a7c00866196e501cf27b205b512.png)\n\n2. 简便计算（有误差\n\n![](https://img.cetacis.dev/uploads/big/c659311520ba265464c2b8dee7c84ab5.png)\n\n若观察者与光源离对象表面足够远，且V与L均为常量，则面 上所有点的H也为常量\n\n#### 漫反射镜面反射合并\n\n![单点](https://img.cetacis.dev/uploads/big/5cc88b2d86fe9b8796c2ee8c447809c6.png)\n\n![多点](https://img.cetacis.dev/uploads/big/69d338f3debaf5af31d42b40e5c40e25.png)\n\n## 7.3 透射光\n\n![](https://img.cetacis.dev/uploads/big/abebeaf3cbe28c8cc944353303806331.png)\n\nItrans是到达该点背后的光强\n\n## 7.4全局光照光线跟踪法\n\n全局光照算法\n\n### 7.4.1 概念\n\n从视点出发做经过图像平面上每个像素的光线并射回场景中，以此为基础计算表面的明暗效果\n\n![](https://img.cetacis.dev/uploads/big/5c23bcbda93c41022d88aaff152b40f2.png)\n\n跟踪光线在场景中的反射和折射，并且计算他们对光强的作用\n\n### 7.4.2 优缺点\n\n优点：真实 缺点：计算量大，视点/场景有变化就要重新计算\n\n### 7.4.3 光线跟踪树\n\n停止条件：无相交或者到达最大深度\n\n![](https://img.cetacis.dev/uploads/big/00b4baf553f9e213b47de8d1f8bd3ab1.png)\n\n### 7.4.4 求交计算\n\n![](https://img.cetacis.dev/uploads/big/8423922f57f9c61fe1cd9b35f60182ba.png)\n\n简化计算：\n\n光线与多面体求交：多用包围盒求交。也可以多层包围球减少计算量\n\n空间分割法：立方体分割\n\n## 7.5 纹理\n\n### 7.5.1 纹理映射\n\n**概念** 纹 理模式映射到对象表面上\n\n**种类** 2d 3d\n\n#### 2d映射\n\n1. 平面映射\n\n   将某坐标抛弃，其余两个定位一张素材图\n\n2. 圆柱体包裹\n\n   用一个形状将物体包裹\n\n3. 球体包裹\n\n4. 盒状素材\n\n#### 3d映射\n\n通过点(x,y,z)直接计算纹理颜色，不再使用map shape。即使用函数。\n\n### 7.5.2 凹凸映射\n\n凹凸映射 – 使用扰动函数并在光照模型计算中使用扰动法向量；\n\n通过修改物体表面法向量来 影响表面阴影的计算\n\n令P(u,v)表示一个参数曲面上的点 N = Pu X Pv （关于u,v的偏导数\n\n增加一个小的扰动函数(凹凸函数)b，在表面法向量𝑛 = 𝑵 |𝑵|方向上增加凹凸效果:\n\nP'（u,v） =  P（u,v）+ b(u,v)n\n\n# 第八章 关节动画\n\n1. 层次结构建模\n2. 正向运动学\n3. 逆向运动学\n\n## 8.1 层次结构建模\n\n### 8.1.1 基本概念\n\n关节 如果两个刚体互相连接且能够发生相对运动，则这两个刚 体的关联部分称为关节（=旋转关节 滑动关节）\n\n关节链 – 将一系列一次相连的刚体通过关节连接而成的开链\n\n链杆 – 关节链中每一段刚体\n\n基结点 – 关节链的起点\n\n末端影响器 – 关节链的自由末端(End effector)\n\n关节链结构的自由度 – 完全确定关节链结构状态所需的独立变量 个数\n\n状态空间： 所有可能的空间\n\n状态向量：状态空间中的向量\n\n关节链结构的自由度 – 完全确定关节链结构状态所需的独立变量 个数\n\n### 8.1.2 基于层次建模的数据结构\n\n•弧线–关节  •节点–链接杆\n\n### 8.1.3 正向运动学\n\n","slug":"图形学-上课笔记","published":1,"updated":"2020-03-27T04:02:39.000Z","title":"图形学-上课笔记","comments":1,"layout":"post","photos":[],"link":"","_id":"ck985a7800004slqg0bon0871","content":"<h1 id=\"第七章-光照模型s\"><a href=\"#第七章-光照模型s\" class=\"headerlink\" title=\"第七章 光照模型s\"></a>第七章 光照模型s</h1><p>重点</p>\n<ol>\n<li>光源</li>\n<li>基本光照模型（反射</li>\n<li>投射模型</li>\n</ol>\n<h2 id=\"7-1-光源\"><a href=\"#7-1-光源\" class=\"headerlink\" title=\"7.1 光源\"></a>7.1 光源</h2><h3 id=\"7-1-1-光源分类\"><a href=\"#7-1-1-光源分类\" class=\"headerlink\" title=\"7.1.1 光源分类\"></a>7.1.1 光源分类</h3><p>*<em>点光源 *</em> 适用于：比对象小的光源 离场景不是太近的大光源</p>\n<p><strong>无穷远光源</strong> 放射方向一致平行</p>\n<h3 id=\"7-1-2-辐射强度衰减（局部光源）\"><a href=\"#7-1-2-辐射强度衰减（局部光源）\" class=\"headerlink\" title=\"7.1.2 辐射强度衰减（局部光源）\"></a>7.1.2 辐射强度衰减（局部光源）</h3><p><img src=\"https://img.cetacis.dev/uploads/big/1fdcfaa11d17849f9e9367fc6397b965.png\" alt=\"辐射强弱衰减公式\"></p>\n<p>用户可以调整系数a0，a1和a2的值以得到场景中不同的光照效果</p>\n<a id=\"more\"></a>\n<h3 id=\"7-1-3-方向光源和投射效果\"><a href=\"#7-1-3-方向光源和投射效果\" class=\"headerlink\" title=\"7.1.3 方向光源和投射效果\"></a>7.1.3 方向光源和投射效果</h3><p>方向光源 – 对象位于光源的方向范围𝜃𝑙 内才能得到光照</p>\n<p>Vlight – 光源方向的单位向量</p>\n<p>Vobj – 光源位置到一个对象位置 的方向向量</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/b6ec516eb1051a7df41c10720296fd3d.png\" alt=\"\"></p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/c6694a745d69ebdfb354e2b28d2952a7.png\" alt=\"\"></p>\n<h3 id=\"7-1-4-角强度衰减\"><a href=\"#7-1-4-角强度衰减\" class=\"headerlink\" title=\"7.1.4 角强度衰减\"></a>7.1.4 角强度衰减</h3><p>沿着圆锥轴光强最大，离开时强度减弱</p>\n<p>方向光源角强度衰减函数: ($\\alpha$l - 衰减指数)</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/1557b85bf8df80fe0734c2fb6ce94255.png\" alt=\"\"></p>\n<h2 id=\"7-2-基本光照模型（反射）\"><a href=\"#7-2-基本光照模型（反射）\" class=\"headerlink\" title=\"7.2 基本光照模型（反射）\"></a>7.2 基本光照模型（反射）</h2><p>反射：漫反射 镜面反射</p>\n<p>环境光：场景中各个表 面的反射光生成的光照效果</p>\n<h3 id=\"7-2-1-漫反射\"><a href=\"#7-2-1-漫反射\" class=\"headerlink\" title=\"7.2.1 漫反射\"></a>7.2.1 漫反射</h3><p>理想漫反射体 – 入射光在各个方向以相 同强度发散而与观察者位置无关</p>\n<h4 id=\"1-朗伯余弦定理\"><a href=\"#1-朗伯余弦定理\" class=\"headerlink\" title=\"1.朗伯余弦定理\"></a>1.<strong>朗伯余弦定理</strong></h4><p>在与对象表面法向量夹角为𝜙𝑁 方向上，每个面积为dA的平面单位所 发散的光线与cos𝜙𝑁 成正比</p>\n<h4 id=\"2-漫反射系数\"><a href=\"#2-漫反射系数\" class=\"headerlink\" title=\"2. 漫反射系数\"></a>2. <strong>漫反射系数</strong></h4><p>假设每一表面都按照理想漫反射体对待，则可确定将要按漫反射 发散的入射光部分的每一个表面设定一个参数kd，该参数称为漫 反射系数</p>\n<p>kd在0-1之间 强反射表面1.0 能吸收大部分入射光的表面 0</p>\n<p>####3. <strong>环境光漫反射</strong></p>\n<p>I anbdiff = kd * Ia</p>\n<p>Ia即背景光</p>\n<h4 id=\"4-光源漫反射\"><a href=\"#4-光源漫反射\" class=\"headerlink\" title=\"4. 光源漫反射\"></a>4. <strong>光源漫反射</strong></h4><p>当强度为Il的光源照射一个表面时，从该光 源来的入射光总量依赖于表面与光源的相对 方向</p>\n<p>与表面相交的光线数量与该表面投影到入射 光方向的面积成正比</p>\n<p>一个强度为I(l)的光源的入射光总量:</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/49c2b91638dbeee51cee963d81576792.png\" alt=\"光源漫反射\"></p>\n<p>$cos\\alpha$算法：N · L</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/4a9707ec9798e0699611e001c228453a.png\" alt=\"漫反射公式\"></p>\n<p>向量L 的算法：</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/537c02af96b767ae95dd840d89136d88.png\" alt=\"向量L 的算法\"></p>\n<h3 id=\"7-2-2-镜面反射\"><a href=\"#7-2-2-镜面反射\" class=\"headerlink\" title=\"7.2.2 镜面反射\"></a>7.2.2 镜面反射</h3><p>镜面反射:在光滑表面上看到的 高光</p>\n<p>镜面反射是由接近镜面反射角的 一个汇聚区域内，入射光的全部 或绝大部分成为反射光所导致的</p>\n<p>理想的反射体 – V与R的夹角为0， 仅当V与R重合时才能观察到反 射光（一般考虑非理想）</p>\n<h4 id=\"非理想反射体\"><a href=\"#非理想反射体\" class=\"headerlink\" title=\"非理想反射体\"></a>非理想反射体</h4><p> 反射方向分布在向量R周围的有 限范围内</p>\n<p>较光滑表面的镜面反射范围较小，粗糙的对象表面有较大的反射范 围</p>\n<h4 id=\"Phong-镜面反射模型\"><a href=\"#Phong-镜面反射模型\" class=\"headerlink\" title=\"Phong 镜面反射模型\"></a>Phong 镜面反射模型</h4><p>Phong镜面反射模型 – 镜面反射光强度与𝑐𝑜𝑠𝑛𝑠 𝜙成正比</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/8d7c8af4e669020b9b925a6c70ad1dd9.png\" alt=\"Phong镜面反射模型\"></p>\n<p>Ns :镜面反射参数 由镜面表面材质决定，光滑ns打，粗糙ns小。</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/14c20471921ac45b6af7196439b04f17.png\" alt=\"\"></p>\n<p>𝜙为V与R之间夹角 cos𝜙 = 𝑽 ∙ 𝑹 带入反射模型</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/72f787e580d4a578087689c90e909a93.png\" alt=\"\"></p>\n<p><strong>R的计算方法：</strong></p>\n<ol>\n<li><p>精确计算</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/f48f8a7c00866196e501cf27b205b512.png\" alt=\"\"></p>\n</li>\n<li><p>简便计算（有误差</p>\n</li>\n</ol>\n<p><img src=\"https://img.cetacis.dev/uploads/big/c659311520ba265464c2b8dee7c84ab5.png\" alt=\"\"></p>\n<p>若观察者与光源离对象表面足够远，且V与L均为常量，则面 上所有点的H也为常量</p>\n<h4 id=\"漫反射镜面反射合并\"><a href=\"#漫反射镜面反射合并\" class=\"headerlink\" title=\"漫反射镜面反射合并\"></a>漫反射镜面反射合并</h4><p><img src=\"https://img.cetacis.dev/uploads/big/5cc88b2d86fe9b8796c2ee8c447809c6.png\" alt=\"单点\"></p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/69d338f3debaf5af31d42b40e5c40e25.png\" alt=\"多点\"></p>\n<h2 id=\"7-3-透射光\"><a href=\"#7-3-透射光\" class=\"headerlink\" title=\"7.3 透射光\"></a>7.3 透射光</h2><p><img src=\"https://img.cetacis.dev/uploads/big/abebeaf3cbe28c8cc944353303806331.png\" alt=\"\"></p>\n<p>Itrans是到达该点背后的光强</p>\n<h2 id=\"7-4全局光照光线跟踪法\"><a href=\"#7-4全局光照光线跟踪法\" class=\"headerlink\" title=\"7.4全局光照光线跟踪法\"></a>7.4全局光照光线跟踪法</h2><p>全局光照算法</p>\n<h3 id=\"7-4-1-概念\"><a href=\"#7-4-1-概念\" class=\"headerlink\" title=\"7.4.1 概念\"></a>7.4.1 概念</h3><p>从视点出发做经过图像平面上每个像素的光线并射回场景中，以此为基础计算表面的明暗效果</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/5c23bcbda93c41022d88aaff152b40f2.png\" alt=\"\"></p>\n<p>跟踪光线在场景中的反射和折射，并且计算他们对光强的作用</p>\n<h3 id=\"7-4-2-优缺点\"><a href=\"#7-4-2-优缺点\" class=\"headerlink\" title=\"7.4.2 优缺点\"></a>7.4.2 优缺点</h3><p>优点：真实 缺点：计算量大，视点/场景有变化就要重新计算</p>\n<h3 id=\"7-4-3-光线跟踪树\"><a href=\"#7-4-3-光线跟踪树\" class=\"headerlink\" title=\"7.4.3 光线跟踪树\"></a>7.4.3 光线跟踪树</h3><p>停止条件：无相交或者到达最大深度</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/00b4baf553f9e213b47de8d1f8bd3ab1.png\" alt=\"\"></p>\n<h3 id=\"7-4-4-求交计算\"><a href=\"#7-4-4-求交计算\" class=\"headerlink\" title=\"7.4.4 求交计算\"></a>7.4.4 求交计算</h3><p><img src=\"https://img.cetacis.dev/uploads/big/8423922f57f9c61fe1cd9b35f60182ba.png\" alt=\"\"></p>\n<p>简化计算：</p>\n<p>光线与多面体求交：多用包围盒求交。也可以多层包围球减少计算量</p>\n<p>空间分割法：立方体分割</p>\n<h2 id=\"7-5-纹理\"><a href=\"#7-5-纹理\" class=\"headerlink\" title=\"7.5 纹理\"></a>7.5 纹理</h2><h3 id=\"7-5-1-纹理映射\"><a href=\"#7-5-1-纹理映射\" class=\"headerlink\" title=\"7.5.1 纹理映射\"></a>7.5.1 纹理映射</h3><p><strong>概念</strong> 纹 理模式映射到对象表面上</p>\n<p><strong>种类</strong> 2d 3d</p>\n<h4 id=\"2d映射\"><a href=\"#2d映射\" class=\"headerlink\" title=\"2d映射\"></a>2d映射</h4><ol>\n<li><p>平面映射</p>\n<p>将某坐标抛弃，其余两个定位一张素材图</p>\n</li>\n<li><p>圆柱体包裹</p>\n<p>用一个形状将物体包裹</p>\n</li>\n<li><p>球体包裹</p>\n</li>\n<li><p>盒状素材</p>\n</li>\n</ol>\n<h4 id=\"3d映射\"><a href=\"#3d映射\" class=\"headerlink\" title=\"3d映射\"></a>3d映射</h4><p>通过点(x,y,z)直接计算纹理颜色，不再使用map shape。即使用函数。</p>\n<h3 id=\"7-5-2-凹凸映射\"><a href=\"#7-5-2-凹凸映射\" class=\"headerlink\" title=\"7.5.2 凹凸映射\"></a>7.5.2 凹凸映射</h3><p>凹凸映射 – 使用扰动函数并在光照模型计算中使用扰动法向量；</p>\n<p>通过修改物体表面法向量来 影响表面阴影的计算</p>\n<p>令P(u,v)表示一个参数曲面上的点 N = Pu X Pv （关于u,v的偏导数</p>\n<p>增加一个小的扰动函数(凹凸函数)b，在表面法向量𝑛 = 𝑵 |𝑵|方向上增加凹凸效果:</p>\n<p>P’（u,v） =  P（u,v）+ b(u,v)n</p>\n<h1 id=\"第八章-关节动画\"><a href=\"#第八章-关节动画\" class=\"headerlink\" title=\"第八章 关节动画\"></a>第八章 关节动画</h1><ol>\n<li>层次结构建模</li>\n<li>正向运动学</li>\n<li>逆向运动学</li>\n</ol>\n<h2 id=\"8-1-层次结构建模\"><a href=\"#8-1-层次结构建模\" class=\"headerlink\" title=\"8.1 层次结构建模\"></a>8.1 层次结构建模</h2><h3 id=\"8-1-1-基本概念\"><a href=\"#8-1-1-基本概念\" class=\"headerlink\" title=\"8.1.1 基本概念\"></a>8.1.1 基本概念</h3><p>关节 如果两个刚体互相连接且能够发生相对运动，则这两个刚 体的关联部分称为关节（=旋转关节 滑动关节）</p>\n<p>关节链 – 将一系列一次相连的刚体通过关节连接而成的开链</p>\n<p>链杆 – 关节链中每一段刚体</p>\n<p>基结点 – 关节链的起点</p>\n<p>末端影响器 – 关节链的自由末端(End effector)</p>\n<p>关节链结构的自由度 – 完全确定关节链结构状态所需的独立变量 个数</p>\n<p>状态空间： 所有可能的空间</p>\n<p>状态向量：状态空间中的向量</p>\n<p>关节链结构的自由度 – 完全确定关节链结构状态所需的独立变量 个数</p>\n<h3 id=\"8-1-2-基于层次建模的数据结构\"><a href=\"#8-1-2-基于层次建模的数据结构\" class=\"headerlink\" title=\"8.1.2 基于层次建模的数据结构\"></a>8.1.2 基于层次建模的数据结构</h3><p>•弧线–关节  •节点–链接杆</p>\n<h3 id=\"8-1-3-正向运动学\"><a href=\"#8-1-3-正向运动学\" class=\"headerlink\" title=\"8.1.3 正向运动学\"></a>8.1.3 正向运动学</h3>","site":{"data":{}},"excerpt":"<h1 id=\"第七章-光照模型s\"><a href=\"#第七章-光照模型s\" class=\"headerlink\" title=\"第七章 光照模型s\"></a>第七章 光照模型s</h1><p>重点</p>\n<ol>\n<li>光源</li>\n<li>基本光照模型（反射</li>\n<li>投射模型</li>\n</ol>\n<h2 id=\"7-1-光源\"><a href=\"#7-1-光源\" class=\"headerlink\" title=\"7.1 光源\"></a>7.1 光源</h2><h3 id=\"7-1-1-光源分类\"><a href=\"#7-1-1-光源分类\" class=\"headerlink\" title=\"7.1.1 光源分类\"></a>7.1.1 光源分类</h3><p>*<em>点光源 *</em> 适用于：比对象小的光源 离场景不是太近的大光源</p>\n<p><strong>无穷远光源</strong> 放射方向一致平行</p>\n<h3 id=\"7-1-2-辐射强度衰减（局部光源）\"><a href=\"#7-1-2-辐射强度衰减（局部光源）\" class=\"headerlink\" title=\"7.1.2 辐射强度衰减（局部光源）\"></a>7.1.2 辐射强度衰减（局部光源）</h3><p><img src=\"https://img.cetacis.dev/uploads/big/1fdcfaa11d17849f9e9367fc6397b965.png\" alt=\"辐射强弱衰减公式\"></p>\n<p>用户可以调整系数a0，a1和a2的值以得到场景中不同的光照效果</p>","more":"<h3 id=\"7-1-3-方向光源和投射效果\"><a href=\"#7-1-3-方向光源和投射效果\" class=\"headerlink\" title=\"7.1.3 方向光源和投射效果\"></a>7.1.3 方向光源和投射效果</h3><p>方向光源 – 对象位于光源的方向范围𝜃𝑙 内才能得到光照</p>\n<p>Vlight – 光源方向的单位向量</p>\n<p>Vobj – 光源位置到一个对象位置 的方向向量</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/b6ec516eb1051a7df41c10720296fd3d.png\" alt=\"\"></p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/c6694a745d69ebdfb354e2b28d2952a7.png\" alt=\"\"></p>\n<h3 id=\"7-1-4-角强度衰减\"><a href=\"#7-1-4-角强度衰减\" class=\"headerlink\" title=\"7.1.4 角强度衰减\"></a>7.1.4 角强度衰减</h3><p>沿着圆锥轴光强最大，离开时强度减弱</p>\n<p>方向光源角强度衰减函数: ($\\alpha$l - 衰减指数)</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/1557b85bf8df80fe0734c2fb6ce94255.png\" alt=\"\"></p>\n<h2 id=\"7-2-基本光照模型（反射）\"><a href=\"#7-2-基本光照模型（反射）\" class=\"headerlink\" title=\"7.2 基本光照模型（反射）\"></a>7.2 基本光照模型（反射）</h2><p>反射：漫反射 镜面反射</p>\n<p>环境光：场景中各个表 面的反射光生成的光照效果</p>\n<h3 id=\"7-2-1-漫反射\"><a href=\"#7-2-1-漫反射\" class=\"headerlink\" title=\"7.2.1 漫反射\"></a>7.2.1 漫反射</h3><p>理想漫反射体 – 入射光在各个方向以相 同强度发散而与观察者位置无关</p>\n<h4 id=\"1-朗伯余弦定理\"><a href=\"#1-朗伯余弦定理\" class=\"headerlink\" title=\"1.朗伯余弦定理\"></a>1.<strong>朗伯余弦定理</strong></h4><p>在与对象表面法向量夹角为𝜙𝑁 方向上，每个面积为dA的平面单位所 发散的光线与cos𝜙𝑁 成正比</p>\n<h4 id=\"2-漫反射系数\"><a href=\"#2-漫反射系数\" class=\"headerlink\" title=\"2. 漫反射系数\"></a>2. <strong>漫反射系数</strong></h4><p>假设每一表面都按照理想漫反射体对待，则可确定将要按漫反射 发散的入射光部分的每一个表面设定一个参数kd，该参数称为漫 反射系数</p>\n<p>kd在0-1之间 强反射表面1.0 能吸收大部分入射光的表面 0</p>\n<p>####3. <strong>环境光漫反射</strong></p>\n<p>I anbdiff = kd * Ia</p>\n<p>Ia即背景光</p>\n<h4 id=\"4-光源漫反射\"><a href=\"#4-光源漫反射\" class=\"headerlink\" title=\"4. 光源漫反射\"></a>4. <strong>光源漫反射</strong></h4><p>当强度为Il的光源照射一个表面时，从该光 源来的入射光总量依赖于表面与光源的相对 方向</p>\n<p>与表面相交的光线数量与该表面投影到入射 光方向的面积成正比</p>\n<p>一个强度为I(l)的光源的入射光总量:</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/49c2b91638dbeee51cee963d81576792.png\" alt=\"光源漫反射\"></p>\n<p>$cos\\alpha$算法：N · L</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/4a9707ec9798e0699611e001c228453a.png\" alt=\"漫反射公式\"></p>\n<p>向量L 的算法：</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/537c02af96b767ae95dd840d89136d88.png\" alt=\"向量L 的算法\"></p>\n<h3 id=\"7-2-2-镜面反射\"><a href=\"#7-2-2-镜面反射\" class=\"headerlink\" title=\"7.2.2 镜面反射\"></a>7.2.2 镜面反射</h3><p>镜面反射:在光滑表面上看到的 高光</p>\n<p>镜面反射是由接近镜面反射角的 一个汇聚区域内，入射光的全部 或绝大部分成为反射光所导致的</p>\n<p>理想的反射体 – V与R的夹角为0， 仅当V与R重合时才能观察到反 射光（一般考虑非理想）</p>\n<h4 id=\"非理想反射体\"><a href=\"#非理想反射体\" class=\"headerlink\" title=\"非理想反射体\"></a>非理想反射体</h4><p> 反射方向分布在向量R周围的有 限范围内</p>\n<p>较光滑表面的镜面反射范围较小，粗糙的对象表面有较大的反射范 围</p>\n<h4 id=\"Phong-镜面反射模型\"><a href=\"#Phong-镜面反射模型\" class=\"headerlink\" title=\"Phong 镜面反射模型\"></a>Phong 镜面反射模型</h4><p>Phong镜面反射模型 – 镜面反射光强度与𝑐𝑜𝑠𝑛𝑠 𝜙成正比</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/8d7c8af4e669020b9b925a6c70ad1dd9.png\" alt=\"Phong镜面反射模型\"></p>\n<p>Ns :镜面反射参数 由镜面表面材质决定，光滑ns打，粗糙ns小。</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/14c20471921ac45b6af7196439b04f17.png\" alt=\"\"></p>\n<p>𝜙为V与R之间夹角 cos𝜙 = 𝑽 ∙ 𝑹 带入反射模型</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/72f787e580d4a578087689c90e909a93.png\" alt=\"\"></p>\n<p><strong>R的计算方法：</strong></p>\n<ol>\n<li><p>精确计算</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/f48f8a7c00866196e501cf27b205b512.png\" alt=\"\"></p>\n</li>\n<li><p>简便计算（有误差</p>\n</li>\n</ol>\n<p><img src=\"https://img.cetacis.dev/uploads/big/c659311520ba265464c2b8dee7c84ab5.png\" alt=\"\"></p>\n<p>若观察者与光源离对象表面足够远，且V与L均为常量，则面 上所有点的H也为常量</p>\n<h4 id=\"漫反射镜面反射合并\"><a href=\"#漫反射镜面反射合并\" class=\"headerlink\" title=\"漫反射镜面反射合并\"></a>漫反射镜面反射合并</h4><p><img src=\"https://img.cetacis.dev/uploads/big/5cc88b2d86fe9b8796c2ee8c447809c6.png\" alt=\"单点\"></p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/69d338f3debaf5af31d42b40e5c40e25.png\" alt=\"多点\"></p>\n<h2 id=\"7-3-透射光\"><a href=\"#7-3-透射光\" class=\"headerlink\" title=\"7.3 透射光\"></a>7.3 透射光</h2><p><img src=\"https://img.cetacis.dev/uploads/big/abebeaf3cbe28c8cc944353303806331.png\" alt=\"\"></p>\n<p>Itrans是到达该点背后的光强</p>\n<h2 id=\"7-4全局光照光线跟踪法\"><a href=\"#7-4全局光照光线跟踪法\" class=\"headerlink\" title=\"7.4全局光照光线跟踪法\"></a>7.4全局光照光线跟踪法</h2><p>全局光照算法</p>\n<h3 id=\"7-4-1-概念\"><a href=\"#7-4-1-概念\" class=\"headerlink\" title=\"7.4.1 概念\"></a>7.4.1 概念</h3><p>从视点出发做经过图像平面上每个像素的光线并射回场景中，以此为基础计算表面的明暗效果</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/5c23bcbda93c41022d88aaff152b40f2.png\" alt=\"\"></p>\n<p>跟踪光线在场景中的反射和折射，并且计算他们对光强的作用</p>\n<h3 id=\"7-4-2-优缺点\"><a href=\"#7-4-2-优缺点\" class=\"headerlink\" title=\"7.4.2 优缺点\"></a>7.4.2 优缺点</h3><p>优点：真实 缺点：计算量大，视点/场景有变化就要重新计算</p>\n<h3 id=\"7-4-3-光线跟踪树\"><a href=\"#7-4-3-光线跟踪树\" class=\"headerlink\" title=\"7.4.3 光线跟踪树\"></a>7.4.3 光线跟踪树</h3><p>停止条件：无相交或者到达最大深度</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/00b4baf553f9e213b47de8d1f8bd3ab1.png\" alt=\"\"></p>\n<h3 id=\"7-4-4-求交计算\"><a href=\"#7-4-4-求交计算\" class=\"headerlink\" title=\"7.4.4 求交计算\"></a>7.4.4 求交计算</h3><p><img src=\"https://img.cetacis.dev/uploads/big/8423922f57f9c61fe1cd9b35f60182ba.png\" alt=\"\"></p>\n<p>简化计算：</p>\n<p>光线与多面体求交：多用包围盒求交。也可以多层包围球减少计算量</p>\n<p>空间分割法：立方体分割</p>\n<h2 id=\"7-5-纹理\"><a href=\"#7-5-纹理\" class=\"headerlink\" title=\"7.5 纹理\"></a>7.5 纹理</h2><h3 id=\"7-5-1-纹理映射\"><a href=\"#7-5-1-纹理映射\" class=\"headerlink\" title=\"7.5.1 纹理映射\"></a>7.5.1 纹理映射</h3><p><strong>概念</strong> 纹 理模式映射到对象表面上</p>\n<p><strong>种类</strong> 2d 3d</p>\n<h4 id=\"2d映射\"><a href=\"#2d映射\" class=\"headerlink\" title=\"2d映射\"></a>2d映射</h4><ol>\n<li><p>平面映射</p>\n<p>将某坐标抛弃，其余两个定位一张素材图</p>\n</li>\n<li><p>圆柱体包裹</p>\n<p>用一个形状将物体包裹</p>\n</li>\n<li><p>球体包裹</p>\n</li>\n<li><p>盒状素材</p>\n</li>\n</ol>\n<h4 id=\"3d映射\"><a href=\"#3d映射\" class=\"headerlink\" title=\"3d映射\"></a>3d映射</h4><p>通过点(x,y,z)直接计算纹理颜色，不再使用map shape。即使用函数。</p>\n<h3 id=\"7-5-2-凹凸映射\"><a href=\"#7-5-2-凹凸映射\" class=\"headerlink\" title=\"7.5.2 凹凸映射\"></a>7.5.2 凹凸映射</h3><p>凹凸映射 – 使用扰动函数并在光照模型计算中使用扰动法向量；</p>\n<p>通过修改物体表面法向量来 影响表面阴影的计算</p>\n<p>令P(u,v)表示一个参数曲面上的点 N = Pu X Pv （关于u,v的偏导数</p>\n<p>增加一个小的扰动函数(凹凸函数)b，在表面法向量𝑛 = 𝑵 |𝑵|方向上增加凹凸效果:</p>\n<p>P’（u,v） =  P（u,v）+ b(u,v)n</p>\n<h1 id=\"第八章-关节动画\"><a href=\"#第八章-关节动画\" class=\"headerlink\" title=\"第八章 关节动画\"></a>第八章 关节动画</h1><ol>\n<li>层次结构建模</li>\n<li>正向运动学</li>\n<li>逆向运动学</li>\n</ol>\n<h2 id=\"8-1-层次结构建模\"><a href=\"#8-1-层次结构建模\" class=\"headerlink\" title=\"8.1 层次结构建模\"></a>8.1 层次结构建模</h2><h3 id=\"8-1-1-基本概念\"><a href=\"#8-1-1-基本概念\" class=\"headerlink\" title=\"8.1.1 基本概念\"></a>8.1.1 基本概念</h3><p>关节 如果两个刚体互相连接且能够发生相对运动，则这两个刚 体的关联部分称为关节（=旋转关节 滑动关节）</p>\n<p>关节链 – 将一系列一次相连的刚体通过关节连接而成的开链</p>\n<p>链杆 – 关节链中每一段刚体</p>\n<p>基结点 – 关节链的起点</p>\n<p>末端影响器 – 关节链的自由末端(End effector)</p>\n<p>关节链结构的自由度 – 完全确定关节链结构状态所需的独立变量 个数</p>\n<p>状态空间： 所有可能的空间</p>\n<p>状态向量：状态空间中的向量</p>\n<p>关节链结构的自由度 – 完全确定关节链结构状态所需的独立变量 个数</p>\n<h3 id=\"8-1-2-基于层次建模的数据结构\"><a href=\"#8-1-2-基于层次建模的数据结构\" class=\"headerlink\" title=\"8.1.2 基于层次建模的数据结构\"></a>8.1.2 基于层次建模的数据结构</h3><p>•弧线–关节  •节点–链接杆</p>\n<h3 id=\"8-1-3-正向运动学\"><a href=\"#8-1-3-正向运动学\" class=\"headerlink\" title=\"8.1.3 正向运动学\"></a>8.1.3 正向运动学</h3>"},{"date":"2020-03-24T16:00:00.000Z","_content":"### 1. 服务器的快捷上传下载功能\n\n* 在~建立bin文件夹\n\n```shell\n~ mkdir bin\n```\n\n* 修改 ~/.zshrc ，将bin文件夹中的文件动态地执行。\n\n在.zshrc 添加语句\n\n```shell\nexport PATH=~/bin:$PATH\n```\n<!-- more -->\n此时 dwf = ./~/bin/dwf  \n\n* 在bin文件夹中定义指令\n\n```shell\nvim upf\n\nscp $2 $1:/public\n\nvim dwf\n\nscp $1:/public $2\n```\n\n* 修改.ssh 文件，添加config，即服务器的别称\n\n```shell\nHost sz # 别名\nHostName ***.com\nUser root # 用户 \n```\n\n即可使用\n\n```shell\nupf sz text\n```\n\n登录服务器\n\n```shell\nssh sz\n```\n\n不登录查看服务器文件夹的方法\n\n```shell\nssh sz \"cd /public; ls\"\n```\n\n\n\n### 2. 反向代理\n\n* 更改 ~/.zshrc\n\n```shell\nplugins=(git extract)\n```\n\n* 运行.zshrc\n\n```shell\nsource ~/.zshrc\n```\n\n* 下载相关工具\n\n```shell\nwget https://github.com/fatedier/frp/releases/download/v0.32.0/frp_0.32.0_darwin_amd64.tar.gz\n```\n\n* 解压\n\n```shell\nx frp_0.32.0_darwin_amd64.tar.gz   \n```\n\n* 修改frpc.ini\n\n在解压后的文件夹里找到frpc.ini并修改（配置文件 看官方文档）\n\n* 在电脑系统设置->共享->勾选远程连接 \n* 后台挂起服务\n\n创建挂起\n\n```shell\ntmux new -s frpc\n```\n\n打开已经挂起的程序\n\n```shell\ntmux attach -t frpc\n```\n\n挂起\n\n在frpc页面开启服务 \n\n```\n./frpc\ncontrol+B\n```\n\n*注意：在终端滑轮会当做指令*\n\n### 3. markdown数学符号\n(简介)[https://www.jianshu.com/p/86d4e3502e46]","source":"_posts/屠龙之技二（持续更新）.md","raw":"---\ndate: 2020/3/25\ntags:\n- 自学笔记\n- 终端基础操作\ncategories:\n- 屠龙之技\n---\n### 1. 服务器的快捷上传下载功能\n\n* 在~建立bin文件夹\n\n```shell\n~ mkdir bin\n```\n\n* 修改 ~/.zshrc ，将bin文件夹中的文件动态地执行。\n\n在.zshrc 添加语句\n\n```shell\nexport PATH=~/bin:$PATH\n```\n<!-- more -->\n此时 dwf = ./~/bin/dwf  \n\n* 在bin文件夹中定义指令\n\n```shell\nvim upf\n\nscp $2 $1:/public\n\nvim dwf\n\nscp $1:/public $2\n```\n\n* 修改.ssh 文件，添加config，即服务器的别称\n\n```shell\nHost sz # 别名\nHostName ***.com\nUser root # 用户 \n```\n\n即可使用\n\n```shell\nupf sz text\n```\n\n登录服务器\n\n```shell\nssh sz\n```\n\n不登录查看服务器文件夹的方法\n\n```shell\nssh sz \"cd /public; ls\"\n```\n\n\n\n### 2. 反向代理\n\n* 更改 ~/.zshrc\n\n```shell\nplugins=(git extract)\n```\n\n* 运行.zshrc\n\n```shell\nsource ~/.zshrc\n```\n\n* 下载相关工具\n\n```shell\nwget https://github.com/fatedier/frp/releases/download/v0.32.0/frp_0.32.0_darwin_amd64.tar.gz\n```\n\n* 解压\n\n```shell\nx frp_0.32.0_darwin_amd64.tar.gz   \n```\n\n* 修改frpc.ini\n\n在解压后的文件夹里找到frpc.ini并修改（配置文件 看官方文档）\n\n* 在电脑系统设置->共享->勾选远程连接 \n* 后台挂起服务\n\n创建挂起\n\n```shell\ntmux new -s frpc\n```\n\n打开已经挂起的程序\n\n```shell\ntmux attach -t frpc\n```\n\n挂起\n\n在frpc页面开启服务 \n\n```\n./frpc\ncontrol+B\n```\n\n*注意：在终端滑轮会当做指令*\n\n### 3. markdown数学符号\n(简介)[https://www.jianshu.com/p/86d4e3502e46]","slug":"屠龙之技二（持续更新）","published":1,"updated":"2020-03-25T03:23:54.000Z","title":"屠龙之技二（持续更新）","comments":1,"layout":"post","photos":[],"link":"","_id":"ck985a7820005slqg33gicbpi","content":"<h3 id=\"1-服务器的快捷上传下载功能\"><a href=\"#1-服务器的快捷上传下载功能\" class=\"headerlink\" title=\"1. 服务器的快捷上传下载功能\"></a>1. 服务器的快捷上传下载功能</h3><ul>\n<li>在~建立bin文件夹</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~ mkdir bin</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>修改 ~/.zshrc ，将bin文件夹中的文件动态地执行。</li>\n</ul>\n<p>在.zshrc 添加语句</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export PATH=~/bin:$PATH</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>此时 dwf = ./~/bin/dwf  </p>\n<ul>\n<li>在bin文件夹中定义指令</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim upf</span><br><span class=\"line\"></span><br><span class=\"line\">scp $2 $1:/public</span><br><span class=\"line\"></span><br><span class=\"line\">vim dwf</span><br><span class=\"line\"></span><br><span class=\"line\">scp $1:/public $2</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>修改.ssh 文件，添加config，即服务器的别称</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Host sz # 别名</span><br><span class=\"line\">HostName ***.com</span><br><span class=\"line\">User root # 用户</span><br></pre></td></tr></table></figure>\n\n<p>即可使用</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upf sz text</span><br></pre></td></tr></table></figure>\n\n<p>登录服务器</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh sz</span><br></pre></td></tr></table></figure>\n\n<p>不登录查看服务器文件夹的方法</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh sz \"cd /public; ls\"</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-反向代理\"><a href=\"#2-反向代理\" class=\"headerlink\" title=\"2. 反向代理\"></a>2. 反向代理</h3><ul>\n<li>更改 ~/.zshrc</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins=(git extract)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>运行.zshrc</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source ~/.zshrc</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>下载相关工具</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://github.com/fatedier/frp/releases/download/v0.32.0/frp_0.32.0_darwin_amd64.tar.gz</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>解压</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x frp_0.32.0_darwin_amd64.tar.gz</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>修改frpc.ini</li>\n</ul>\n<p>在解压后的文件夹里找到frpc.ini并修改（配置文件 看官方文档）</p>\n<ul>\n<li>在电脑系统设置-&gt;共享-&gt;勾选远程连接 </li>\n<li>后台挂起服务</li>\n</ul>\n<p>创建挂起</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tmux new -s frpc</span><br></pre></td></tr></table></figure>\n\n<p>打开已经挂起的程序</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tmux attach -t frpc</span><br></pre></td></tr></table></figure>\n\n<p>挂起</p>\n<p>在frpc页面开启服务 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.&#x2F;frpc</span><br><span class=\"line\">control+B</span><br></pre></td></tr></table></figure>\n\n<p><em>注意：在终端滑轮会当做指令</em></p>\n<h3 id=\"3-markdown数学符号\"><a href=\"#3-markdown数学符号\" class=\"headerlink\" title=\"3. markdown数学符号\"></a>3. markdown数学符号</h3><p>(简介)[<a href=\"https://www.jianshu.com/p/86d4e3502e46]\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/86d4e3502e46]</a></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-服务器的快捷上传下载功能\"><a href=\"#1-服务器的快捷上传下载功能\" class=\"headerlink\" title=\"1. 服务器的快捷上传下载功能\"></a>1. 服务器的快捷上传下载功能</h3><ul>\n<li>在~建立bin文件夹</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~ mkdir bin</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>修改 ~/.zshrc ，将bin文件夹中的文件动态地执行。</li>\n</ul>\n<p>在.zshrc 添加语句</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export PATH=~/bin:$PATH</span><br></pre></td></tr></table></figure>","more":"<p>此时 dwf = ./~/bin/dwf  </p>\n<ul>\n<li>在bin文件夹中定义指令</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim upf</span><br><span class=\"line\"></span><br><span class=\"line\">scp $2 $1:/public</span><br><span class=\"line\"></span><br><span class=\"line\">vim dwf</span><br><span class=\"line\"></span><br><span class=\"line\">scp $1:/public $2</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>修改.ssh 文件，添加config，即服务器的别称</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Host sz # 别名</span><br><span class=\"line\">HostName ***.com</span><br><span class=\"line\">User root # 用户</span><br></pre></td></tr></table></figure>\n\n<p>即可使用</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upf sz text</span><br></pre></td></tr></table></figure>\n\n<p>登录服务器</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh sz</span><br></pre></td></tr></table></figure>\n\n<p>不登录查看服务器文件夹的方法</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh sz \"cd /public; ls\"</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-反向代理\"><a href=\"#2-反向代理\" class=\"headerlink\" title=\"2. 反向代理\"></a>2. 反向代理</h3><ul>\n<li>更改 ~/.zshrc</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins=(git extract)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>运行.zshrc</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source ~/.zshrc</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>下载相关工具</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://github.com/fatedier/frp/releases/download/v0.32.0/frp_0.32.0_darwin_amd64.tar.gz</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>解压</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x frp_0.32.0_darwin_amd64.tar.gz</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>修改frpc.ini</li>\n</ul>\n<p>在解压后的文件夹里找到frpc.ini并修改（配置文件 看官方文档）</p>\n<ul>\n<li>在电脑系统设置-&gt;共享-&gt;勾选远程连接 </li>\n<li>后台挂起服务</li>\n</ul>\n<p>创建挂起</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tmux new -s frpc</span><br></pre></td></tr></table></figure>\n\n<p>打开已经挂起的程序</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tmux attach -t frpc</span><br></pre></td></tr></table></figure>\n\n<p>挂起</p>\n<p>在frpc页面开启服务 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.&#x2F;frpc</span><br><span class=\"line\">control+B</span><br></pre></td></tr></table></figure>\n\n<p><em>注意：在终端滑轮会当做指令</em></p>\n<h3 id=\"3-markdown数学符号\"><a href=\"#3-markdown数学符号\" class=\"headerlink\" title=\"3. markdown数学符号\"></a>3. markdown数学符号</h3><p>(简介)[<a href=\"https://www.jianshu.com/p/86d4e3502e46]\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/86d4e3502e46]</a></p>"},{"date":"2020-03-29T16:00:00.000Z","_content":"\n\n\n# 自顶向下的计算机网络3 运输层\n\n# 第三章 运输层\n\n目录：\n\n**传输层服务**\n\n**多路复用和多路分解**\n\n**无连接传输UDP**\n\n**可靠数据传输原理**\n\n**面向连接传输**\n\n**拥塞控制原理**   原因 后果 控制\n\n**TCP** **拥塞控制** \n<!-- more -->\n\n##  3.1 传输层服务\n\n1. 传输层服务和协议\n\n在两个不同的主机上运行的应用程序之间提供逻辑通信\n\n传输层协议运行在**端系统**（核心的交换机部分，只存在下面三层）：\n\n* 发送方: 将应用程序报文分成数据段传递给网络层\n* 接受方: 将数据段重新组装成报文传递到应用层 \n\n运输层协议：tcp udp\n\n![逻辑端到端](https://img.cetacis.dev/uploads/big/3aabb85d17bcec6c61b085fc5637f141.png)\n\n**可靠按序递交 (TCP) ：**  拥塞控制（拥塞时减缓发送方） 流量控制 （发送接收速度匹配） 连接建立 （握手）\n\n**不可靠的无序传递（udp）: **  UDP “尽力传递” IP的直接扩展  不提供的服务 : 延迟保证 带宽保证 \n\ntcp是可靠的，udp是不可靠的。网络层不可靠的\n\n------\n\n2. 运输层和网络层\n\n从通信和信息处理的角度看，运输层向它上面的 应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。\n\n类比：家庭类比:\n\n12个孩子向12个孩子发信   • 主机 = 家庭  • 进程 = 孩子  • 应用报文= 信封中的信 \n\n​                                               • 网络层协议= 邮政服务   • 运输协议 = Ann和Bill（家庭分发）\n\n**网络层：**两个主机之间的逻辑通信\n\n**传输层**：两个进程之间的逻辑通信  *可靠, 增强的网络层服务*\n\n## 3.2 多路复用和多路分解\n\n1. 总览\n\n![](https://img.cetacis.dev/uploads/big/ef6baf7007621db3e46d865f2616248b.png)\n\n**在发送主机多路复用:**\n\n从多个套接字收集数据, 用首部 封装数据，然后将报文段传递到 网络层多路复用\n\n**在接收主机多路分解:**\n\n将接收到的数据段传递到正确的套接字(多路分解)\n\n![](https://img.cetacis.dev/uploads/big/23ee20a92cd5b8b75415db0530a62cbf.png)\n\n---\n\n2. 多路分解如何工作\n\n主机接收IP数据报\n\n* 每个数据报承载1个运输层报文段\n\n* 每个段具有源、目的端口号\n  端口号代表不同的服务（进程）\n\n 主机使用IP地址 &端口号将段定向到适当的套接字\n\n![](https://img.cetacis.dev/uploads/big/e92bb4c5d174311573d73c7973ef121f.png)\n\n端口扫描：通过端口知悉服务\n\n---\n\n3. Udp无连接多路分解（一对多，多对一，多对多）\n\n* 套接字编程：\n\n  生成具有端口号的套接字: \n\n```java\nDatagramSocket mySocket1 = new DatagramSocket(9911); // mySocket1是一个套接字\n```\n\n```python\nserverSocket = socket(AF_INET, SOCK_DGRAM)# 创造套接字\nserverSocket.bind(('', serverPort))# 将端口号连接\n```\n\n* UDP套接字由二元组标识 : (目的ip地址，目的端口号)\n\n* 当主机接收UDP报文段时:\n\n  在报文段中检查目的地端口号\n\n  将UDP段定向到具有该端口号的套接字\n\n具有不同的源IP地址且/或源端口号，但 具有相同的目的IP地址和目的端口号的IP 报文段指向同样的套接字\n\n ![](https://img.cetacis.dev/uploads/big/6ae3c1f037ac20cb3f39433fedd97c09.png)\n\n原端口号（A.sp)是自动生成的，他在整个过程中不具有定位功能，他只是c在回发时的dp，所以它并不用指定。它为请求报文段中提供返回地址(包括IP地址和端口号)\n\n但是服务器的目的端口一定要指定\n\n---\n\n4. 面向连接的多路分解（TCP）\n\n**TCP 套接字由4部分指定:**\n\n源IP地址 源端口号 目的IP地址 目的端口号 \n\n接收主机使用所有四个值将数据段定位到合适的套接字\n\n**TCP服务器的套接字**\n\n服务器主机支持很多同时的tcp套接字：每个套接字用四个部分来表示\n\ntcp服务器有一个欢迎套接字，接受连接请求，tcp收到请求后会重开一个单独的连接套接字与客户机进行连接。\n\n连接套接字都是80端口，用源ip地址进行区分。\n\n![tcp服务器](https://img.cetacis.dev/uploads/big/a7bfeca2042c5f2cccd546dfe84ce1ed.png)\n\nweb：\n\n![](https://img.cetacis.dev/uploads/big/83d9d0dba8a39d31b343997ad1309c02.png)\n\n如图，b发出的两个tcp连接，通过源端口号区分\n\n## 3.3 udp\n\n1. udp：用户数据报协议（udp的报文段有时候叫数据报）\n\n特点：\n\n* 它是“基本要素”互联网传输协议\n\n* 因为是“尽力而为”服务，可能丢包，对应用程序交付失序\n\n* 无连接： 在udp发送方和接收方之间无握手；\n\n  ​\t\t\t\t每个udp段的处理独立于其他段（tcp面向流，可能同一个应用分在两个段中）\n\n- UDP 只在 IP 的数据报服务之上增加了很少一点的功能，即端口的功能和 差错检测的功能。 \n\n- 虽然 UDP 用户数据报只能提供不可靠的交付，但 UDP 在某些方面有其 特殊的优点。 \n\n- UDP 是无连接的，即发送数据之前不需要建立连接。 \n\n- UDP 使用尽最大努力交付，即不保证可靠交付，同时也不使用拥塞控制。 \n\n- UDP 没有拥塞控制，很适合多媒体通信的要求。  \n\n- UDP 支持一对一、一对多、多对一和多对多的交互通信。 \n\n- UDP 的首部开销小，只有 8 个字节。 \n\n- UDP 是面向报文的。发送方 UDP 对应用程序交下来的报文，在添加  首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并， 也不拆分，而是保留这些报文的边界。\n\n  *tcp无报文边界* \n\n- 应用层交给 UDP 多长的报文，UDP 就照样发送，即一次发送一个报文。 \n\n- 接收方 UDP 对 IP 层交上来的 UDP 用户数据报，在去除首部后就原 封不动地交付上层的应用进程，一次交付一个完整的报文。 \n\n- 应用程序必须选择合适大小的报文。\n\n----\n\n2. 为什么用udp？\n\n- 无连接创建（减少时延\n- 简单：可并发更多\n- 段首部小\n- 无拥塞控制：udp能够尽可能快地传输\n\n![面向报文的udp数据包](https://img.cetacis.dev/uploads/big/2dd4c563c7157a58d462f132de254834.png)\n\n---\n\n3. **udp的应用：**\n\n常用于流式多媒体应用 ：丢包容忍、速率敏感\n\n其他UDP应用： DNS（增加速率）、SNMP、RTP（路由选择协议 向其他路由器通报信息）\n\n经UDP的可靠传输 : 在应用层增加可靠性，应用程序特定的差错恢复!\n\n![](https://img.cetacis.dev/uploads/big/bfb81d85950595932dbf162253b0887d.png)\n\n*检验和：检查数据报是否出错*\n\n4. udp检验和与差错检测\n\n* 差错检测\n\n![差错检测](https://img.cetacis.dev/uploads/big/01028c74db7d536acdeb68fe37e9b401.png)\n\n*检错可能出现漏掉的错误（很少；大的校验信息 域能提供更好 的检错能力*\n\n* 检验和\n\n目标：对传输的数据进行差错检测\n\n发送方：将数据段看成16bit的整数序列\n\n​\t\t\t\t校验和:段内容进行带循环进位的加法，结果取反码\n\n​\t\t\t\t发送者将校验和值放入UDP的校验和域\n\n接收方：计算接收到数据段的校验和 \n\n​\t\t\t\t检查 计算的校验和是否等于校验和域中的值:\n​\t\t\t\t• NO – 检测到错误\n​\t\t\t\t• YES – 没有检测到错误\n\n​\t\t\t\t还是有可能出错\n\n![](https://img.cetacis.dev/uploads/big/559a0e644e35a34f5ae4ee80aa39a8e9.png)\n\n![注意循环进位](https://img.cetacis.dev/uploads/big/31cb0a6d0772550ca5bf8be2393c5055.png)\n\n**记得循环进位**\n\n## 3.4 可靠数据传输原理\n\n运输层需要提供可靠传输，但是网络层没有可靠，所以就需要接口。\n\n![可靠数据传输：基本概念](https://img.cetacis.dev/uploads/big/7a39d15318100c8d1431b69927c59bab.png)\n\n四个函数可以看做动作/事件\n\n逐步开发发送方和接收方的可靠数据传输协议 (rdt)：\n\n* 仅考虑单向数据传输\n* 控制信息将在两个方向流动\n\n有限状态机 (FSM)来定义发送方和接收方\n\n![有限状态机<数字逻辑>](https://img.cetacis.dev/uploads/big/72bf5f176f835798782c1dac3f21ad16.png)\n\n1. rdt的发展\n\n**Rdt1.0:** **完全可靠信道上的可靠数据传输**\n\n在完美可靠的信道上\n\t• 没有bit错误\n\n​\t• 没有分组丢失 \n\n发送方，接收方单独的 FSMs : \n\n​\t• 发送方发送数据到下层信道 \n\n​\t• 接收方从下层信道接收数据 \n\n![rdt1.0](https://img.cetacis.dev/uploads/big/cffcc44f90050d8d2170c4fe8fbf126f.png)\n\n**Rdt2.0:** **具有bit错误的信道**\n\n下层信道可能让传输分组中的bit受损 \n\n* 校验和将检测到bit错误\n\n问题: 如何从错误中恢复\n\n* 确认(ACKs): 接收方明确告诉发送方 分组接收正确\n* 否认 (NAKs):接收方明确告诉发送方 分组接收出错 \n* 发送方收到NAK后重发这个分组\n\n在 rdt2.0的新机制 (在 rdt1.0中没有的): \n\n* 差错检测\n\n* 接收方反馈: 控制信息 (ACK,NAK)\n* 重传\n\n![rdt2.0](https://img.cetacis.dev/uploads/big/2998071b3d7db73519ca8bcd2d69b288.png)\n\nrdt2.0是一个停-等协议（字面意思\n\nRdt2.0的缺陷：如果ACK/NAK受损，将会出现 发送方不知道在接收方会发生 什么情况。\n\n​\t\t\t\t\t\t  重传可能导致冗余\n\n处理冗余:\n\n• 发送方对每个分组增加序列号\n\n• 如果ACK/NAK受损，发送方重传当前的分组\n\n• 接收方丢弃(不再向上交付)冗 余分组\n\n**rdt2.1**\n\n发送方：\n\n两个序号0/1 够用，为什么？  -因为停等协议\n\n检查是否收到的ACK/NAK 受损\n\n状态增加一倍 状态必须“记住”是否“当前的”分组具有0或1序号\n\n接收方：\n\n检查是否接收到分组时候冗余  状态指示是否0/1是否是起飞的分组序号\n\n注意：接收方不知道它的ack/nal时候被正确接收\n\n发送方\n\n![](https://img.cetacis.dev/uploads/big/b36b7d0725db5c2df42f09cd2668e081.png)\n\n\n\n\n\n接收方：\n\n![接收方处理受损的ack/nak](https://img.cetacis.dev/uploads/big/d26e255338267a9c4a5750b63487e51a.png)\n\n正确报文序号正确：拆包，上传给上方->等待来自下面的调用1\n\n正确报文序号错误1 ：回发ack（因为发出了1，所以可能是因为上次接收方回发的ack1受损了，所以此时应该回发ack1使发送方发送下一个序号的数据报）->等待来自下面的调用0\n\n错误报文：回发NAK->等待来自下面的调用0\n\n**rdt2.2 : 不要nak的协议 **\n\n同 rdt2.1一样的功能, 只用 ACKs\n不用 NAK, 如果上个报文接收正确接收方发送 ACK\n\n* 接收方必须明确包含被确认的报文的序号 \n\n发送方收到重复 ACK 将导致和 NAK一样的 处理: 重发当前报文 \n\n发送方发送0包，但是收到的是ack1，则等于获得了nak.\n\n![](https://img.cetacis.dev/uploads/big/cea7c4f6f57bef7bd7fefab902433f52.png)**rdt3.0**\n\n当下面的信道也能丢失分组：怎么检测丢包？丢包该怎么办？\n\n方法: \n\n发送方等待ACK一段“合理的”时间 \n\n• 如在这段时间没有收到ACK则重传\n\n• 可能出现问题  如果分组(或ACK)只是延迟(没有丢失):\n\n重传将是冗余的，但序号的使用已经处理了该情况；接收方必须定义被确认的分组序号\n\n • 需要倒计时定时器\n\n*发送方数据重发只发生在timeout时，收到错误序号包是不会重发的。*\n\n*接收方会回应所有数据发送请求*\n\n![](https://img.cetacis.dev/uploads/big/210ecfd4eb2f6cf1efa886d3229c903d.png)\n\n\n\n![](https://img.cetacis.dev/uploads/big/dd47a9b82f26c69d6bea0a5be1ef1dc4.png)\n\n![](https://img.cetacis.dev/uploads/big/7046a71ca26f5ffcaaea651abeb8516d.png)\n\n**rdt3.0的性能**\n\n性能落后：停等协议\n\n![](https://img.cetacis.dev/uploads/big/9a89b4a3aa15d4d84cffb9d09808b36d.png)\n\n**利用率**：发送方实际用于将发送bit送进信道的时间与发送时间的比率\n\n这个例子利用率只有0.027%，网路协议限制了物理资源的使用\n\n2. 流水线技术\n\n序号要多；缓冲区要扩展（放置未收到相应的发送包\n\n![](https://img.cetacis.dev/uploads/big/b372cbc539f2f1ddb75a3d93b3221314.png)\n\nGo-Back-N（滑动窗口协议）GBN\n\n限制已发送未应答的分组数量\n\n分组序号空间使用摸2^k\n\nACK(n)：累计ACK；只对第一个发送未被确认的报文定时，timeout要重传全部的分组\n\n接收方无缓存\n\n![S](https://img.cetacis.dev/uploads/big/a75be72a5039ecd408dfc96e8108f83b.png)\n\n选择性重传 Selective repeat （SR）\n\n发送方接收方都有缓存；每一个分组都有自己的定时器\n\n![](https://img.cetacis.dev/uploads/big/5e33f383e9633f0682fda94bbd78e4a6.png)\n\n\n\n分组n在[rcvbase-N,rcvbase-1]内的原因：之前的N个ack丢失\n\n窗口小于或等于序号空间大小的一半 使不会重复\n\n否则：\n\n![](https://img.cetacis.dev/uploads/big/d08a22b7e97539a46fe1b1a174fbf9e0.png)\n\n## 3.5 面向连接传输 TCP\n\n![](https://img.cetacis.dev/uploads/big/53971cfe3e91069e16ccfd3fe9e3c055.png)\n\n图中上层：**发送和接受缓冲区**\n\nMSS：最大报文段长度。一次从换从中读取的信息长度。\n\nMTU：最大传输单元，一般由与本机相连链路决定。在网络上可能不同。\n\n\n\n### 3.5.1 tcp面向流\n\n* 流水线 \n\n  tcp拥塞和流量控制设置滑动窗口协议\n\n* 流量控制\n\n  发送方不能淹没接收方\n\n* 拥塞控制\n\n  防止过度占用网络资源\n\n* 面向连接\n\n  在数据交换前握手(交换控制信息) 初始化发 送方和接收方的状态\n\n* 全双工数据\n\n  同一个连接上的双向数据流\n\n  ![面向流](https://img.cetacis.dev/uploads/big/280aab142b63d9a01cb369c1f2c0383f.png)\n\n  没有吧报文边界，但是最大为MSS\n\n### 3.5.2 报文段结构\n\n#### 1. 首部结构概述\n\n![](https://img.cetacis.dev/uploads/big/c419e17b244a1258d8e17b77a134301b.png)\n\n**序号**：占4字节 确定是否按序收到分组，是否冗余，或者是否丢包。TCP连接中序号是报文段所发送的数据的第一字节的序号。（不是顺序\n\n**确认号字段**：4字节 期望收到对方的下一个报文段的数据的第一字节的序号。告诉发送方，之前的序号已经收到。\n\n**首部长度（数据偏移）**：4位 指出报文段数据距离tcp报文段的起始处有多远。数据偏移的单位是32字。\n\n**保留字段**：6位 拥塞控制可用\n\n**紧急URG**：当URG=1，告诉系统次报文段有紧急数据，优先传送。\n\n**紧急指针：**说明到哪里是紧急数据。当URG=1时，此指针有用\n\n**ACK：**确认号 ACK=1 确认号字段有效\n\n**PSH：**PSH=1的报文段，应尽快交付至上层，而不是等整个缓存填充满了以后再向上交付。\n\n**RST：** =1，表明TCP链接出现差错，必须释放链接，然后再重新建立链接。（端口不存在或者主机崩溃）\n\n**SYN：**=1，表明这是一个连接请求或者链接接受报文。用于建立握手。\n\n**FIN：**=1，请求释放连接，表明数据传送完成\n\n**窗口：**2字节 单位为字节，设置让对方设置发送窗口的依据，用于流量控制。表明接收方愿意接受的长度。\n\n**检验和：**2字节，包括首部和数据两部分。计算校验和要在TCP报文段的前面加上12字节伪首部\n\n**选项字段：**TCP最初只有一种选项，即最大报文段长度MSS。MSS告诉对方TCP：“我缓存能接受的报文段的数据字段的最大长度是MSS字节”。现在还可作为：窗口确定选项；时间戳选项（对ack的确认计算时间）；\n\n**填充**\n\n#### 2. TCP序号和确认\n\n**序号：**\n\n报文段中第一个数据在字节流中的位置编号\n\n*例子 5M的数据 MSS 1000*\n\n*分组一 序号 0 分组二 序号 1000 分组三 序号 2000*\n\n**确认号：**\n\n期望从对方收到的下一个字节的序号\n\n累计确认\n\n*例子： 已发送 0-535 ，接收方会发536的确认号*\n\n*例子二：已发送 0-535 536-899 900-1000，某种原因，536-899丢失。接收方会发536的确认号。*\n\n接收方如何处理失序报文段：TCP无规定，由实现者选择：抛弃/缓存。\n\n![](https://img.cetacis.dev/uploads/big/a43d34595f97615d29fcdd187b6772c2.png)\n\n#### 3. TCP往返时延的估计和超时\n\n### 3.5.3 可靠数据传输\n\n* TCP在IP不可靠服务的基础上\n\n创建可靠数据传输服务：肯定确认和定时器；序号、重传\n\n* 流水线发送报文段\n\n* 累计确认 收到一个确认，则意味着收到之前所有的\n* TCP使用单个重传定时器 （定时器管理消耗大。\n\n* 重传被下列事件触发：超时；重复ack\n\n#### 1. tcp发送方事件\n\n1. 从应用程序接收数据:\n\n 用序号创造一个数据段\n\n序号是数据段中第一个数据字节在字节流中的位置编号\n\n如果没有启动定时器，则启动定时器\n\n* 定时器是最早没有被确认的数据 段发送时启动的\n\n* 设置超时间隔: TimeOutInterval\n\n2. 超时：\n\n   重发导致超时的报文段\n\n   重新开始定时器\n\n3. 收到确认：\n\n   如果确认了还没有确认的数据段：\n\n   更新还没有确认的状态；\n\n   还有未完成的数据段，重新开始定时器\n\n   \n\n![](https://img.cetacis.dev/uploads/big/6c57e6c1f8351ddd9a438f88bd29d821.png)\n\nsendbase （sendbase之前都已经被确认\n\n![](https://img.cetacis.dev/uploads/big/1312199c28b46fc684802f2926ba46da.png)\n\n\n\n**超时间隔加倍**\n\ntcp每次重传 会把下一次的超时间间隔设置为先前的两倍\n\n当**收到上层应用的数据**或者**收到ack**两个事件中的任意个时，定时器恢复。\n\n这种修改提供了一种形式受限的拥塞控制。\n\n**快速重传**\n\n超时触发重传会导致超时周期长\n\n* 发送方常常一个接一个地发送很多报文段，如果报文段丢失,则发送方将可能接收到很多重复的 ACKs\n\n* 如果发送方收到3个对同样报文段的确认，则发送方认为该报文段之后的数据已经丢失。\n*  启动快速重传: 在定时器超时之前重发丢失的报文段 \n\n#### 2. 接收方行为\n\n![](https://img.cetacis.dev/uploads/big/6db99dd0e5267aaa84f5f5f6607db26c.png)\n\n如图3是快速重传的原理\n\n![快速重传](https://img.cetacis.dev/uploads/big/ef4d1bdcb260136ae9feb9b4dcc853d7.png)\n\n![](https://img.cetacis.dev/uploads/big/f800231b2377036999ece5a3bdd56af2.png)\n\n![快速重传&缓存](https://img.cetacis.dev/uploads/big/1f6a31ebf20801f39e32a777e13e679e.png)\n\n### 3.5.4 tcp流控\n\nTCP链接的接收方有一个缓冲区 \n\n速度匹配服务：发送速率和接收应用程序的提取速率匹配\n\n流量控制：发送方不能发送太多太快，让接受缓冲区溢出\n\ntcp报文中窗口字段会告知缓冲区剩余空间 \n\n发送方要限制未确认的数据不超过RcvWindow\n\n当RcWindow已满，会发送试探报文\n\n### 3.5.5 TCP 连接管理\n\n#### 1. 三次握手\n\n\n\n建立连接：\n\n步骤一  客户机向服务器发送 TCP SYN报文段（SYN = 1, SEQ = x）\n\n* 指定初试序号\n* 没有数据\n\n步骤二 服务器收到SYN报文段, 用SYNACK报文段回复(SYN = 1, ACK = 1, SEQ = y, ack = x+1)(y在于确定客户机的身份)\n\n* 服务器为该连接分配缓冲区和变量\n\n* 指定服务器初始序号\n\n步骤 3: 客户机接收到 SYNACK, 分配缓冲，用ACK报文段回复,可能包含数据 \n\n![](https://img.cetacis.dev/uploads/big/197aa58d6e85a0b8b1f1a90847d59e7a.png)\n\n#### 2. 两次握手错误\n\n\n\n![](https://img.cetacis.dev/uploads/big/0a7c53bb51d10be438e91b4a28ebb590.png)\n\n* 服务器请求超时，客户重新发送，服务器多次得到请求，导致“半链接”，分配缓冲区，长时间占用缓冲区。当三次时，半链接会短\n\n![](https://img.cetacis.dev/uploads/big/b5b7c3b19144d506115331453541e7f7.png)\n\n* 碰巧出现客户机不知的链接\n\n#### 3. 关闭连接\n\n关闭链接的一方为客户端\n\n**客户关闭套接字: clientSocket.close** \n\nStep 1 : 客户发送 TCP FIN 控制报文段到服务器\n\nStep 2 : 服务器接收 FIN, 回复 ACK. 半关闭连接, 并发送FIN到客户 \n\nStep 3: 客户接收 FIN, 回复 ACK.\n\n进入 “timed wait”状态\n\n 等待结束时释放连接资源\n\nStep 4: 服务器接收 ACK. 连接关闭. \n\n![](https://img.cetacis.dev/uploads/big/db92bfb62bbbb56275bce3431d323dfd.png)\n\nTimed wait for 2 * max segment ligetime （timeout意义）: 客户端结束后，套接字被重用，如果之前的连接中有游荡的报文，可能就会被新的链接接收\n\n![](https://img.cetacis.dev/uploads/big/fb30b019f55978ab648fbe516e5b4d56.png)\n\n![](https://img.cetacis.dev/uploads/big/fb30b019f55978ab648fbe516e5b4d56.png)\n\n## 3.6 拥塞控制\n\n拥塞：从信息角度看: “太多源主机发送太多的数据，速度太快以至于网络来不及处理”\n\n不同于流量控制\n\n表现：丢失分组 (路由器的缓冲区溢出)  长延迟（在路由器的缓冲区排队）\n\n#### 1. **拥塞的代价**\n\n发送方必须执行重传以补偿因缓存溢出而 丢弃的分组。\n\n不必要的重发**:**链路 需要运输多个分组的拷贝\n\n当分组丢失后， 任何上游路由器的发送能力都浪费了!\n\n#### 2. 拥塞控制的方法\n\n端到端的拥塞控制:\n\n- 网路层没有为运算层提 供显示的支持。\n- 从端系统根据观察到的 时延和丢失现象推断出 拥塞\n- 这是TCP所采用的方法\n\n网络辅助的拥塞控制:\n\n* 一个bit指示一条链路出现拥塞(SNA,DECnet)\n\n* 指示发送方按照一定速率 发送(ATM)\n\n* 两种形式 ：1. 直接告诉发送方 2. 先给接收方，再由接收方发会发送方\n\n## 3.7 TCP拥塞控制\n\n采用端到端控制\n\n### 3.7.1 三个问题：\n\n 一个TCP发送方如何限制它向其连接发送速率的?\n 一个TCP发送方如何感知从它到目的地之间的路径上存在拥塞的?\n 当发送方感知到端到端的拥塞时，采用何种算法来改变其发送速率?\n\n#### 1. 发送方如何限制发送速率\n\n发送方通过CongWin限制传输: LastByteSent-LastByteAcked <=min{ CongWin，RecWin}\n\n最大平均速率：CongWin/RTT Bytes/s  (忽略传输时间，忽略封装时间，忽略窗口大小影响)\n\n拥塞窗口是动态的, 通过调节 CongWin的值，发送方因此能调整 它向连接发送数据的速率。\n\n#### 2. 发送方如何感知网络拥塞\n\n丢失事件 = 超时或者 3个重复ACK\n\n发生丢失时间，tcp发送降低速率（拥塞窗口）\n\n正常增加发送速率：自计时\n\n#### 3. TCP发送方怎样确定它应当发送的速率呢? \n\n好的发送策略：既使得网络不会拥塞，与此同时又能充分利用所有可用的带宽。\n\n**TCP策略原则：**\n\n* 一个丢失的报文段意味着拥塞，应当降低TCP发送速率。（超时或者 3个重复ACK）\n\n* 当收到未确认报文段的确认到达时，能够增加发送方的速率。（顺利的指示）\n\n* 带宽探测：*每个TCP发送方根据异步于其他发送的本地信息而行动。*\n\n  （第三点理解：执行拥塞控制的时候，不和其他tcp进行协调，只根据本地信息进行控制）\n\n### 3.7.2 TCP拥塞控制\n\n####1. TCP拥塞控制算法详述\n\n* 慢启动\n* 拥塞避免\n* 快速恢复\n\n慢启动阶段\n\nMSS ：最大报文段长度\n\n链接开始：Congwin = 1MSS \n\n​     MSS  = 500 bytes & RTT = 200 sec\n\n​    speed = 20 kbps\n\n**实现：**\n\n1. 当连接开始的时候以指数方式增加速率，直到出现丢包：\n\n* 当传输报文段首次被确认，拥塞窗口增加一个MSS。\n* 每RTT倍增拥塞窗口值\n\n2. 何时结束增长：\n\n* 超时事件以后:\n\n• CongWin值设置为1 MSS • Ssthresh= CongWin /2\n\n窗口指数增长(慢启动状态)，到达一 个阈值 (ssthresh) 后，再线性增长(拥 塞避免状态)\n\n* 收到3个冗余确认后:\n\n• CongWin减半+3个MSS • 进入快速恢复阶段（tcp reno）\n\n*不同的丢包事件*\n\n3 个重复的 ACKs 表明网络具有传输一些数据段的能力\n\n 在三个重复的确认之前超时是“更加严重的警告”\n\n3. 拥塞发生后\n\n一旦进入拥塞避免状态，CongWin的值大约是上次遇到拥塞时的一半。每个RTT只将CongWin的值增加一个MSS。\n\n4.  何时结束拥塞避免的线性增长?\n\n* 超时事件以后，\n\n  迁移到慢启动状态:  \n\n  CongWin值设置为1 MSS \n\n  Ssthresh= CongWin /2\n\n* 收到3个冗余确认后:\n\n  CongWin减半+3个MSS \n\n  进入快速恢复阶段\n\n*快速恢复*\n\n 对于引起TCP进入快速恢复状态的缺失报文段，每收到一个冗余的 ACK，CongWin的值增加一个MSS。\n\n 最终，当对丢失的报文段的一个ACK到达时，TCP在降低 CongWin后进 入拥塞避免状态。\n\n 如果出现超时事件，迁移到慢启动状态: CongWin值设置为1 MSS Ssthresh= CongWin /2\n\nssthresh ：阈值    crmd：最大窗口 \n\n![](https://img.cetacis.dev/uploads/big/558c8514b15f21cc581efcbda9f0c647.png)\n\n ![](https://img.cetacis.dev/uploads/big/3f17b94d3ab78d0ef84d262f45323c8f.png)\n\nreno：有快速恢复   tahoe：无快速恢复 如图\n\n#### 2. 总结\n\n当CongWin < ssthresh时，发送者处于慢启动阶段, CongWin指数增长\n\n当CongWin > ssthresh时，发送者处于拥塞避免阶段, CongWin线性增长\n\n当出现3个冗余确认时,发送者处于快速恢复阶段。阈值ssthresh设置为 CongWin/2，且CongWin设置为ssthresh+3*MSS\n\n当超时发生时，阈值ssthresh设置为CongWin/2，并且CongWin设置为1 MSS.\n\nTCP AIMD （加性增 乘性减）\n\n![](https://img.cetacis.dev/uploads/big/ec1154af7b0e07c03914e08cb42a7e00.png)\n\n#### tcp平均吞吐量\n\n估算： 0.75w / rtt\n\n#### 3. ECN 网络辅助拥塞控制\n\n在网络层 ，IP 数据报首部的服务类型字段中的两个比特被用于ECN。\n\n路由器所使用的一种 ECN 比特设置指示该路由器正在历经拥塞 。 该拥塞指示则由被标记的IP数据报所携带， 送给目的主机 。\n\n再由目的主机通知发送主机（TCP ACK segment）\n\n![](https://img.cetacis.dev/uploads/big/02ca99f8d0957dfe1f01a2068e942653.png)\n\ntcp发送方会减半拥塞窗口，并且将报文段首部中对cwr（拥塞窗口缩减）进行设置。\n\n# 实验：\n\n![](https://img.cetacis.dev/uploads/big/37d074f219036e3c5770d8f7505b53ca.png)\n\n![](https://img.cetacis.dev/uploads/big/db92a4e4bedcab79b59fa577b74c9a2e.png)\n\nb) 检测客户是否在线\n\n![实验要点](https://img.cetacis.dev/uploads/big/c157d44a236d7c0db05060b319fca1bc.png)\n\nPDU JSON-RPC\n\n","source":"_posts/自顶向下的计算机网络3 运输层.md","raw":"---\ndate: 2020/3/30\ntags:\n- 上课笔记\n- 运输层\ncategories:\n- 计算机网络\n- 自顶向下的计算机网络\n- 运输层\n---\n\n\n\n# 自顶向下的计算机网络3 运输层\n\n# 第三章 运输层\n\n目录：\n\n**传输层服务**\n\n**多路复用和多路分解**\n\n**无连接传输UDP**\n\n**可靠数据传输原理**\n\n**面向连接传输**\n\n**拥塞控制原理**   原因 后果 控制\n\n**TCP** **拥塞控制** \n<!-- more -->\n\n##  3.1 传输层服务\n\n1. 传输层服务和协议\n\n在两个不同的主机上运行的应用程序之间提供逻辑通信\n\n传输层协议运行在**端系统**（核心的交换机部分，只存在下面三层）：\n\n* 发送方: 将应用程序报文分成数据段传递给网络层\n* 接受方: 将数据段重新组装成报文传递到应用层 \n\n运输层协议：tcp udp\n\n![逻辑端到端](https://img.cetacis.dev/uploads/big/3aabb85d17bcec6c61b085fc5637f141.png)\n\n**可靠按序递交 (TCP) ：**  拥塞控制（拥塞时减缓发送方） 流量控制 （发送接收速度匹配） 连接建立 （握手）\n\n**不可靠的无序传递（udp）: **  UDP “尽力传递” IP的直接扩展  不提供的服务 : 延迟保证 带宽保证 \n\ntcp是可靠的，udp是不可靠的。网络层不可靠的\n\n------\n\n2. 运输层和网络层\n\n从通信和信息处理的角度看，运输层向它上面的 应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。\n\n类比：家庭类比:\n\n12个孩子向12个孩子发信   • 主机 = 家庭  • 进程 = 孩子  • 应用报文= 信封中的信 \n\n​                                               • 网络层协议= 邮政服务   • 运输协议 = Ann和Bill（家庭分发）\n\n**网络层：**两个主机之间的逻辑通信\n\n**传输层**：两个进程之间的逻辑通信  *可靠, 增强的网络层服务*\n\n## 3.2 多路复用和多路分解\n\n1. 总览\n\n![](https://img.cetacis.dev/uploads/big/ef6baf7007621db3e46d865f2616248b.png)\n\n**在发送主机多路复用:**\n\n从多个套接字收集数据, 用首部 封装数据，然后将报文段传递到 网络层多路复用\n\n**在接收主机多路分解:**\n\n将接收到的数据段传递到正确的套接字(多路分解)\n\n![](https://img.cetacis.dev/uploads/big/23ee20a92cd5b8b75415db0530a62cbf.png)\n\n---\n\n2. 多路分解如何工作\n\n主机接收IP数据报\n\n* 每个数据报承载1个运输层报文段\n\n* 每个段具有源、目的端口号\n  端口号代表不同的服务（进程）\n\n 主机使用IP地址 &端口号将段定向到适当的套接字\n\n![](https://img.cetacis.dev/uploads/big/e92bb4c5d174311573d73c7973ef121f.png)\n\n端口扫描：通过端口知悉服务\n\n---\n\n3. Udp无连接多路分解（一对多，多对一，多对多）\n\n* 套接字编程：\n\n  生成具有端口号的套接字: \n\n```java\nDatagramSocket mySocket1 = new DatagramSocket(9911); // mySocket1是一个套接字\n```\n\n```python\nserverSocket = socket(AF_INET, SOCK_DGRAM)# 创造套接字\nserverSocket.bind(('', serverPort))# 将端口号连接\n```\n\n* UDP套接字由二元组标识 : (目的ip地址，目的端口号)\n\n* 当主机接收UDP报文段时:\n\n  在报文段中检查目的地端口号\n\n  将UDP段定向到具有该端口号的套接字\n\n具有不同的源IP地址且/或源端口号，但 具有相同的目的IP地址和目的端口号的IP 报文段指向同样的套接字\n\n ![](https://img.cetacis.dev/uploads/big/6ae3c1f037ac20cb3f39433fedd97c09.png)\n\n原端口号（A.sp)是自动生成的，他在整个过程中不具有定位功能，他只是c在回发时的dp，所以它并不用指定。它为请求报文段中提供返回地址(包括IP地址和端口号)\n\n但是服务器的目的端口一定要指定\n\n---\n\n4. 面向连接的多路分解（TCP）\n\n**TCP 套接字由4部分指定:**\n\n源IP地址 源端口号 目的IP地址 目的端口号 \n\n接收主机使用所有四个值将数据段定位到合适的套接字\n\n**TCP服务器的套接字**\n\n服务器主机支持很多同时的tcp套接字：每个套接字用四个部分来表示\n\ntcp服务器有一个欢迎套接字，接受连接请求，tcp收到请求后会重开一个单独的连接套接字与客户机进行连接。\n\n连接套接字都是80端口，用源ip地址进行区分。\n\n![tcp服务器](https://img.cetacis.dev/uploads/big/a7bfeca2042c5f2cccd546dfe84ce1ed.png)\n\nweb：\n\n![](https://img.cetacis.dev/uploads/big/83d9d0dba8a39d31b343997ad1309c02.png)\n\n如图，b发出的两个tcp连接，通过源端口号区分\n\n## 3.3 udp\n\n1. udp：用户数据报协议（udp的报文段有时候叫数据报）\n\n特点：\n\n* 它是“基本要素”互联网传输协议\n\n* 因为是“尽力而为”服务，可能丢包，对应用程序交付失序\n\n* 无连接： 在udp发送方和接收方之间无握手；\n\n  ​\t\t\t\t每个udp段的处理独立于其他段（tcp面向流，可能同一个应用分在两个段中）\n\n- UDP 只在 IP 的数据报服务之上增加了很少一点的功能，即端口的功能和 差错检测的功能。 \n\n- 虽然 UDP 用户数据报只能提供不可靠的交付，但 UDP 在某些方面有其 特殊的优点。 \n\n- UDP 是无连接的，即发送数据之前不需要建立连接。 \n\n- UDP 使用尽最大努力交付，即不保证可靠交付，同时也不使用拥塞控制。 \n\n- UDP 没有拥塞控制，很适合多媒体通信的要求。  \n\n- UDP 支持一对一、一对多、多对一和多对多的交互通信。 \n\n- UDP 的首部开销小，只有 8 个字节。 \n\n- UDP 是面向报文的。发送方 UDP 对应用程序交下来的报文，在添加  首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并， 也不拆分，而是保留这些报文的边界。\n\n  *tcp无报文边界* \n\n- 应用层交给 UDP 多长的报文，UDP 就照样发送，即一次发送一个报文。 \n\n- 接收方 UDP 对 IP 层交上来的 UDP 用户数据报，在去除首部后就原 封不动地交付上层的应用进程，一次交付一个完整的报文。 \n\n- 应用程序必须选择合适大小的报文。\n\n----\n\n2. 为什么用udp？\n\n- 无连接创建（减少时延\n- 简单：可并发更多\n- 段首部小\n- 无拥塞控制：udp能够尽可能快地传输\n\n![面向报文的udp数据包](https://img.cetacis.dev/uploads/big/2dd4c563c7157a58d462f132de254834.png)\n\n---\n\n3. **udp的应用：**\n\n常用于流式多媒体应用 ：丢包容忍、速率敏感\n\n其他UDP应用： DNS（增加速率）、SNMP、RTP（路由选择协议 向其他路由器通报信息）\n\n经UDP的可靠传输 : 在应用层增加可靠性，应用程序特定的差错恢复!\n\n![](https://img.cetacis.dev/uploads/big/bfb81d85950595932dbf162253b0887d.png)\n\n*检验和：检查数据报是否出错*\n\n4. udp检验和与差错检测\n\n* 差错检测\n\n![差错检测](https://img.cetacis.dev/uploads/big/01028c74db7d536acdeb68fe37e9b401.png)\n\n*检错可能出现漏掉的错误（很少；大的校验信息 域能提供更好 的检错能力*\n\n* 检验和\n\n目标：对传输的数据进行差错检测\n\n发送方：将数据段看成16bit的整数序列\n\n​\t\t\t\t校验和:段内容进行带循环进位的加法，结果取反码\n\n​\t\t\t\t发送者将校验和值放入UDP的校验和域\n\n接收方：计算接收到数据段的校验和 \n\n​\t\t\t\t检查 计算的校验和是否等于校验和域中的值:\n​\t\t\t\t• NO – 检测到错误\n​\t\t\t\t• YES – 没有检测到错误\n\n​\t\t\t\t还是有可能出错\n\n![](https://img.cetacis.dev/uploads/big/559a0e644e35a34f5ae4ee80aa39a8e9.png)\n\n![注意循环进位](https://img.cetacis.dev/uploads/big/31cb0a6d0772550ca5bf8be2393c5055.png)\n\n**记得循环进位**\n\n## 3.4 可靠数据传输原理\n\n运输层需要提供可靠传输，但是网络层没有可靠，所以就需要接口。\n\n![可靠数据传输：基本概念](https://img.cetacis.dev/uploads/big/7a39d15318100c8d1431b69927c59bab.png)\n\n四个函数可以看做动作/事件\n\n逐步开发发送方和接收方的可靠数据传输协议 (rdt)：\n\n* 仅考虑单向数据传输\n* 控制信息将在两个方向流动\n\n有限状态机 (FSM)来定义发送方和接收方\n\n![有限状态机<数字逻辑>](https://img.cetacis.dev/uploads/big/72bf5f176f835798782c1dac3f21ad16.png)\n\n1. rdt的发展\n\n**Rdt1.0:** **完全可靠信道上的可靠数据传输**\n\n在完美可靠的信道上\n\t• 没有bit错误\n\n​\t• 没有分组丢失 \n\n发送方，接收方单独的 FSMs : \n\n​\t• 发送方发送数据到下层信道 \n\n​\t• 接收方从下层信道接收数据 \n\n![rdt1.0](https://img.cetacis.dev/uploads/big/cffcc44f90050d8d2170c4fe8fbf126f.png)\n\n**Rdt2.0:** **具有bit错误的信道**\n\n下层信道可能让传输分组中的bit受损 \n\n* 校验和将检测到bit错误\n\n问题: 如何从错误中恢复\n\n* 确认(ACKs): 接收方明确告诉发送方 分组接收正确\n* 否认 (NAKs):接收方明确告诉发送方 分组接收出错 \n* 发送方收到NAK后重发这个分组\n\n在 rdt2.0的新机制 (在 rdt1.0中没有的): \n\n* 差错检测\n\n* 接收方反馈: 控制信息 (ACK,NAK)\n* 重传\n\n![rdt2.0](https://img.cetacis.dev/uploads/big/2998071b3d7db73519ca8bcd2d69b288.png)\n\nrdt2.0是一个停-等协议（字面意思\n\nRdt2.0的缺陷：如果ACK/NAK受损，将会出现 发送方不知道在接收方会发生 什么情况。\n\n​\t\t\t\t\t\t  重传可能导致冗余\n\n处理冗余:\n\n• 发送方对每个分组增加序列号\n\n• 如果ACK/NAK受损，发送方重传当前的分组\n\n• 接收方丢弃(不再向上交付)冗 余分组\n\n**rdt2.1**\n\n发送方：\n\n两个序号0/1 够用，为什么？  -因为停等协议\n\n检查是否收到的ACK/NAK 受损\n\n状态增加一倍 状态必须“记住”是否“当前的”分组具有0或1序号\n\n接收方：\n\n检查是否接收到分组时候冗余  状态指示是否0/1是否是起飞的分组序号\n\n注意：接收方不知道它的ack/nal时候被正确接收\n\n发送方\n\n![](https://img.cetacis.dev/uploads/big/b36b7d0725db5c2df42f09cd2668e081.png)\n\n\n\n\n\n接收方：\n\n![接收方处理受损的ack/nak](https://img.cetacis.dev/uploads/big/d26e255338267a9c4a5750b63487e51a.png)\n\n正确报文序号正确：拆包，上传给上方->等待来自下面的调用1\n\n正确报文序号错误1 ：回发ack（因为发出了1，所以可能是因为上次接收方回发的ack1受损了，所以此时应该回发ack1使发送方发送下一个序号的数据报）->等待来自下面的调用0\n\n错误报文：回发NAK->等待来自下面的调用0\n\n**rdt2.2 : 不要nak的协议 **\n\n同 rdt2.1一样的功能, 只用 ACKs\n不用 NAK, 如果上个报文接收正确接收方发送 ACK\n\n* 接收方必须明确包含被确认的报文的序号 \n\n发送方收到重复 ACK 将导致和 NAK一样的 处理: 重发当前报文 \n\n发送方发送0包，但是收到的是ack1，则等于获得了nak.\n\n![](https://img.cetacis.dev/uploads/big/cea7c4f6f57bef7bd7fefab902433f52.png)**rdt3.0**\n\n当下面的信道也能丢失分组：怎么检测丢包？丢包该怎么办？\n\n方法: \n\n发送方等待ACK一段“合理的”时间 \n\n• 如在这段时间没有收到ACK则重传\n\n• 可能出现问题  如果分组(或ACK)只是延迟(没有丢失):\n\n重传将是冗余的，但序号的使用已经处理了该情况；接收方必须定义被确认的分组序号\n\n • 需要倒计时定时器\n\n*发送方数据重发只发生在timeout时，收到错误序号包是不会重发的。*\n\n*接收方会回应所有数据发送请求*\n\n![](https://img.cetacis.dev/uploads/big/210ecfd4eb2f6cf1efa886d3229c903d.png)\n\n\n\n![](https://img.cetacis.dev/uploads/big/dd47a9b82f26c69d6bea0a5be1ef1dc4.png)\n\n![](https://img.cetacis.dev/uploads/big/7046a71ca26f5ffcaaea651abeb8516d.png)\n\n**rdt3.0的性能**\n\n性能落后：停等协议\n\n![](https://img.cetacis.dev/uploads/big/9a89b4a3aa15d4d84cffb9d09808b36d.png)\n\n**利用率**：发送方实际用于将发送bit送进信道的时间与发送时间的比率\n\n这个例子利用率只有0.027%，网路协议限制了物理资源的使用\n\n2. 流水线技术\n\n序号要多；缓冲区要扩展（放置未收到相应的发送包\n\n![](https://img.cetacis.dev/uploads/big/b372cbc539f2f1ddb75a3d93b3221314.png)\n\nGo-Back-N（滑动窗口协议）GBN\n\n限制已发送未应答的分组数量\n\n分组序号空间使用摸2^k\n\nACK(n)：累计ACK；只对第一个发送未被确认的报文定时，timeout要重传全部的分组\n\n接收方无缓存\n\n![S](https://img.cetacis.dev/uploads/big/a75be72a5039ecd408dfc96e8108f83b.png)\n\n选择性重传 Selective repeat （SR）\n\n发送方接收方都有缓存；每一个分组都有自己的定时器\n\n![](https://img.cetacis.dev/uploads/big/5e33f383e9633f0682fda94bbd78e4a6.png)\n\n\n\n分组n在[rcvbase-N,rcvbase-1]内的原因：之前的N个ack丢失\n\n窗口小于或等于序号空间大小的一半 使不会重复\n\n否则：\n\n![](https://img.cetacis.dev/uploads/big/d08a22b7e97539a46fe1b1a174fbf9e0.png)\n\n## 3.5 面向连接传输 TCP\n\n![](https://img.cetacis.dev/uploads/big/53971cfe3e91069e16ccfd3fe9e3c055.png)\n\n图中上层：**发送和接受缓冲区**\n\nMSS：最大报文段长度。一次从换从中读取的信息长度。\n\nMTU：最大传输单元，一般由与本机相连链路决定。在网络上可能不同。\n\n\n\n### 3.5.1 tcp面向流\n\n* 流水线 \n\n  tcp拥塞和流量控制设置滑动窗口协议\n\n* 流量控制\n\n  发送方不能淹没接收方\n\n* 拥塞控制\n\n  防止过度占用网络资源\n\n* 面向连接\n\n  在数据交换前握手(交换控制信息) 初始化发 送方和接收方的状态\n\n* 全双工数据\n\n  同一个连接上的双向数据流\n\n  ![面向流](https://img.cetacis.dev/uploads/big/280aab142b63d9a01cb369c1f2c0383f.png)\n\n  没有吧报文边界，但是最大为MSS\n\n### 3.5.2 报文段结构\n\n#### 1. 首部结构概述\n\n![](https://img.cetacis.dev/uploads/big/c419e17b244a1258d8e17b77a134301b.png)\n\n**序号**：占4字节 确定是否按序收到分组，是否冗余，或者是否丢包。TCP连接中序号是报文段所发送的数据的第一字节的序号。（不是顺序\n\n**确认号字段**：4字节 期望收到对方的下一个报文段的数据的第一字节的序号。告诉发送方，之前的序号已经收到。\n\n**首部长度（数据偏移）**：4位 指出报文段数据距离tcp报文段的起始处有多远。数据偏移的单位是32字。\n\n**保留字段**：6位 拥塞控制可用\n\n**紧急URG**：当URG=1，告诉系统次报文段有紧急数据，优先传送。\n\n**紧急指针：**说明到哪里是紧急数据。当URG=1时，此指针有用\n\n**ACK：**确认号 ACK=1 确认号字段有效\n\n**PSH：**PSH=1的报文段，应尽快交付至上层，而不是等整个缓存填充满了以后再向上交付。\n\n**RST：** =1，表明TCP链接出现差错，必须释放链接，然后再重新建立链接。（端口不存在或者主机崩溃）\n\n**SYN：**=1，表明这是一个连接请求或者链接接受报文。用于建立握手。\n\n**FIN：**=1，请求释放连接，表明数据传送完成\n\n**窗口：**2字节 单位为字节，设置让对方设置发送窗口的依据，用于流量控制。表明接收方愿意接受的长度。\n\n**检验和：**2字节，包括首部和数据两部分。计算校验和要在TCP报文段的前面加上12字节伪首部\n\n**选项字段：**TCP最初只有一种选项，即最大报文段长度MSS。MSS告诉对方TCP：“我缓存能接受的报文段的数据字段的最大长度是MSS字节”。现在还可作为：窗口确定选项；时间戳选项（对ack的确认计算时间）；\n\n**填充**\n\n#### 2. TCP序号和确认\n\n**序号：**\n\n报文段中第一个数据在字节流中的位置编号\n\n*例子 5M的数据 MSS 1000*\n\n*分组一 序号 0 分组二 序号 1000 分组三 序号 2000*\n\n**确认号：**\n\n期望从对方收到的下一个字节的序号\n\n累计确认\n\n*例子： 已发送 0-535 ，接收方会发536的确认号*\n\n*例子二：已发送 0-535 536-899 900-1000，某种原因，536-899丢失。接收方会发536的确认号。*\n\n接收方如何处理失序报文段：TCP无规定，由实现者选择：抛弃/缓存。\n\n![](https://img.cetacis.dev/uploads/big/a43d34595f97615d29fcdd187b6772c2.png)\n\n#### 3. TCP往返时延的估计和超时\n\n### 3.5.3 可靠数据传输\n\n* TCP在IP不可靠服务的基础上\n\n创建可靠数据传输服务：肯定确认和定时器；序号、重传\n\n* 流水线发送报文段\n\n* 累计确认 收到一个确认，则意味着收到之前所有的\n* TCP使用单个重传定时器 （定时器管理消耗大。\n\n* 重传被下列事件触发：超时；重复ack\n\n#### 1. tcp发送方事件\n\n1. 从应用程序接收数据:\n\n 用序号创造一个数据段\n\n序号是数据段中第一个数据字节在字节流中的位置编号\n\n如果没有启动定时器，则启动定时器\n\n* 定时器是最早没有被确认的数据 段发送时启动的\n\n* 设置超时间隔: TimeOutInterval\n\n2. 超时：\n\n   重发导致超时的报文段\n\n   重新开始定时器\n\n3. 收到确认：\n\n   如果确认了还没有确认的数据段：\n\n   更新还没有确认的状态；\n\n   还有未完成的数据段，重新开始定时器\n\n   \n\n![](https://img.cetacis.dev/uploads/big/6c57e6c1f8351ddd9a438f88bd29d821.png)\n\nsendbase （sendbase之前都已经被确认\n\n![](https://img.cetacis.dev/uploads/big/1312199c28b46fc684802f2926ba46da.png)\n\n\n\n**超时间隔加倍**\n\ntcp每次重传 会把下一次的超时间间隔设置为先前的两倍\n\n当**收到上层应用的数据**或者**收到ack**两个事件中的任意个时，定时器恢复。\n\n这种修改提供了一种形式受限的拥塞控制。\n\n**快速重传**\n\n超时触发重传会导致超时周期长\n\n* 发送方常常一个接一个地发送很多报文段，如果报文段丢失,则发送方将可能接收到很多重复的 ACKs\n\n* 如果发送方收到3个对同样报文段的确认，则发送方认为该报文段之后的数据已经丢失。\n*  启动快速重传: 在定时器超时之前重发丢失的报文段 \n\n#### 2. 接收方行为\n\n![](https://img.cetacis.dev/uploads/big/6db99dd0e5267aaa84f5f5f6607db26c.png)\n\n如图3是快速重传的原理\n\n![快速重传](https://img.cetacis.dev/uploads/big/ef4d1bdcb260136ae9feb9b4dcc853d7.png)\n\n![](https://img.cetacis.dev/uploads/big/f800231b2377036999ece5a3bdd56af2.png)\n\n![快速重传&缓存](https://img.cetacis.dev/uploads/big/1f6a31ebf20801f39e32a777e13e679e.png)\n\n### 3.5.4 tcp流控\n\nTCP链接的接收方有一个缓冲区 \n\n速度匹配服务：发送速率和接收应用程序的提取速率匹配\n\n流量控制：发送方不能发送太多太快，让接受缓冲区溢出\n\ntcp报文中窗口字段会告知缓冲区剩余空间 \n\n发送方要限制未确认的数据不超过RcvWindow\n\n当RcWindow已满，会发送试探报文\n\n### 3.5.5 TCP 连接管理\n\n#### 1. 三次握手\n\n\n\n建立连接：\n\n步骤一  客户机向服务器发送 TCP SYN报文段（SYN = 1, SEQ = x）\n\n* 指定初试序号\n* 没有数据\n\n步骤二 服务器收到SYN报文段, 用SYNACK报文段回复(SYN = 1, ACK = 1, SEQ = y, ack = x+1)(y在于确定客户机的身份)\n\n* 服务器为该连接分配缓冲区和变量\n\n* 指定服务器初始序号\n\n步骤 3: 客户机接收到 SYNACK, 分配缓冲，用ACK报文段回复,可能包含数据 \n\n![](https://img.cetacis.dev/uploads/big/197aa58d6e85a0b8b1f1a90847d59e7a.png)\n\n#### 2. 两次握手错误\n\n\n\n![](https://img.cetacis.dev/uploads/big/0a7c53bb51d10be438e91b4a28ebb590.png)\n\n* 服务器请求超时，客户重新发送，服务器多次得到请求，导致“半链接”，分配缓冲区，长时间占用缓冲区。当三次时，半链接会短\n\n![](https://img.cetacis.dev/uploads/big/b5b7c3b19144d506115331453541e7f7.png)\n\n* 碰巧出现客户机不知的链接\n\n#### 3. 关闭连接\n\n关闭链接的一方为客户端\n\n**客户关闭套接字: clientSocket.close** \n\nStep 1 : 客户发送 TCP FIN 控制报文段到服务器\n\nStep 2 : 服务器接收 FIN, 回复 ACK. 半关闭连接, 并发送FIN到客户 \n\nStep 3: 客户接收 FIN, 回复 ACK.\n\n进入 “timed wait”状态\n\n 等待结束时释放连接资源\n\nStep 4: 服务器接收 ACK. 连接关闭. \n\n![](https://img.cetacis.dev/uploads/big/db92bfb62bbbb56275bce3431d323dfd.png)\n\nTimed wait for 2 * max segment ligetime （timeout意义）: 客户端结束后，套接字被重用，如果之前的连接中有游荡的报文，可能就会被新的链接接收\n\n![](https://img.cetacis.dev/uploads/big/fb30b019f55978ab648fbe516e5b4d56.png)\n\n![](https://img.cetacis.dev/uploads/big/fb30b019f55978ab648fbe516e5b4d56.png)\n\n## 3.6 拥塞控制\n\n拥塞：从信息角度看: “太多源主机发送太多的数据，速度太快以至于网络来不及处理”\n\n不同于流量控制\n\n表现：丢失分组 (路由器的缓冲区溢出)  长延迟（在路由器的缓冲区排队）\n\n#### 1. **拥塞的代价**\n\n发送方必须执行重传以补偿因缓存溢出而 丢弃的分组。\n\n不必要的重发**:**链路 需要运输多个分组的拷贝\n\n当分组丢失后， 任何上游路由器的发送能力都浪费了!\n\n#### 2. 拥塞控制的方法\n\n端到端的拥塞控制:\n\n- 网路层没有为运算层提 供显示的支持。\n- 从端系统根据观察到的 时延和丢失现象推断出 拥塞\n- 这是TCP所采用的方法\n\n网络辅助的拥塞控制:\n\n* 一个bit指示一条链路出现拥塞(SNA,DECnet)\n\n* 指示发送方按照一定速率 发送(ATM)\n\n* 两种形式 ：1. 直接告诉发送方 2. 先给接收方，再由接收方发会发送方\n\n## 3.7 TCP拥塞控制\n\n采用端到端控制\n\n### 3.7.1 三个问题：\n\n 一个TCP发送方如何限制它向其连接发送速率的?\n 一个TCP发送方如何感知从它到目的地之间的路径上存在拥塞的?\n 当发送方感知到端到端的拥塞时，采用何种算法来改变其发送速率?\n\n#### 1. 发送方如何限制发送速率\n\n发送方通过CongWin限制传输: LastByteSent-LastByteAcked <=min{ CongWin，RecWin}\n\n最大平均速率：CongWin/RTT Bytes/s  (忽略传输时间，忽略封装时间，忽略窗口大小影响)\n\n拥塞窗口是动态的, 通过调节 CongWin的值，发送方因此能调整 它向连接发送数据的速率。\n\n#### 2. 发送方如何感知网络拥塞\n\n丢失事件 = 超时或者 3个重复ACK\n\n发生丢失时间，tcp发送降低速率（拥塞窗口）\n\n正常增加发送速率：自计时\n\n#### 3. TCP发送方怎样确定它应当发送的速率呢? \n\n好的发送策略：既使得网络不会拥塞，与此同时又能充分利用所有可用的带宽。\n\n**TCP策略原则：**\n\n* 一个丢失的报文段意味着拥塞，应当降低TCP发送速率。（超时或者 3个重复ACK）\n\n* 当收到未确认报文段的确认到达时，能够增加发送方的速率。（顺利的指示）\n\n* 带宽探测：*每个TCP发送方根据异步于其他发送的本地信息而行动。*\n\n  （第三点理解：执行拥塞控制的时候，不和其他tcp进行协调，只根据本地信息进行控制）\n\n### 3.7.2 TCP拥塞控制\n\n####1. TCP拥塞控制算法详述\n\n* 慢启动\n* 拥塞避免\n* 快速恢复\n\n慢启动阶段\n\nMSS ：最大报文段长度\n\n链接开始：Congwin = 1MSS \n\n​     MSS  = 500 bytes & RTT = 200 sec\n\n​    speed = 20 kbps\n\n**实现：**\n\n1. 当连接开始的时候以指数方式增加速率，直到出现丢包：\n\n* 当传输报文段首次被确认，拥塞窗口增加一个MSS。\n* 每RTT倍增拥塞窗口值\n\n2. 何时结束增长：\n\n* 超时事件以后:\n\n• CongWin值设置为1 MSS • Ssthresh= CongWin /2\n\n窗口指数增长(慢启动状态)，到达一 个阈值 (ssthresh) 后，再线性增长(拥 塞避免状态)\n\n* 收到3个冗余确认后:\n\n• CongWin减半+3个MSS • 进入快速恢复阶段（tcp reno）\n\n*不同的丢包事件*\n\n3 个重复的 ACKs 表明网络具有传输一些数据段的能力\n\n 在三个重复的确认之前超时是“更加严重的警告”\n\n3. 拥塞发生后\n\n一旦进入拥塞避免状态，CongWin的值大约是上次遇到拥塞时的一半。每个RTT只将CongWin的值增加一个MSS。\n\n4.  何时结束拥塞避免的线性增长?\n\n* 超时事件以后，\n\n  迁移到慢启动状态:  \n\n  CongWin值设置为1 MSS \n\n  Ssthresh= CongWin /2\n\n* 收到3个冗余确认后:\n\n  CongWin减半+3个MSS \n\n  进入快速恢复阶段\n\n*快速恢复*\n\n 对于引起TCP进入快速恢复状态的缺失报文段，每收到一个冗余的 ACK，CongWin的值增加一个MSS。\n\n 最终，当对丢失的报文段的一个ACK到达时，TCP在降低 CongWin后进 入拥塞避免状态。\n\n 如果出现超时事件，迁移到慢启动状态: CongWin值设置为1 MSS Ssthresh= CongWin /2\n\nssthresh ：阈值    crmd：最大窗口 \n\n![](https://img.cetacis.dev/uploads/big/558c8514b15f21cc581efcbda9f0c647.png)\n\n ![](https://img.cetacis.dev/uploads/big/3f17b94d3ab78d0ef84d262f45323c8f.png)\n\nreno：有快速恢复   tahoe：无快速恢复 如图\n\n#### 2. 总结\n\n当CongWin < ssthresh时，发送者处于慢启动阶段, CongWin指数增长\n\n当CongWin > ssthresh时，发送者处于拥塞避免阶段, CongWin线性增长\n\n当出现3个冗余确认时,发送者处于快速恢复阶段。阈值ssthresh设置为 CongWin/2，且CongWin设置为ssthresh+3*MSS\n\n当超时发生时，阈值ssthresh设置为CongWin/2，并且CongWin设置为1 MSS.\n\nTCP AIMD （加性增 乘性减）\n\n![](https://img.cetacis.dev/uploads/big/ec1154af7b0e07c03914e08cb42a7e00.png)\n\n#### tcp平均吞吐量\n\n估算： 0.75w / rtt\n\n#### 3. ECN 网络辅助拥塞控制\n\n在网络层 ，IP 数据报首部的服务类型字段中的两个比特被用于ECN。\n\n路由器所使用的一种 ECN 比特设置指示该路由器正在历经拥塞 。 该拥塞指示则由被标记的IP数据报所携带， 送给目的主机 。\n\n再由目的主机通知发送主机（TCP ACK segment）\n\n![](https://img.cetacis.dev/uploads/big/02ca99f8d0957dfe1f01a2068e942653.png)\n\ntcp发送方会减半拥塞窗口，并且将报文段首部中对cwr（拥塞窗口缩减）进行设置。\n\n# 实验：\n\n![](https://img.cetacis.dev/uploads/big/37d074f219036e3c5770d8f7505b53ca.png)\n\n![](https://img.cetacis.dev/uploads/big/db92a4e4bedcab79b59fa577b74c9a2e.png)\n\nb) 检测客户是否在线\n\n![实验要点](https://img.cetacis.dev/uploads/big/c157d44a236d7c0db05060b319fca1bc.png)\n\nPDU JSON-RPC\n\n","slug":"自顶向下的计算机网络3-运输层","published":1,"updated":"2020-04-02T11:15:53.000Z","title":"自顶向下的计算机网络3-运输层","comments":1,"layout":"post","photos":[],"link":"","_id":"ck985a7840007slqgay5935i2","content":"<h1 id=\"自顶向下的计算机网络3-运输层\"><a href=\"#自顶向下的计算机网络3-运输层\" class=\"headerlink\" title=\"自顶向下的计算机网络3 运输层\"></a>自顶向下的计算机网络3 运输层</h1><h1 id=\"第三章-运输层\"><a href=\"#第三章-运输层\" class=\"headerlink\" title=\"第三章 运输层\"></a>第三章 运输层</h1><p>目录：</p>\n<p><strong>传输层服务</strong></p>\n<p><strong>多路复用和多路分解</strong></p>\n<p><strong>无连接传输UDP</strong></p>\n<p><strong>可靠数据传输原理</strong></p>\n<p><strong>面向连接传输</strong></p>\n<p><strong>拥塞控制原理</strong>   原因 后果 控制</p>\n<p><strong>TCP</strong> <strong>拥塞控制</strong> </p>\n<a id=\"more\"></a>\n\n<h2 id=\"3-1-传输层服务\"><a href=\"#3-1-传输层服务\" class=\"headerlink\" title=\"3.1 传输层服务\"></a>3.1 传输层服务</h2><ol>\n<li>传输层服务和协议</li>\n</ol>\n<p>在两个不同的主机上运行的应用程序之间提供逻辑通信</p>\n<p>传输层协议运行在<strong>端系统</strong>（核心的交换机部分，只存在下面三层）：</p>\n<ul>\n<li>发送方: 将应用程序报文分成数据段传递给网络层</li>\n<li>接受方: 将数据段重新组装成报文传递到应用层 </li>\n</ul>\n<p>运输层协议：tcp udp</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/3aabb85d17bcec6c61b085fc5637f141.png\" alt=\"逻辑端到端\"></p>\n<p><strong>可靠按序递交 (TCP) ：</strong>  拥塞控制（拥塞时减缓发送方） 流量控制 （发送接收速度匹配） 连接建立 （握手）</p>\n<p>*<em>不可靠的无序传递（udp）: *</em>  UDP “尽力传递” IP的直接扩展  不提供的服务 : 延迟保证 带宽保证 </p>\n<p>tcp是可靠的，udp是不可靠的。网络层不可靠的</p>\n<hr>\n<ol start=\"2\">\n<li>运输层和网络层</li>\n</ol>\n<p>从通信和信息处理的角度看，运输层向它上面的 应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。</p>\n<p>类比：家庭类比:</p>\n<p>12个孩子向12个孩子发信   • 主机 = 家庭  • 进程 = 孩子  • 应用报文= 信封中的信 </p>\n<p>​                                               • 网络层协议= 邮政服务   • 运输协议 = Ann和Bill（家庭分发）</p>\n<p><strong>网络层：</strong>两个主机之间的逻辑通信</p>\n<p><strong>传输层</strong>：两个进程之间的逻辑通信  <em>可靠, 增强的网络层服务</em></p>\n<h2 id=\"3-2-多路复用和多路分解\"><a href=\"#3-2-多路复用和多路分解\" class=\"headerlink\" title=\"3.2 多路复用和多路分解\"></a>3.2 多路复用和多路分解</h2><ol>\n<li>总览</li>\n</ol>\n<p><img src=\"https://img.cetacis.dev/uploads/big/ef6baf7007621db3e46d865f2616248b.png\" alt=\"\"></p>\n<p><strong>在发送主机多路复用:</strong></p>\n<p>从多个套接字收集数据, 用首部 封装数据，然后将报文段传递到 网络层多路复用</p>\n<p><strong>在接收主机多路分解:</strong></p>\n<p>将接收到的数据段传递到正确的套接字(多路分解)</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/23ee20a92cd5b8b75415db0530a62cbf.png\" alt=\"\"></p>\n<hr>\n<ol start=\"2\">\n<li>多路分解如何工作</li>\n</ol>\n<p>主机接收IP数据报</p>\n<ul>\n<li><p>每个数据报承载1个运输层报文段</p>\n</li>\n<li><p>每个段具有源、目的端口号<br>端口号代表不同的服务（进程）</p>\n<p>主机使用IP地址 &amp;端口号将段定向到适当的套接字</p>\n</li>\n</ul>\n<p><img src=\"https://img.cetacis.dev/uploads/big/e92bb4c5d174311573d73c7973ef121f.png\" alt=\"\"></p>\n<p>端口扫描：通过端口知悉服务</p>\n<hr>\n<ol start=\"3\">\n<li>Udp无连接多路分解（一对多，多对一，多对多）</li>\n</ol>\n<ul>\n<li><p>套接字编程：</p>\n<p>生成具有端口号的套接字: </p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DatagramSocket mySocket1 = <span class=\"keyword\">new</span> DatagramSocket(<span class=\"number\">9911</span>); <span class=\"comment\">// mySocket1是一个套接字</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">serverSocket = socket(AF_INET, SOCK_DGRAM)<span class=\"comment\"># 创造套接字</span></span><br><span class=\"line\">serverSocket.bind((<span class=\"string\">''</span>, serverPort))<span class=\"comment\"># 将端口号连接</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>UDP套接字由二元组标识 : (目的ip地址，目的端口号)</p>\n</li>\n<li><p>当主机接收UDP报文段时:</p>\n<p>在报文段中检查目的地端口号</p>\n<p>将UDP段定向到具有该端口号的套接字</p>\n</li>\n</ul>\n<p>具有不同的源IP地址且/或源端口号，但 具有相同的目的IP地址和目的端口号的IP 报文段指向同样的套接字</p>\n<p> <img src=\"https://img.cetacis.dev/uploads/big/6ae3c1f037ac20cb3f39433fedd97c09.png\" alt=\"\"></p>\n<p>原端口号（A.sp)是自动生成的，他在整个过程中不具有定位功能，他只是c在回发时的dp，所以它并不用指定。它为请求报文段中提供返回地址(包括IP地址和端口号)</p>\n<p>但是服务器的目的端口一定要指定</p>\n<hr>\n<ol start=\"4\">\n<li>面向连接的多路分解（TCP）</li>\n</ol>\n<p><strong>TCP 套接字由4部分指定:</strong></p>\n<p>源IP地址 源端口号 目的IP地址 目的端口号 </p>\n<p>接收主机使用所有四个值将数据段定位到合适的套接字</p>\n<p><strong>TCP服务器的套接字</strong></p>\n<p>服务器主机支持很多同时的tcp套接字：每个套接字用四个部分来表示</p>\n<p>tcp服务器有一个欢迎套接字，接受连接请求，tcp收到请求后会重开一个单独的连接套接字与客户机进行连接。</p>\n<p>连接套接字都是80端口，用源ip地址进行区分。</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/a7bfeca2042c5f2cccd546dfe84ce1ed.png\" alt=\"tcp服务器\"></p>\n<p>web：</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/83d9d0dba8a39d31b343997ad1309c02.png\" alt=\"\"></p>\n<p>如图，b发出的两个tcp连接，通过源端口号区分</p>\n<h2 id=\"3-3-udp\"><a href=\"#3-3-udp\" class=\"headerlink\" title=\"3.3 udp\"></a>3.3 udp</h2><ol>\n<li>udp：用户数据报协议（udp的报文段有时候叫数据报）</li>\n</ol>\n<p>特点：</p>\n<ul>\n<li><p>它是“基本要素”互联网传输协议</p>\n</li>\n<li><p>因为是“尽力而为”服务，可能丢包，对应用程序交付失序</p>\n</li>\n<li><p>无连接： 在udp发送方和接收方之间无握手；</p>\n<p>​                每个udp段的处理独立于其他段（tcp面向流，可能同一个应用分在两个段中）</p>\n</li>\n</ul>\n<ul>\n<li><p>UDP 只在 IP 的数据报服务之上增加了很少一点的功能，即端口的功能和 差错检测的功能。 </p>\n</li>\n<li><p>虽然 UDP 用户数据报只能提供不可靠的交付，但 UDP 在某些方面有其 特殊的优点。 </p>\n</li>\n<li><p>UDP 是无连接的，即发送数据之前不需要建立连接。 </p>\n</li>\n<li><p>UDP 使用尽最大努力交付，即不保证可靠交付，同时也不使用拥塞控制。 </p>\n</li>\n<li><p>UDP 没有拥塞控制，很适合多媒体通信的要求。  </p>\n</li>\n<li><p>UDP 支持一对一、一对多、多对一和多对多的交互通信。 </p>\n</li>\n<li><p>UDP 的首部开销小，只有 8 个字节。 </p>\n</li>\n<li><p>UDP 是面向报文的。发送方 UDP 对应用程序交下来的报文，在添加  首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并， 也不拆分，而是保留这些报文的边界。</p>\n<p><em>tcp无报文边界</em> </p>\n</li>\n<li><p>应用层交给 UDP 多长的报文，UDP 就照样发送，即一次发送一个报文。 </p>\n</li>\n<li><p>接收方 UDP 对 IP 层交上来的 UDP 用户数据报，在去除首部后就原 封不动地交付上层的应用进程，一次交付一个完整的报文。 </p>\n</li>\n<li><p>应用程序必须选择合适大小的报文。</p>\n</li>\n</ul>\n<hr>\n<ol start=\"2\">\n<li>为什么用udp？</li>\n</ol>\n<ul>\n<li>无连接创建（减少时延</li>\n<li>简单：可并发更多</li>\n<li>段首部小</li>\n<li>无拥塞控制：udp能够尽可能快地传输</li>\n</ul>\n<p><img src=\"https://img.cetacis.dev/uploads/big/2dd4c563c7157a58d462f132de254834.png\" alt=\"面向报文的udp数据包\"></p>\n<hr>\n<ol start=\"3\">\n<li><strong>udp的应用：</strong></li>\n</ol>\n<p>常用于流式多媒体应用 ：丢包容忍、速率敏感</p>\n<p>其他UDP应用： DNS（增加速率）、SNMP、RTP（路由选择协议 向其他路由器通报信息）</p>\n<p>经UDP的可靠传输 : 在应用层增加可靠性，应用程序特定的差错恢复!</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/bfb81d85950595932dbf162253b0887d.png\" alt=\"\"></p>\n<p><em>检验和：检查数据报是否出错</em></p>\n<ol start=\"4\">\n<li>udp检验和与差错检测</li>\n</ol>\n<ul>\n<li>差错检测</li>\n</ul>\n<p><img src=\"https://img.cetacis.dev/uploads/big/01028c74db7d536acdeb68fe37e9b401.png\" alt=\"差错检测\"></p>\n<p><em>检错可能出现漏掉的错误（很少；大的校验信息 域能提供更好 的检错能力</em></p>\n<ul>\n<li>检验和</li>\n</ul>\n<p>目标：对传输的数据进行差错检测</p>\n<p>发送方：将数据段看成16bit的整数序列</p>\n<p>​                校验和:段内容进行带循环进位的加法，结果取反码</p>\n<p>​                发送者将校验和值放入UDP的校验和域</p>\n<p>接收方：计算接收到数据段的校验和 </p>\n<p>​                检查 计算的校验和是否等于校验和域中的值:<br>​                • NO – 检测到错误<br>​                • YES – 没有检测到错误</p>\n<p>​                还是有可能出错</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/559a0e644e35a34f5ae4ee80aa39a8e9.png\" alt=\"\"></p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/31cb0a6d0772550ca5bf8be2393c5055.png\" alt=\"注意循环进位\"></p>\n<p><strong>记得循环进位</strong></p>\n<h2 id=\"3-4-可靠数据传输原理\"><a href=\"#3-4-可靠数据传输原理\" class=\"headerlink\" title=\"3.4 可靠数据传输原理\"></a>3.4 可靠数据传输原理</h2><p>运输层需要提供可靠传输，但是网络层没有可靠，所以就需要接口。</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/7a39d15318100c8d1431b69927c59bab.png\" alt=\"可靠数据传输：基本概念\"></p>\n<p>四个函数可以看做动作/事件</p>\n<p>逐步开发发送方和接收方的可靠数据传输协议 (rdt)：</p>\n<ul>\n<li>仅考虑单向数据传输</li>\n<li>控制信息将在两个方向流动</li>\n</ul>\n<p>有限状态机 (FSM)来定义发送方和接收方</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/72bf5f176f835798782c1dac3f21ad16.png\" alt=\"有限状态机&lt;数字逻辑&gt;\"></p>\n<ol>\n<li>rdt的发展</li>\n</ol>\n<p><strong>Rdt1.0:</strong> <strong>完全可靠信道上的可靠数据传输</strong></p>\n<p>在完美可靠的信道上<br>    • 没有bit错误</p>\n<p>​    • 没有分组丢失 </p>\n<p>发送方，接收方单独的 FSMs : </p>\n<p>​    • 发送方发送数据到下层信道 </p>\n<p>​    • 接收方从下层信道接收数据 </p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/cffcc44f90050d8d2170c4fe8fbf126f.png\" alt=\"rdt1.0\"></p>\n<p><strong>Rdt2.0:</strong> <strong>具有bit错误的信道</strong></p>\n<p>下层信道可能让传输分组中的bit受损 </p>\n<ul>\n<li>校验和将检测到bit错误</li>\n</ul>\n<p>问题: 如何从错误中恢复</p>\n<ul>\n<li>确认(ACKs): 接收方明确告诉发送方 分组接收正确</li>\n<li>否认 (NAKs):接收方明确告诉发送方 分组接收出错 </li>\n<li>发送方收到NAK后重发这个分组</li>\n</ul>\n<p>在 rdt2.0的新机制 (在 rdt1.0中没有的): </p>\n<ul>\n<li><p>差错检测</p>\n</li>\n<li><p>接收方反馈: 控制信息 (ACK,NAK)</p>\n</li>\n<li><p>重传</p>\n</li>\n</ul>\n<p><img src=\"https://img.cetacis.dev/uploads/big/2998071b3d7db73519ca8bcd2d69b288.png\" alt=\"rdt2.0\"></p>\n<p>rdt2.0是一个停-等协议（字面意思</p>\n<p>Rdt2.0的缺陷：如果ACK/NAK受损，将会出现 发送方不知道在接收方会发生 什么情况。</p>\n<p>​                          重传可能导致冗余</p>\n<p>处理冗余:</p>\n<p>• 发送方对每个分组增加序列号</p>\n<p>• 如果ACK/NAK受损，发送方重传当前的分组</p>\n<p>• 接收方丢弃(不再向上交付)冗 余分组</p>\n<p><strong>rdt2.1</strong></p>\n<p>发送方：</p>\n<p>两个序号0/1 够用，为什么？  -因为停等协议</p>\n<p>检查是否收到的ACK/NAK 受损</p>\n<p>状态增加一倍 状态必须“记住”是否“当前的”分组具有0或1序号</p>\n<p>接收方：</p>\n<p>检查是否接收到分组时候冗余  状态指示是否0/1是否是起飞的分组序号</p>\n<p>注意：接收方不知道它的ack/nal时候被正确接收</p>\n<p>发送方</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/b36b7d0725db5c2df42f09cd2668e081.png\" alt=\"\"></p>\n<p>接收方：</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/d26e255338267a9c4a5750b63487e51a.png\" alt=\"接收方处理受损的ack/nak\"></p>\n<p>正确报文序号正确：拆包，上传给上方-&gt;等待来自下面的调用1</p>\n<p>正确报文序号错误1 ：回发ack（因为发出了1，所以可能是因为上次接收方回发的ack1受损了，所以此时应该回发ack1使发送方发送下一个序号的数据报）-&gt;等待来自下面的调用0</p>\n<p>错误报文：回发NAK-&gt;等待来自下面的调用0</p>\n<p>*<em>rdt2.2 : 不要nak的协议 *</em></p>\n<p>同 rdt2.1一样的功能, 只用 ACKs<br>不用 NAK, 如果上个报文接收正确接收方发送 ACK</p>\n<ul>\n<li>接收方必须明确包含被确认的报文的序号 </li>\n</ul>\n<p>发送方收到重复 ACK 将导致和 NAK一样的 处理: 重发当前报文 </p>\n<p>发送方发送0包，但是收到的是ack1，则等于获得了nak.</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/cea7c4f6f57bef7bd7fefab902433f52.png\" alt=\"\"><strong>rdt3.0</strong></p>\n<p>当下面的信道也能丢失分组：怎么检测丢包？丢包该怎么办？</p>\n<p>方法: </p>\n<p>发送方等待ACK一段“合理的”时间 </p>\n<p>• 如在这段时间没有收到ACK则重传</p>\n<p>• 可能出现问题  如果分组(或ACK)只是延迟(没有丢失):</p>\n<p>重传将是冗余的，但序号的使用已经处理了该情况；接收方必须定义被确认的分组序号</p>\n<p> • 需要倒计时定时器</p>\n<p><em>发送方数据重发只发生在timeout时，收到错误序号包是不会重发的。</em></p>\n<p><em>接收方会回应所有数据发送请求</em></p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/210ecfd4eb2f6cf1efa886d3229c903d.png\" alt=\"\"></p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/dd47a9b82f26c69d6bea0a5be1ef1dc4.png\" alt=\"\"></p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/7046a71ca26f5ffcaaea651abeb8516d.png\" alt=\"\"></p>\n<p><strong>rdt3.0的性能</strong></p>\n<p>性能落后：停等协议</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/9a89b4a3aa15d4d84cffb9d09808b36d.png\" alt=\"\"></p>\n<p><strong>利用率</strong>：发送方实际用于将发送bit送进信道的时间与发送时间的比率</p>\n<p>这个例子利用率只有0.027%，网路协议限制了物理资源的使用</p>\n<ol start=\"2\">\n<li>流水线技术</li>\n</ol>\n<p>序号要多；缓冲区要扩展（放置未收到相应的发送包</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/b372cbc539f2f1ddb75a3d93b3221314.png\" alt=\"\"></p>\n<p>Go-Back-N（滑动窗口协议）GBN</p>\n<p>限制已发送未应答的分组数量</p>\n<p>分组序号空间使用摸2^k</p>\n<p>ACK(n)：累计ACK；只对第一个发送未被确认的报文定时，timeout要重传全部的分组</p>\n<p>接收方无缓存</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/a75be72a5039ecd408dfc96e8108f83b.png\" alt=\"S\"></p>\n<p>选择性重传 Selective repeat （SR）</p>\n<p>发送方接收方都有缓存；每一个分组都有自己的定时器</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/5e33f383e9633f0682fda94bbd78e4a6.png\" alt=\"\"></p>\n<p>分组n在[rcvbase-N,rcvbase-1]内的原因：之前的N个ack丢失</p>\n<p>窗口小于或等于序号空间大小的一半 使不会重复</p>\n<p>否则：</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/d08a22b7e97539a46fe1b1a174fbf9e0.png\" alt=\"\"></p>\n<h2 id=\"3-5-面向连接传输-TCP\"><a href=\"#3-5-面向连接传输-TCP\" class=\"headerlink\" title=\"3.5 面向连接传输 TCP\"></a>3.5 面向连接传输 TCP</h2><p><img src=\"https://img.cetacis.dev/uploads/big/53971cfe3e91069e16ccfd3fe9e3c055.png\" alt=\"\"></p>\n<p>图中上层：<strong>发送和接受缓冲区</strong></p>\n<p>MSS：最大报文段长度。一次从换从中读取的信息长度。</p>\n<p>MTU：最大传输单元，一般由与本机相连链路决定。在网络上可能不同。</p>\n<h3 id=\"3-5-1-tcp面向流\"><a href=\"#3-5-1-tcp面向流\" class=\"headerlink\" title=\"3.5.1 tcp面向流\"></a>3.5.1 tcp面向流</h3><ul>\n<li><p>流水线 </p>\n<p>tcp拥塞和流量控制设置滑动窗口协议</p>\n</li>\n<li><p>流量控制</p>\n<p>发送方不能淹没接收方</p>\n</li>\n<li><p>拥塞控制</p>\n<p>防止过度占用网络资源</p>\n</li>\n<li><p>面向连接</p>\n<p>在数据交换前握手(交换控制信息) 初始化发 送方和接收方的状态</p>\n</li>\n<li><p>全双工数据</p>\n<p>同一个连接上的双向数据流</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/280aab142b63d9a01cb369c1f2c0383f.png\" alt=\"面向流\"></p>\n<p>没有吧报文边界，但是最大为MSS</p>\n</li>\n</ul>\n<h3 id=\"3-5-2-报文段结构\"><a href=\"#3-5-2-报文段结构\" class=\"headerlink\" title=\"3.5.2 报文段结构\"></a>3.5.2 报文段结构</h3><h4 id=\"1-首部结构概述\"><a href=\"#1-首部结构概述\" class=\"headerlink\" title=\"1. 首部结构概述\"></a>1. 首部结构概述</h4><p><img src=\"https://img.cetacis.dev/uploads/big/c419e17b244a1258d8e17b77a134301b.png\" alt=\"\"></p>\n<p><strong>序号</strong>：占4字节 确定是否按序收到分组，是否冗余，或者是否丢包。TCP连接中序号是报文段所发送的数据的第一字节的序号。（不是顺序</p>\n<p><strong>确认号字段</strong>：4字节 期望收到对方的下一个报文段的数据的第一字节的序号。告诉发送方，之前的序号已经收到。</p>\n<p><strong>首部长度（数据偏移）</strong>：4位 指出报文段数据距离tcp报文段的起始处有多远。数据偏移的单位是32字。</p>\n<p><strong>保留字段</strong>：6位 拥塞控制可用</p>\n<p><strong>紧急URG</strong>：当URG=1，告诉系统次报文段有紧急数据，优先传送。</p>\n<p><strong>紧急指针：</strong>说明到哪里是紧急数据。当URG=1时，此指针有用</p>\n<p><strong>ACK：</strong>确认号 ACK=1 确认号字段有效</p>\n<p><strong>PSH：</strong>PSH=1的报文段，应尽快交付至上层，而不是等整个缓存填充满了以后再向上交付。</p>\n<p><strong>RST：</strong> =1，表明TCP链接出现差错，必须释放链接，然后再重新建立链接。（端口不存在或者主机崩溃）</p>\n<p><strong>SYN：</strong>=1，表明这是一个连接请求或者链接接受报文。用于建立握手。</p>\n<p><strong>FIN：</strong>=1，请求释放连接，表明数据传送完成</p>\n<p><strong>窗口：</strong>2字节 单位为字节，设置让对方设置发送窗口的依据，用于流量控制。表明接收方愿意接受的长度。</p>\n<p><strong>检验和：</strong>2字节，包括首部和数据两部分。计算校验和要在TCP报文段的前面加上12字节伪首部</p>\n<p><strong>选项字段：</strong>TCP最初只有一种选项，即最大报文段长度MSS。MSS告诉对方TCP：“我缓存能接受的报文段的数据字段的最大长度是MSS字节”。现在还可作为：窗口确定选项；时间戳选项（对ack的确认计算时间）；</p>\n<p><strong>填充</strong></p>\n<h4 id=\"2-TCP序号和确认\"><a href=\"#2-TCP序号和确认\" class=\"headerlink\" title=\"2. TCP序号和确认\"></a>2. TCP序号和确认</h4><p><strong>序号：</strong></p>\n<p>报文段中第一个数据在字节流中的位置编号</p>\n<p><em>例子 5M的数据 MSS 1000</em></p>\n<p><em>分组一 序号 0 分组二 序号 1000 分组三 序号 2000</em></p>\n<p><strong>确认号：</strong></p>\n<p>期望从对方收到的下一个字节的序号</p>\n<p>累计确认</p>\n<p><em>例子： 已发送 0-535 ，接收方会发536的确认号</em></p>\n<p><em>例子二：已发送 0-535 536-899 900-1000，某种原因，536-899丢失。接收方会发536的确认号。</em></p>\n<p>接收方如何处理失序报文段：TCP无规定，由实现者选择：抛弃/缓存。</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/a43d34595f97615d29fcdd187b6772c2.png\" alt=\"\"></p>\n<h4 id=\"3-TCP往返时延的估计和超时\"><a href=\"#3-TCP往返时延的估计和超时\" class=\"headerlink\" title=\"3. TCP往返时延的估计和超时\"></a>3. TCP往返时延的估计和超时</h4><h3 id=\"3-5-3-可靠数据传输\"><a href=\"#3-5-3-可靠数据传输\" class=\"headerlink\" title=\"3.5.3 可靠数据传输\"></a>3.5.3 可靠数据传输</h3><ul>\n<li>TCP在IP不可靠服务的基础上</li>\n</ul>\n<p>创建可靠数据传输服务：肯定确认和定时器；序号、重传</p>\n<ul>\n<li><p>流水线发送报文段</p>\n</li>\n<li><p>累计确认 收到一个确认，则意味着收到之前所有的</p>\n</li>\n<li><p>TCP使用单个重传定时器 （定时器管理消耗大。</p>\n</li>\n<li><p>重传被下列事件触发：超时；重复ack</p>\n</li>\n</ul>\n<h4 id=\"1-tcp发送方事件\"><a href=\"#1-tcp发送方事件\" class=\"headerlink\" title=\"1. tcp发送方事件\"></a>1. tcp发送方事件</h4><ol>\n<li><p>从应用程序接收数据:</p>\n<p>用序号创造一个数据段</p>\n</li>\n</ol>\n<p>序号是数据段中第一个数据字节在字节流中的位置编号</p>\n<p>如果没有启动定时器，则启动定时器</p>\n<ul>\n<li><p>定时器是最早没有被确认的数据 段发送时启动的</p>\n</li>\n<li><p>设置超时间隔: TimeOutInterval</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li><p>超时：</p>\n<p>重发导致超时的报文段</p>\n<p>重新开始定时器</p>\n</li>\n<li><p>收到确认：</p>\n<p>如果确认了还没有确认的数据段：</p>\n<p>更新还没有确认的状态；</p>\n<p>还有未完成的数据段，重新开始定时器</p>\n</li>\n</ol>\n<p><img src=\"https://img.cetacis.dev/uploads/big/6c57e6c1f8351ddd9a438f88bd29d821.png\" alt=\"\"></p>\n<p>sendbase （sendbase之前都已经被确认</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/1312199c28b46fc684802f2926ba46da.png\" alt=\"\"></p>\n<p><strong>超时间隔加倍</strong></p>\n<p>tcp每次重传 会把下一次的超时间间隔设置为先前的两倍</p>\n<p>当<strong>收到上层应用的数据</strong>或者<strong>收到ack</strong>两个事件中的任意个时，定时器恢复。</p>\n<p>这种修改提供了一种形式受限的拥塞控制。</p>\n<p><strong>快速重传</strong></p>\n<p>超时触发重传会导致超时周期长</p>\n<ul>\n<li><p>发送方常常一个接一个地发送很多报文段，如果报文段丢失,则发送方将可能接收到很多重复的 ACKs</p>\n</li>\n<li><p>如果发送方收到3个对同样报文段的确认，则发送方认为该报文段之后的数据已经丢失。</p>\n</li>\n<li><p>启动快速重传: 在定时器超时之前重发丢失的报文段 </p>\n</li>\n</ul>\n<h4 id=\"2-接收方行为\"><a href=\"#2-接收方行为\" class=\"headerlink\" title=\"2. 接收方行为\"></a>2. 接收方行为</h4><p><img src=\"https://img.cetacis.dev/uploads/big/6db99dd0e5267aaa84f5f5f6607db26c.png\" alt=\"\"></p>\n<p>如图3是快速重传的原理</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/ef4d1bdcb260136ae9feb9b4dcc853d7.png\" alt=\"快速重传\"></p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/f800231b2377036999ece5a3bdd56af2.png\" alt=\"\"></p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/1f6a31ebf20801f39e32a777e13e679e.png\" alt=\"快速重传&amp;缓存\"></p>\n<h3 id=\"3-5-4-tcp流控\"><a href=\"#3-5-4-tcp流控\" class=\"headerlink\" title=\"3.5.4 tcp流控\"></a>3.5.4 tcp流控</h3><p>TCP链接的接收方有一个缓冲区 </p>\n<p>速度匹配服务：发送速率和接收应用程序的提取速率匹配</p>\n<p>流量控制：发送方不能发送太多太快，让接受缓冲区溢出</p>\n<p>tcp报文中窗口字段会告知缓冲区剩余空间 </p>\n<p>发送方要限制未确认的数据不超过RcvWindow</p>\n<p>当RcWindow已满，会发送试探报文</p>\n<h3 id=\"3-5-5-TCP-连接管理\"><a href=\"#3-5-5-TCP-连接管理\" class=\"headerlink\" title=\"3.5.5 TCP 连接管理\"></a>3.5.5 TCP 连接管理</h3><h4 id=\"1-三次握手\"><a href=\"#1-三次握手\" class=\"headerlink\" title=\"1. 三次握手\"></a>1. 三次握手</h4><p>建立连接：</p>\n<p>步骤一  客户机向服务器发送 TCP SYN报文段（SYN = 1, SEQ = x）</p>\n<ul>\n<li>指定初试序号</li>\n<li>没有数据</li>\n</ul>\n<p>步骤二 服务器收到SYN报文段, 用SYNACK报文段回复(SYN = 1, ACK = 1, SEQ = y, ack = x+1)(y在于确定客户机的身份)</p>\n<ul>\n<li><p>服务器为该连接分配缓冲区和变量</p>\n</li>\n<li><p>指定服务器初始序号</p>\n</li>\n</ul>\n<p>步骤 3: 客户机接收到 SYNACK, 分配缓冲，用ACK报文段回复,可能包含数据 </p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/197aa58d6e85a0b8b1f1a90847d59e7a.png\" alt=\"\"></p>\n<h4 id=\"2-两次握手错误\"><a href=\"#2-两次握手错误\" class=\"headerlink\" title=\"2. 两次握手错误\"></a>2. 两次握手错误</h4><p><img src=\"https://img.cetacis.dev/uploads/big/0a7c53bb51d10be438e91b4a28ebb590.png\" alt=\"\"></p>\n<ul>\n<li>服务器请求超时，客户重新发送，服务器多次得到请求，导致“半链接”，分配缓冲区，长时间占用缓冲区。当三次时，半链接会短</li>\n</ul>\n<p><img src=\"https://img.cetacis.dev/uploads/big/b5b7c3b19144d506115331453541e7f7.png\" alt=\"\"></p>\n<ul>\n<li>碰巧出现客户机不知的链接</li>\n</ul>\n<h4 id=\"3-关闭连接\"><a href=\"#3-关闭连接\" class=\"headerlink\" title=\"3. 关闭连接\"></a>3. 关闭连接</h4><p>关闭链接的一方为客户端</p>\n<p><strong>客户关闭套接字: clientSocket.close</strong> </p>\n<p>Step 1 : 客户发送 TCP FIN 控制报文段到服务器</p>\n<p>Step 2 : 服务器接收 FIN, 回复 ACK. 半关闭连接, 并发送FIN到客户 </p>\n<p>Step 3: 客户接收 FIN, 回复 ACK.</p>\n<p>进入 “timed wait”状态</p>\n<p> 等待结束时释放连接资源</p>\n<p>Step 4: 服务器接收 ACK. 连接关闭. </p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/db92bfb62bbbb56275bce3431d323dfd.png\" alt=\"\"></p>\n<p>Timed wait for 2 * max segment ligetime （timeout意义）: 客户端结束后，套接字被重用，如果之前的连接中有游荡的报文，可能就会被新的链接接收</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/fb30b019f55978ab648fbe516e5b4d56.png\" alt=\"\"></p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/fb30b019f55978ab648fbe516e5b4d56.png\" alt=\"\"></p>\n<h2 id=\"3-6-拥塞控制\"><a href=\"#3-6-拥塞控制\" class=\"headerlink\" title=\"3.6 拥塞控制\"></a>3.6 拥塞控制</h2><p>拥塞：从信息角度看: “太多源主机发送太多的数据，速度太快以至于网络来不及处理”</p>\n<p>不同于流量控制</p>\n<p>表现：丢失分组 (路由器的缓冲区溢出)  长延迟（在路由器的缓冲区排队）</p>\n<h4 id=\"1-拥塞的代价\"><a href=\"#1-拥塞的代价\" class=\"headerlink\" title=\"1. 拥塞的代价\"></a>1. <strong>拥塞的代价</strong></h4><p>发送方必须执行重传以补偿因缓存溢出而 丢弃的分组。</p>\n<p>不必要的重发<strong>:</strong>链路 需要运输多个分组的拷贝</p>\n<p>当分组丢失后， 任何上游路由器的发送能力都浪费了!</p>\n<h4 id=\"2-拥塞控制的方法\"><a href=\"#2-拥塞控制的方法\" class=\"headerlink\" title=\"2. 拥塞控制的方法\"></a>2. 拥塞控制的方法</h4><p>端到端的拥塞控制:</p>\n<ul>\n<li>网路层没有为运算层提 供显示的支持。</li>\n<li>从端系统根据观察到的 时延和丢失现象推断出 拥塞</li>\n<li>这是TCP所采用的方法</li>\n</ul>\n<p>网络辅助的拥塞控制:</p>\n<ul>\n<li><p>一个bit指示一条链路出现拥塞(SNA,DECnet)</p>\n</li>\n<li><p>指示发送方按照一定速率 发送(ATM)</p>\n</li>\n<li><p>两种形式 ：1. 直接告诉发送方 2. 先给接收方，再由接收方发会发送方</p>\n</li>\n</ul>\n<h2 id=\"3-7-TCP拥塞控制\"><a href=\"#3-7-TCP拥塞控制\" class=\"headerlink\" title=\"3.7 TCP拥塞控制\"></a>3.7 TCP拥塞控制</h2><p>采用端到端控制</p>\n<h3 id=\"3-7-1-三个问题：\"><a href=\"#3-7-1-三个问题：\" class=\"headerlink\" title=\"3.7.1 三个问题：\"></a>3.7.1 三个问题：</h3><p> 一个TCP发送方如何限制它向其连接发送速率的?<br> 一个TCP发送方如何感知从它到目的地之间的路径上存在拥塞的?<br> 当发送方感知到端到端的拥塞时，采用何种算法来改变其发送速率?</p>\n<h4 id=\"1-发送方如何限制发送速率\"><a href=\"#1-发送方如何限制发送速率\" class=\"headerlink\" title=\"1. 发送方如何限制发送速率\"></a>1. 发送方如何限制发送速率</h4><p>发送方通过CongWin限制传输: LastByteSent-LastByteAcked &lt;=min{ CongWin，RecWin}</p>\n<p>最大平均速率：CongWin/RTT Bytes/s  (忽略传输时间，忽略封装时间，忽略窗口大小影响)</p>\n<p>拥塞窗口是动态的, 通过调节 CongWin的值，发送方因此能调整 它向连接发送数据的速率。</p>\n<h4 id=\"2-发送方如何感知网络拥塞\"><a href=\"#2-发送方如何感知网络拥塞\" class=\"headerlink\" title=\"2. 发送方如何感知网络拥塞\"></a>2. 发送方如何感知网络拥塞</h4><p>丢失事件 = 超时或者 3个重复ACK</p>\n<p>发生丢失时间，tcp发送降低速率（拥塞窗口）</p>\n<p>正常增加发送速率：自计时</p>\n<h4 id=\"3-TCP发送方怎样确定它应当发送的速率呢\"><a href=\"#3-TCP发送方怎样确定它应当发送的速率呢\" class=\"headerlink\" title=\"3. TCP发送方怎样确定它应当发送的速率呢?\"></a>3. TCP发送方怎样确定它应当发送的速率呢?</h4><p>好的发送策略：既使得网络不会拥塞，与此同时又能充分利用所有可用的带宽。</p>\n<p><strong>TCP策略原则：</strong></p>\n<ul>\n<li><p>一个丢失的报文段意味着拥塞，应当降低TCP发送速率。（超时或者 3个重复ACK）</p>\n</li>\n<li><p>当收到未确认报文段的确认到达时，能够增加发送方的速率。（顺利的指示）</p>\n</li>\n<li><p>带宽探测：<em>每个TCP发送方根据异步于其他发送的本地信息而行动。</em></p>\n<p>（第三点理解：执行拥塞控制的时候，不和其他tcp进行协调，只根据本地信息进行控制）</p>\n</li>\n</ul>\n<h3 id=\"3-7-2-TCP拥塞控制\"><a href=\"#3-7-2-TCP拥塞控制\" class=\"headerlink\" title=\"3.7.2 TCP拥塞控制\"></a>3.7.2 TCP拥塞控制</h3><p>####1. TCP拥塞控制算法详述</p>\n<ul>\n<li>慢启动</li>\n<li>拥塞避免</li>\n<li>快速恢复</li>\n</ul>\n<p>慢启动阶段</p>\n<p>MSS ：最大报文段长度</p>\n<p>链接开始：Congwin = 1MSS </p>\n<p>​     MSS  = 500 bytes &amp; RTT = 200 sec</p>\n<p>​    speed = 20 kbps</p>\n<p><strong>实现：</strong></p>\n<ol>\n<li>当连接开始的时候以指数方式增加速率，直到出现丢包：</li>\n</ol>\n<ul>\n<li>当传输报文段首次被确认，拥塞窗口增加一个MSS。</li>\n<li>每RTT倍增拥塞窗口值</li>\n</ul>\n<ol start=\"2\">\n<li>何时结束增长：</li>\n</ol>\n<ul>\n<li>超时事件以后:</li>\n</ul>\n<p>• CongWin值设置为1 MSS • Ssthresh= CongWin /2</p>\n<p>窗口指数增长(慢启动状态)，到达一 个阈值 (ssthresh) 后，再线性增长(拥 塞避免状态)</p>\n<ul>\n<li>收到3个冗余确认后:</li>\n</ul>\n<p>• CongWin减半+3个MSS • 进入快速恢复阶段（tcp reno）</p>\n<p><em>不同的丢包事件</em></p>\n<p>3 个重复的 ACKs 表明网络具有传输一些数据段的能力</p>\n<p> 在三个重复的确认之前超时是“更加严重的警告”</p>\n<ol start=\"3\">\n<li>拥塞发生后</li>\n</ol>\n<p>一旦进入拥塞避免状态，CongWin的值大约是上次遇到拥塞时的一半。每个RTT只将CongWin的值增加一个MSS。</p>\n<ol start=\"4\">\n<li>何时结束拥塞避免的线性增长?</li>\n</ol>\n<ul>\n<li><p>超时事件以后，</p>\n<p>迁移到慢启动状态:  </p>\n<p>CongWin值设置为1 MSS </p>\n<p>Ssthresh= CongWin /2</p>\n</li>\n<li><p>收到3个冗余确认后:</p>\n<p>CongWin减半+3个MSS </p>\n<p>进入快速恢复阶段</p>\n</li>\n</ul>\n<p><em>快速恢复</em></p>\n<p> 对于引起TCP进入快速恢复状态的缺失报文段，每收到一个冗余的 ACK，CongWin的值增加一个MSS。</p>\n<p> 最终，当对丢失的报文段的一个ACK到达时，TCP在降低 CongWin后进 入拥塞避免状态。</p>\n<p> 如果出现超时事件，迁移到慢启动状态: CongWin值设置为1 MSS Ssthresh= CongWin /2</p>\n<p>ssthresh ：阈值    crmd：最大窗口 </p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/558c8514b15f21cc581efcbda9f0c647.png\" alt=\"\"></p>\n<p> <img src=\"https://img.cetacis.dev/uploads/big/3f17b94d3ab78d0ef84d262f45323c8f.png\" alt=\"\"></p>\n<p>reno：有快速恢复   tahoe：无快速恢复 如图</p>\n<h4 id=\"2-总结\"><a href=\"#2-总结\" class=\"headerlink\" title=\"2. 总结\"></a>2. 总结</h4><p>当CongWin &lt; ssthresh时，发送者处于慢启动阶段, CongWin指数增长</p>\n<p>当CongWin &gt; ssthresh时，发送者处于拥塞避免阶段, CongWin线性增长</p>\n<p>当出现3个冗余确认时,发送者处于快速恢复阶段。阈值ssthresh设置为 CongWin/2，且CongWin设置为ssthresh+3*MSS</p>\n<p>当超时发生时，阈值ssthresh设置为CongWin/2，并且CongWin设置为1 MSS.</p>\n<p>TCP AIMD （加性增 乘性减）</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/ec1154af7b0e07c03914e08cb42a7e00.png\" alt=\"\"></p>\n<h4 id=\"tcp平均吞吐量\"><a href=\"#tcp平均吞吐量\" class=\"headerlink\" title=\"tcp平均吞吐量\"></a>tcp平均吞吐量</h4><p>估算： 0.75w / rtt</p>\n<h4 id=\"3-ECN-网络辅助拥塞控制\"><a href=\"#3-ECN-网络辅助拥塞控制\" class=\"headerlink\" title=\"3. ECN 网络辅助拥塞控制\"></a>3. ECN 网络辅助拥塞控制</h4><p>在网络层 ，IP 数据报首部的服务类型字段中的两个比特被用于ECN。</p>\n<p>路由器所使用的一种 ECN 比特设置指示该路由器正在历经拥塞 。 该拥塞指示则由被标记的IP数据报所携带， 送给目的主机 。</p>\n<p>再由目的主机通知发送主机（TCP ACK segment）</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/02ca99f8d0957dfe1f01a2068e942653.png\" alt=\"\"></p>\n<p>tcp发送方会减半拥塞窗口，并且将报文段首部中对cwr（拥塞窗口缩减）进行设置。</p>\n<h1 id=\"实验：\"><a href=\"#实验：\" class=\"headerlink\" title=\"实验：\"></a>实验：</h1><p><img src=\"https://img.cetacis.dev/uploads/big/37d074f219036e3c5770d8f7505b53ca.png\" alt=\"\"></p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/db92a4e4bedcab79b59fa577b74c9a2e.png\" alt=\"\"></p>\n<p>b) 检测客户是否在线</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/c157d44a236d7c0db05060b319fca1bc.png\" alt=\"实验要点\"></p>\n<p>PDU JSON-RPC</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"自顶向下的计算机网络3-运输层\"><a href=\"#自顶向下的计算机网络3-运输层\" class=\"headerlink\" title=\"自顶向下的计算机网络3 运输层\"></a>自顶向下的计算机网络3 运输层</h1><h1 id=\"第三章-运输层\"><a href=\"#第三章-运输层\" class=\"headerlink\" title=\"第三章 运输层\"></a>第三章 运输层</h1><p>目录：</p>\n<p><strong>传输层服务</strong></p>\n<p><strong>多路复用和多路分解</strong></p>\n<p><strong>无连接传输UDP</strong></p>\n<p><strong>可靠数据传输原理</strong></p>\n<p><strong>面向连接传输</strong></p>\n<p><strong>拥塞控制原理</strong>   原因 后果 控制</p>\n<p><strong>TCP</strong> <strong>拥塞控制</strong> </p>","more":"<h2 id=\"3-1-传输层服务\"><a href=\"#3-1-传输层服务\" class=\"headerlink\" title=\"3.1 传输层服务\"></a>3.1 传输层服务</h2><ol>\n<li>传输层服务和协议</li>\n</ol>\n<p>在两个不同的主机上运行的应用程序之间提供逻辑通信</p>\n<p>传输层协议运行在<strong>端系统</strong>（核心的交换机部分，只存在下面三层）：</p>\n<ul>\n<li>发送方: 将应用程序报文分成数据段传递给网络层</li>\n<li>接受方: 将数据段重新组装成报文传递到应用层 </li>\n</ul>\n<p>运输层协议：tcp udp</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/3aabb85d17bcec6c61b085fc5637f141.png\" alt=\"逻辑端到端\"></p>\n<p><strong>可靠按序递交 (TCP) ：</strong>  拥塞控制（拥塞时减缓发送方） 流量控制 （发送接收速度匹配） 连接建立 （握手）</p>\n<p>*<em>不可靠的无序传递（udp）: *</em>  UDP “尽力传递” IP的直接扩展  不提供的服务 : 延迟保证 带宽保证 </p>\n<p>tcp是可靠的，udp是不可靠的。网络层不可靠的</p>\n<hr>\n<ol start=\"2\">\n<li>运输层和网络层</li>\n</ol>\n<p>从通信和信息处理的角度看，运输层向它上面的 应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。</p>\n<p>类比：家庭类比:</p>\n<p>12个孩子向12个孩子发信   • 主机 = 家庭  • 进程 = 孩子  • 应用报文= 信封中的信 </p>\n<p>​                                               • 网络层协议= 邮政服务   • 运输协议 = Ann和Bill（家庭分发）</p>\n<p><strong>网络层：</strong>两个主机之间的逻辑通信</p>\n<p><strong>传输层</strong>：两个进程之间的逻辑通信  <em>可靠, 增强的网络层服务</em></p>\n<h2 id=\"3-2-多路复用和多路分解\"><a href=\"#3-2-多路复用和多路分解\" class=\"headerlink\" title=\"3.2 多路复用和多路分解\"></a>3.2 多路复用和多路分解</h2><ol>\n<li>总览</li>\n</ol>\n<p><img src=\"https://img.cetacis.dev/uploads/big/ef6baf7007621db3e46d865f2616248b.png\" alt=\"\"></p>\n<p><strong>在发送主机多路复用:</strong></p>\n<p>从多个套接字收集数据, 用首部 封装数据，然后将报文段传递到 网络层多路复用</p>\n<p><strong>在接收主机多路分解:</strong></p>\n<p>将接收到的数据段传递到正确的套接字(多路分解)</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/23ee20a92cd5b8b75415db0530a62cbf.png\" alt=\"\"></p>\n<hr>\n<ol start=\"2\">\n<li>多路分解如何工作</li>\n</ol>\n<p>主机接收IP数据报</p>\n<ul>\n<li><p>每个数据报承载1个运输层报文段</p>\n</li>\n<li><p>每个段具有源、目的端口号<br>端口号代表不同的服务（进程）</p>\n<p>主机使用IP地址 &amp;端口号将段定向到适当的套接字</p>\n</li>\n</ul>\n<p><img src=\"https://img.cetacis.dev/uploads/big/e92bb4c5d174311573d73c7973ef121f.png\" alt=\"\"></p>\n<p>端口扫描：通过端口知悉服务</p>\n<hr>\n<ol start=\"3\">\n<li>Udp无连接多路分解（一对多，多对一，多对多）</li>\n</ol>\n<ul>\n<li><p>套接字编程：</p>\n<p>生成具有端口号的套接字: </p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DatagramSocket mySocket1 = <span class=\"keyword\">new</span> DatagramSocket(<span class=\"number\">9911</span>); <span class=\"comment\">// mySocket1是一个套接字</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">serverSocket = socket(AF_INET, SOCK_DGRAM)<span class=\"comment\"># 创造套接字</span></span><br><span class=\"line\">serverSocket.bind((<span class=\"string\">''</span>, serverPort))<span class=\"comment\"># 将端口号连接</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>UDP套接字由二元组标识 : (目的ip地址，目的端口号)</p>\n</li>\n<li><p>当主机接收UDP报文段时:</p>\n<p>在报文段中检查目的地端口号</p>\n<p>将UDP段定向到具有该端口号的套接字</p>\n</li>\n</ul>\n<p>具有不同的源IP地址且/或源端口号，但 具有相同的目的IP地址和目的端口号的IP 报文段指向同样的套接字</p>\n<p> <img src=\"https://img.cetacis.dev/uploads/big/6ae3c1f037ac20cb3f39433fedd97c09.png\" alt=\"\"></p>\n<p>原端口号（A.sp)是自动生成的，他在整个过程中不具有定位功能，他只是c在回发时的dp，所以它并不用指定。它为请求报文段中提供返回地址(包括IP地址和端口号)</p>\n<p>但是服务器的目的端口一定要指定</p>\n<hr>\n<ol start=\"4\">\n<li>面向连接的多路分解（TCP）</li>\n</ol>\n<p><strong>TCP 套接字由4部分指定:</strong></p>\n<p>源IP地址 源端口号 目的IP地址 目的端口号 </p>\n<p>接收主机使用所有四个值将数据段定位到合适的套接字</p>\n<p><strong>TCP服务器的套接字</strong></p>\n<p>服务器主机支持很多同时的tcp套接字：每个套接字用四个部分来表示</p>\n<p>tcp服务器有一个欢迎套接字，接受连接请求，tcp收到请求后会重开一个单独的连接套接字与客户机进行连接。</p>\n<p>连接套接字都是80端口，用源ip地址进行区分。</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/a7bfeca2042c5f2cccd546dfe84ce1ed.png\" alt=\"tcp服务器\"></p>\n<p>web：</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/83d9d0dba8a39d31b343997ad1309c02.png\" alt=\"\"></p>\n<p>如图，b发出的两个tcp连接，通过源端口号区分</p>\n<h2 id=\"3-3-udp\"><a href=\"#3-3-udp\" class=\"headerlink\" title=\"3.3 udp\"></a>3.3 udp</h2><ol>\n<li>udp：用户数据报协议（udp的报文段有时候叫数据报）</li>\n</ol>\n<p>特点：</p>\n<ul>\n<li><p>它是“基本要素”互联网传输协议</p>\n</li>\n<li><p>因为是“尽力而为”服务，可能丢包，对应用程序交付失序</p>\n</li>\n<li><p>无连接： 在udp发送方和接收方之间无握手；</p>\n<p>​                每个udp段的处理独立于其他段（tcp面向流，可能同一个应用分在两个段中）</p>\n</li>\n</ul>\n<ul>\n<li><p>UDP 只在 IP 的数据报服务之上增加了很少一点的功能，即端口的功能和 差错检测的功能。 </p>\n</li>\n<li><p>虽然 UDP 用户数据报只能提供不可靠的交付，但 UDP 在某些方面有其 特殊的优点。 </p>\n</li>\n<li><p>UDP 是无连接的，即发送数据之前不需要建立连接。 </p>\n</li>\n<li><p>UDP 使用尽最大努力交付，即不保证可靠交付，同时也不使用拥塞控制。 </p>\n</li>\n<li><p>UDP 没有拥塞控制，很适合多媒体通信的要求。  </p>\n</li>\n<li><p>UDP 支持一对一、一对多、多对一和多对多的交互通信。 </p>\n</li>\n<li><p>UDP 的首部开销小，只有 8 个字节。 </p>\n</li>\n<li><p>UDP 是面向报文的。发送方 UDP 对应用程序交下来的报文，在添加  首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并， 也不拆分，而是保留这些报文的边界。</p>\n<p><em>tcp无报文边界</em> </p>\n</li>\n<li><p>应用层交给 UDP 多长的报文，UDP 就照样发送，即一次发送一个报文。 </p>\n</li>\n<li><p>接收方 UDP 对 IP 层交上来的 UDP 用户数据报，在去除首部后就原 封不动地交付上层的应用进程，一次交付一个完整的报文。 </p>\n</li>\n<li><p>应用程序必须选择合适大小的报文。</p>\n</li>\n</ul>\n<hr>\n<ol start=\"2\">\n<li>为什么用udp？</li>\n</ol>\n<ul>\n<li>无连接创建（减少时延</li>\n<li>简单：可并发更多</li>\n<li>段首部小</li>\n<li>无拥塞控制：udp能够尽可能快地传输</li>\n</ul>\n<p><img src=\"https://img.cetacis.dev/uploads/big/2dd4c563c7157a58d462f132de254834.png\" alt=\"面向报文的udp数据包\"></p>\n<hr>\n<ol start=\"3\">\n<li><strong>udp的应用：</strong></li>\n</ol>\n<p>常用于流式多媒体应用 ：丢包容忍、速率敏感</p>\n<p>其他UDP应用： DNS（增加速率）、SNMP、RTP（路由选择协议 向其他路由器通报信息）</p>\n<p>经UDP的可靠传输 : 在应用层增加可靠性，应用程序特定的差错恢复!</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/bfb81d85950595932dbf162253b0887d.png\" alt=\"\"></p>\n<p><em>检验和：检查数据报是否出错</em></p>\n<ol start=\"4\">\n<li>udp检验和与差错检测</li>\n</ol>\n<ul>\n<li>差错检测</li>\n</ul>\n<p><img src=\"https://img.cetacis.dev/uploads/big/01028c74db7d536acdeb68fe37e9b401.png\" alt=\"差错检测\"></p>\n<p><em>检错可能出现漏掉的错误（很少；大的校验信息 域能提供更好 的检错能力</em></p>\n<ul>\n<li>检验和</li>\n</ul>\n<p>目标：对传输的数据进行差错检测</p>\n<p>发送方：将数据段看成16bit的整数序列</p>\n<p>​                校验和:段内容进行带循环进位的加法，结果取反码</p>\n<p>​                发送者将校验和值放入UDP的校验和域</p>\n<p>接收方：计算接收到数据段的校验和 </p>\n<p>​                检查 计算的校验和是否等于校验和域中的值:<br>​                • NO – 检测到错误<br>​                • YES – 没有检测到错误</p>\n<p>​                还是有可能出错</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/559a0e644e35a34f5ae4ee80aa39a8e9.png\" alt=\"\"></p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/31cb0a6d0772550ca5bf8be2393c5055.png\" alt=\"注意循环进位\"></p>\n<p><strong>记得循环进位</strong></p>\n<h2 id=\"3-4-可靠数据传输原理\"><a href=\"#3-4-可靠数据传输原理\" class=\"headerlink\" title=\"3.4 可靠数据传输原理\"></a>3.4 可靠数据传输原理</h2><p>运输层需要提供可靠传输，但是网络层没有可靠，所以就需要接口。</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/7a39d15318100c8d1431b69927c59bab.png\" alt=\"可靠数据传输：基本概念\"></p>\n<p>四个函数可以看做动作/事件</p>\n<p>逐步开发发送方和接收方的可靠数据传输协议 (rdt)：</p>\n<ul>\n<li>仅考虑单向数据传输</li>\n<li>控制信息将在两个方向流动</li>\n</ul>\n<p>有限状态机 (FSM)来定义发送方和接收方</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/72bf5f176f835798782c1dac3f21ad16.png\" alt=\"有限状态机&lt;数字逻辑&gt;\"></p>\n<ol>\n<li>rdt的发展</li>\n</ol>\n<p><strong>Rdt1.0:</strong> <strong>完全可靠信道上的可靠数据传输</strong></p>\n<p>在完美可靠的信道上<br>    • 没有bit错误</p>\n<p>​    • 没有分组丢失 </p>\n<p>发送方，接收方单独的 FSMs : </p>\n<p>​    • 发送方发送数据到下层信道 </p>\n<p>​    • 接收方从下层信道接收数据 </p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/cffcc44f90050d8d2170c4fe8fbf126f.png\" alt=\"rdt1.0\"></p>\n<p><strong>Rdt2.0:</strong> <strong>具有bit错误的信道</strong></p>\n<p>下层信道可能让传输分组中的bit受损 </p>\n<ul>\n<li>校验和将检测到bit错误</li>\n</ul>\n<p>问题: 如何从错误中恢复</p>\n<ul>\n<li>确认(ACKs): 接收方明确告诉发送方 分组接收正确</li>\n<li>否认 (NAKs):接收方明确告诉发送方 分组接收出错 </li>\n<li>发送方收到NAK后重发这个分组</li>\n</ul>\n<p>在 rdt2.0的新机制 (在 rdt1.0中没有的): </p>\n<ul>\n<li><p>差错检测</p>\n</li>\n<li><p>接收方反馈: 控制信息 (ACK,NAK)</p>\n</li>\n<li><p>重传</p>\n</li>\n</ul>\n<p><img src=\"https://img.cetacis.dev/uploads/big/2998071b3d7db73519ca8bcd2d69b288.png\" alt=\"rdt2.0\"></p>\n<p>rdt2.0是一个停-等协议（字面意思</p>\n<p>Rdt2.0的缺陷：如果ACK/NAK受损，将会出现 发送方不知道在接收方会发生 什么情况。</p>\n<p>​                          重传可能导致冗余</p>\n<p>处理冗余:</p>\n<p>• 发送方对每个分组增加序列号</p>\n<p>• 如果ACK/NAK受损，发送方重传当前的分组</p>\n<p>• 接收方丢弃(不再向上交付)冗 余分组</p>\n<p><strong>rdt2.1</strong></p>\n<p>发送方：</p>\n<p>两个序号0/1 够用，为什么？  -因为停等协议</p>\n<p>检查是否收到的ACK/NAK 受损</p>\n<p>状态增加一倍 状态必须“记住”是否“当前的”分组具有0或1序号</p>\n<p>接收方：</p>\n<p>检查是否接收到分组时候冗余  状态指示是否0/1是否是起飞的分组序号</p>\n<p>注意：接收方不知道它的ack/nal时候被正确接收</p>\n<p>发送方</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/b36b7d0725db5c2df42f09cd2668e081.png\" alt=\"\"></p>\n<p>接收方：</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/d26e255338267a9c4a5750b63487e51a.png\" alt=\"接收方处理受损的ack/nak\"></p>\n<p>正确报文序号正确：拆包，上传给上方-&gt;等待来自下面的调用1</p>\n<p>正确报文序号错误1 ：回发ack（因为发出了1，所以可能是因为上次接收方回发的ack1受损了，所以此时应该回发ack1使发送方发送下一个序号的数据报）-&gt;等待来自下面的调用0</p>\n<p>错误报文：回发NAK-&gt;等待来自下面的调用0</p>\n<p>*<em>rdt2.2 : 不要nak的协议 *</em></p>\n<p>同 rdt2.1一样的功能, 只用 ACKs<br>不用 NAK, 如果上个报文接收正确接收方发送 ACK</p>\n<ul>\n<li>接收方必须明确包含被确认的报文的序号 </li>\n</ul>\n<p>发送方收到重复 ACK 将导致和 NAK一样的 处理: 重发当前报文 </p>\n<p>发送方发送0包，但是收到的是ack1，则等于获得了nak.</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/cea7c4f6f57bef7bd7fefab902433f52.png\" alt=\"\"><strong>rdt3.0</strong></p>\n<p>当下面的信道也能丢失分组：怎么检测丢包？丢包该怎么办？</p>\n<p>方法: </p>\n<p>发送方等待ACK一段“合理的”时间 </p>\n<p>• 如在这段时间没有收到ACK则重传</p>\n<p>• 可能出现问题  如果分组(或ACK)只是延迟(没有丢失):</p>\n<p>重传将是冗余的，但序号的使用已经处理了该情况；接收方必须定义被确认的分组序号</p>\n<p> • 需要倒计时定时器</p>\n<p><em>发送方数据重发只发生在timeout时，收到错误序号包是不会重发的。</em></p>\n<p><em>接收方会回应所有数据发送请求</em></p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/210ecfd4eb2f6cf1efa886d3229c903d.png\" alt=\"\"></p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/dd47a9b82f26c69d6bea0a5be1ef1dc4.png\" alt=\"\"></p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/7046a71ca26f5ffcaaea651abeb8516d.png\" alt=\"\"></p>\n<p><strong>rdt3.0的性能</strong></p>\n<p>性能落后：停等协议</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/9a89b4a3aa15d4d84cffb9d09808b36d.png\" alt=\"\"></p>\n<p><strong>利用率</strong>：发送方实际用于将发送bit送进信道的时间与发送时间的比率</p>\n<p>这个例子利用率只有0.027%，网路协议限制了物理资源的使用</p>\n<ol start=\"2\">\n<li>流水线技术</li>\n</ol>\n<p>序号要多；缓冲区要扩展（放置未收到相应的发送包</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/b372cbc539f2f1ddb75a3d93b3221314.png\" alt=\"\"></p>\n<p>Go-Back-N（滑动窗口协议）GBN</p>\n<p>限制已发送未应答的分组数量</p>\n<p>分组序号空间使用摸2^k</p>\n<p>ACK(n)：累计ACK；只对第一个发送未被确认的报文定时，timeout要重传全部的分组</p>\n<p>接收方无缓存</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/a75be72a5039ecd408dfc96e8108f83b.png\" alt=\"S\"></p>\n<p>选择性重传 Selective repeat （SR）</p>\n<p>发送方接收方都有缓存；每一个分组都有自己的定时器</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/5e33f383e9633f0682fda94bbd78e4a6.png\" alt=\"\"></p>\n<p>分组n在[rcvbase-N,rcvbase-1]内的原因：之前的N个ack丢失</p>\n<p>窗口小于或等于序号空间大小的一半 使不会重复</p>\n<p>否则：</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/d08a22b7e97539a46fe1b1a174fbf9e0.png\" alt=\"\"></p>\n<h2 id=\"3-5-面向连接传输-TCP\"><a href=\"#3-5-面向连接传输-TCP\" class=\"headerlink\" title=\"3.5 面向连接传输 TCP\"></a>3.5 面向连接传输 TCP</h2><p><img src=\"https://img.cetacis.dev/uploads/big/53971cfe3e91069e16ccfd3fe9e3c055.png\" alt=\"\"></p>\n<p>图中上层：<strong>发送和接受缓冲区</strong></p>\n<p>MSS：最大报文段长度。一次从换从中读取的信息长度。</p>\n<p>MTU：最大传输单元，一般由与本机相连链路决定。在网络上可能不同。</p>\n<h3 id=\"3-5-1-tcp面向流\"><a href=\"#3-5-1-tcp面向流\" class=\"headerlink\" title=\"3.5.1 tcp面向流\"></a>3.5.1 tcp面向流</h3><ul>\n<li><p>流水线 </p>\n<p>tcp拥塞和流量控制设置滑动窗口协议</p>\n</li>\n<li><p>流量控制</p>\n<p>发送方不能淹没接收方</p>\n</li>\n<li><p>拥塞控制</p>\n<p>防止过度占用网络资源</p>\n</li>\n<li><p>面向连接</p>\n<p>在数据交换前握手(交换控制信息) 初始化发 送方和接收方的状态</p>\n</li>\n<li><p>全双工数据</p>\n<p>同一个连接上的双向数据流</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/280aab142b63d9a01cb369c1f2c0383f.png\" alt=\"面向流\"></p>\n<p>没有吧报文边界，但是最大为MSS</p>\n</li>\n</ul>\n<h3 id=\"3-5-2-报文段结构\"><a href=\"#3-5-2-报文段结构\" class=\"headerlink\" title=\"3.5.2 报文段结构\"></a>3.5.2 报文段结构</h3><h4 id=\"1-首部结构概述\"><a href=\"#1-首部结构概述\" class=\"headerlink\" title=\"1. 首部结构概述\"></a>1. 首部结构概述</h4><p><img src=\"https://img.cetacis.dev/uploads/big/c419e17b244a1258d8e17b77a134301b.png\" alt=\"\"></p>\n<p><strong>序号</strong>：占4字节 确定是否按序收到分组，是否冗余，或者是否丢包。TCP连接中序号是报文段所发送的数据的第一字节的序号。（不是顺序</p>\n<p><strong>确认号字段</strong>：4字节 期望收到对方的下一个报文段的数据的第一字节的序号。告诉发送方，之前的序号已经收到。</p>\n<p><strong>首部长度（数据偏移）</strong>：4位 指出报文段数据距离tcp报文段的起始处有多远。数据偏移的单位是32字。</p>\n<p><strong>保留字段</strong>：6位 拥塞控制可用</p>\n<p><strong>紧急URG</strong>：当URG=1，告诉系统次报文段有紧急数据，优先传送。</p>\n<p><strong>紧急指针：</strong>说明到哪里是紧急数据。当URG=1时，此指针有用</p>\n<p><strong>ACK：</strong>确认号 ACK=1 确认号字段有效</p>\n<p><strong>PSH：</strong>PSH=1的报文段，应尽快交付至上层，而不是等整个缓存填充满了以后再向上交付。</p>\n<p><strong>RST：</strong> =1，表明TCP链接出现差错，必须释放链接，然后再重新建立链接。（端口不存在或者主机崩溃）</p>\n<p><strong>SYN：</strong>=1，表明这是一个连接请求或者链接接受报文。用于建立握手。</p>\n<p><strong>FIN：</strong>=1，请求释放连接，表明数据传送完成</p>\n<p><strong>窗口：</strong>2字节 单位为字节，设置让对方设置发送窗口的依据，用于流量控制。表明接收方愿意接受的长度。</p>\n<p><strong>检验和：</strong>2字节，包括首部和数据两部分。计算校验和要在TCP报文段的前面加上12字节伪首部</p>\n<p><strong>选项字段：</strong>TCP最初只有一种选项，即最大报文段长度MSS。MSS告诉对方TCP：“我缓存能接受的报文段的数据字段的最大长度是MSS字节”。现在还可作为：窗口确定选项；时间戳选项（对ack的确认计算时间）；</p>\n<p><strong>填充</strong></p>\n<h4 id=\"2-TCP序号和确认\"><a href=\"#2-TCP序号和确认\" class=\"headerlink\" title=\"2. TCP序号和确认\"></a>2. TCP序号和确认</h4><p><strong>序号：</strong></p>\n<p>报文段中第一个数据在字节流中的位置编号</p>\n<p><em>例子 5M的数据 MSS 1000</em></p>\n<p><em>分组一 序号 0 分组二 序号 1000 分组三 序号 2000</em></p>\n<p><strong>确认号：</strong></p>\n<p>期望从对方收到的下一个字节的序号</p>\n<p>累计确认</p>\n<p><em>例子： 已发送 0-535 ，接收方会发536的确认号</em></p>\n<p><em>例子二：已发送 0-535 536-899 900-1000，某种原因，536-899丢失。接收方会发536的确认号。</em></p>\n<p>接收方如何处理失序报文段：TCP无规定，由实现者选择：抛弃/缓存。</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/a43d34595f97615d29fcdd187b6772c2.png\" alt=\"\"></p>\n<h4 id=\"3-TCP往返时延的估计和超时\"><a href=\"#3-TCP往返时延的估计和超时\" class=\"headerlink\" title=\"3. TCP往返时延的估计和超时\"></a>3. TCP往返时延的估计和超时</h4><h3 id=\"3-5-3-可靠数据传输\"><a href=\"#3-5-3-可靠数据传输\" class=\"headerlink\" title=\"3.5.3 可靠数据传输\"></a>3.5.3 可靠数据传输</h3><ul>\n<li>TCP在IP不可靠服务的基础上</li>\n</ul>\n<p>创建可靠数据传输服务：肯定确认和定时器；序号、重传</p>\n<ul>\n<li><p>流水线发送报文段</p>\n</li>\n<li><p>累计确认 收到一个确认，则意味着收到之前所有的</p>\n</li>\n<li><p>TCP使用单个重传定时器 （定时器管理消耗大。</p>\n</li>\n<li><p>重传被下列事件触发：超时；重复ack</p>\n</li>\n</ul>\n<h4 id=\"1-tcp发送方事件\"><a href=\"#1-tcp发送方事件\" class=\"headerlink\" title=\"1. tcp发送方事件\"></a>1. tcp发送方事件</h4><ol>\n<li><p>从应用程序接收数据:</p>\n<p>用序号创造一个数据段</p>\n</li>\n</ol>\n<p>序号是数据段中第一个数据字节在字节流中的位置编号</p>\n<p>如果没有启动定时器，则启动定时器</p>\n<ul>\n<li><p>定时器是最早没有被确认的数据 段发送时启动的</p>\n</li>\n<li><p>设置超时间隔: TimeOutInterval</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li><p>超时：</p>\n<p>重发导致超时的报文段</p>\n<p>重新开始定时器</p>\n</li>\n<li><p>收到确认：</p>\n<p>如果确认了还没有确认的数据段：</p>\n<p>更新还没有确认的状态；</p>\n<p>还有未完成的数据段，重新开始定时器</p>\n</li>\n</ol>\n<p><img src=\"https://img.cetacis.dev/uploads/big/6c57e6c1f8351ddd9a438f88bd29d821.png\" alt=\"\"></p>\n<p>sendbase （sendbase之前都已经被确认</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/1312199c28b46fc684802f2926ba46da.png\" alt=\"\"></p>\n<p><strong>超时间隔加倍</strong></p>\n<p>tcp每次重传 会把下一次的超时间间隔设置为先前的两倍</p>\n<p>当<strong>收到上层应用的数据</strong>或者<strong>收到ack</strong>两个事件中的任意个时，定时器恢复。</p>\n<p>这种修改提供了一种形式受限的拥塞控制。</p>\n<p><strong>快速重传</strong></p>\n<p>超时触发重传会导致超时周期长</p>\n<ul>\n<li><p>发送方常常一个接一个地发送很多报文段，如果报文段丢失,则发送方将可能接收到很多重复的 ACKs</p>\n</li>\n<li><p>如果发送方收到3个对同样报文段的确认，则发送方认为该报文段之后的数据已经丢失。</p>\n</li>\n<li><p>启动快速重传: 在定时器超时之前重发丢失的报文段 </p>\n</li>\n</ul>\n<h4 id=\"2-接收方行为\"><a href=\"#2-接收方行为\" class=\"headerlink\" title=\"2. 接收方行为\"></a>2. 接收方行为</h4><p><img src=\"https://img.cetacis.dev/uploads/big/6db99dd0e5267aaa84f5f5f6607db26c.png\" alt=\"\"></p>\n<p>如图3是快速重传的原理</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/ef4d1bdcb260136ae9feb9b4dcc853d7.png\" alt=\"快速重传\"></p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/f800231b2377036999ece5a3bdd56af2.png\" alt=\"\"></p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/1f6a31ebf20801f39e32a777e13e679e.png\" alt=\"快速重传&amp;缓存\"></p>\n<h3 id=\"3-5-4-tcp流控\"><a href=\"#3-5-4-tcp流控\" class=\"headerlink\" title=\"3.5.4 tcp流控\"></a>3.5.4 tcp流控</h3><p>TCP链接的接收方有一个缓冲区 </p>\n<p>速度匹配服务：发送速率和接收应用程序的提取速率匹配</p>\n<p>流量控制：发送方不能发送太多太快，让接受缓冲区溢出</p>\n<p>tcp报文中窗口字段会告知缓冲区剩余空间 </p>\n<p>发送方要限制未确认的数据不超过RcvWindow</p>\n<p>当RcWindow已满，会发送试探报文</p>\n<h3 id=\"3-5-5-TCP-连接管理\"><a href=\"#3-5-5-TCP-连接管理\" class=\"headerlink\" title=\"3.5.5 TCP 连接管理\"></a>3.5.5 TCP 连接管理</h3><h4 id=\"1-三次握手\"><a href=\"#1-三次握手\" class=\"headerlink\" title=\"1. 三次握手\"></a>1. 三次握手</h4><p>建立连接：</p>\n<p>步骤一  客户机向服务器发送 TCP SYN报文段（SYN = 1, SEQ = x）</p>\n<ul>\n<li>指定初试序号</li>\n<li>没有数据</li>\n</ul>\n<p>步骤二 服务器收到SYN报文段, 用SYNACK报文段回复(SYN = 1, ACK = 1, SEQ = y, ack = x+1)(y在于确定客户机的身份)</p>\n<ul>\n<li><p>服务器为该连接分配缓冲区和变量</p>\n</li>\n<li><p>指定服务器初始序号</p>\n</li>\n</ul>\n<p>步骤 3: 客户机接收到 SYNACK, 分配缓冲，用ACK报文段回复,可能包含数据 </p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/197aa58d6e85a0b8b1f1a90847d59e7a.png\" alt=\"\"></p>\n<h4 id=\"2-两次握手错误\"><a href=\"#2-两次握手错误\" class=\"headerlink\" title=\"2. 两次握手错误\"></a>2. 两次握手错误</h4><p><img src=\"https://img.cetacis.dev/uploads/big/0a7c53bb51d10be438e91b4a28ebb590.png\" alt=\"\"></p>\n<ul>\n<li>服务器请求超时，客户重新发送，服务器多次得到请求，导致“半链接”，分配缓冲区，长时间占用缓冲区。当三次时，半链接会短</li>\n</ul>\n<p><img src=\"https://img.cetacis.dev/uploads/big/b5b7c3b19144d506115331453541e7f7.png\" alt=\"\"></p>\n<ul>\n<li>碰巧出现客户机不知的链接</li>\n</ul>\n<h4 id=\"3-关闭连接\"><a href=\"#3-关闭连接\" class=\"headerlink\" title=\"3. 关闭连接\"></a>3. 关闭连接</h4><p>关闭链接的一方为客户端</p>\n<p><strong>客户关闭套接字: clientSocket.close</strong> </p>\n<p>Step 1 : 客户发送 TCP FIN 控制报文段到服务器</p>\n<p>Step 2 : 服务器接收 FIN, 回复 ACK. 半关闭连接, 并发送FIN到客户 </p>\n<p>Step 3: 客户接收 FIN, 回复 ACK.</p>\n<p>进入 “timed wait”状态</p>\n<p> 等待结束时释放连接资源</p>\n<p>Step 4: 服务器接收 ACK. 连接关闭. </p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/db92bfb62bbbb56275bce3431d323dfd.png\" alt=\"\"></p>\n<p>Timed wait for 2 * max segment ligetime （timeout意义）: 客户端结束后，套接字被重用，如果之前的连接中有游荡的报文，可能就会被新的链接接收</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/fb30b019f55978ab648fbe516e5b4d56.png\" alt=\"\"></p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/fb30b019f55978ab648fbe516e5b4d56.png\" alt=\"\"></p>\n<h2 id=\"3-6-拥塞控制\"><a href=\"#3-6-拥塞控制\" class=\"headerlink\" title=\"3.6 拥塞控制\"></a>3.6 拥塞控制</h2><p>拥塞：从信息角度看: “太多源主机发送太多的数据，速度太快以至于网络来不及处理”</p>\n<p>不同于流量控制</p>\n<p>表现：丢失分组 (路由器的缓冲区溢出)  长延迟（在路由器的缓冲区排队）</p>\n<h4 id=\"1-拥塞的代价\"><a href=\"#1-拥塞的代价\" class=\"headerlink\" title=\"1. 拥塞的代价\"></a>1. <strong>拥塞的代价</strong></h4><p>发送方必须执行重传以补偿因缓存溢出而 丢弃的分组。</p>\n<p>不必要的重发<strong>:</strong>链路 需要运输多个分组的拷贝</p>\n<p>当分组丢失后， 任何上游路由器的发送能力都浪费了!</p>\n<h4 id=\"2-拥塞控制的方法\"><a href=\"#2-拥塞控制的方法\" class=\"headerlink\" title=\"2. 拥塞控制的方法\"></a>2. 拥塞控制的方法</h4><p>端到端的拥塞控制:</p>\n<ul>\n<li>网路层没有为运算层提 供显示的支持。</li>\n<li>从端系统根据观察到的 时延和丢失现象推断出 拥塞</li>\n<li>这是TCP所采用的方法</li>\n</ul>\n<p>网络辅助的拥塞控制:</p>\n<ul>\n<li><p>一个bit指示一条链路出现拥塞(SNA,DECnet)</p>\n</li>\n<li><p>指示发送方按照一定速率 发送(ATM)</p>\n</li>\n<li><p>两种形式 ：1. 直接告诉发送方 2. 先给接收方，再由接收方发会发送方</p>\n</li>\n</ul>\n<h2 id=\"3-7-TCP拥塞控制\"><a href=\"#3-7-TCP拥塞控制\" class=\"headerlink\" title=\"3.7 TCP拥塞控制\"></a>3.7 TCP拥塞控制</h2><p>采用端到端控制</p>\n<h3 id=\"3-7-1-三个问题：\"><a href=\"#3-7-1-三个问题：\" class=\"headerlink\" title=\"3.7.1 三个问题：\"></a>3.7.1 三个问题：</h3><p> 一个TCP发送方如何限制它向其连接发送速率的?<br> 一个TCP发送方如何感知从它到目的地之间的路径上存在拥塞的?<br> 当发送方感知到端到端的拥塞时，采用何种算法来改变其发送速率?</p>\n<h4 id=\"1-发送方如何限制发送速率\"><a href=\"#1-发送方如何限制发送速率\" class=\"headerlink\" title=\"1. 发送方如何限制发送速率\"></a>1. 发送方如何限制发送速率</h4><p>发送方通过CongWin限制传输: LastByteSent-LastByteAcked &lt;=min{ CongWin，RecWin}</p>\n<p>最大平均速率：CongWin/RTT Bytes/s  (忽略传输时间，忽略封装时间，忽略窗口大小影响)</p>\n<p>拥塞窗口是动态的, 通过调节 CongWin的值，发送方因此能调整 它向连接发送数据的速率。</p>\n<h4 id=\"2-发送方如何感知网络拥塞\"><a href=\"#2-发送方如何感知网络拥塞\" class=\"headerlink\" title=\"2. 发送方如何感知网络拥塞\"></a>2. 发送方如何感知网络拥塞</h4><p>丢失事件 = 超时或者 3个重复ACK</p>\n<p>发生丢失时间，tcp发送降低速率（拥塞窗口）</p>\n<p>正常增加发送速率：自计时</p>\n<h4 id=\"3-TCP发送方怎样确定它应当发送的速率呢\"><a href=\"#3-TCP发送方怎样确定它应当发送的速率呢\" class=\"headerlink\" title=\"3. TCP发送方怎样确定它应当发送的速率呢?\"></a>3. TCP发送方怎样确定它应当发送的速率呢?</h4><p>好的发送策略：既使得网络不会拥塞，与此同时又能充分利用所有可用的带宽。</p>\n<p><strong>TCP策略原则：</strong></p>\n<ul>\n<li><p>一个丢失的报文段意味着拥塞，应当降低TCP发送速率。（超时或者 3个重复ACK）</p>\n</li>\n<li><p>当收到未确认报文段的确认到达时，能够增加发送方的速率。（顺利的指示）</p>\n</li>\n<li><p>带宽探测：<em>每个TCP发送方根据异步于其他发送的本地信息而行动。</em></p>\n<p>（第三点理解：执行拥塞控制的时候，不和其他tcp进行协调，只根据本地信息进行控制）</p>\n</li>\n</ul>\n<h3 id=\"3-7-2-TCP拥塞控制\"><a href=\"#3-7-2-TCP拥塞控制\" class=\"headerlink\" title=\"3.7.2 TCP拥塞控制\"></a>3.7.2 TCP拥塞控制</h3><p>####1. TCP拥塞控制算法详述</p>\n<ul>\n<li>慢启动</li>\n<li>拥塞避免</li>\n<li>快速恢复</li>\n</ul>\n<p>慢启动阶段</p>\n<p>MSS ：最大报文段长度</p>\n<p>链接开始：Congwin = 1MSS </p>\n<p>​     MSS  = 500 bytes &amp; RTT = 200 sec</p>\n<p>​    speed = 20 kbps</p>\n<p><strong>实现：</strong></p>\n<ol>\n<li>当连接开始的时候以指数方式增加速率，直到出现丢包：</li>\n</ol>\n<ul>\n<li>当传输报文段首次被确认，拥塞窗口增加一个MSS。</li>\n<li>每RTT倍增拥塞窗口值</li>\n</ul>\n<ol start=\"2\">\n<li>何时结束增长：</li>\n</ol>\n<ul>\n<li>超时事件以后:</li>\n</ul>\n<p>• CongWin值设置为1 MSS • Ssthresh= CongWin /2</p>\n<p>窗口指数增长(慢启动状态)，到达一 个阈值 (ssthresh) 后，再线性增长(拥 塞避免状态)</p>\n<ul>\n<li>收到3个冗余确认后:</li>\n</ul>\n<p>• CongWin减半+3个MSS • 进入快速恢复阶段（tcp reno）</p>\n<p><em>不同的丢包事件</em></p>\n<p>3 个重复的 ACKs 表明网络具有传输一些数据段的能力</p>\n<p> 在三个重复的确认之前超时是“更加严重的警告”</p>\n<ol start=\"3\">\n<li>拥塞发生后</li>\n</ol>\n<p>一旦进入拥塞避免状态，CongWin的值大约是上次遇到拥塞时的一半。每个RTT只将CongWin的值增加一个MSS。</p>\n<ol start=\"4\">\n<li>何时结束拥塞避免的线性增长?</li>\n</ol>\n<ul>\n<li><p>超时事件以后，</p>\n<p>迁移到慢启动状态:  </p>\n<p>CongWin值设置为1 MSS </p>\n<p>Ssthresh= CongWin /2</p>\n</li>\n<li><p>收到3个冗余确认后:</p>\n<p>CongWin减半+3个MSS </p>\n<p>进入快速恢复阶段</p>\n</li>\n</ul>\n<p><em>快速恢复</em></p>\n<p> 对于引起TCP进入快速恢复状态的缺失报文段，每收到一个冗余的 ACK，CongWin的值增加一个MSS。</p>\n<p> 最终，当对丢失的报文段的一个ACK到达时，TCP在降低 CongWin后进 入拥塞避免状态。</p>\n<p> 如果出现超时事件，迁移到慢启动状态: CongWin值设置为1 MSS Ssthresh= CongWin /2</p>\n<p>ssthresh ：阈值    crmd：最大窗口 </p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/558c8514b15f21cc581efcbda9f0c647.png\" alt=\"\"></p>\n<p> <img src=\"https://img.cetacis.dev/uploads/big/3f17b94d3ab78d0ef84d262f45323c8f.png\" alt=\"\"></p>\n<p>reno：有快速恢复   tahoe：无快速恢复 如图</p>\n<h4 id=\"2-总结\"><a href=\"#2-总结\" class=\"headerlink\" title=\"2. 总结\"></a>2. 总结</h4><p>当CongWin &lt; ssthresh时，发送者处于慢启动阶段, CongWin指数增长</p>\n<p>当CongWin &gt; ssthresh时，发送者处于拥塞避免阶段, CongWin线性增长</p>\n<p>当出现3个冗余确认时,发送者处于快速恢复阶段。阈值ssthresh设置为 CongWin/2，且CongWin设置为ssthresh+3*MSS</p>\n<p>当超时发生时，阈值ssthresh设置为CongWin/2，并且CongWin设置为1 MSS.</p>\n<p>TCP AIMD （加性增 乘性减）</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/ec1154af7b0e07c03914e08cb42a7e00.png\" alt=\"\"></p>\n<h4 id=\"tcp平均吞吐量\"><a href=\"#tcp平均吞吐量\" class=\"headerlink\" title=\"tcp平均吞吐量\"></a>tcp平均吞吐量</h4><p>估算： 0.75w / rtt</p>\n<h4 id=\"3-ECN-网络辅助拥塞控制\"><a href=\"#3-ECN-网络辅助拥塞控制\" class=\"headerlink\" title=\"3. ECN 网络辅助拥塞控制\"></a>3. ECN 网络辅助拥塞控制</h4><p>在网络层 ，IP 数据报首部的服务类型字段中的两个比特被用于ECN。</p>\n<p>路由器所使用的一种 ECN 比特设置指示该路由器正在历经拥塞 。 该拥塞指示则由被标记的IP数据报所携带， 送给目的主机 。</p>\n<p>再由目的主机通知发送主机（TCP ACK segment）</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/02ca99f8d0957dfe1f01a2068e942653.png\" alt=\"\"></p>\n<p>tcp发送方会减半拥塞窗口，并且将报文段首部中对cwr（拥塞窗口缩减）进行设置。</p>\n<h1 id=\"实验：\"><a href=\"#实验：\" class=\"headerlink\" title=\"实验：\"></a>实验：</h1><p><img src=\"https://img.cetacis.dev/uploads/big/37d074f219036e3c5770d8f7505b53ca.png\" alt=\"\"></p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/db92a4e4bedcab79b59fa577b74c9a2e.png\" alt=\"\"></p>\n<p>b) 检测客户是否在线</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/c157d44a236d7c0db05060b319fca1bc.png\" alt=\"实验要点\"></p>\n<p>PDU JSON-RPC</p>"},{"_content":"# 操作系統-4-存儲器管理\n\n## 4.1 存儲器\n\n### 4.1.1 硬件\n\n内存：Cpu  存儲器\n\n外存：视频控制器 键盘控制器 usb控制器 硬盘控制器\n\ncpu <--->存儲器 <--->外存\n\n### 4.1.2 层次机构\n\n寄存器  \n\n \t|\n\n高速缓存     < --- cpu访问 主存儲器比寄存器慢，所以需要緩存\n\n​\t |\n\n主存储器 \n\n​\t  |\n\n磁盘缓存  固存移動比主存慢，因此需要緩存\n\n​\t  | \n\n固定磁盘（外存）\n\n​\t  |\n\n可移动存储介质（U盘 移动硬盘 磁带机） 優點：容量大 缺點：速度慢\n<!-- more -->\n* 高速缓存介于寄存器和主存器之间的存储器，主要用于备份主存中较常用的指 令和数据，以减少对主存器的访问次数。\n\n- 高速缓存的访问比寄存器慢，但其访问速度却远快于主存。容量也介于二者之 间。高速缓存的有效性是建立在“程序局部性原理”基础上。\n  * 程序局部性原理：一條指令可能多次執行；程序運行一條接一條，具有局部性特征。\n- 由于磁盘I/O速度远低于主存，因此设置了磁盘缓存，主要用于暂时存放频繁 使用的一部分磁盘数据\n\n#### 4.2  程序的裝入和鏈接\n\n* 如何将一个用户源程序变成一个可在内存中执行的程序，通常要经过3步骤:\n\n1. 编译:由编译程序(Compiler)将用户源代码编译成若个目标模块 。\n\n2. 链接:由链接程序(Linker)将编译后形成的一组目标模块，以及它们所需 要的库函数链接在一起，形成一个完整的装入模块 。\n\n3. 装入:由装入程序(Loader)将装入模块装入内存。\n\n#### 4.2.1 程序的裝入\n\n(1) ***绝对装入方式*** \n\n如果知道程序将驻留在内存的什么位置，那么，编译程序将产生绝对地址的目标代码。\n\n绝对装入程序按照装入模块中的地址，将程序和数据装入内存。装入模块 被装入内存后，由于程序中的逻辑地址与实际内存地址完全相同，故不需对 程序和数据的地址进行修改。\n\n(2) ***可重定位装入方式***\n\n把在装入时对目标程序中指令和数据的变换过程称为重定位。\n\n采用静态重定位方法将程序装入内存,称为可重定位装入方式。\n\n因为地址变换是在装入时一次完成的，以后不再改变，故称为静态重定位。\n\n(3)***动态运行时装入方式*** \n\n装入程序将目标模块装入内存后，并不立即把装入模块中的相对地址转换为 绝对地址，而是把这种地址转换推迟到程序执行时进行，在硬件地址变换机构 的支持下，随着对每条指令或数据的访问自动进行地址变换，故称为动态重定 位。\n\n采用动态重定位方法将程序装入内存，称为动态运行时装入方式 。\n\n![](https://img.cetacis.dev/uploads/big/ff19d327ad7da5a5f878f546038c8ba5.png)\n\n### 4.2.2 程序的鏈接 \n\n鏈接時間：（1）先鏈接再裝入 （2）先裝入再鏈接\n\n(1)、静态链接方式。\n\n在程序运行之前，先将各目标模块及它们所需的库函数， 链接成一个完整的装配模块(又称执行模块)，以后不再拆开。我们把这种事 先进行链接的方式称为静态链接方式。\n\n(2)、装入时动态链接程序的链接\n\n是指将用户源程序编译后所得到的一组目标模块，在装入内存时，采用边 装入边链接的链接方式。即分别装入各模块，并且在装入的过程中修改相对地 址和外部引用地址。\n\n優點：\n\n1. 便于修改和更新\n\n   若采用动态链接方式，由于各目标模块是分开存放的，所以要修改或更新各目 标模块，是件非常容易的事。\n\n2. 便于实现对目标模块的共享\n\n   采用装入时动态链接方式时，OS则很容易将一个目标模块链接到几个应用模 块上，实现多个应用程序对该模块的共享。\n\n(3)、运行时动态链接 \n\n各模块被独立装入系统，而且也不进行链接，运行时发现引用的地址是相对地址或者外部地址时，才发起链接，寻找正确的引用地址。\n\n优点:凡在执行过程中未被用到的目标模块，都不会被调入内存和被链接到 装入模块上，这样不仅可加快程序的装入过程，而且可节省大量的内存空间。\n\n*该方法是目前最常使用的链接方式。*\n\n## 4.3 連續分配方式\n\n- 连续分配方式，是指为一个用户程序分配一个连续的内存空间。\n- 连续分配方式有四种:\n  1. 单一连续分配\n  2. 固定分区分配\n  3. 动态分区分配\n  4. 动态重定位分区分配\n\n### 4.2.1 單一連續分配\n\n它规定整个内存的用户区中只驻留一 个用户的一个程序，因此该方式只适用于单用户、单任务的操作系统。\n\n为了防止OS的代码和数据被用户进程所破坏，把内存分为系统区和用户区 两部分:\n\n1. 系统区:仅提供给0S使用，通常是放在内存的低址部分;\n2. 用户区:是指除系统区以外的全部内存空间，提供给唯一的用户使用，存放用户程序和数据。\n\n优缺点:简单、内存利用率低。\n\n### 4.2.2 分區管理 - 固定分區分配\n\n固定分区分配思想:将内存用户空间划分为若干个固定大小的区域，每个区域 称为一个分区(region)，在每个分区中只装入一道作业 ，从而支持多道程序 并发设计。\n\n#### **分区大小**\n\n1. 分区大小相等。当程序太小时，会造成内存空间的浪费 。当程序太大时，一个分区又不足以装入该程序，致使该程序无法运行。\n\n2. 分区大小不等。可把内存区划成含有多个较小的分区、适量的中等分区及 少量的大分区。\n\n#### 分區分配：固定分區分配\n\n 当有作业要装入内存时，内存分配程序检索分区描述表，从中找出尚未使 用的最接近大小的分区分配给该作业，然后修改分区的状态;如果找不到合适 的分区就拒绝为该作业分配内存。当程序运行完成时，系统回收内存资源，并修改分区描述表中分区的状态。\n\n優缺點：\n\n最早的可运行多道程序的存储管理方式 。 \n\n存在“内零头”会造成存储空间的浪费。\n\n* 内零头——在分区内没有利用的部分称为内零头。\n\n#### 分區分配：動態分區方式\n\n动态分区分配思想:分区数量和大小都不固定，根据进程的实际需要，动态地 为之分配内存空间。\n\n(1)分区分配数据结构 记录系统中各空闲分区的情况，以便分配时能找到可以分配的空间。\n\n1. 空闲分区表。在系统中设置一张空闲分区表，用于记录每个空闲分区的情 况(包含空闲分区号、分区大小、起始地址)。\n\n2. 空闲分区链表。为了实现对空闲分区的分配和链接，设置前向指针和后向 指针，通过前、后向链接指针将所有的空闲分区链接成一个双向链。\n\n![空閒分區鏈錶](https://img.cetacis.dev/uploads/big/434e0854f453f3189fa76563a284226b.png)","source":"_posts/操作系統-4-存儲器管理.md","raw":"# 操作系統-4-存儲器管理\n\n## 4.1 存儲器\n\n### 4.1.1 硬件\n\n内存：Cpu  存儲器\n\n外存：视频控制器 键盘控制器 usb控制器 硬盘控制器\n\ncpu <--->存儲器 <--->外存\n\n### 4.1.2 层次机构\n\n寄存器  \n\n \t|\n\n高速缓存     < --- cpu访问 主存儲器比寄存器慢，所以需要緩存\n\n​\t |\n\n主存储器 \n\n​\t  |\n\n磁盘缓存  固存移動比主存慢，因此需要緩存\n\n​\t  | \n\n固定磁盘（外存）\n\n​\t  |\n\n可移动存储介质（U盘 移动硬盘 磁带机） 優點：容量大 缺點：速度慢\n<!-- more -->\n* 高速缓存介于寄存器和主存器之间的存储器，主要用于备份主存中较常用的指 令和数据，以减少对主存器的访问次数。\n\n- 高速缓存的访问比寄存器慢，但其访问速度却远快于主存。容量也介于二者之 间。高速缓存的有效性是建立在“程序局部性原理”基础上。\n  * 程序局部性原理：一條指令可能多次執行；程序運行一條接一條，具有局部性特征。\n- 由于磁盘I/O速度远低于主存，因此设置了磁盘缓存，主要用于暂时存放频繁 使用的一部分磁盘数据\n\n#### 4.2  程序的裝入和鏈接\n\n* 如何将一个用户源程序变成一个可在内存中执行的程序，通常要经过3步骤:\n\n1. 编译:由编译程序(Compiler)将用户源代码编译成若个目标模块 。\n\n2. 链接:由链接程序(Linker)将编译后形成的一组目标模块，以及它们所需 要的库函数链接在一起，形成一个完整的装入模块 。\n\n3. 装入:由装入程序(Loader)将装入模块装入内存。\n\n#### 4.2.1 程序的裝入\n\n(1) ***绝对装入方式*** \n\n如果知道程序将驻留在内存的什么位置，那么，编译程序将产生绝对地址的目标代码。\n\n绝对装入程序按照装入模块中的地址，将程序和数据装入内存。装入模块 被装入内存后，由于程序中的逻辑地址与实际内存地址完全相同，故不需对 程序和数据的地址进行修改。\n\n(2) ***可重定位装入方式***\n\n把在装入时对目标程序中指令和数据的变换过程称为重定位。\n\n采用静态重定位方法将程序装入内存,称为可重定位装入方式。\n\n因为地址变换是在装入时一次完成的，以后不再改变，故称为静态重定位。\n\n(3)***动态运行时装入方式*** \n\n装入程序将目标模块装入内存后，并不立即把装入模块中的相对地址转换为 绝对地址，而是把这种地址转换推迟到程序执行时进行，在硬件地址变换机构 的支持下，随着对每条指令或数据的访问自动进行地址变换，故称为动态重定 位。\n\n采用动态重定位方法将程序装入内存，称为动态运行时装入方式 。\n\n![](https://img.cetacis.dev/uploads/big/ff19d327ad7da5a5f878f546038c8ba5.png)\n\n### 4.2.2 程序的鏈接 \n\n鏈接時間：（1）先鏈接再裝入 （2）先裝入再鏈接\n\n(1)、静态链接方式。\n\n在程序运行之前，先将各目标模块及它们所需的库函数， 链接成一个完整的装配模块(又称执行模块)，以后不再拆开。我们把这种事 先进行链接的方式称为静态链接方式。\n\n(2)、装入时动态链接程序的链接\n\n是指将用户源程序编译后所得到的一组目标模块，在装入内存时，采用边 装入边链接的链接方式。即分别装入各模块，并且在装入的过程中修改相对地 址和外部引用地址。\n\n優點：\n\n1. 便于修改和更新\n\n   若采用动态链接方式，由于各目标模块是分开存放的，所以要修改或更新各目 标模块，是件非常容易的事。\n\n2. 便于实现对目标模块的共享\n\n   采用装入时动态链接方式时，OS则很容易将一个目标模块链接到几个应用模 块上，实现多个应用程序对该模块的共享。\n\n(3)、运行时动态链接 \n\n各模块被独立装入系统，而且也不进行链接，运行时发现引用的地址是相对地址或者外部地址时，才发起链接，寻找正确的引用地址。\n\n优点:凡在执行过程中未被用到的目标模块，都不会被调入内存和被链接到 装入模块上，这样不仅可加快程序的装入过程，而且可节省大量的内存空间。\n\n*该方法是目前最常使用的链接方式。*\n\n## 4.3 連續分配方式\n\n- 连续分配方式，是指为一个用户程序分配一个连续的内存空间。\n- 连续分配方式有四种:\n  1. 单一连续分配\n  2. 固定分区分配\n  3. 动态分区分配\n  4. 动态重定位分区分配\n\n### 4.2.1 單一連續分配\n\n它规定整个内存的用户区中只驻留一 个用户的一个程序，因此该方式只适用于单用户、单任务的操作系统。\n\n为了防止OS的代码和数据被用户进程所破坏，把内存分为系统区和用户区 两部分:\n\n1. 系统区:仅提供给0S使用，通常是放在内存的低址部分;\n2. 用户区:是指除系统区以外的全部内存空间，提供给唯一的用户使用，存放用户程序和数据。\n\n优缺点:简单、内存利用率低。\n\n### 4.2.2 分區管理 - 固定分區分配\n\n固定分区分配思想:将内存用户空间划分为若干个固定大小的区域，每个区域 称为一个分区(region)，在每个分区中只装入一道作业 ，从而支持多道程序 并发设计。\n\n#### **分区大小**\n\n1. 分区大小相等。当程序太小时，会造成内存空间的浪费 。当程序太大时，一个分区又不足以装入该程序，致使该程序无法运行。\n\n2. 分区大小不等。可把内存区划成含有多个较小的分区、适量的中等分区及 少量的大分区。\n\n#### 分區分配：固定分區分配\n\n 当有作业要装入内存时，内存分配程序检索分区描述表，从中找出尚未使 用的最接近大小的分区分配给该作业，然后修改分区的状态;如果找不到合适 的分区就拒绝为该作业分配内存。当程序运行完成时，系统回收内存资源，并修改分区描述表中分区的状态。\n\n優缺點：\n\n最早的可运行多道程序的存储管理方式 。 \n\n存在“内零头”会造成存储空间的浪费。\n\n* 内零头——在分区内没有利用的部分称为内零头。\n\n#### 分區分配：動態分區方式\n\n动态分区分配思想:分区数量和大小都不固定，根据进程的实际需要，动态地 为之分配内存空间。\n\n(1)分区分配数据结构 记录系统中各空闲分区的情况，以便分配时能找到可以分配的空间。\n\n1. 空闲分区表。在系统中设置一张空闲分区表，用于记录每个空闲分区的情 况(包含空闲分区号、分区大小、起始地址)。\n\n2. 空闲分区链表。为了实现对空闲分区的分配和链接，设置前向指针和后向 指针，通过前、后向链接指针将所有的空闲分区链接成一个双向链。\n\n![空閒分區鏈錶](https://img.cetacis.dev/uploads/big/434e0854f453f3189fa76563a284226b.png)","slug":"操作系統-4-存儲器管理","published":1,"date":"2020-04-09T15:38:03.311Z","updated":"2020-04-09T15:36:11.000Z","title":"操作系統-4-存儲器管理","comments":1,"layout":"post","photos":[],"link":"","_id":"ck985a86c0011slqg816ogxgd","content":"<h1 id=\"操作系統-4-存儲器管理\"><a href=\"#操作系統-4-存儲器管理\" class=\"headerlink\" title=\"操作系統-4-存儲器管理\"></a>操作系統-4-存儲器管理</h1><h2 id=\"4-1-存儲器\"><a href=\"#4-1-存儲器\" class=\"headerlink\" title=\"4.1 存儲器\"></a>4.1 存儲器</h2><h3 id=\"4-1-1-硬件\"><a href=\"#4-1-1-硬件\" class=\"headerlink\" title=\"4.1.1 硬件\"></a>4.1.1 硬件</h3><p>内存：Cpu  存儲器</p>\n<p>外存：视频控制器 键盘控制器 usb控制器 硬盘控制器</p>\n<p>cpu &lt;—&gt;存儲器 &lt;—&gt;外存</p>\n<h3 id=\"4-1-2-层次机构\"><a href=\"#4-1-2-层次机构\" class=\"headerlink\" title=\"4.1.2 层次机构\"></a>4.1.2 层次机构</h3><p>寄存器  </p>\n<pre><code>|</code></pre><p>高速缓存     &lt; — cpu访问 主存儲器比寄存器慢，所以需要緩存</p>\n<p>​     |</p>\n<p>主存储器 </p>\n<p>​      |</p>\n<p>磁盘缓存  固存移動比主存慢，因此需要緩存</p>\n<p>​      | </p>\n<p>固定磁盘（外存）</p>\n<p>​      |</p>\n<p>可移动存储介质（U盘 移动硬盘 磁带机） 優點：容量大 缺點：速度慢</p>\n<a id=\"more\"></a>\n<ul>\n<li>高速缓存介于寄存器和主存器之间的存储器，主要用于备份主存中较常用的指 令和数据，以减少对主存器的访问次数。</li>\n</ul>\n<ul>\n<li>高速缓存的访问比寄存器慢，但其访问速度却远快于主存。容量也介于二者之 间。高速缓存的有效性是建立在“程序局部性原理”基础上。<ul>\n<li>程序局部性原理：一條指令可能多次執行；程序運行一條接一條，具有局部性特征。</li>\n</ul>\n</li>\n<li>由于磁盘I/O速度远低于主存，因此设置了磁盘缓存，主要用于暂时存放频繁 使用的一部分磁盘数据</li>\n</ul>\n<h4 id=\"4-2-程序的裝入和鏈接\"><a href=\"#4-2-程序的裝入和鏈接\" class=\"headerlink\" title=\"4.2  程序的裝入和鏈接\"></a>4.2  程序的裝入和鏈接</h4><ul>\n<li>如何将一个用户源程序变成一个可在内存中执行的程序，通常要经过3步骤:</li>\n</ul>\n<ol>\n<li><p>编译:由编译程序(Compiler)将用户源代码编译成若个目标模块 。</p>\n</li>\n<li><p>链接:由链接程序(Linker)将编译后形成的一组目标模块，以及它们所需 要的库函数链接在一起，形成一个完整的装入模块 。</p>\n</li>\n<li><p>装入:由装入程序(Loader)将装入模块装入内存。</p>\n</li>\n</ol>\n<h4 id=\"4-2-1-程序的裝入\"><a href=\"#4-2-1-程序的裝入\" class=\"headerlink\" title=\"4.2.1 程序的裝入\"></a>4.2.1 程序的裝入</h4><p>(1) <strong><em>绝对装入方式</em></strong> </p>\n<p>如果知道程序将驻留在内存的什么位置，那么，编译程序将产生绝对地址的目标代码。</p>\n<p>绝对装入程序按照装入模块中的地址，将程序和数据装入内存。装入模块 被装入内存后，由于程序中的逻辑地址与实际内存地址完全相同，故不需对 程序和数据的地址进行修改。</p>\n<p>(2) <strong><em>可重定位装入方式</em></strong></p>\n<p>把在装入时对目标程序中指令和数据的变换过程称为重定位。</p>\n<p>采用静态重定位方法将程序装入内存,称为可重定位装入方式。</p>\n<p>因为地址变换是在装入时一次完成的，以后不再改变，故称为静态重定位。</p>\n<p>(3)<strong><em>动态运行时装入方式</em></strong> </p>\n<p>装入程序将目标模块装入内存后，并不立即把装入模块中的相对地址转换为 绝对地址，而是把这种地址转换推迟到程序执行时进行，在硬件地址变换机构 的支持下，随着对每条指令或数据的访问自动进行地址变换，故称为动态重定 位。</p>\n<p>采用动态重定位方法将程序装入内存，称为动态运行时装入方式 。</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/ff19d327ad7da5a5f878f546038c8ba5.png\" alt=\"\"></p>\n<h3 id=\"4-2-2-程序的鏈接\"><a href=\"#4-2-2-程序的鏈接\" class=\"headerlink\" title=\"4.2.2 程序的鏈接\"></a>4.2.2 程序的鏈接</h3><p>鏈接時間：（1）先鏈接再裝入 （2）先裝入再鏈接</p>\n<p>(1)、静态链接方式。</p>\n<p>在程序运行之前，先将各目标模块及它们所需的库函数， 链接成一个完整的装配模块(又称执行模块)，以后不再拆开。我们把这种事 先进行链接的方式称为静态链接方式。</p>\n<p>(2)、装入时动态链接程序的链接</p>\n<p>是指将用户源程序编译后所得到的一组目标模块，在装入内存时，采用边 装入边链接的链接方式。即分别装入各模块，并且在装入的过程中修改相对地 址和外部引用地址。</p>\n<p>優點：</p>\n<ol>\n<li><p>便于修改和更新</p>\n<p>若采用动态链接方式，由于各目标模块是分开存放的，所以要修改或更新各目 标模块，是件非常容易的事。</p>\n</li>\n<li><p>便于实现对目标模块的共享</p>\n<p>采用装入时动态链接方式时，OS则很容易将一个目标模块链接到几个应用模 块上，实现多个应用程序对该模块的共享。</p>\n</li>\n</ol>\n<p>(3)、运行时动态链接 </p>\n<p>各模块被独立装入系统，而且也不进行链接，运行时发现引用的地址是相对地址或者外部地址时，才发起链接，寻找正确的引用地址。</p>\n<p>优点:凡在执行过程中未被用到的目标模块，都不会被调入内存和被链接到 装入模块上，这样不仅可加快程序的装入过程，而且可节省大量的内存空间。</p>\n<p><em>该方法是目前最常使用的链接方式。</em></p>\n<h2 id=\"4-3-連續分配方式\"><a href=\"#4-3-連續分配方式\" class=\"headerlink\" title=\"4.3 連續分配方式\"></a>4.3 連續分配方式</h2><ul>\n<li>连续分配方式，是指为一个用户程序分配一个连续的内存空间。</li>\n<li>连续分配方式有四种:<ol>\n<li>单一连续分配</li>\n<li>固定分区分配</li>\n<li>动态分区分配</li>\n<li>动态重定位分区分配</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"4-2-1-單一連續分配\"><a href=\"#4-2-1-單一連續分配\" class=\"headerlink\" title=\"4.2.1 單一連續分配\"></a>4.2.1 單一連續分配</h3><p>它规定整个内存的用户区中只驻留一 个用户的一个程序，因此该方式只适用于单用户、单任务的操作系统。</p>\n<p>为了防止OS的代码和数据被用户进程所破坏，把内存分为系统区和用户区 两部分:</p>\n<ol>\n<li>系统区:仅提供给0S使用，通常是放在内存的低址部分;</li>\n<li>用户区:是指除系统区以外的全部内存空间，提供给唯一的用户使用，存放用户程序和数据。</li>\n</ol>\n<p>优缺点:简单、内存利用率低。</p>\n<h3 id=\"4-2-2-分區管理-固定分區分配\"><a href=\"#4-2-2-分區管理-固定分區分配\" class=\"headerlink\" title=\"4.2.2 分區管理 - 固定分區分配\"></a>4.2.2 分區管理 - 固定分區分配</h3><p>固定分区分配思想:将内存用户空间划分为若干个固定大小的区域，每个区域 称为一个分区(region)，在每个分区中只装入一道作业 ，从而支持多道程序 并发设计。</p>\n<h4 id=\"分区大小\"><a href=\"#分区大小\" class=\"headerlink\" title=\"分区大小\"></a><strong>分区大小</strong></h4><ol>\n<li><p>分区大小相等。当程序太小时，会造成内存空间的浪费 。当程序太大时，一个分区又不足以装入该程序，致使该程序无法运行。</p>\n</li>\n<li><p>分区大小不等。可把内存区划成含有多个较小的分区、适量的中等分区及 少量的大分区。</p>\n</li>\n</ol>\n<h4 id=\"分區分配：固定分區分配\"><a href=\"#分區分配：固定分區分配\" class=\"headerlink\" title=\"分區分配：固定分區分配\"></a>分區分配：固定分區分配</h4><p> 当有作业要装入内存时，内存分配程序检索分区描述表，从中找出尚未使 用的最接近大小的分区分配给该作业，然后修改分区的状态;如果找不到合适 的分区就拒绝为该作业分配内存。当程序运行完成时，系统回收内存资源，并修改分区描述表中分区的状态。</p>\n<p>優缺點：</p>\n<p>最早的可运行多道程序的存储管理方式 。 </p>\n<p>存在“内零头”会造成存储空间的浪费。</p>\n<ul>\n<li>内零头——在分区内没有利用的部分称为内零头。</li>\n</ul>\n<h4 id=\"分區分配：動態分區方式\"><a href=\"#分區分配：動態分區方式\" class=\"headerlink\" title=\"分區分配：動態分區方式\"></a>分區分配：動態分區方式</h4><p>动态分区分配思想:分区数量和大小都不固定，根据进程的实际需要，动态地 为之分配内存空间。</p>\n<p>(1)分区分配数据结构 记录系统中各空闲分区的情况，以便分配时能找到可以分配的空间。</p>\n<ol>\n<li><p>空闲分区表。在系统中设置一张空闲分区表，用于记录每个空闲分区的情 况(包含空闲分区号、分区大小、起始地址)。</p>\n</li>\n<li><p>空闲分区链表。为了实现对空闲分区的分配和链接，设置前向指针和后向 指针，通过前、后向链接指针将所有的空闲分区链接成一个双向链。</p>\n</li>\n</ol>\n<p><img src=\"https://img.cetacis.dev/uploads/big/434e0854f453f3189fa76563a284226b.png\" alt=\"空閒分區鏈錶\"></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"操作系統-4-存儲器管理\"><a href=\"#操作系統-4-存儲器管理\" class=\"headerlink\" title=\"操作系統-4-存儲器管理\"></a>操作系統-4-存儲器管理</h1><h2 id=\"4-1-存儲器\"><a href=\"#4-1-存儲器\" class=\"headerlink\" title=\"4.1 存儲器\"></a>4.1 存儲器</h2><h3 id=\"4-1-1-硬件\"><a href=\"#4-1-1-硬件\" class=\"headerlink\" title=\"4.1.1 硬件\"></a>4.1.1 硬件</h3><p>内存：Cpu  存儲器</p>\n<p>外存：视频控制器 键盘控制器 usb控制器 硬盘控制器</p>\n<p>cpu &lt;—&gt;存儲器 &lt;—&gt;外存</p>\n<h3 id=\"4-1-2-层次机构\"><a href=\"#4-1-2-层次机构\" class=\"headerlink\" title=\"4.1.2 层次机构\"></a>4.1.2 层次机构</h3><p>寄存器  </p>\n<pre><code>|</code></pre><p>高速缓存     &lt; — cpu访问 主存儲器比寄存器慢，所以需要緩存</p>\n<p>​     |</p>\n<p>主存储器 </p>\n<p>​      |</p>\n<p>磁盘缓存  固存移動比主存慢，因此需要緩存</p>\n<p>​      | </p>\n<p>固定磁盘（外存）</p>\n<p>​      |</p>\n<p>可移动存储介质（U盘 移动硬盘 磁带机） 優點：容量大 缺點：速度慢</p>","more":"<ul>\n<li>高速缓存介于寄存器和主存器之间的存储器，主要用于备份主存中较常用的指 令和数据，以减少对主存器的访问次数。</li>\n</ul>\n<ul>\n<li>高速缓存的访问比寄存器慢，但其访问速度却远快于主存。容量也介于二者之 间。高速缓存的有效性是建立在“程序局部性原理”基础上。<ul>\n<li>程序局部性原理：一條指令可能多次執行；程序運行一條接一條，具有局部性特征。</li>\n</ul>\n</li>\n<li>由于磁盘I/O速度远低于主存，因此设置了磁盘缓存，主要用于暂时存放频繁 使用的一部分磁盘数据</li>\n</ul>\n<h4 id=\"4-2-程序的裝入和鏈接\"><a href=\"#4-2-程序的裝入和鏈接\" class=\"headerlink\" title=\"4.2  程序的裝入和鏈接\"></a>4.2  程序的裝入和鏈接</h4><ul>\n<li>如何将一个用户源程序变成一个可在内存中执行的程序，通常要经过3步骤:</li>\n</ul>\n<ol>\n<li><p>编译:由编译程序(Compiler)将用户源代码编译成若个目标模块 。</p>\n</li>\n<li><p>链接:由链接程序(Linker)将编译后形成的一组目标模块，以及它们所需 要的库函数链接在一起，形成一个完整的装入模块 。</p>\n</li>\n<li><p>装入:由装入程序(Loader)将装入模块装入内存。</p>\n</li>\n</ol>\n<h4 id=\"4-2-1-程序的裝入\"><a href=\"#4-2-1-程序的裝入\" class=\"headerlink\" title=\"4.2.1 程序的裝入\"></a>4.2.1 程序的裝入</h4><p>(1) <strong><em>绝对装入方式</em></strong> </p>\n<p>如果知道程序将驻留在内存的什么位置，那么，编译程序将产生绝对地址的目标代码。</p>\n<p>绝对装入程序按照装入模块中的地址，将程序和数据装入内存。装入模块 被装入内存后，由于程序中的逻辑地址与实际内存地址完全相同，故不需对 程序和数据的地址进行修改。</p>\n<p>(2) <strong><em>可重定位装入方式</em></strong></p>\n<p>把在装入时对目标程序中指令和数据的变换过程称为重定位。</p>\n<p>采用静态重定位方法将程序装入内存,称为可重定位装入方式。</p>\n<p>因为地址变换是在装入时一次完成的，以后不再改变，故称为静态重定位。</p>\n<p>(3)<strong><em>动态运行时装入方式</em></strong> </p>\n<p>装入程序将目标模块装入内存后，并不立即把装入模块中的相对地址转换为 绝对地址，而是把这种地址转换推迟到程序执行时进行，在硬件地址变换机构 的支持下，随着对每条指令或数据的访问自动进行地址变换，故称为动态重定 位。</p>\n<p>采用动态重定位方法将程序装入内存，称为动态运行时装入方式 。</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/ff19d327ad7da5a5f878f546038c8ba5.png\" alt=\"\"></p>\n<h3 id=\"4-2-2-程序的鏈接\"><a href=\"#4-2-2-程序的鏈接\" class=\"headerlink\" title=\"4.2.2 程序的鏈接\"></a>4.2.2 程序的鏈接</h3><p>鏈接時間：（1）先鏈接再裝入 （2）先裝入再鏈接</p>\n<p>(1)、静态链接方式。</p>\n<p>在程序运行之前，先将各目标模块及它们所需的库函数， 链接成一个完整的装配模块(又称执行模块)，以后不再拆开。我们把这种事 先进行链接的方式称为静态链接方式。</p>\n<p>(2)、装入时动态链接程序的链接</p>\n<p>是指将用户源程序编译后所得到的一组目标模块，在装入内存时，采用边 装入边链接的链接方式。即分别装入各模块，并且在装入的过程中修改相对地 址和外部引用地址。</p>\n<p>優點：</p>\n<ol>\n<li><p>便于修改和更新</p>\n<p>若采用动态链接方式，由于各目标模块是分开存放的，所以要修改或更新各目 标模块，是件非常容易的事。</p>\n</li>\n<li><p>便于实现对目标模块的共享</p>\n<p>采用装入时动态链接方式时，OS则很容易将一个目标模块链接到几个应用模 块上，实现多个应用程序对该模块的共享。</p>\n</li>\n</ol>\n<p>(3)、运行时动态链接 </p>\n<p>各模块被独立装入系统，而且也不进行链接，运行时发现引用的地址是相对地址或者外部地址时，才发起链接，寻找正确的引用地址。</p>\n<p>优点:凡在执行过程中未被用到的目标模块，都不会被调入内存和被链接到 装入模块上，这样不仅可加快程序的装入过程，而且可节省大量的内存空间。</p>\n<p><em>该方法是目前最常使用的链接方式。</em></p>\n<h2 id=\"4-3-連續分配方式\"><a href=\"#4-3-連續分配方式\" class=\"headerlink\" title=\"4.3 連續分配方式\"></a>4.3 連續分配方式</h2><ul>\n<li>连续分配方式，是指为一个用户程序分配一个连续的内存空间。</li>\n<li>连续分配方式有四种:<ol>\n<li>单一连续分配</li>\n<li>固定分区分配</li>\n<li>动态分区分配</li>\n<li>动态重定位分区分配</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"4-2-1-單一連續分配\"><a href=\"#4-2-1-單一連續分配\" class=\"headerlink\" title=\"4.2.1 單一連續分配\"></a>4.2.1 單一連續分配</h3><p>它规定整个内存的用户区中只驻留一 个用户的一个程序，因此该方式只适用于单用户、单任务的操作系统。</p>\n<p>为了防止OS的代码和数据被用户进程所破坏，把内存分为系统区和用户区 两部分:</p>\n<ol>\n<li>系统区:仅提供给0S使用，通常是放在内存的低址部分;</li>\n<li>用户区:是指除系统区以外的全部内存空间，提供给唯一的用户使用，存放用户程序和数据。</li>\n</ol>\n<p>优缺点:简单、内存利用率低。</p>\n<h3 id=\"4-2-2-分區管理-固定分區分配\"><a href=\"#4-2-2-分區管理-固定分區分配\" class=\"headerlink\" title=\"4.2.2 分區管理 - 固定分區分配\"></a>4.2.2 分區管理 - 固定分區分配</h3><p>固定分区分配思想:将内存用户空间划分为若干个固定大小的区域，每个区域 称为一个分区(region)，在每个分区中只装入一道作业 ，从而支持多道程序 并发设计。</p>\n<h4 id=\"分区大小\"><a href=\"#分区大小\" class=\"headerlink\" title=\"分区大小\"></a><strong>分区大小</strong></h4><ol>\n<li><p>分区大小相等。当程序太小时，会造成内存空间的浪费 。当程序太大时，一个分区又不足以装入该程序，致使该程序无法运行。</p>\n</li>\n<li><p>分区大小不等。可把内存区划成含有多个较小的分区、适量的中等分区及 少量的大分区。</p>\n</li>\n</ol>\n<h4 id=\"分區分配：固定分區分配\"><a href=\"#分區分配：固定分區分配\" class=\"headerlink\" title=\"分區分配：固定分區分配\"></a>分區分配：固定分區分配</h4><p> 当有作业要装入内存时，内存分配程序检索分区描述表，从中找出尚未使 用的最接近大小的分区分配给该作业，然后修改分区的状态;如果找不到合适 的分区就拒绝为该作业分配内存。当程序运行完成时，系统回收内存资源，并修改分区描述表中分区的状态。</p>\n<p>優缺點：</p>\n<p>最早的可运行多道程序的存储管理方式 。 </p>\n<p>存在“内零头”会造成存储空间的浪费。</p>\n<ul>\n<li>内零头——在分区内没有利用的部分称为内零头。</li>\n</ul>\n<h4 id=\"分區分配：動態分區方式\"><a href=\"#分區分配：動態分區方式\" class=\"headerlink\" title=\"分區分配：動態分區方式\"></a>分區分配：動態分區方式</h4><p>动态分区分配思想:分区数量和大小都不固定，根据进程的实际需要，动态地 为之分配内存空间。</p>\n<p>(1)分区分配数据结构 记录系统中各空闲分区的情况，以便分配时能找到可以分配的空间。</p>\n<ol>\n<li><p>空闲分区表。在系统中设置一张空闲分区表，用于记录每个空闲分区的情 况(包含空闲分区号、分区大小、起始地址)。</p>\n</li>\n<li><p>空闲分区链表。为了实现对空闲分区的分配和链接，设置前向指针和后向 指针，通过前、后向链接指针将所有的空闲分区链接成一个双向链。</p>\n</li>\n</ol>\n<p><img src=\"https://img.cetacis.dev/uploads/big/434e0854f453f3189fa76563a284226b.png\" alt=\"空閒分區鏈錶\"></p>"},{"date":"2020-02-04T16:00:00.000Z","_content":"## 1. 终端压缩\n\n1. 第一种压缩方式\n\n   * **tar - 归档命令** \n\n     多文件归档：    tar  [参数]  打包文件名  文件1 文件2\n\n     目录归档：      tar  [参数]  打包文件名  目录\n\n     -c\t生成档案文件，创建打包文件\n\n     -v\t列出归档解档的详细过程，显示进度\n\n     -f\t指定档案文件名称，f后面一定是.tar文件，**所以必须放选项最后**\n\n     -t\t列出档案中包含的文件\n\n     -x\t解开档案文件\n<!-- more -->\n     ```\n     tar -cvf test.tar * # 将当前目录下的所有文件打包归档\n     \n     tar -xvf test.tar # 将tar文件解开\n     ```\n\n   * **gzip - 文件压缩解压**\n\n     tar和gzip结合实现文件打包、压缩。扩展名一般为XXX.tar.gz\n\n     ```\n     gzip  [选项]  被压缩文件\n     \n     gzip xx.tar        压缩\n     \n     gzip -r xx.tar xx.tar.gz  压缩这个文件的所有子目录，不包括这个文件\n     \n     gzip -d xx.tar.gz  解压\n     ```\n\n   * **tar -z**\n\n     ```\n     tar zcvf 压缩包包名 文件1 文件2 ...\n     \n     -z ：指定压缩包的格式为：file.tar.gz\n     \n     tar -zcvf test.tar.gz * 将当前路径下所有的文件以及文件夹打包并压缩到test.tar.gz中。\n     \n     tar -zxvf test.tar.gz解压到当前路径下\n     \n     tar -zxvf test.tar.gz -C xx 解压到指定路径下。\n     ```\n2. 第二种压缩方式\n    * **bzip2**\n    \n        压缩: \n    \n        ```\n        bzip2 filename ---> 删除filename文件，生成 filename.bz2\n        ```\n\n        解压缩：\n    \n        ```\n        bzip2 -d filename.bz2 ---> 删除filename.bz2 ，生成 filename文件\n        ```\n    \n    * **tar + bzip2**（tar -jcvf）\n    \n        扩展名：XXX.tar.gz2\n    \n        压缩：\n    \n        ```\n        tar -jcvf 压缩包包名 文件...(tar jcvf bk.tar.bz2 *)\n        ```\n    \n        解压缩：\n    \n        ```\n        tar -jxvf 压缩包包名 (tar jxvf bk.tar.bz2)\n        ```\n    \n        *注意：上述方式压缩后保留源文件，解压后保留压缩文件*\n\n3. 第三种压缩方式\n\n   * **zip**\n\n     压缩：\n\n     ```\n     zip [-r] 目标文件(可以没有扩展名) 源文件\n     \n     zip myzip *\n     ```\n\n     解压缩：\n\n     ```\n     unzip -d 解压后目录文件 压缩文件\n     \n     unzip -d ./xx myzip.zip\n     ```\n\n     *注意：不需要指定扩展名。默认zip*\n\n4. 三种比较\n\n   gzip压缩最小，bzip居中，zip最大\n\n5. 解压 x\n\n## 2. 文章权限\n\n1. 权限表示\n\n![文章权限](https://img.cetacis.dev/uploads/2020/02/05/Screen-Shot-2020-02-05-at-3.01.40-PM.png)\n\nr（可读）、w（可写）、x（可执行）\n\n2. 修改权限**chmod**\n\n   * 字母修改\n\n     ```\n     chmod u=rwx,g=rx,o=r filename\n     ```\n\n   * 数字修改\n\n     ```\n     chmod 751 filename\n     ```\n\n3. **-R**递归为目录下所有文件加权限\n\n   ```\n   chmod 777 test/ -R \n   ```\n\n## 3. 流\n\n1. Linux有三种流\n\n   * 标准输出流：正常信息的输出，默认输出到屏幕上。\n\n     标准错误输出流：错误的信息的输出，默认输出到屏幕上。\n\n     标准输入流：向系统中输入数据，默认就是键盘输入的数据。\n\n   * 我们可以通过重定向的技术，把输出、输入的信息重定向到其它的地方去。比如，我们可以把系统中的错误信息输出到一个文件中去。\n\n   * 如：ls > test.txt ( test.txt 如果不存在，则创建，存在则覆盖其内容 )\n\n     *注意:>是覆盖原来的内容，>>是添加内容。（这是重定向）*\n\n2. 管道\n\n   左边是写入信息，右边是读取左边的结果作为输入。\n\n## 4. 链接文件 ln\n\n1. 硬链接\n\n   文件有一个或者多个文件名。\n\n   ```\n   ln 源文件 链接文件\n   ```\n\n2. 软链接\n\n   软链接不占用磁盘空间，源文件删除则软连接就会失效。相当于重命名。\n\n   ```\n   ln -s 源文件 链接文件\n   ```\n\n3. 关系\n\n   * 软链接和硬链接都可以修改源文件内容，删除源文件后，硬链接仍然可以访问，软连接不可以，删除软连接就相当于删除了快捷方式，对源文件没有影响。\n   * 软链接可以跨文件系统，硬链接不可以;\n   * 软链接可以对一个不存在的文件名(filename)进行链接(当然此时如果你vi这个软链接文件，linux会自动新建一个文件名为filename的文件),硬链接不可以(其文件必须存在，inode必须存在);\n   * 软链接可以对目录进行连接，硬链接不可以\n\n## 5. 文件内容搜索 grep\n\n1. 一般格式\n\n   ```\n   grep [-选项] ‘搜索内容串’ 文件名（是对文件内容的搜索）\n   ```\n\n2. 选项\n\n   -V 显示不包含文本的所有行 -n 显示匹配行以及行号 -i 忽略大小写进行搜索\n\n3. 正则表达式\n\n   ^a 搜寻以a开头的行。\n\n    ke$搜索以Ke结束的行。\n\n   [Ss]nal[Ll]匹配[]中的任意一个。\n\n   \".\"匹配一个非换行符的字符。\n\n## 6. 特定文件搜索 find\n\n搜索符合条件的文件，搜索特定用户属主的文件。\n\n![find](https://img.cetacis.dev/uploads/2020/02/05/find.png)\n\n## 7. 特定命令搜索 which is\n\n```\nwhich is gcc\n```\n\n## 8. 用户管理\n\n1. 切换到管理员账号 sudo -s $显示为普通用户 #显示为管理员用户\n\n2. 设置用户密码：passwd  修改密码 sudo passwd 账户名\n\n3. 退出登录账户:exit \n4.  查看登录用户。\n\n## 9. 关机重启\n\n* 关机重启：reboot、shutdown、init\n\n  reboot\t重新启动操作系统\n\n  shutdown –r now\t重新启动操作系统，shutdown会给别的用户提示\n\n  shutdown -h now\t立刻关机，其中now相当于时间为0的状态\n\n  shutdown -h 20:25\t系统在今天的20:25 会关机\n\n  shutdown -h +10\t系统再过十分钟后自动关机\n\n## 10. 二分法\n\n```\nint l=1,r=ll;// 1 是答案的最小值，ll是答案的最大值\n    while(l<=r)\n    {\n        int mid=(l+r)>>1,q=check(mid);//“>>1”相当于“/2”\n        if(q>m)r=mid-1;\n        else l=mid+1;\n    }\n```\ncheck()函数根据不同的题不一样，其他都是一样的\n\n* 二分查找\n\n```javascript\nlet a = [1, 2, 3, 4, 5, 20,38,44];\ncheck = 3\nlet l = 0,r = a.length-1;\nwhile(l <= r){\n    let mid = (l + r) >> 1;\n    if(check < a[mid])\n        r = mid - 1;\n    else\n        l = mid +1;\n}\n\nconsole.log(r);\n```\n\n* 题目描述\n\n伐木工人米尔科需要砍倒M米长的木材。这是一个对米尔科来说很容易的工作，因为他有一个漂亮的新伐木机，可以像野火一样砍倒森林。不过，米尔科只被允许砍倒单行树木。\n\n米尔科的伐木机工作过程如下：米尔科设置一个高度参数H（米），伐木机升起一个巨大的锯片到高度H，并锯掉所有的树比H高的部分（当然，树木不高于H米的部分保持不变）。米尔科就行到树木被锯下的部分。\n\n例如，如果一行树的高度分别为20，15，10和17，米尔科把锯片升到15米的高度，切割后树木剩下的高度将是15，15，10和15，而米尔科将从第1棵树得到5米，从第4棵树得到2米，共得到7米木材。\n\n米尔科非常关注生态保护，所以他不会砍掉过多的木材。这正是他为什么尽可能高地设定伐木机锯片的原因。帮助米尔科找到伐木机锯片的最大的整数高度H，使得他能得到木材至少为M米。换句话说，如果再升高1米，则他将得不到M米木材。\n\n输入输出格式\n\n输入格式： \n第1行：2个整数N和M，N表示树木的数量（1<=N<=1000000）,M表示需要的木材总长度（1<=M<=2000000000）\n\n第2行：N个整数表示每棵树的高度，值均不超过1000000000。所有木材长度之和大于M，因此必有解。\n\n输出格式： \n第1行：1个整数，表示砍树的最高高度。\n\n输入输出样例\n\n输入样例#1： \n5 20 \n4 42 40 26 46 \n输出样例#1： \n36\n\n这个题的答案有明显的单调性，砍树的高度越低，得到的木材就越多，所以用二分在答案区间里找答案就行了。\n\n```c++\n#include<iostream>\n#include<cstdio>\nlong long m,n,a[1000005],temp;//因为我菜，所以就全设成long long；\nusing namespace std;\nlong long check(long long x)//这个check函数是二分的最重要的一环\n{\n    long long ans=0;\n    for(int i=1;i<=n;i++)\n    {\n        if(a[i]>x)\n        ans=ans-x+a[i];//ans用来记录能够得到的木材长度\n     } \n     return ans;\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d\",&a[i]);\n        temp=max(temp,a[i]);//temp用来记录最高的树的高度\n    }\n    long long l=1,r=temp;//把右边界设成最高的树的高度\n    while(l<=r)//二分操作\n    {\n        long long mid=(l+r)>>1,q=check(mid);\n        if(q<m)r=mid-1;\n        else l=mid+1;\n    }\n    printf(\"%d\",r);\n    return 0;\n}\n\n```\n\n## 11. 终端替换某文本\n\n```\nsed -i \"\" 's/http:\\/\\/47.101.139.155:23333\\/images/https:\\/\\/img.cetacis.dev\\/uploads/g' `grep \"http:\\/\\/47.101.139.155:23333\\/images\" -rl .` \n```\n\n## 12. 对集合的二进制表示\n\n[引用网站](https://www.cnblogs.com/astonc/p/10859115.html)\n\n## 13. ping\n\n**1）**假设有两个主机，主机A（192.168.0.1）和主机B（192.168.0.2），现在我们要监测主机A和主机B之间网络是否可达，那么我们在主机A上输入命令：ping 192.168.0.2；\n\n**2）**此时，ping命令会在主机A上构建一个 ICMP的请求数据包（数据包里的内容后面再详述），然后 ICMP协议会将这个数据包以及目标IP（192.168.0.2）等信息一同交给IP层协议；\n\n**3）**IP层协议得到这些信息后，将源地址（即本机IP）、目标地址（即目标IP：192.168.0.2）、再加上一些其它的控制信息，构建成一个IP数据包；\n\n**4）**IP数据包构建完成后，还不够，还需要加上MAC地址，因此，还需要通过ARP映射表找出目标IP所对应的MAC地址。当拿到了目标主机的MAC地址和本机MAC后，一并交给数据链路层，组装成一个数据帧，依据以太网的介质访问规则，将它们传送出出去；\n\n**5）**当主机B收到这个数据帧之后，会首先检查它的C目标MAC地址是不是本机，如果是就接收下来处理，接收之后会检查这个数据帧，将数据帧中的IP数据包取出来，交给本机的IP层协议，然后IP层协议检查完之后，再将ICMP数据包取出来交给ICMP协议处理，当这一步也处理完成之后，就会构建一个ICMP应答数据包，回发给主机A；\n\n**6）**在一定的时间内，如果主机A收到了应答包，则说明它与主机B之间网络可达，如果没有收到，则说明网络不可达。除了监测是否可达以外，还可以利用应答时间和发起时间之间的差值，计算出数据包的延迟耗时。\n\n## 14. 域名解析\n\nMX 邮箱服务  txt spf mx\n\nNS指定域名解析服务器\n\ncname  证明域名拥有权\n\nTXT 验证记录\n\n*A ipv4\n\nAAAA ipv6sp\n\nanti-spam：防止垃圾邮件\n\n* [阿里云文档：添加解析记录](https://help.aliyun.com/knowledge_detail/29725.html)\n\n* [CloudFlare API：批量添加域名并添加解析记录](https://blog.51cto.com/xsboke/2115548)\n\n* **dns系统**\n\n  Internet 上的所有计算机，从您的智能手机或笔记本电脑到可提供大量零售网站内容的服务器，均通过使用编号寻找另一方并相互通信。这些编号称为 **IP 地址**。当您打开 Web 浏览器并前往一个网站时，您不必记住和输入长编号。而是输入**域名** (入 example.com)，然后在正确的位置结束。\n\n  Amazon Route 53 等 DNS 服务是一种全球分布式服务，它将人类可读的名称 (如 www.example.com) 转换为数字 IP 地址 (如 192.0.2.1)，供计算机用于相互连接。Internet 的 DNS 系统的工作原理和电话簿相似，都是管理名称和数字之间的映射关系。DNS 服务器可以将名称请求转换为 IP 地址，从而控制最终用户在 Web 浏览器中输入域名时所访问的服务器。这些请求称为**查询**。\n\n  ![dns将流量路由到我的web程序](https://img.cetacis.dev/uploads/big/f443431781d872c8d466bc245975729d.png)\n\n1. 用户打开 Web 浏览器，在地址栏中输入 www.example.com，然后按 Enter 键。\n2. www.example.com 的请求被路由到 DNS 解析程序，这一般由用户的 Internet 服务提供商 (ISP) 进行管理，例如有线 Internet 服务提供商、DSL 宽带提供商或公司网络。\n3. ISP 的 DNS 解析程序将 www.example.com 的请求转发到 DNS 根名称服务器。\n4. ISP 的 DNS 解析程序再次转发 www.example.com 的请求，这次转发到 .com 域的一个 TLD 名称服务器。.com 域的名称服务器使用与 example.com 域相关的四个 Amazon Route 53 名称服务器的名称来响应该请求。\n5. ISP 的 DNS 解析程序选择一个 Amazon Route 53 名称服务器，并将 www.example.com 的请求转发到该名称服务器。\n6. Amazon Route 53 名称服务器在 example.com 托管区域中查找 www.example.com 记录，获得相关值，例如，Web 服务器的 IP 地址 (192.0.2.44)，并将 IP 地址返回至 DNS 解析程序。\n7. ISP 的 DNS 解析程序最终获得用户需要的 IP 地址。解析程序将此值返回至 Web 浏览器。DNS 解析程序还会将 example.com 的 IP 地址缓存 (存储) 您指定的时长，以便它能够在下次有人浏览 example.com 时更快地作出响应。有关更多信息，请参阅存活期 (TTL)。\n8. Web 浏览器将 www.example.com 的请求发送到从 DNS 解析程序中获得的 IP 地址。这是您的内容所处位置，例如，在 Amazon EC2 实例中或配置为网站终端节点的 Amazon S3 存储桶中运行的 Web 服务器。\n9. 192.0.2.44 上的 Web 服务器或其他资源将 www.example.com 的 Web 页面返回到 Web 浏览器，且 Web 浏览器会显示该页面。\n\n* **json**\n\n  一种轻量级数据交换结构\n\n  ```javascript\n  var json = '{\"a\": \"Hello\", \"b\": \"World\"}';\n  ```\n\n  作用：\n\n  简单地说，JSON 可以将 JavaScript 对象中表示的一组数据转换为字符串，然后就可以在网络或者程序之间轻松地传递这个字符串，并在需要的时候将它还原为各编程语言所支持的数据格式，例如在 PHP 中，可以将 JSON 还原为数组或者一个基本对象。在用到AJAX时，如果需要用到数组传值，这时就需要用JSON将数组转化为字符串。\n\n  * 表示对象\n\n  对象是一个无序的“‘名称/值’对”集合。一个对象以{左括号开始，}右括号结束。每个“名称”后跟一个:冒号；“‘名称/值’ 对”之间使用,逗号分隔。\n\n  ```javascript\n  `{``\"firstName\"``: ``\"Brett\"``, ``\"lastName\"``: ``\"McLaughlin\"``}                                        `\n  ```\n\n  * 表示数组\n\n  和普通的 JS 数组一样，JSON 表示数组的方式也是使用方括号 []。\n\n  ```javascript\n  `{ ``\"people\":[ ``{``\"firstName\": \"Brett\",            ``\"lastName\":\"McLaughlin\"        ``},      ``{        ``\"firstName\":\"Jason\",``\"lastName\":\"Hunter\"``}``]``}`\n  ```\n\n  这不难理解。在这个示例中，只有一个名为 people的变量，值是包含两个条目的数组，每个条目是一个人的记录，其中包含名和姓。上面的示例演示如何用括号将记录组合成一个值。当然，可以使用相同的语法表示更过多的值（每个值包含多个记录）。\n\n  * 要实现从JSON字符串转换为JS对象，使用 JSON.parse() 方法：\n\n    ```javascript\n    `var` `obj = JSON.parse(``'{\"a\": \"Hello\", \"b\": \"World\"}'``); ``//结果是 {a: 'Hello', b: 'World'}`\n    ```\n\n    要实现从JS对象转换为JSON字符串，使用 JSON.stringify() 方法：\n\n    ```javascript\n    `var` `json = JSON.stringify({a: ``'Hello'``, b: ``'World'``}); ``//结果是 '{\"a\": \"Hello\", \"b\": \"World\"}'`\n    ```\n\n## 15. telegram bot nginx\n\n鉴权 ->链接cf ->看cf 的 api\n\n*  https://api.cloudflare.com ：cloudflare 's api ：看网站\n\n  目标：增加A记录（API token）\n\n* bot api \n\n  git源码 https://github.com/yagop/node-telegram-bot-api\n\n  参考blog  [建立 telegram bot and nginx](https://segmentfault.com/a/1190000018716076)    \n\n## 16. 正则表达式\n\n正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。\n\n* 非打印字符\n\n| \\cx  | 匹配由x指明的控制字符。例如， \\cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。 |\n| ---- | ------------------------------------------------------------ |\n| \\f   | 匹配一个换页符。等价于 \\x0c 和 \\cL。                         |\n| \\n   | 匹配一个换行符。等价于 \\x0a 和 \\cJ。                         |\n| \\r   | 匹配一个回车符。等价于 \\x0d 和 \\cM。                         |\n| \\s   | 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。注意 Unicode 正则表达式会匹配全角空格符。 |\n| \\S   | 匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。                  |\n| \\t   | 匹配一个制表符。等价于 \\x09 和 \\cI。                         |\n| \\v   | 匹配一个垂直制表符。等价于 \\x0b 和 \\cK。                     |\n\n* 特殊字符\n\n| $    | 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 '\\n' 或 '\\r'。要匹配 $ 字符本身，请使用  \\\\$。 |\n| ---- | ------------------------------------------------------------ |\n| ( )  | 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 \\\\( 和\\ \\)。 |\n| *    | 匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 \\\\*。    |\n| +    | 匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 \\\\+。    |\n| .    | 匹配除换行符 \\n 之外的任何单字符。要匹配 . ，请使用 \\\\. 。   |\n| [    | 标记一个中括号表达式的开始。要匹配 [，请使用 \\\\[。           |\n| ?    | 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \\?。 |\n| \\    | 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， 'n' 匹配字符 'n'。'\\n' 匹配换行符。序列 '\\\\\\\\' 匹配 \"\\\\\"，而 '\\\\(' 则匹配 \"(\"。 |\n| ^    | 匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 \\^。 |\n| {    | 标记限定符表达式的开始。要匹配 {，请使用 \\\\{。               |\n| \\|   | 指明两项之间的一个选择。要匹配 \\|，请使用 \\\\|。              |\n\n* 限定符\n\n| *     | 匹配前面的子表达式零次或多次。例如，zo* 能匹配 \"z\" 以及 \"zoo\"。* 等价于{0,}。 |\n| ----- | ------------------------------------------------------------ |\n| +     | 匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 \"zo\" 以及 \"zoo\"，但不能匹配 \"z\"。+ 等价于 {1,}。 |\n| ?     | 匹配前面的子表达式零次或一次。例如，\"do(es)?\" 可以匹配 \"do\" 、 \"does\" 中的 \"does\" 、 \"doxy\" 中的 \"do\" 。? 等价于 {0,1}。 |\n| {n}   | n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 \"Bob\" 中的 'o'，但是能匹配 \"food\" 中的两个 o。 |\n| {n,}  | n 是一个非负整数。至少匹配n 次。例如，'o{2,}' 不能匹配 \"Bob\" 中的 'o'，但能匹配 \"foooood\" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。 |\n| {n,m} | m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。例如，\"o{1,3}\" 将匹配 \"fooooood\" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。``` |\n\n```\n/[0-9]{1,2}/    # 至少一位至多两位的数字，设置0-99 缺点在于\n```\n\n```\n[1-9]?[0-9]   ￥ \n```\n\n* 贪婪非贪婪：\n\n  \\* 是贪婪的，他会尽可能多的匹配字符。比如\n\n  ```\n  <h1>123</h1>\n  ```\n\n  如果用<.*>匹配，他会把<h1>123</h1>全匹配上（贪婪）\n\n  如果同<.*?>匹配，只会匹配<h1>（非贪婪：最小匹配）\n\n* 定位符\n\n定位符用来描述字符串或单词的边界，**^** 和 **$** 分别指字符串的开始与结束，**\\b** 描述单词的前或后边界，**\\B** 表示非单词边界。\n\n| 字符 | 描述                                                         |\n| :--- | :----------------------------------------------------------- |\n| ^    | 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \\n 或 \\r 之后的位置匹配。 |\n| $    | 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \\n 或 \\r 之前的位置匹配。 |\n| \\b   | 匹配一个单词边界，即字与空格间的位置。                       |\n| \\B   | 非单词边界匹配。                                             |\n\n若要在搜索章节标题时使用定位点，下面的正则表达式匹配一个章节标题，该标题只包含两个尾随数字，并且出现在行首：\n\n```\n/^Chapter [1-9][0-9]{0,1}/\n```\n\n真正的章节标题不仅出现行的开始处，而且它还是该行中仅有的文本。它即出现在行首又出现在同一行的结尾。下面的表达式能确保指定的匹配只匹配章节而不匹配交叉引用。通过创建只匹配一行文本的开始和结尾的正则表达式，就可做到这一点。\n\n```\n/^Chapter [1-9][0-9]{0,1}$/\n```\n\n匹配单词边界稍有不同，但向正则表达式添加了很重要的能力。单词边界是单词和空格之间的位置。非单词边界是任何其他位置。下面的表达式匹配单词 Chapter 的开头三个字符，因为这三个字符出现在单词边界后面：\n\n```\n/\\bCha/\n```\n\n**\\b** 字符的位置是非常重要的。如果它位于要匹配的字符串的开始，它在单词的开始处查找匹配项。如果它位于字符串的结尾，它在单词的结尾处查找匹配项。例如，下面的表达式匹配单词 Chapter 中的字符串 ter，因为它出现在单词边界的前面：\n\n```\n/ter\\b/\n```\n\n下面的表达式匹配 Chapter 中的字符串 apt，但不匹配 aptitude 中的字符串 apt：\n\n```\n/\\Bapt/\n```\n\n字符串 apt 出现在单词 Chapter 中的非单词边界处，但出现在单词 aptitude 中的单词边界处。对于 **\\B** 非单词边界运算符，位置并不重要，因为匹配不关心究竟是单词的开头还是结尾。\n\n```javascript\nvar str = \"http://www.runoob.com:80/html/html-tutorial.html\";\nvar patt1 = /(\\w+):\\/\\/([^/:]+)(:\\d*)?([^# ]*)/;\narr = str.match(patt1);\nfor (var i = 0; i < arr.length ; i++) {\n    document.write(arr[i]);\n    document.write(\"<br>\");\n}\n```\n\n第三行代码 **str.match(patt1)** 返回一个数组，实例中的数组包含 5 个元素，索引 0 对应的是整个字符串，索引 1 对应第一个匹配符（括号内），以此类推。\n\n第一个括号子表达式捕获 Web 地址的协议部分。该子表达式匹配在冒号和两个正斜杠前面的任何单词。\n\n第二个括号子表达式捕获地址的域地址部分。子表达式匹配非 **:** 和 **/** 之后的一个或多个字符。\n\n第三个括号子表达式捕获端口号（如果指定了的话）。该子表达式匹配冒号后面的零个或多个数字。只能重复一次该子表达式。\n\n最后，第四个括号子表达式捕获 Web 地址指定的路径和 / 或页信息。该子表达式能匹配不包括 # 或空格字符的任何字符序列。\n\n将正则表达式应用到上面的 URI，各子匹配项包含下面的内容：\n\n- 第一个括号子表达式包含 **http**\n- 第二个括号子表达式包含 **www.runoob.com**\n- 第三个括号子表达式包含 **:80**\n- 第四个括号子表达式包含 **/html/html-tutorial.html**\n\n","source":"_posts/屠龙之技一.md","raw":"---\ndate: 2020/2/5\ntags:\n- 自学笔记\n- 终端基础操作\ncategories:\n- 屠龙之技\n---\n## 1. 终端压缩\n\n1. 第一种压缩方式\n\n   * **tar - 归档命令** \n\n     多文件归档：    tar  [参数]  打包文件名  文件1 文件2\n\n     目录归档：      tar  [参数]  打包文件名  目录\n\n     -c\t生成档案文件，创建打包文件\n\n     -v\t列出归档解档的详细过程，显示进度\n\n     -f\t指定档案文件名称，f后面一定是.tar文件，**所以必须放选项最后**\n\n     -t\t列出档案中包含的文件\n\n     -x\t解开档案文件\n<!-- more -->\n     ```\n     tar -cvf test.tar * # 将当前目录下的所有文件打包归档\n     \n     tar -xvf test.tar # 将tar文件解开\n     ```\n\n   * **gzip - 文件压缩解压**\n\n     tar和gzip结合实现文件打包、压缩。扩展名一般为XXX.tar.gz\n\n     ```\n     gzip  [选项]  被压缩文件\n     \n     gzip xx.tar        压缩\n     \n     gzip -r xx.tar xx.tar.gz  压缩这个文件的所有子目录，不包括这个文件\n     \n     gzip -d xx.tar.gz  解压\n     ```\n\n   * **tar -z**\n\n     ```\n     tar zcvf 压缩包包名 文件1 文件2 ...\n     \n     -z ：指定压缩包的格式为：file.tar.gz\n     \n     tar -zcvf test.tar.gz * 将当前路径下所有的文件以及文件夹打包并压缩到test.tar.gz中。\n     \n     tar -zxvf test.tar.gz解压到当前路径下\n     \n     tar -zxvf test.tar.gz -C xx 解压到指定路径下。\n     ```\n2. 第二种压缩方式\n    * **bzip2**\n    \n        压缩: \n    \n        ```\n        bzip2 filename ---> 删除filename文件，生成 filename.bz2\n        ```\n\n        解压缩：\n    \n        ```\n        bzip2 -d filename.bz2 ---> 删除filename.bz2 ，生成 filename文件\n        ```\n    \n    * **tar + bzip2**（tar -jcvf）\n    \n        扩展名：XXX.tar.gz2\n    \n        压缩：\n    \n        ```\n        tar -jcvf 压缩包包名 文件...(tar jcvf bk.tar.bz2 *)\n        ```\n    \n        解压缩：\n    \n        ```\n        tar -jxvf 压缩包包名 (tar jxvf bk.tar.bz2)\n        ```\n    \n        *注意：上述方式压缩后保留源文件，解压后保留压缩文件*\n\n3. 第三种压缩方式\n\n   * **zip**\n\n     压缩：\n\n     ```\n     zip [-r] 目标文件(可以没有扩展名) 源文件\n     \n     zip myzip *\n     ```\n\n     解压缩：\n\n     ```\n     unzip -d 解压后目录文件 压缩文件\n     \n     unzip -d ./xx myzip.zip\n     ```\n\n     *注意：不需要指定扩展名。默认zip*\n\n4. 三种比较\n\n   gzip压缩最小，bzip居中，zip最大\n\n5. 解压 x\n\n## 2. 文章权限\n\n1. 权限表示\n\n![文章权限](https://img.cetacis.dev/uploads/2020/02/05/Screen-Shot-2020-02-05-at-3.01.40-PM.png)\n\nr（可读）、w（可写）、x（可执行）\n\n2. 修改权限**chmod**\n\n   * 字母修改\n\n     ```\n     chmod u=rwx,g=rx,o=r filename\n     ```\n\n   * 数字修改\n\n     ```\n     chmod 751 filename\n     ```\n\n3. **-R**递归为目录下所有文件加权限\n\n   ```\n   chmod 777 test/ -R \n   ```\n\n## 3. 流\n\n1. Linux有三种流\n\n   * 标准输出流：正常信息的输出，默认输出到屏幕上。\n\n     标准错误输出流：错误的信息的输出，默认输出到屏幕上。\n\n     标准输入流：向系统中输入数据，默认就是键盘输入的数据。\n\n   * 我们可以通过重定向的技术，把输出、输入的信息重定向到其它的地方去。比如，我们可以把系统中的错误信息输出到一个文件中去。\n\n   * 如：ls > test.txt ( test.txt 如果不存在，则创建，存在则覆盖其内容 )\n\n     *注意:>是覆盖原来的内容，>>是添加内容。（这是重定向）*\n\n2. 管道\n\n   左边是写入信息，右边是读取左边的结果作为输入。\n\n## 4. 链接文件 ln\n\n1. 硬链接\n\n   文件有一个或者多个文件名。\n\n   ```\n   ln 源文件 链接文件\n   ```\n\n2. 软链接\n\n   软链接不占用磁盘空间，源文件删除则软连接就会失效。相当于重命名。\n\n   ```\n   ln -s 源文件 链接文件\n   ```\n\n3. 关系\n\n   * 软链接和硬链接都可以修改源文件内容，删除源文件后，硬链接仍然可以访问，软连接不可以，删除软连接就相当于删除了快捷方式，对源文件没有影响。\n   * 软链接可以跨文件系统，硬链接不可以;\n   * 软链接可以对一个不存在的文件名(filename)进行链接(当然此时如果你vi这个软链接文件，linux会自动新建一个文件名为filename的文件),硬链接不可以(其文件必须存在，inode必须存在);\n   * 软链接可以对目录进行连接，硬链接不可以\n\n## 5. 文件内容搜索 grep\n\n1. 一般格式\n\n   ```\n   grep [-选项] ‘搜索内容串’ 文件名（是对文件内容的搜索）\n   ```\n\n2. 选项\n\n   -V 显示不包含文本的所有行 -n 显示匹配行以及行号 -i 忽略大小写进行搜索\n\n3. 正则表达式\n\n   ^a 搜寻以a开头的行。\n\n    ke$搜索以Ke结束的行。\n\n   [Ss]nal[Ll]匹配[]中的任意一个。\n\n   \".\"匹配一个非换行符的字符。\n\n## 6. 特定文件搜索 find\n\n搜索符合条件的文件，搜索特定用户属主的文件。\n\n![find](https://img.cetacis.dev/uploads/2020/02/05/find.png)\n\n## 7. 特定命令搜索 which is\n\n```\nwhich is gcc\n```\n\n## 8. 用户管理\n\n1. 切换到管理员账号 sudo -s $显示为普通用户 #显示为管理员用户\n\n2. 设置用户密码：passwd  修改密码 sudo passwd 账户名\n\n3. 退出登录账户:exit \n4.  查看登录用户。\n\n## 9. 关机重启\n\n* 关机重启：reboot、shutdown、init\n\n  reboot\t重新启动操作系统\n\n  shutdown –r now\t重新启动操作系统，shutdown会给别的用户提示\n\n  shutdown -h now\t立刻关机，其中now相当于时间为0的状态\n\n  shutdown -h 20:25\t系统在今天的20:25 会关机\n\n  shutdown -h +10\t系统再过十分钟后自动关机\n\n## 10. 二分法\n\n```\nint l=1,r=ll;// 1 是答案的最小值，ll是答案的最大值\n    while(l<=r)\n    {\n        int mid=(l+r)>>1,q=check(mid);//“>>1”相当于“/2”\n        if(q>m)r=mid-1;\n        else l=mid+1;\n    }\n```\ncheck()函数根据不同的题不一样，其他都是一样的\n\n* 二分查找\n\n```javascript\nlet a = [1, 2, 3, 4, 5, 20,38,44];\ncheck = 3\nlet l = 0,r = a.length-1;\nwhile(l <= r){\n    let mid = (l + r) >> 1;\n    if(check < a[mid])\n        r = mid - 1;\n    else\n        l = mid +1;\n}\n\nconsole.log(r);\n```\n\n* 题目描述\n\n伐木工人米尔科需要砍倒M米长的木材。这是一个对米尔科来说很容易的工作，因为他有一个漂亮的新伐木机，可以像野火一样砍倒森林。不过，米尔科只被允许砍倒单行树木。\n\n米尔科的伐木机工作过程如下：米尔科设置一个高度参数H（米），伐木机升起一个巨大的锯片到高度H，并锯掉所有的树比H高的部分（当然，树木不高于H米的部分保持不变）。米尔科就行到树木被锯下的部分。\n\n例如，如果一行树的高度分别为20，15，10和17，米尔科把锯片升到15米的高度，切割后树木剩下的高度将是15，15，10和15，而米尔科将从第1棵树得到5米，从第4棵树得到2米，共得到7米木材。\n\n米尔科非常关注生态保护，所以他不会砍掉过多的木材。这正是他为什么尽可能高地设定伐木机锯片的原因。帮助米尔科找到伐木机锯片的最大的整数高度H，使得他能得到木材至少为M米。换句话说，如果再升高1米，则他将得不到M米木材。\n\n输入输出格式\n\n输入格式： \n第1行：2个整数N和M，N表示树木的数量（1<=N<=1000000）,M表示需要的木材总长度（1<=M<=2000000000）\n\n第2行：N个整数表示每棵树的高度，值均不超过1000000000。所有木材长度之和大于M，因此必有解。\n\n输出格式： \n第1行：1个整数，表示砍树的最高高度。\n\n输入输出样例\n\n输入样例#1： \n5 20 \n4 42 40 26 46 \n输出样例#1： \n36\n\n这个题的答案有明显的单调性，砍树的高度越低，得到的木材就越多，所以用二分在答案区间里找答案就行了。\n\n```c++\n#include<iostream>\n#include<cstdio>\nlong long m,n,a[1000005],temp;//因为我菜，所以就全设成long long；\nusing namespace std;\nlong long check(long long x)//这个check函数是二分的最重要的一环\n{\n    long long ans=0;\n    for(int i=1;i<=n;i++)\n    {\n        if(a[i]>x)\n        ans=ans-x+a[i];//ans用来记录能够得到的木材长度\n     } \n     return ans;\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d\",&a[i]);\n        temp=max(temp,a[i]);//temp用来记录最高的树的高度\n    }\n    long long l=1,r=temp;//把右边界设成最高的树的高度\n    while(l<=r)//二分操作\n    {\n        long long mid=(l+r)>>1,q=check(mid);\n        if(q<m)r=mid-1;\n        else l=mid+1;\n    }\n    printf(\"%d\",r);\n    return 0;\n}\n\n```\n\n## 11. 终端替换某文本\n\n```\nsed -i \"\" 's/http:\\/\\/47.101.139.155:23333\\/images/https:\\/\\/img.cetacis.dev\\/uploads/g' `grep \"http:\\/\\/47.101.139.155:23333\\/images\" -rl .` \n```\n\n## 12. 对集合的二进制表示\n\n[引用网站](https://www.cnblogs.com/astonc/p/10859115.html)\n\n## 13. ping\n\n**1）**假设有两个主机，主机A（192.168.0.1）和主机B（192.168.0.2），现在我们要监测主机A和主机B之间网络是否可达，那么我们在主机A上输入命令：ping 192.168.0.2；\n\n**2）**此时，ping命令会在主机A上构建一个 ICMP的请求数据包（数据包里的内容后面再详述），然后 ICMP协议会将这个数据包以及目标IP（192.168.0.2）等信息一同交给IP层协议；\n\n**3）**IP层协议得到这些信息后，将源地址（即本机IP）、目标地址（即目标IP：192.168.0.2）、再加上一些其它的控制信息，构建成一个IP数据包；\n\n**4）**IP数据包构建完成后，还不够，还需要加上MAC地址，因此，还需要通过ARP映射表找出目标IP所对应的MAC地址。当拿到了目标主机的MAC地址和本机MAC后，一并交给数据链路层，组装成一个数据帧，依据以太网的介质访问规则，将它们传送出出去；\n\n**5）**当主机B收到这个数据帧之后，会首先检查它的C目标MAC地址是不是本机，如果是就接收下来处理，接收之后会检查这个数据帧，将数据帧中的IP数据包取出来，交给本机的IP层协议，然后IP层协议检查完之后，再将ICMP数据包取出来交给ICMP协议处理，当这一步也处理完成之后，就会构建一个ICMP应答数据包，回发给主机A；\n\n**6）**在一定的时间内，如果主机A收到了应答包，则说明它与主机B之间网络可达，如果没有收到，则说明网络不可达。除了监测是否可达以外，还可以利用应答时间和发起时间之间的差值，计算出数据包的延迟耗时。\n\n## 14. 域名解析\n\nMX 邮箱服务  txt spf mx\n\nNS指定域名解析服务器\n\ncname  证明域名拥有权\n\nTXT 验证记录\n\n*A ipv4\n\nAAAA ipv6sp\n\nanti-spam：防止垃圾邮件\n\n* [阿里云文档：添加解析记录](https://help.aliyun.com/knowledge_detail/29725.html)\n\n* [CloudFlare API：批量添加域名并添加解析记录](https://blog.51cto.com/xsboke/2115548)\n\n* **dns系统**\n\n  Internet 上的所有计算机，从您的智能手机或笔记本电脑到可提供大量零售网站内容的服务器，均通过使用编号寻找另一方并相互通信。这些编号称为 **IP 地址**。当您打开 Web 浏览器并前往一个网站时，您不必记住和输入长编号。而是输入**域名** (入 example.com)，然后在正确的位置结束。\n\n  Amazon Route 53 等 DNS 服务是一种全球分布式服务，它将人类可读的名称 (如 www.example.com) 转换为数字 IP 地址 (如 192.0.2.1)，供计算机用于相互连接。Internet 的 DNS 系统的工作原理和电话簿相似，都是管理名称和数字之间的映射关系。DNS 服务器可以将名称请求转换为 IP 地址，从而控制最终用户在 Web 浏览器中输入域名时所访问的服务器。这些请求称为**查询**。\n\n  ![dns将流量路由到我的web程序](https://img.cetacis.dev/uploads/big/f443431781d872c8d466bc245975729d.png)\n\n1. 用户打开 Web 浏览器，在地址栏中输入 www.example.com，然后按 Enter 键。\n2. www.example.com 的请求被路由到 DNS 解析程序，这一般由用户的 Internet 服务提供商 (ISP) 进行管理，例如有线 Internet 服务提供商、DSL 宽带提供商或公司网络。\n3. ISP 的 DNS 解析程序将 www.example.com 的请求转发到 DNS 根名称服务器。\n4. ISP 的 DNS 解析程序再次转发 www.example.com 的请求，这次转发到 .com 域的一个 TLD 名称服务器。.com 域的名称服务器使用与 example.com 域相关的四个 Amazon Route 53 名称服务器的名称来响应该请求。\n5. ISP 的 DNS 解析程序选择一个 Amazon Route 53 名称服务器，并将 www.example.com 的请求转发到该名称服务器。\n6. Amazon Route 53 名称服务器在 example.com 托管区域中查找 www.example.com 记录，获得相关值，例如，Web 服务器的 IP 地址 (192.0.2.44)，并将 IP 地址返回至 DNS 解析程序。\n7. ISP 的 DNS 解析程序最终获得用户需要的 IP 地址。解析程序将此值返回至 Web 浏览器。DNS 解析程序还会将 example.com 的 IP 地址缓存 (存储) 您指定的时长，以便它能够在下次有人浏览 example.com 时更快地作出响应。有关更多信息，请参阅存活期 (TTL)。\n8. Web 浏览器将 www.example.com 的请求发送到从 DNS 解析程序中获得的 IP 地址。这是您的内容所处位置，例如，在 Amazon EC2 实例中或配置为网站终端节点的 Amazon S3 存储桶中运行的 Web 服务器。\n9. 192.0.2.44 上的 Web 服务器或其他资源将 www.example.com 的 Web 页面返回到 Web 浏览器，且 Web 浏览器会显示该页面。\n\n* **json**\n\n  一种轻量级数据交换结构\n\n  ```javascript\n  var json = '{\"a\": \"Hello\", \"b\": \"World\"}';\n  ```\n\n  作用：\n\n  简单地说，JSON 可以将 JavaScript 对象中表示的一组数据转换为字符串，然后就可以在网络或者程序之间轻松地传递这个字符串，并在需要的时候将它还原为各编程语言所支持的数据格式，例如在 PHP 中，可以将 JSON 还原为数组或者一个基本对象。在用到AJAX时，如果需要用到数组传值，这时就需要用JSON将数组转化为字符串。\n\n  * 表示对象\n\n  对象是一个无序的“‘名称/值’对”集合。一个对象以{左括号开始，}右括号结束。每个“名称”后跟一个:冒号；“‘名称/值’ 对”之间使用,逗号分隔。\n\n  ```javascript\n  `{``\"firstName\"``: ``\"Brett\"``, ``\"lastName\"``: ``\"McLaughlin\"``}                                        `\n  ```\n\n  * 表示数组\n\n  和普通的 JS 数组一样，JSON 表示数组的方式也是使用方括号 []。\n\n  ```javascript\n  `{ ``\"people\":[ ``{``\"firstName\": \"Brett\",            ``\"lastName\":\"McLaughlin\"        ``},      ``{        ``\"firstName\":\"Jason\",``\"lastName\":\"Hunter\"``}``]``}`\n  ```\n\n  这不难理解。在这个示例中，只有一个名为 people的变量，值是包含两个条目的数组，每个条目是一个人的记录，其中包含名和姓。上面的示例演示如何用括号将记录组合成一个值。当然，可以使用相同的语法表示更过多的值（每个值包含多个记录）。\n\n  * 要实现从JSON字符串转换为JS对象，使用 JSON.parse() 方法：\n\n    ```javascript\n    `var` `obj = JSON.parse(``'{\"a\": \"Hello\", \"b\": \"World\"}'``); ``//结果是 {a: 'Hello', b: 'World'}`\n    ```\n\n    要实现从JS对象转换为JSON字符串，使用 JSON.stringify() 方法：\n\n    ```javascript\n    `var` `json = JSON.stringify({a: ``'Hello'``, b: ``'World'``}); ``//结果是 '{\"a\": \"Hello\", \"b\": \"World\"}'`\n    ```\n\n## 15. telegram bot nginx\n\n鉴权 ->链接cf ->看cf 的 api\n\n*  https://api.cloudflare.com ：cloudflare 's api ：看网站\n\n  目标：增加A记录（API token）\n\n* bot api \n\n  git源码 https://github.com/yagop/node-telegram-bot-api\n\n  参考blog  [建立 telegram bot and nginx](https://segmentfault.com/a/1190000018716076)    \n\n## 16. 正则表达式\n\n正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。\n\n* 非打印字符\n\n| \\cx  | 匹配由x指明的控制字符。例如， \\cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。 |\n| ---- | ------------------------------------------------------------ |\n| \\f   | 匹配一个换页符。等价于 \\x0c 和 \\cL。                         |\n| \\n   | 匹配一个换行符。等价于 \\x0a 和 \\cJ。                         |\n| \\r   | 匹配一个回车符。等价于 \\x0d 和 \\cM。                         |\n| \\s   | 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。注意 Unicode 正则表达式会匹配全角空格符。 |\n| \\S   | 匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。                  |\n| \\t   | 匹配一个制表符。等价于 \\x09 和 \\cI。                         |\n| \\v   | 匹配一个垂直制表符。等价于 \\x0b 和 \\cK。                     |\n\n* 特殊字符\n\n| $    | 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 '\\n' 或 '\\r'。要匹配 $ 字符本身，请使用  \\\\$。 |\n| ---- | ------------------------------------------------------------ |\n| ( )  | 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 \\\\( 和\\ \\)。 |\n| *    | 匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 \\\\*。    |\n| +    | 匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 \\\\+。    |\n| .    | 匹配除换行符 \\n 之外的任何单字符。要匹配 . ，请使用 \\\\. 。   |\n| [    | 标记一个中括号表达式的开始。要匹配 [，请使用 \\\\[。           |\n| ?    | 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \\?。 |\n| \\    | 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， 'n' 匹配字符 'n'。'\\n' 匹配换行符。序列 '\\\\\\\\' 匹配 \"\\\\\"，而 '\\\\(' 则匹配 \"(\"。 |\n| ^    | 匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 \\^。 |\n| {    | 标记限定符表达式的开始。要匹配 {，请使用 \\\\{。               |\n| \\|   | 指明两项之间的一个选择。要匹配 \\|，请使用 \\\\|。              |\n\n* 限定符\n\n| *     | 匹配前面的子表达式零次或多次。例如，zo* 能匹配 \"z\" 以及 \"zoo\"。* 等价于{0,}。 |\n| ----- | ------------------------------------------------------------ |\n| +     | 匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 \"zo\" 以及 \"zoo\"，但不能匹配 \"z\"。+ 等价于 {1,}。 |\n| ?     | 匹配前面的子表达式零次或一次。例如，\"do(es)?\" 可以匹配 \"do\" 、 \"does\" 中的 \"does\" 、 \"doxy\" 中的 \"do\" 。? 等价于 {0,1}。 |\n| {n}   | n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 \"Bob\" 中的 'o'，但是能匹配 \"food\" 中的两个 o。 |\n| {n,}  | n 是一个非负整数。至少匹配n 次。例如，'o{2,}' 不能匹配 \"Bob\" 中的 'o'，但能匹配 \"foooood\" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。 |\n| {n,m} | m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。例如，\"o{1,3}\" 将匹配 \"fooooood\" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。``` |\n\n```\n/[0-9]{1,2}/    # 至少一位至多两位的数字，设置0-99 缺点在于\n```\n\n```\n[1-9]?[0-9]   ￥ \n```\n\n* 贪婪非贪婪：\n\n  \\* 是贪婪的，他会尽可能多的匹配字符。比如\n\n  ```\n  <h1>123</h1>\n  ```\n\n  如果用<.*>匹配，他会把<h1>123</h1>全匹配上（贪婪）\n\n  如果同<.*?>匹配，只会匹配<h1>（非贪婪：最小匹配）\n\n* 定位符\n\n定位符用来描述字符串或单词的边界，**^** 和 **$** 分别指字符串的开始与结束，**\\b** 描述单词的前或后边界，**\\B** 表示非单词边界。\n\n| 字符 | 描述                                                         |\n| :--- | :----------------------------------------------------------- |\n| ^    | 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \\n 或 \\r 之后的位置匹配。 |\n| $    | 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \\n 或 \\r 之前的位置匹配。 |\n| \\b   | 匹配一个单词边界，即字与空格间的位置。                       |\n| \\B   | 非单词边界匹配。                                             |\n\n若要在搜索章节标题时使用定位点，下面的正则表达式匹配一个章节标题，该标题只包含两个尾随数字，并且出现在行首：\n\n```\n/^Chapter [1-9][0-9]{0,1}/\n```\n\n真正的章节标题不仅出现行的开始处，而且它还是该行中仅有的文本。它即出现在行首又出现在同一行的结尾。下面的表达式能确保指定的匹配只匹配章节而不匹配交叉引用。通过创建只匹配一行文本的开始和结尾的正则表达式，就可做到这一点。\n\n```\n/^Chapter [1-9][0-9]{0,1}$/\n```\n\n匹配单词边界稍有不同，但向正则表达式添加了很重要的能力。单词边界是单词和空格之间的位置。非单词边界是任何其他位置。下面的表达式匹配单词 Chapter 的开头三个字符，因为这三个字符出现在单词边界后面：\n\n```\n/\\bCha/\n```\n\n**\\b** 字符的位置是非常重要的。如果它位于要匹配的字符串的开始，它在单词的开始处查找匹配项。如果它位于字符串的结尾，它在单词的结尾处查找匹配项。例如，下面的表达式匹配单词 Chapter 中的字符串 ter，因为它出现在单词边界的前面：\n\n```\n/ter\\b/\n```\n\n下面的表达式匹配 Chapter 中的字符串 apt，但不匹配 aptitude 中的字符串 apt：\n\n```\n/\\Bapt/\n```\n\n字符串 apt 出现在单词 Chapter 中的非单词边界处，但出现在单词 aptitude 中的单词边界处。对于 **\\B** 非单词边界运算符，位置并不重要，因为匹配不关心究竟是单词的开头还是结尾。\n\n```javascript\nvar str = \"http://www.runoob.com:80/html/html-tutorial.html\";\nvar patt1 = /(\\w+):\\/\\/([^/:]+)(:\\d*)?([^# ]*)/;\narr = str.match(patt1);\nfor (var i = 0; i < arr.length ; i++) {\n    document.write(arr[i]);\n    document.write(\"<br>\");\n}\n```\n\n第三行代码 **str.match(patt1)** 返回一个数组，实例中的数组包含 5 个元素，索引 0 对应的是整个字符串，索引 1 对应第一个匹配符（括号内），以此类推。\n\n第一个括号子表达式捕获 Web 地址的协议部分。该子表达式匹配在冒号和两个正斜杠前面的任何单词。\n\n第二个括号子表达式捕获地址的域地址部分。子表达式匹配非 **:** 和 **/** 之后的一个或多个字符。\n\n第三个括号子表达式捕获端口号（如果指定了的话）。该子表达式匹配冒号后面的零个或多个数字。只能重复一次该子表达式。\n\n最后，第四个括号子表达式捕获 Web 地址指定的路径和 / 或页信息。该子表达式能匹配不包括 # 或空格字符的任何字符序列。\n\n将正则表达式应用到上面的 URI，各子匹配项包含下面的内容：\n\n- 第一个括号子表达式包含 **http**\n- 第二个括号子表达式包含 **www.runoob.com**\n- 第三个括号子表达式包含 **:80**\n- 第四个括号子表达式包含 **/html/html-tutorial.html**\n\n","slug":"屠龙之技一","published":1,"updated":"2020-03-25T01:23:19.000Z","title":"屠龙之技一","comments":1,"layout":"post","photos":[],"link":"","_id":"ck985a86e0012slqgg1saa5fu","content":"<h2 id=\"1-终端压缩\"><a href=\"#1-终端压缩\" class=\"headerlink\" title=\"1. 终端压缩\"></a>1. 终端压缩</h2><ol>\n<li><p>第一种压缩方式</p>\n<ul>\n<li><p><strong>tar - 归档命令</strong> </p>\n<p>多文件归档：    tar  [参数]  打包文件名  文件1 文件2</p>\n<p>目录归档：      tar  [参数]  打包文件名  目录</p>\n<p>-c    生成档案文件，创建打包文件</p>\n<p>-v    列出归档解档的详细过程，显示进度</p>\n<p>-f    指定档案文件名称，f后面一定是.tar文件，<strong>所以必须放选项最后</strong></p>\n<p>-t    列出档案中包含的文件</p>\n<p>-x    解开档案文件</p>\n<a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -cvf test.tar * # 将当前目录下的所有文件打包归档</span><br><span class=\"line\"></span><br><span class=\"line\">tar -xvf test.tar # 将tar文件解开</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>gzip - 文件压缩解压</strong></p>\n<p>tar和gzip结合实现文件打包、压缩。扩展名一般为XXX.tar.gz</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gzip  [选项]  被压缩文件</span><br><span class=\"line\"></span><br><span class=\"line\">gzip xx.tar        压缩</span><br><span class=\"line\"></span><br><span class=\"line\">gzip -r xx.tar xx.tar.gz  压缩这个文件的所有子目录，不包括这个文件</span><br><span class=\"line\"></span><br><span class=\"line\">gzip -d xx.tar.gz  解压</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>tar -z</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar zcvf 压缩包包名 文件1 文件2 ...</span><br><span class=\"line\"></span><br><span class=\"line\">-z ：指定压缩包的格式为：file.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\">tar -zcvf test.tar.gz * 将当前路径下所有的文件以及文件夹打包并压缩到test.tar.gz中。</span><br><span class=\"line\"></span><br><span class=\"line\">tar -zxvf test.tar.gz解压到当前路径下</span><br><span class=\"line\"></span><br><span class=\"line\">tar -zxvf test.tar.gz -C xx 解压到指定路径下。</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>第二种压缩方式</p>\n<ul>\n<li><p><strong>bzip2</strong></p>\n<p>  压缩: </p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bzip2 filename ---&gt; 删除filename文件，生成 filename.bz2</span><br></pre></td></tr></table></figure>\n\n<p>  解压缩：</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bzip2 -d filename.bz2 ---&gt; 删除filename.bz2 ，生成 filename文件</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>tar + bzip2</strong>（tar -jcvf）</p>\n<p>  扩展名：XXX.tar.gz2</p>\n<p>  压缩：</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -jcvf 压缩包包名 文件...(tar jcvf bk.tar.bz2 *)</span><br></pre></td></tr></table></figure>\n\n<p>  解压缩：</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -jxvf 压缩包包名 (tar jxvf bk.tar.bz2)</span><br></pre></td></tr></table></figure>\n\n<p>  <em>注意：上述方式压缩后保留源文件，解压后保留压缩文件</em></p>\n</li>\n</ul>\n</li>\n<li><p>第三种压缩方式</p>\n<ul>\n<li><p><strong>zip</strong></p>\n<p>压缩：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">zip [-r] 目标文件(可以没有扩展名) 源文件</span><br><span class=\"line\"></span><br><span class=\"line\">zip myzip *</span><br></pre></td></tr></table></figure>\n\n<p>解压缩：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unzip -d 解压后目录文件 压缩文件</span><br><span class=\"line\"></span><br><span class=\"line\">unzip -d .&#x2F;xx myzip.zip</span><br></pre></td></tr></table></figure>\n\n<p><em>注意：不需要指定扩展名。默认zip</em></p>\n</li>\n</ul>\n</li>\n<li><p>三种比较</p>\n<p>gzip压缩最小，bzip居中，zip最大</p>\n</li>\n<li><p>解压 x</p>\n</li>\n</ol>\n<h2 id=\"2-文章权限\"><a href=\"#2-文章权限\" class=\"headerlink\" title=\"2. 文章权限\"></a>2. 文章权限</h2><ol>\n<li>权限表示</li>\n</ol>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/05/Screen-Shot-2020-02-05-at-3.01.40-PM.png\" alt=\"文章权限\"></p>\n<p>r（可读）、w（可写）、x（可执行）</p>\n<ol start=\"2\">\n<li><p>修改权限<strong>chmod</strong></p>\n<ul>\n<li><p>字母修改</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod u&#x3D;rwx,g&#x3D;rx,o&#x3D;r filename</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>数字修改</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod 751 filename</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p><strong>-R</strong>递归为目录下所有文件加权限</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod 777 test&#x2F; -R</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h2 id=\"3-流\"><a href=\"#3-流\" class=\"headerlink\" title=\"3. 流\"></a>3. 流</h2><ol>\n<li><p>Linux有三种流</p>\n<ul>\n<li><p>标准输出流：正常信息的输出，默认输出到屏幕上。</p>\n<p>标准错误输出流：错误的信息的输出，默认输出到屏幕上。</p>\n<p>标准输入流：向系统中输入数据，默认就是键盘输入的数据。</p>\n</li>\n<li><p>我们可以通过重定向的技术，把输出、输入的信息重定向到其它的地方去。比如，我们可以把系统中的错误信息输出到一个文件中去。</p>\n</li>\n<li><p>如：ls &gt; test.txt ( test.txt 如果不存在，则创建，存在则覆盖其内容 )</p>\n<p><em>注意:&gt;是覆盖原来的内容，&gt;&gt;是添加内容。（这是重定向）</em></p>\n</li>\n</ul>\n</li>\n<li><p>管道</p>\n<p>左边是写入信息，右边是读取左边的结果作为输入。</p>\n</li>\n</ol>\n<h2 id=\"4-链接文件-ln\"><a href=\"#4-链接文件-ln\" class=\"headerlink\" title=\"4. 链接文件 ln\"></a>4. 链接文件 ln</h2><ol>\n<li><p>硬链接</p>\n<p>文件有一个或者多个文件名。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ln 源文件 链接文件</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>软链接</p>\n<p>软链接不占用磁盘空间，源文件删除则软连接就会失效。相当于重命名。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ln -s 源文件 链接文件</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>关系</p>\n<ul>\n<li>软链接和硬链接都可以修改源文件内容，删除源文件后，硬链接仍然可以访问，软连接不可以，删除软连接就相当于删除了快捷方式，对源文件没有影响。</li>\n<li>软链接可以跨文件系统，硬链接不可以;</li>\n<li>软链接可以对一个不存在的文件名(filename)进行链接(当然此时如果你vi这个软链接文件，linux会自动新建一个文件名为filename的文件),硬链接不可以(其文件必须存在，inode必须存在);</li>\n<li>软链接可以对目录进行连接，硬链接不可以</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"5-文件内容搜索-grep\"><a href=\"#5-文件内容搜索-grep\" class=\"headerlink\" title=\"5. 文件内容搜索 grep\"></a>5. 文件内容搜索 grep</h2><ol>\n<li><p>一般格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grep [-选项] ‘搜索内容串’ 文件名（是对文件内容的搜索）</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>选项</p>\n<p>-V 显示不包含文本的所有行 -n 显示匹配行以及行号 -i 忽略大小写进行搜索</p>\n</li>\n<li><p>正则表达式</p>\n<p>^a 搜寻以a开头的行。</p>\n<p> ke$搜索以Ke结束的行。</p>\n<p>[Ss]nal[Ll]匹配[]中的任意一个。</p>\n<p>“.”匹配一个非换行符的字符。</p>\n</li>\n</ol>\n<h2 id=\"6-特定文件搜索-find\"><a href=\"#6-特定文件搜索-find\" class=\"headerlink\" title=\"6. 特定文件搜索 find\"></a>6. 特定文件搜索 find</h2><p>搜索符合条件的文件，搜索特定用户属主的文件。</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/05/find.png\" alt=\"find\"></p>\n<h2 id=\"7-特定命令搜索-which-is\"><a href=\"#7-特定命令搜索-which-is\" class=\"headerlink\" title=\"7. 特定命令搜索 which is\"></a>7. 特定命令搜索 which is</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">which is gcc</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"8-用户管理\"><a href=\"#8-用户管理\" class=\"headerlink\" title=\"8. 用户管理\"></a>8. 用户管理</h2><ol>\n<li><p>切换到管理员账号 sudo -s $显示为普通用户 #显示为管理员用户</p>\n</li>\n<li><p>设置用户密码：passwd  修改密码 sudo passwd 账户名</p>\n</li>\n<li><p>退出登录账户:exit </p>\n</li>\n<li><p>查看登录用户。</p>\n</li>\n</ol>\n<h2 id=\"9-关机重启\"><a href=\"#9-关机重启\" class=\"headerlink\" title=\"9. 关机重启\"></a>9. 关机重启</h2><ul>\n<li><p>关机重启：reboot、shutdown、init</p>\n<p>reboot    重新启动操作系统</p>\n<p>shutdown –r now    重新启动操作系统，shutdown会给别的用户提示</p>\n<p>shutdown -h now    立刻关机，其中now相当于时间为0的状态</p>\n<p>shutdown -h 20:25    系统在今天的20:25 会关机</p>\n<p>shutdown -h +10    系统再过十分钟后自动关机</p>\n</li>\n</ul>\n<h2 id=\"10-二分法\"><a href=\"#10-二分法\" class=\"headerlink\" title=\"10. 二分法\"></a>10. 二分法</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int l&#x3D;1,r&#x3D;ll;&#x2F;&#x2F; 1 是答案的最小值，ll是答案的最大值</span><br><span class=\"line\">    while(l&lt;&#x3D;r)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        int mid&#x3D;(l+r)&gt;&gt;1,q&#x3D;check(mid);&#x2F;&#x2F;“&gt;&gt;1”相当于“&#x2F;2”</span><br><span class=\"line\">        if(q&gt;m)r&#x3D;mid-1;</span><br><span class=\"line\">        else l&#x3D;mid+1;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>check()函数根据不同的题不一样，其他都是一样的</p>\n<ul>\n<li>二分查找</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">20</span>,<span class=\"number\">38</span>,<span class=\"number\">44</span>];</span><br><span class=\"line\">check = <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> l = <span class=\"number\">0</span>,r = a.length<span class=\"number\">-1</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(l &lt;= r)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> mid = (l + r) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(check &lt; a[mid])</span><br><span class=\"line\">        r = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        l = mid +<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(r);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>题目描述</li>\n</ul>\n<p>伐木工人米尔科需要砍倒M米长的木材。这是一个对米尔科来说很容易的工作，因为他有一个漂亮的新伐木机，可以像野火一样砍倒森林。不过，米尔科只被允许砍倒单行树木。</p>\n<p>米尔科的伐木机工作过程如下：米尔科设置一个高度参数H（米），伐木机升起一个巨大的锯片到高度H，并锯掉所有的树比H高的部分（当然，树木不高于H米的部分保持不变）。米尔科就行到树木被锯下的部分。</p>\n<p>例如，如果一行树的高度分别为20，15，10和17，米尔科把锯片升到15米的高度，切割后树木剩下的高度将是15，15，10和15，而米尔科将从第1棵树得到5米，从第4棵树得到2米，共得到7米木材。</p>\n<p>米尔科非常关注生态保护，所以他不会砍掉过多的木材。这正是他为什么尽可能高地设定伐木机锯片的原因。帮助米尔科找到伐木机锯片的最大的整数高度H，使得他能得到木材至少为M米。换句话说，如果再升高1米，则他将得不到M米木材。</p>\n<p>输入输出格式</p>\n<p>输入格式：<br>第1行：2个整数N和M，N表示树木的数量（1&lt;=N&lt;=1000000）,M表示需要的木材总长度（1&lt;=M&lt;=2000000000）</p>\n<p>第2行：N个整数表示每棵树的高度，值均不超过1000000000。所有木材长度之和大于M，因此必有解。</p>\n<p>输出格式：<br>第1行：1个整数，表示砍树的最高高度。</p>\n<p>输入输出样例</p>\n<p>输入样例#1：<br>5 20<br>4 42 40 26 46<br>输出样例#1：<br>36</p>\n<p>这个题的答案有明显的单调性，砍树的高度越低，得到的木材就越多，所以用二分在答案区间里找答案就行了。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> m,n,a[<span class=\"number\">1000005</span>],temp;<span class=\"comment\">//因为我菜，所以就全设成long long；</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> <span class=\"title\">check</span><span class=\"params\">(<span class=\"keyword\">long</span> <span class=\"keyword\">long</span> x)</span><span class=\"comment\">//这个check函数是二分的最重要的一环</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ans=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(a[i]&gt;x)</span><br><span class=\"line\">        ans=ans-x+a[i];<span class=\"comment\">//ans用来记录能够得到的木材长度</span></span><br><span class=\"line\">     &#125; </span><br><span class=\"line\">     <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>,&amp;n,&amp;m);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;a[i]);</span><br><span class=\"line\">        temp=<span class=\"built_in\">max</span>(temp,a[i]);<span class=\"comment\">//temp用来记录最高的树的高度</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> l=<span class=\"number\">1</span>,r=temp;<span class=\"comment\">//把右边界设成最高的树的高度</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(l&lt;=r)<span class=\"comment\">//二分操作</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> mid=(l+r)&gt;&gt;<span class=\"number\">1</span>,q=check(mid);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(q&lt;m)r=mid<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> l=mid+<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,r);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"11-终端替换某文本\"><a href=\"#11-终端替换某文本\" class=\"headerlink\" title=\"11. 终端替换某文本\"></a>11. 终端替换某文本</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sed -i &quot;&quot; &#39;s&#x2F;http:\\&#x2F;\\&#x2F;47.101.139.155:23333\\&#x2F;images&#x2F;https:\\&#x2F;\\&#x2F;img.cetacis.dev\\&#x2F;uploads&#x2F;g&#39; &#96;grep &quot;http:\\&#x2F;\\&#x2F;47.101.139.155:23333\\&#x2F;images&quot; -rl .&#96;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"12-对集合的二进制表示\"><a href=\"#12-对集合的二进制表示\" class=\"headerlink\" title=\"12. 对集合的二进制表示\"></a>12. 对集合的二进制表示</h2><p><a href=\"https://www.cnblogs.com/astonc/p/10859115.html\" target=\"_blank\" rel=\"noopener\">引用网站</a></p>\n<h2 id=\"13-ping\"><a href=\"#13-ping\" class=\"headerlink\" title=\"13. ping\"></a>13. ping</h2><p><strong>1）</strong>假设有两个主机，主机A（192.168.0.1）和主机B（192.168.0.2），现在我们要监测主机A和主机B之间网络是否可达，那么我们在主机A上输入命令：ping 192.168.0.2；</p>\n<p><strong>2）</strong>此时，ping命令会在主机A上构建一个 ICMP的请求数据包（数据包里的内容后面再详述），然后 ICMP协议会将这个数据包以及目标IP（192.168.0.2）等信息一同交给IP层协议；</p>\n<p><strong>3）</strong>IP层协议得到这些信息后，将源地址（即本机IP）、目标地址（即目标IP：192.168.0.2）、再加上一些其它的控制信息，构建成一个IP数据包；</p>\n<p><strong>4）</strong>IP数据包构建完成后，还不够，还需要加上MAC地址，因此，还需要通过ARP映射表找出目标IP所对应的MAC地址。当拿到了目标主机的MAC地址和本机MAC后，一并交给数据链路层，组装成一个数据帧，依据以太网的介质访问规则，将它们传送出出去；</p>\n<p><strong>5）</strong>当主机B收到这个数据帧之后，会首先检查它的C目标MAC地址是不是本机，如果是就接收下来处理，接收之后会检查这个数据帧，将数据帧中的IP数据包取出来，交给本机的IP层协议，然后IP层协议检查完之后，再将ICMP数据包取出来交给ICMP协议处理，当这一步也处理完成之后，就会构建一个ICMP应答数据包，回发给主机A；</p>\n<p><strong>6）</strong>在一定的时间内，如果主机A收到了应答包，则说明它与主机B之间网络可达，如果没有收到，则说明网络不可达。除了监测是否可达以外，还可以利用应答时间和发起时间之间的差值，计算出数据包的延迟耗时。</p>\n<h2 id=\"14-域名解析\"><a href=\"#14-域名解析\" class=\"headerlink\" title=\"14. 域名解析\"></a>14. 域名解析</h2><p>MX 邮箱服务  txt spf mx</p>\n<p>NS指定域名解析服务器</p>\n<p>cname  证明域名拥有权</p>\n<p>TXT 验证记录</p>\n<p>*A ipv4</p>\n<p>AAAA ipv6sp</p>\n<p>anti-spam：防止垃圾邮件</p>\n<ul>\n<li><p><a href=\"https://help.aliyun.com/knowledge_detail/29725.html\" target=\"_blank\" rel=\"noopener\">阿里云文档：添加解析记录</a></p>\n</li>\n<li><p><a href=\"https://blog.51cto.com/xsboke/2115548\" target=\"_blank\" rel=\"noopener\">CloudFlare API：批量添加域名并添加解析记录</a></p>\n</li>\n<li><p><strong>dns系统</strong></p>\n<p>Internet 上的所有计算机，从您的智能手机或笔记本电脑到可提供大量零售网站内容的服务器，均通过使用编号寻找另一方并相互通信。这些编号称为 <strong>IP 地址</strong>。当您打开 Web 浏览器并前往一个网站时，您不必记住和输入长编号。而是输入<strong>域名</strong> (入 example.com)，然后在正确的位置结束。</p>\n<p>Amazon Route 53 等 DNS 服务是一种全球分布式服务，它将人类可读的名称 (如 <a href=\"http://www.example.com\" target=\"_blank\" rel=\"noopener\">www.example.com</a>) 转换为数字 IP 地址 (如 192.0.2.1)，供计算机用于相互连接。Internet 的 DNS 系统的工作原理和电话簿相似，都是管理名称和数字之间的映射关系。DNS 服务器可以将名称请求转换为 IP 地址，从而控制最终用户在 Web 浏览器中输入域名时所访问的服务器。这些请求称为<strong>查询</strong>。</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/f443431781d872c8d466bc245975729d.png\" alt=\"dns将流量路由到我的web程序\"></p>\n</li>\n</ul>\n<ol>\n<li>用户打开 Web 浏览器，在地址栏中输入 <a href=\"http://www.example.com，然后按\" target=\"_blank\" rel=\"noopener\">www.example.com，然后按</a> Enter 键。</li>\n<li><a href=\"http://www.example.com\" target=\"_blank\" rel=\"noopener\">www.example.com</a> 的请求被路由到 DNS 解析程序，这一般由用户的 Internet 服务提供商 (ISP) 进行管理，例如有线 Internet 服务提供商、DSL 宽带提供商或公司网络。</li>\n<li>ISP 的 DNS 解析程序将 <a href=\"http://www.example.com\" target=\"_blank\" rel=\"noopener\">www.example.com</a> 的请求转发到 DNS 根名称服务器。</li>\n<li>ISP 的 DNS 解析程序再次转发 <a href=\"http://www.example.com\" target=\"_blank\" rel=\"noopener\">www.example.com</a> 的请求，这次转发到 .com 域的一个 TLD 名称服务器。.com 域的名称服务器使用与 example.com 域相关的四个 Amazon Route 53 名称服务器的名称来响应该请求。</li>\n<li>ISP 的 DNS 解析程序选择一个 Amazon Route 53 名称服务器，并将 <a href=\"http://www.example.com\" target=\"_blank\" rel=\"noopener\">www.example.com</a> 的请求转发到该名称服务器。</li>\n<li>Amazon Route 53 名称服务器在 example.com 托管区域中查找 <a href=\"http://www.example.com\" target=\"_blank\" rel=\"noopener\">www.example.com</a> 记录，获得相关值，例如，Web 服务器的 IP 地址 (192.0.2.44)，并将 IP 地址返回至 DNS 解析程序。</li>\n<li>ISP 的 DNS 解析程序最终获得用户需要的 IP 地址。解析程序将此值返回至 Web 浏览器。DNS 解析程序还会将 example.com 的 IP 地址缓存 (存储) 您指定的时长，以便它能够在下次有人浏览 example.com 时更快地作出响应。有关更多信息，请参阅存活期 (TTL)。</li>\n<li>Web 浏览器将 <a href=\"http://www.example.com\" target=\"_blank\" rel=\"noopener\">www.example.com</a> 的请求发送到从 DNS 解析程序中获得的 IP 地址。这是您的内容所处位置，例如，在 Amazon EC2 实例中或配置为网站终端节点的 Amazon S3 存储桶中运行的 Web 服务器。</li>\n<li>192.0.2.44 上的 Web 服务器或其他资源将 <a href=\"http://www.example.com\" target=\"_blank\" rel=\"noopener\">www.example.com</a> 的 Web 页面返回到 Web 浏览器，且 Web 浏览器会显示该页面。</li>\n</ol>\n<ul>\n<li><p><strong>json</strong></p>\n<p>一种轻量级数据交换结构</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> json = <span class=\"string\">'&#123;\"a\": \"Hello\", \"b\": \"World\"&#125;'</span>;</span><br></pre></td></tr></table></figure>\n\n<p>作用：</p>\n<p>简单地说，JSON 可以将 JavaScript 对象中表示的一组数据转换为字符串，然后就可以在网络或者程序之间轻松地传递这个字符串，并在需要的时候将它还原为各编程语言所支持的数据格式，例如在 PHP 中，可以将 JSON 还原为数组或者一个基本对象。在用到AJAX时，如果需要用到数组传值，这时就需要用JSON将数组转化为字符串。</p>\n<ul>\n<li>表示对象</li>\n</ul>\n<p>对象是一个无序的“‘名称/值’对”集合。一个对象以{左括号开始，}右括号结束。每个“名称”后跟一个:冒号；“‘名称/值’ 对”之间使用,逗号分隔。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">`&#123;`</span><span class=\"string\">`\"firstName\"`</span><span class=\"string\">`: `</span><span class=\"string\">`\"Brett\"`</span><span class=\"string\">`, `</span><span class=\"string\">`\"lastName\"`</span><span class=\"string\">`: `</span><span class=\"string\">`\"McLaughlin\"`</span><span class=\"string\">`&#125;                                        `</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>表示数组</li>\n</ul>\n<p>和普通的 JS 数组一样，JSON 表示数组的方式也是使用方括号 []。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">`&#123; `</span><span class=\"string\">`\"people\":[ `</span><span class=\"string\">`&#123;`</span><span class=\"string\">`\"firstName\": \"Brett\",            `</span><span class=\"string\">`\"lastName\":\"McLaughlin\"        `</span><span class=\"string\">`&#125;,      `</span><span class=\"string\">`&#123;        `</span><span class=\"string\">`\"firstName\":\"Jason\",`</span><span class=\"string\">`\"lastName\":\"Hunter\"`</span><span class=\"string\">`&#125;`</span><span class=\"string\">`]`</span><span class=\"string\">`&#125;`</span></span><br></pre></td></tr></table></figure>\n\n<p>这不难理解。在这个示例中，只有一个名为 people的变量，值是包含两个条目的数组，每个条目是一个人的记录，其中包含名和姓。上面的示例演示如何用括号将记录组合成一个值。当然，可以使用相同的语法表示更过多的值（每个值包含多个记录）。</p>\n<ul>\n<li><p>要实现从JSON字符串转换为JS对象，使用 JSON.parse() 方法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">`var`</span> <span class=\"string\">`obj = JSON.parse(`</span><span class=\"string\">`'&#123;\"a\": \"Hello\", \"b\": \"World\"&#125;'`</span><span class=\"string\">`); `</span><span class=\"string\">`//结果是 &#123;a: 'Hello', b: 'World'&#125;`</span></span><br></pre></td></tr></table></figure>\n\n<p>要实现从JS对象转换为JSON字符串，使用 JSON.stringify() 方法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">`var`</span> <span class=\"string\">`json = JSON.stringify(&#123;a: `</span><span class=\"string\">`'Hello'`</span><span class=\"string\">`, b: `</span><span class=\"string\">`'World'`</span><span class=\"string\">`&#125;); `</span><span class=\"string\">`//结果是 '&#123;\"a\": \"Hello\", \"b\": \"World\"&#125;'`</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"15-telegram-bot-nginx\"><a href=\"#15-telegram-bot-nginx\" class=\"headerlink\" title=\"15. telegram bot nginx\"></a>15. telegram bot nginx</h2><p>鉴权 -&gt;链接cf -&gt;看cf 的 api</p>\n<ul>\n<li><p><a href=\"https://api.cloudflare.com\" target=\"_blank\" rel=\"noopener\">https://api.cloudflare.com</a> ：cloudflare ‘s api ：看网站</p>\n<p>目标：增加A记录（API token）</p>\n</li>\n<li><p>bot api </p>\n<p>git源码 <a href=\"https://github.com/yagop/node-telegram-bot-api\" target=\"_blank\" rel=\"noopener\">https://github.com/yagop/node-telegram-bot-api</a></p>\n<p>参考blog  <a href=\"https://segmentfault.com/a/1190000018716076\" target=\"_blank\" rel=\"noopener\">建立 telegram bot and nginx</a>    </p>\n</li>\n</ul>\n<h2 id=\"16-正则表达式\"><a href=\"#16-正则表达式\" class=\"headerlink\" title=\"16. 正则表达式\"></a>16. 正则表达式</h2><p>正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。</p>\n<ul>\n<li>非打印字符</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>\\cx</th>\n<th>匹配由x指明的控制字符。例如， \\cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>\\f</td>\n<td>匹配一个换页符。等价于 \\x0c 和 \\cL。</td>\n</tr>\n<tr>\n<td>\\n</td>\n<td>匹配一个换行符。等价于 \\x0a 和 \\cJ。</td>\n</tr>\n<tr>\n<td>\\r</td>\n<td>匹配一个回车符。等价于 \\x0d 和 \\cM。</td>\n</tr>\n<tr>\n<td>\\s</td>\n<td>匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。注意 Unicode 正则表达式会匹配全角空格符。</td>\n</tr>\n<tr>\n<td>\\S</td>\n<td>匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。</td>\n</tr>\n<tr>\n<td>\\t</td>\n<td>匹配一个制表符。等价于 \\x09 和 \\cI。</td>\n</tr>\n<tr>\n<td>\\v</td>\n<td>匹配一个垂直制表符。等价于 \\x0b 和 \\cK。</td>\n</tr>\n</tbody></table>\n<ul>\n<li>特殊字符</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>$</th>\n<th>匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\\n’ 或 ‘\\r’。要匹配 $ 字符本身，请使用  \\$。</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>( )</td>\n<td>标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 \\( 和\\ )。</td>\n</tr>\n<tr>\n<td>*</td>\n<td>匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 \\*。</td>\n</tr>\n<tr>\n<td>+</td>\n<td>匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 \\+。</td>\n</tr>\n<tr>\n<td>.</td>\n<td>匹配除换行符 \\n 之外的任何单字符。要匹配 . ，请使用 \\. 。</td>\n</tr>\n<tr>\n<td>[</td>\n<td>标记一个中括号表达式的开始。要匹配 [，请使用 \\[。</td>\n</tr>\n<tr>\n<td>?</td>\n<td>匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 ?。</td>\n</tr>\n<tr>\n<td>\\</td>\n<td>将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\\n’ 匹配换行符。序列 ‘\\\\‘ 匹配 “\\“，而 ‘\\(‘ 则匹配 “(“。</td>\n</tr>\n<tr>\n<td>^</td>\n<td>匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 ^。</td>\n</tr>\n<tr>\n<td>{</td>\n<td>标记限定符表达式的开始。要匹配 {，请使用 \\{。</td>\n</tr>\n<tr>\n<td>|</td>\n<td>指明两项之间的一个选择。要匹配 |，请使用 \\</td>\n</tr>\n</tbody></table>\n<ul>\n<li>限定符</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>*</th>\n<th>匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>+</td>\n<td>匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td>\n</tr>\n<tr>\n<td>?</td>\n<td>匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 、 “does” 中的 “does” 、 “doxy” 中的 “do” 。? 等价于 {0,1}。</td>\n</tr>\n<tr>\n<td>{n}</td>\n<td>n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td>\n</tr>\n<tr>\n<td>{n,}</td>\n<td>n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。</td>\n</tr>\n<tr>\n<td>{n,m}</td>\n<td>m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。```</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;[0-9]&#123;1,2&#125;&#x2F;    # 至少一位至多两位的数字，设置0-99 缺点在于</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1-9]?[0-9]   ￥</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>贪婪非贪婪：</p>\n<p>* 是贪婪的，他会尽可能多的匹配字符。比如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h1&gt;123&lt;&#x2F;h1&gt;</span><br></pre></td></tr></table></figure>\n\n<p>如果用&lt;.*&gt;匹配，他会把<h1>123</h1>全匹配上（贪婪）</p>\n<p>如果同&lt;.*?&gt;匹配，只会匹配<h1>（非贪婪：最小匹配）</p>\n</li>\n<li><p>定位符</p>\n</li>\n</ul>\n<p>定位符用来描述字符串或单词的边界，<strong>^</strong> 和 <strong>$</strong> 分别指字符串的开始与结束，<strong>\\b</strong> 描述单词的前或后边界，<strong>\\B</strong> 表示非单词边界。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">字符</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">^</td>\n<td align=\"left\">匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \\n 或 \\r 之后的位置匹配。</td>\n</tr>\n<tr>\n<td align=\"left\">$</td>\n<td align=\"left\">匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \\n 或 \\r 之前的位置匹配。</td>\n</tr>\n<tr>\n<td align=\"left\">\\b</td>\n<td align=\"left\">匹配一个单词边界，即字与空格间的位置。</td>\n</tr>\n<tr>\n<td align=\"left\">\\B</td>\n<td align=\"left\">非单词边界匹配。</td>\n</tr>\n</tbody></table>\n<p>若要在搜索章节标题时使用定位点，下面的正则表达式匹配一个章节标题，该标题只包含两个尾随数字，并且出现在行首：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;^Chapter [1-9][0-9]&#123;0,1&#125;&#x2F;</span><br></pre></td></tr></table></figure>\n\n<p>真正的章节标题不仅出现行的开始处，而且它还是该行中仅有的文本。它即出现在行首又出现在同一行的结尾。下面的表达式能确保指定的匹配只匹配章节而不匹配交叉引用。通过创建只匹配一行文本的开始和结尾的正则表达式，就可做到这一点。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;^Chapter [1-9][0-9]&#123;0,1&#125;$&#x2F;</span><br></pre></td></tr></table></figure>\n\n<p>匹配单词边界稍有不同，但向正则表达式添加了很重要的能力。单词边界是单词和空格之间的位置。非单词边界是任何其他位置。下面的表达式匹配单词 Chapter 的开头三个字符，因为这三个字符出现在单词边界后面：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;\\bCha&#x2F;</span><br></pre></td></tr></table></figure>\n\n<p><strong>\\b</strong> 字符的位置是非常重要的。如果它位于要匹配的字符串的开始，它在单词的开始处查找匹配项。如果它位于字符串的结尾，它在单词的结尾处查找匹配项。例如，下面的表达式匹配单词 Chapter 中的字符串 ter，因为它出现在单词边界的前面：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;ter\\b&#x2F;</span><br></pre></td></tr></table></figure>\n\n<p>下面的表达式匹配 Chapter 中的字符串 apt，但不匹配 aptitude 中的字符串 apt：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;\\Bapt&#x2F;</span><br></pre></td></tr></table></figure>\n\n<p>字符串 apt 出现在单词 Chapter 中的非单词边界处，但出现在单词 aptitude 中的单词边界处。对于 <strong>\\B</strong> 非单词边界运算符，位置并不重要，因为匹配不关心究竟是单词的开头还是结尾。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">\"http://www.runoob.com:80/html/html-tutorial.html\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> patt1 = <span class=\"regexp\">/(\\w+):\\/\\/([^/:]+)(:\\d*)?([^# ]*)/</span>;</span><br><span class=\"line\">arr = str.match(patt1);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; arr.length ; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.write(arr[i]);</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.write(<span class=\"string\">\"&lt;br&gt;\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>第三行代码 <strong>str.match(patt1)</strong> 返回一个数组，实例中的数组包含 5 个元素，索引 0 对应的是整个字符串，索引 1 对应第一个匹配符（括号内），以此类推。</p>\n<p>第一个括号子表达式捕获 Web 地址的协议部分。该子表达式匹配在冒号和两个正斜杠前面的任何单词。</p>\n<p>第二个括号子表达式捕获地址的域地址部分。子表达式匹配非 <strong>:</strong> 和 <strong>/</strong> 之后的一个或多个字符。</p>\n<p>第三个括号子表达式捕获端口号（如果指定了的话）。该子表达式匹配冒号后面的零个或多个数字。只能重复一次该子表达式。</p>\n<p>最后，第四个括号子表达式捕获 Web 地址指定的路径和 / 或页信息。该子表达式能匹配不包括 # 或空格字符的任何字符序列。</p>\n<p>将正则表达式应用到上面的 URI，各子匹配项包含下面的内容：</p>\n<ul>\n<li>第一个括号子表达式包含 <strong>http</strong></li>\n<li>第二个括号子表达式包含 <strong><a href=\"http://www.runoob.com\" target=\"_blank\" rel=\"noopener\">www.runoob.com</a></strong></li>\n<li>第三个括号子表达式包含 <strong>:80</strong></li>\n<li>第四个括号子表达式包含 <strong>/html/html-tutorial.html</strong></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"1-终端压缩\"><a href=\"#1-终端压缩\" class=\"headerlink\" title=\"1. 终端压缩\"></a>1. 终端压缩</h2><ol>\n<li><p>第一种压缩方式</p>\n<ul>\n<li><p><strong>tar - 归档命令</strong> </p>\n<p>多文件归档：    tar  [参数]  打包文件名  文件1 文件2</p>\n<p>目录归档：      tar  [参数]  打包文件名  目录</p>\n<p>-c    生成档案文件，创建打包文件</p>\n<p>-v    列出归档解档的详细过程，显示进度</p>\n<p>-f    指定档案文件名称，f后面一定是.tar文件，<strong>所以必须放选项最后</strong></p>\n<p>-t    列出档案中包含的文件</p>\n<p>-x    解开档案文件</p>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -cvf test.tar * # 将当前目录下的所有文件打包归档</span><br><span class=\"line\"></span><br><span class=\"line\">tar -xvf test.tar # 将tar文件解开</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>gzip - 文件压缩解压</strong></p>\n<p>tar和gzip结合实现文件打包、压缩。扩展名一般为XXX.tar.gz</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gzip  [选项]  被压缩文件</span><br><span class=\"line\"></span><br><span class=\"line\">gzip xx.tar        压缩</span><br><span class=\"line\"></span><br><span class=\"line\">gzip -r xx.tar xx.tar.gz  压缩这个文件的所有子目录，不包括这个文件</span><br><span class=\"line\"></span><br><span class=\"line\">gzip -d xx.tar.gz  解压</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>tar -z</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar zcvf 压缩包包名 文件1 文件2 ...</span><br><span class=\"line\"></span><br><span class=\"line\">-z ：指定压缩包的格式为：file.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\">tar -zcvf test.tar.gz * 将当前路径下所有的文件以及文件夹打包并压缩到test.tar.gz中。</span><br><span class=\"line\"></span><br><span class=\"line\">tar -zxvf test.tar.gz解压到当前路径下</span><br><span class=\"line\"></span><br><span class=\"line\">tar -zxvf test.tar.gz -C xx 解压到指定路径下。</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>第二种压缩方式</p>\n<ul>\n<li><p><strong>bzip2</strong></p>\n<p>  压缩: </p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bzip2 filename ---&gt; 删除filename文件，生成 filename.bz2</span><br></pre></td></tr></table></figure>\n\n<p>  解压缩：</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bzip2 -d filename.bz2 ---&gt; 删除filename.bz2 ，生成 filename文件</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>tar + bzip2</strong>（tar -jcvf）</p>\n<p>  扩展名：XXX.tar.gz2</p>\n<p>  压缩：</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -jcvf 压缩包包名 文件...(tar jcvf bk.tar.bz2 *)</span><br></pre></td></tr></table></figure>\n\n<p>  解压缩：</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -jxvf 压缩包包名 (tar jxvf bk.tar.bz2)</span><br></pre></td></tr></table></figure>\n\n<p>  <em>注意：上述方式压缩后保留源文件，解压后保留压缩文件</em></p>\n</li>\n</ul>\n</li>\n<li><p>第三种压缩方式</p>\n<ul>\n<li><p><strong>zip</strong></p>\n<p>压缩：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">zip [-r] 目标文件(可以没有扩展名) 源文件</span><br><span class=\"line\"></span><br><span class=\"line\">zip myzip *</span><br></pre></td></tr></table></figure>\n\n<p>解压缩：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unzip -d 解压后目录文件 压缩文件</span><br><span class=\"line\"></span><br><span class=\"line\">unzip -d .&#x2F;xx myzip.zip</span><br></pre></td></tr></table></figure>\n\n<p><em>注意：不需要指定扩展名。默认zip</em></p>\n</li>\n</ul>\n</li>\n<li><p>三种比较</p>\n<p>gzip压缩最小，bzip居中，zip最大</p>\n</li>\n<li><p>解压 x</p>\n</li>\n</ol>\n<h2 id=\"2-文章权限\"><a href=\"#2-文章权限\" class=\"headerlink\" title=\"2. 文章权限\"></a>2. 文章权限</h2><ol>\n<li>权限表示</li>\n</ol>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/05/Screen-Shot-2020-02-05-at-3.01.40-PM.png\" alt=\"文章权限\"></p>\n<p>r（可读）、w（可写）、x（可执行）</p>\n<ol start=\"2\">\n<li><p>修改权限<strong>chmod</strong></p>\n<ul>\n<li><p>字母修改</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod u&#x3D;rwx,g&#x3D;rx,o&#x3D;r filename</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>数字修改</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod 751 filename</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p><strong>-R</strong>递归为目录下所有文件加权限</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod 777 test&#x2F; -R</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h2 id=\"3-流\"><a href=\"#3-流\" class=\"headerlink\" title=\"3. 流\"></a>3. 流</h2><ol>\n<li><p>Linux有三种流</p>\n<ul>\n<li><p>标准输出流：正常信息的输出，默认输出到屏幕上。</p>\n<p>标准错误输出流：错误的信息的输出，默认输出到屏幕上。</p>\n<p>标准输入流：向系统中输入数据，默认就是键盘输入的数据。</p>\n</li>\n<li><p>我们可以通过重定向的技术，把输出、输入的信息重定向到其它的地方去。比如，我们可以把系统中的错误信息输出到一个文件中去。</p>\n</li>\n<li><p>如：ls &gt; test.txt ( test.txt 如果不存在，则创建，存在则覆盖其内容 )</p>\n<p><em>注意:&gt;是覆盖原来的内容，&gt;&gt;是添加内容。（这是重定向）</em></p>\n</li>\n</ul>\n</li>\n<li><p>管道</p>\n<p>左边是写入信息，右边是读取左边的结果作为输入。</p>\n</li>\n</ol>\n<h2 id=\"4-链接文件-ln\"><a href=\"#4-链接文件-ln\" class=\"headerlink\" title=\"4. 链接文件 ln\"></a>4. 链接文件 ln</h2><ol>\n<li><p>硬链接</p>\n<p>文件有一个或者多个文件名。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ln 源文件 链接文件</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>软链接</p>\n<p>软链接不占用磁盘空间，源文件删除则软连接就会失效。相当于重命名。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ln -s 源文件 链接文件</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>关系</p>\n<ul>\n<li>软链接和硬链接都可以修改源文件内容，删除源文件后，硬链接仍然可以访问，软连接不可以，删除软连接就相当于删除了快捷方式，对源文件没有影响。</li>\n<li>软链接可以跨文件系统，硬链接不可以;</li>\n<li>软链接可以对一个不存在的文件名(filename)进行链接(当然此时如果你vi这个软链接文件，linux会自动新建一个文件名为filename的文件),硬链接不可以(其文件必须存在，inode必须存在);</li>\n<li>软链接可以对目录进行连接，硬链接不可以</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"5-文件内容搜索-grep\"><a href=\"#5-文件内容搜索-grep\" class=\"headerlink\" title=\"5. 文件内容搜索 grep\"></a>5. 文件内容搜索 grep</h2><ol>\n<li><p>一般格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grep [-选项] ‘搜索内容串’ 文件名（是对文件内容的搜索）</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>选项</p>\n<p>-V 显示不包含文本的所有行 -n 显示匹配行以及行号 -i 忽略大小写进行搜索</p>\n</li>\n<li><p>正则表达式</p>\n<p>^a 搜寻以a开头的行。</p>\n<p> ke$搜索以Ke结束的行。</p>\n<p>[Ss]nal[Ll]匹配[]中的任意一个。</p>\n<p>“.”匹配一个非换行符的字符。</p>\n</li>\n</ol>\n<h2 id=\"6-特定文件搜索-find\"><a href=\"#6-特定文件搜索-find\" class=\"headerlink\" title=\"6. 特定文件搜索 find\"></a>6. 特定文件搜索 find</h2><p>搜索符合条件的文件，搜索特定用户属主的文件。</p>\n<p><img src=\"https://img.cetacis.dev/uploads/2020/02/05/find.png\" alt=\"find\"></p>\n<h2 id=\"7-特定命令搜索-which-is\"><a href=\"#7-特定命令搜索-which-is\" class=\"headerlink\" title=\"7. 特定命令搜索 which is\"></a>7. 特定命令搜索 which is</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">which is gcc</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"8-用户管理\"><a href=\"#8-用户管理\" class=\"headerlink\" title=\"8. 用户管理\"></a>8. 用户管理</h2><ol>\n<li><p>切换到管理员账号 sudo -s $显示为普通用户 #显示为管理员用户</p>\n</li>\n<li><p>设置用户密码：passwd  修改密码 sudo passwd 账户名</p>\n</li>\n<li><p>退出登录账户:exit </p>\n</li>\n<li><p>查看登录用户。</p>\n</li>\n</ol>\n<h2 id=\"9-关机重启\"><a href=\"#9-关机重启\" class=\"headerlink\" title=\"9. 关机重启\"></a>9. 关机重启</h2><ul>\n<li><p>关机重启：reboot、shutdown、init</p>\n<p>reboot    重新启动操作系统</p>\n<p>shutdown –r now    重新启动操作系统，shutdown会给别的用户提示</p>\n<p>shutdown -h now    立刻关机，其中now相当于时间为0的状态</p>\n<p>shutdown -h 20:25    系统在今天的20:25 会关机</p>\n<p>shutdown -h +10    系统再过十分钟后自动关机</p>\n</li>\n</ul>\n<h2 id=\"10-二分法\"><a href=\"#10-二分法\" class=\"headerlink\" title=\"10. 二分法\"></a>10. 二分法</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int l&#x3D;1,r&#x3D;ll;&#x2F;&#x2F; 1 是答案的最小值，ll是答案的最大值</span><br><span class=\"line\">    while(l&lt;&#x3D;r)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        int mid&#x3D;(l+r)&gt;&gt;1,q&#x3D;check(mid);&#x2F;&#x2F;“&gt;&gt;1”相当于“&#x2F;2”</span><br><span class=\"line\">        if(q&gt;m)r&#x3D;mid-1;</span><br><span class=\"line\">        else l&#x3D;mid+1;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>check()函数根据不同的题不一样，其他都是一样的</p>\n<ul>\n<li>二分查找</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">20</span>,<span class=\"number\">38</span>,<span class=\"number\">44</span>];</span><br><span class=\"line\">check = <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> l = <span class=\"number\">0</span>,r = a.length<span class=\"number\">-1</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(l &lt;= r)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> mid = (l + r) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(check &lt; a[mid])</span><br><span class=\"line\">        r = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        l = mid +<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(r);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>题目描述</li>\n</ul>\n<p>伐木工人米尔科需要砍倒M米长的木材。这是一个对米尔科来说很容易的工作，因为他有一个漂亮的新伐木机，可以像野火一样砍倒森林。不过，米尔科只被允许砍倒单行树木。</p>\n<p>米尔科的伐木机工作过程如下：米尔科设置一个高度参数H（米），伐木机升起一个巨大的锯片到高度H，并锯掉所有的树比H高的部分（当然，树木不高于H米的部分保持不变）。米尔科就行到树木被锯下的部分。</p>\n<p>例如，如果一行树的高度分别为20，15，10和17，米尔科把锯片升到15米的高度，切割后树木剩下的高度将是15，15，10和15，而米尔科将从第1棵树得到5米，从第4棵树得到2米，共得到7米木材。</p>\n<p>米尔科非常关注生态保护，所以他不会砍掉过多的木材。这正是他为什么尽可能高地设定伐木机锯片的原因。帮助米尔科找到伐木机锯片的最大的整数高度H，使得他能得到木材至少为M米。换句话说，如果再升高1米，则他将得不到M米木材。</p>\n<p>输入输出格式</p>\n<p>输入格式：<br>第1行：2个整数N和M，N表示树木的数量（1&lt;=N&lt;=1000000）,M表示需要的木材总长度（1&lt;=M&lt;=2000000000）</p>\n<p>第2行：N个整数表示每棵树的高度，值均不超过1000000000。所有木材长度之和大于M，因此必有解。</p>\n<p>输出格式：<br>第1行：1个整数，表示砍树的最高高度。</p>\n<p>输入输出样例</p>\n<p>输入样例#1：<br>5 20<br>4 42 40 26 46<br>输出样例#1：<br>36</p>\n<p>这个题的答案有明显的单调性，砍树的高度越低，得到的木材就越多，所以用二分在答案区间里找答案就行了。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> m,n,a[<span class=\"number\">1000005</span>],temp;<span class=\"comment\">//因为我菜，所以就全设成long long；</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> <span class=\"title\">check</span><span class=\"params\">(<span class=\"keyword\">long</span> <span class=\"keyword\">long</span> x)</span><span class=\"comment\">//这个check函数是二分的最重要的一环</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ans=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(a[i]&gt;x)</span><br><span class=\"line\">        ans=ans-x+a[i];<span class=\"comment\">//ans用来记录能够得到的木材长度</span></span><br><span class=\"line\">     &#125; </span><br><span class=\"line\">     <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>,&amp;n,&amp;m);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;a[i]);</span><br><span class=\"line\">        temp=<span class=\"built_in\">max</span>(temp,a[i]);<span class=\"comment\">//temp用来记录最高的树的高度</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> l=<span class=\"number\">1</span>,r=temp;<span class=\"comment\">//把右边界设成最高的树的高度</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(l&lt;=r)<span class=\"comment\">//二分操作</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> mid=(l+r)&gt;&gt;<span class=\"number\">1</span>,q=check(mid);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(q&lt;m)r=mid<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> l=mid+<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,r);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"11-终端替换某文本\"><a href=\"#11-终端替换某文本\" class=\"headerlink\" title=\"11. 终端替换某文本\"></a>11. 终端替换某文本</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sed -i &quot;&quot; &#39;s&#x2F;http:\\&#x2F;\\&#x2F;47.101.139.155:23333\\&#x2F;images&#x2F;https:\\&#x2F;\\&#x2F;img.cetacis.dev\\&#x2F;uploads&#x2F;g&#39; &#96;grep &quot;http:\\&#x2F;\\&#x2F;47.101.139.155:23333\\&#x2F;images&quot; -rl .&#96;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"12-对集合的二进制表示\"><a href=\"#12-对集合的二进制表示\" class=\"headerlink\" title=\"12. 对集合的二进制表示\"></a>12. 对集合的二进制表示</h2><p><a href=\"https://www.cnblogs.com/astonc/p/10859115.html\" target=\"_blank\" rel=\"noopener\">引用网站</a></p>\n<h2 id=\"13-ping\"><a href=\"#13-ping\" class=\"headerlink\" title=\"13. ping\"></a>13. ping</h2><p><strong>1）</strong>假设有两个主机，主机A（192.168.0.1）和主机B（192.168.0.2），现在我们要监测主机A和主机B之间网络是否可达，那么我们在主机A上输入命令：ping 192.168.0.2；</p>\n<p><strong>2）</strong>此时，ping命令会在主机A上构建一个 ICMP的请求数据包（数据包里的内容后面再详述），然后 ICMP协议会将这个数据包以及目标IP（192.168.0.2）等信息一同交给IP层协议；</p>\n<p><strong>3）</strong>IP层协议得到这些信息后，将源地址（即本机IP）、目标地址（即目标IP：192.168.0.2）、再加上一些其它的控制信息，构建成一个IP数据包；</p>\n<p><strong>4）</strong>IP数据包构建完成后，还不够，还需要加上MAC地址，因此，还需要通过ARP映射表找出目标IP所对应的MAC地址。当拿到了目标主机的MAC地址和本机MAC后，一并交给数据链路层，组装成一个数据帧，依据以太网的介质访问规则，将它们传送出出去；</p>\n<p><strong>5）</strong>当主机B收到这个数据帧之后，会首先检查它的C目标MAC地址是不是本机，如果是就接收下来处理，接收之后会检查这个数据帧，将数据帧中的IP数据包取出来，交给本机的IP层协议，然后IP层协议检查完之后，再将ICMP数据包取出来交给ICMP协议处理，当这一步也处理完成之后，就会构建一个ICMP应答数据包，回发给主机A；</p>\n<p><strong>6）</strong>在一定的时间内，如果主机A收到了应答包，则说明它与主机B之间网络可达，如果没有收到，则说明网络不可达。除了监测是否可达以外，还可以利用应答时间和发起时间之间的差值，计算出数据包的延迟耗时。</p>\n<h2 id=\"14-域名解析\"><a href=\"#14-域名解析\" class=\"headerlink\" title=\"14. 域名解析\"></a>14. 域名解析</h2><p>MX 邮箱服务  txt spf mx</p>\n<p>NS指定域名解析服务器</p>\n<p>cname  证明域名拥有权</p>\n<p>TXT 验证记录</p>\n<p>*A ipv4</p>\n<p>AAAA ipv6sp</p>\n<p>anti-spam：防止垃圾邮件</p>\n<ul>\n<li><p><a href=\"https://help.aliyun.com/knowledge_detail/29725.html\" target=\"_blank\" rel=\"noopener\">阿里云文档：添加解析记录</a></p>\n</li>\n<li><p><a href=\"https://blog.51cto.com/xsboke/2115548\" target=\"_blank\" rel=\"noopener\">CloudFlare API：批量添加域名并添加解析记录</a></p>\n</li>\n<li><p><strong>dns系统</strong></p>\n<p>Internet 上的所有计算机，从您的智能手机或笔记本电脑到可提供大量零售网站内容的服务器，均通过使用编号寻找另一方并相互通信。这些编号称为 <strong>IP 地址</strong>。当您打开 Web 浏览器并前往一个网站时，您不必记住和输入长编号。而是输入<strong>域名</strong> (入 example.com)，然后在正确的位置结束。</p>\n<p>Amazon Route 53 等 DNS 服务是一种全球分布式服务，它将人类可读的名称 (如 <a href=\"http://www.example.com\" target=\"_blank\" rel=\"noopener\">www.example.com</a>) 转换为数字 IP 地址 (如 192.0.2.1)，供计算机用于相互连接。Internet 的 DNS 系统的工作原理和电话簿相似，都是管理名称和数字之间的映射关系。DNS 服务器可以将名称请求转换为 IP 地址，从而控制最终用户在 Web 浏览器中输入域名时所访问的服务器。这些请求称为<strong>查询</strong>。</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/f443431781d872c8d466bc245975729d.png\" alt=\"dns将流量路由到我的web程序\"></p>\n</li>\n</ul>\n<ol>\n<li>用户打开 Web 浏览器，在地址栏中输入 <a href=\"http://www.example.com，然后按\" target=\"_blank\" rel=\"noopener\">www.example.com，然后按</a> Enter 键。</li>\n<li><a href=\"http://www.example.com\" target=\"_blank\" rel=\"noopener\">www.example.com</a> 的请求被路由到 DNS 解析程序，这一般由用户的 Internet 服务提供商 (ISP) 进行管理，例如有线 Internet 服务提供商、DSL 宽带提供商或公司网络。</li>\n<li>ISP 的 DNS 解析程序将 <a href=\"http://www.example.com\" target=\"_blank\" rel=\"noopener\">www.example.com</a> 的请求转发到 DNS 根名称服务器。</li>\n<li>ISP 的 DNS 解析程序再次转发 <a href=\"http://www.example.com\" target=\"_blank\" rel=\"noopener\">www.example.com</a> 的请求，这次转发到 .com 域的一个 TLD 名称服务器。.com 域的名称服务器使用与 example.com 域相关的四个 Amazon Route 53 名称服务器的名称来响应该请求。</li>\n<li>ISP 的 DNS 解析程序选择一个 Amazon Route 53 名称服务器，并将 <a href=\"http://www.example.com\" target=\"_blank\" rel=\"noopener\">www.example.com</a> 的请求转发到该名称服务器。</li>\n<li>Amazon Route 53 名称服务器在 example.com 托管区域中查找 <a href=\"http://www.example.com\" target=\"_blank\" rel=\"noopener\">www.example.com</a> 记录，获得相关值，例如，Web 服务器的 IP 地址 (192.0.2.44)，并将 IP 地址返回至 DNS 解析程序。</li>\n<li>ISP 的 DNS 解析程序最终获得用户需要的 IP 地址。解析程序将此值返回至 Web 浏览器。DNS 解析程序还会将 example.com 的 IP 地址缓存 (存储) 您指定的时长，以便它能够在下次有人浏览 example.com 时更快地作出响应。有关更多信息，请参阅存活期 (TTL)。</li>\n<li>Web 浏览器将 <a href=\"http://www.example.com\" target=\"_blank\" rel=\"noopener\">www.example.com</a> 的请求发送到从 DNS 解析程序中获得的 IP 地址。这是您的内容所处位置，例如，在 Amazon EC2 实例中或配置为网站终端节点的 Amazon S3 存储桶中运行的 Web 服务器。</li>\n<li>192.0.2.44 上的 Web 服务器或其他资源将 <a href=\"http://www.example.com\" target=\"_blank\" rel=\"noopener\">www.example.com</a> 的 Web 页面返回到 Web 浏览器，且 Web 浏览器会显示该页面。</li>\n</ol>\n<ul>\n<li><p><strong>json</strong></p>\n<p>一种轻量级数据交换结构</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> json = <span class=\"string\">'&#123;\"a\": \"Hello\", \"b\": \"World\"&#125;'</span>;</span><br></pre></td></tr></table></figure>\n\n<p>作用：</p>\n<p>简单地说，JSON 可以将 JavaScript 对象中表示的一组数据转换为字符串，然后就可以在网络或者程序之间轻松地传递这个字符串，并在需要的时候将它还原为各编程语言所支持的数据格式，例如在 PHP 中，可以将 JSON 还原为数组或者一个基本对象。在用到AJAX时，如果需要用到数组传值，这时就需要用JSON将数组转化为字符串。</p>\n<ul>\n<li>表示对象</li>\n</ul>\n<p>对象是一个无序的“‘名称/值’对”集合。一个对象以{左括号开始，}右括号结束。每个“名称”后跟一个:冒号；“‘名称/值’ 对”之间使用,逗号分隔。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">`&#123;`</span><span class=\"string\">`\"firstName\"`</span><span class=\"string\">`: `</span><span class=\"string\">`\"Brett\"`</span><span class=\"string\">`, `</span><span class=\"string\">`\"lastName\"`</span><span class=\"string\">`: `</span><span class=\"string\">`\"McLaughlin\"`</span><span class=\"string\">`&#125;                                        `</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>表示数组</li>\n</ul>\n<p>和普通的 JS 数组一样，JSON 表示数组的方式也是使用方括号 []。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">`&#123; `</span><span class=\"string\">`\"people\":[ `</span><span class=\"string\">`&#123;`</span><span class=\"string\">`\"firstName\": \"Brett\",            `</span><span class=\"string\">`\"lastName\":\"McLaughlin\"        `</span><span class=\"string\">`&#125;,      `</span><span class=\"string\">`&#123;        `</span><span class=\"string\">`\"firstName\":\"Jason\",`</span><span class=\"string\">`\"lastName\":\"Hunter\"`</span><span class=\"string\">`&#125;`</span><span class=\"string\">`]`</span><span class=\"string\">`&#125;`</span></span><br></pre></td></tr></table></figure>\n\n<p>这不难理解。在这个示例中，只有一个名为 people的变量，值是包含两个条目的数组，每个条目是一个人的记录，其中包含名和姓。上面的示例演示如何用括号将记录组合成一个值。当然，可以使用相同的语法表示更过多的值（每个值包含多个记录）。</p>\n<ul>\n<li><p>要实现从JSON字符串转换为JS对象，使用 JSON.parse() 方法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">`var`</span> <span class=\"string\">`obj = JSON.parse(`</span><span class=\"string\">`'&#123;\"a\": \"Hello\", \"b\": \"World\"&#125;'`</span><span class=\"string\">`); `</span><span class=\"string\">`//结果是 &#123;a: 'Hello', b: 'World'&#125;`</span></span><br></pre></td></tr></table></figure>\n\n<p>要实现从JS对象转换为JSON字符串，使用 JSON.stringify() 方法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">`var`</span> <span class=\"string\">`json = JSON.stringify(&#123;a: `</span><span class=\"string\">`'Hello'`</span><span class=\"string\">`, b: `</span><span class=\"string\">`'World'`</span><span class=\"string\">`&#125;); `</span><span class=\"string\">`//结果是 '&#123;\"a\": \"Hello\", \"b\": \"World\"&#125;'`</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"15-telegram-bot-nginx\"><a href=\"#15-telegram-bot-nginx\" class=\"headerlink\" title=\"15. telegram bot nginx\"></a>15. telegram bot nginx</h2><p>鉴权 -&gt;链接cf -&gt;看cf 的 api</p>\n<ul>\n<li><p><a href=\"https://api.cloudflare.com\" target=\"_blank\" rel=\"noopener\">https://api.cloudflare.com</a> ：cloudflare ‘s api ：看网站</p>\n<p>目标：增加A记录（API token）</p>\n</li>\n<li><p>bot api </p>\n<p>git源码 <a href=\"https://github.com/yagop/node-telegram-bot-api\" target=\"_blank\" rel=\"noopener\">https://github.com/yagop/node-telegram-bot-api</a></p>\n<p>参考blog  <a href=\"https://segmentfault.com/a/1190000018716076\" target=\"_blank\" rel=\"noopener\">建立 telegram bot and nginx</a>    </p>\n</li>\n</ul>\n<h2 id=\"16-正则表达式\"><a href=\"#16-正则表达式\" class=\"headerlink\" title=\"16. 正则表达式\"></a>16. 正则表达式</h2><p>正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。</p>\n<ul>\n<li>非打印字符</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>\\cx</th>\n<th>匹配由x指明的控制字符。例如， \\cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>\\f</td>\n<td>匹配一个换页符。等价于 \\x0c 和 \\cL。</td>\n</tr>\n<tr>\n<td>\\n</td>\n<td>匹配一个换行符。等价于 \\x0a 和 \\cJ。</td>\n</tr>\n<tr>\n<td>\\r</td>\n<td>匹配一个回车符。等价于 \\x0d 和 \\cM。</td>\n</tr>\n<tr>\n<td>\\s</td>\n<td>匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。注意 Unicode 正则表达式会匹配全角空格符。</td>\n</tr>\n<tr>\n<td>\\S</td>\n<td>匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。</td>\n</tr>\n<tr>\n<td>\\t</td>\n<td>匹配一个制表符。等价于 \\x09 和 \\cI。</td>\n</tr>\n<tr>\n<td>\\v</td>\n<td>匹配一个垂直制表符。等价于 \\x0b 和 \\cK。</td>\n</tr>\n</tbody></table>\n<ul>\n<li>特殊字符</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>$</th>\n<th>匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\\n’ 或 ‘\\r’。要匹配 $ 字符本身，请使用  \\$。</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>( )</td>\n<td>标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 \\( 和\\ )。</td>\n</tr>\n<tr>\n<td>*</td>\n<td>匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 \\*。</td>\n</tr>\n<tr>\n<td>+</td>\n<td>匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 \\+。</td>\n</tr>\n<tr>\n<td>.</td>\n<td>匹配除换行符 \\n 之外的任何单字符。要匹配 . ，请使用 \\. 。</td>\n</tr>\n<tr>\n<td>[</td>\n<td>标记一个中括号表达式的开始。要匹配 [，请使用 \\[。</td>\n</tr>\n<tr>\n<td>?</td>\n<td>匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 ?。</td>\n</tr>\n<tr>\n<td>\\</td>\n<td>将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\\n’ 匹配换行符。序列 ‘\\\\‘ 匹配 “\\“，而 ‘\\(‘ 则匹配 “(“。</td>\n</tr>\n<tr>\n<td>^</td>\n<td>匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 ^。</td>\n</tr>\n<tr>\n<td>{</td>\n<td>标记限定符表达式的开始。要匹配 {，请使用 \\{。</td>\n</tr>\n<tr>\n<td>|</td>\n<td>指明两项之间的一个选择。要匹配 |，请使用 \\</td>\n</tr>\n</tbody></table>\n<ul>\n<li>限定符</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>*</th>\n<th>匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>+</td>\n<td>匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td>\n</tr>\n<tr>\n<td>?</td>\n<td>匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 、 “does” 中的 “does” 、 “doxy” 中的 “do” 。? 等价于 {0,1}。</td>\n</tr>\n<tr>\n<td>{n}</td>\n<td>n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td>\n</tr>\n<tr>\n<td>{n,}</td>\n<td>n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。</td>\n</tr>\n<tr>\n<td>{n,m}</td>\n<td>m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。```</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;[0-9]&#123;1,2&#125;&#x2F;    # 至少一位至多两位的数字，设置0-99 缺点在于</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1-9]?[0-9]   ￥</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>贪婪非贪婪：</p>\n<p>* 是贪婪的，他会尽可能多的匹配字符。比如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h1&gt;123&lt;&#x2F;h1&gt;</span><br></pre></td></tr></table></figure>\n\n<p>如果用&lt;.*&gt;匹配，他会把<h1>123</h1>全匹配上（贪婪）</p>\n<p>如果同&lt;.*?&gt;匹配，只会匹配<h1>（非贪婪：最小匹配）</p>\n</li>\n<li><p>定位符</p>\n</li>\n</ul>\n<p>定位符用来描述字符串或单词的边界，<strong>^</strong> 和 <strong>$</strong> 分别指字符串的开始与结束，<strong>\\b</strong> 描述单词的前或后边界，<strong>\\B</strong> 表示非单词边界。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">字符</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">^</td>\n<td align=\"left\">匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \\n 或 \\r 之后的位置匹配。</td>\n</tr>\n<tr>\n<td align=\"left\">$</td>\n<td align=\"left\">匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \\n 或 \\r 之前的位置匹配。</td>\n</tr>\n<tr>\n<td align=\"left\">\\b</td>\n<td align=\"left\">匹配一个单词边界，即字与空格间的位置。</td>\n</tr>\n<tr>\n<td align=\"left\">\\B</td>\n<td align=\"left\">非单词边界匹配。</td>\n</tr>\n</tbody></table>\n<p>若要在搜索章节标题时使用定位点，下面的正则表达式匹配一个章节标题，该标题只包含两个尾随数字，并且出现在行首：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;^Chapter [1-9][0-9]&#123;0,1&#125;&#x2F;</span><br></pre></td></tr></table></figure>\n\n<p>真正的章节标题不仅出现行的开始处，而且它还是该行中仅有的文本。它即出现在行首又出现在同一行的结尾。下面的表达式能确保指定的匹配只匹配章节而不匹配交叉引用。通过创建只匹配一行文本的开始和结尾的正则表达式，就可做到这一点。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;^Chapter [1-9][0-9]&#123;0,1&#125;$&#x2F;</span><br></pre></td></tr></table></figure>\n\n<p>匹配单词边界稍有不同，但向正则表达式添加了很重要的能力。单词边界是单词和空格之间的位置。非单词边界是任何其他位置。下面的表达式匹配单词 Chapter 的开头三个字符，因为这三个字符出现在单词边界后面：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;\\bCha&#x2F;</span><br></pre></td></tr></table></figure>\n\n<p><strong>\\b</strong> 字符的位置是非常重要的。如果它位于要匹配的字符串的开始，它在单词的开始处查找匹配项。如果它位于字符串的结尾，它在单词的结尾处查找匹配项。例如，下面的表达式匹配单词 Chapter 中的字符串 ter，因为它出现在单词边界的前面：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;ter\\b&#x2F;</span><br></pre></td></tr></table></figure>\n\n<p>下面的表达式匹配 Chapter 中的字符串 apt，但不匹配 aptitude 中的字符串 apt：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;\\Bapt&#x2F;</span><br></pre></td></tr></table></figure>\n\n<p>字符串 apt 出现在单词 Chapter 中的非单词边界处，但出现在单词 aptitude 中的单词边界处。对于 <strong>\\B</strong> 非单词边界运算符，位置并不重要，因为匹配不关心究竟是单词的开头还是结尾。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">\"http://www.runoob.com:80/html/html-tutorial.html\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> patt1 = <span class=\"regexp\">/(\\w+):\\/\\/([^/:]+)(:\\d*)?([^# ]*)/</span>;</span><br><span class=\"line\">arr = str.match(patt1);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; arr.length ; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.write(arr[i]);</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.write(<span class=\"string\">\"&lt;br&gt;\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>第三行代码 <strong>str.match(patt1)</strong> 返回一个数组，实例中的数组包含 5 个元素，索引 0 对应的是整个字符串，索引 1 对应第一个匹配符（括号内），以此类推。</p>\n<p>第一个括号子表达式捕获 Web 地址的协议部分。该子表达式匹配在冒号和两个正斜杠前面的任何单词。</p>\n<p>第二个括号子表达式捕获地址的域地址部分。子表达式匹配非 <strong>:</strong> 和 <strong>/</strong> 之后的一个或多个字符。</p>\n<p>第三个括号子表达式捕获端口号（如果指定了的话）。该子表达式匹配冒号后面的零个或多个数字。只能重复一次该子表达式。</p>\n<p>最后，第四个括号子表达式捕获 Web 地址指定的路径和 / 或页信息。该子表达式能匹配不包括 # 或空格字符的任何字符序列。</p>\n<p>将正则表达式应用到上面的 URI，各子匹配项包含下面的内容：</p>\n<ul>\n<li>第一个括号子表达式包含 <strong>http</strong></li>\n<li>第二个括号子表达式包含 <strong><a href=\"http://www.runoob.com\" target=\"_blank\" rel=\"noopener\">www.runoob.com</a></strong></li>\n<li>第三个括号子表达式包含 <strong>:80</strong></li>\n<li>第四个括号子表达式包含 <strong>/html/html-tutorial.html</strong></li>\n</ul>"},{"date":"2020-04-01T16:00:00.000Z","_content":"\n# 自顶向下的计算机网络4 网络层\n\n## 5.1 概述\n\n网络层在网络的主机和路由器中出现。\n\n本章主要讨论网络层如何实现主机到主机的通信服务。 将分组从发送主机移动到接收主机。\n\n分两个相互关联的部分讲解:数据平面和控制平面。\n\n### 5.1.1 数据平面与控制平面\n\n**数据平面功能：**\n\n转发：每台路由器的功能。当一个分组到达某个路由器的输入链路时，该路由器必须将其移动到合适的输出链路。\n\n**控制平面功能：**\n\n选路：全网范围决定路由的功能。确定分组从发送方流向接收方时所经过的路由或路径。 通过选路算法计算路径。\n<!-- more -->\n**转发和选路区别：**\n\n转发:将分组从路由器的一个输入链路接口转移到一个合适的输出链路接口 的本地动作。\n\n• 只涉及分组在路由器中从入链路到出链路的传送。 • 通常用硬件实现。\n\n选路:指分组从源到目的地的端到端路径的网络范围动作。\n\n• 涉及网络中的所有路由器，集体经选路协议交互，决定分组从源到目的地的路径。\n\n• 通常由软件实现。\n\n**类比：**转发: 通过单个立交桥的过程 选路: 从起点到目的终点计划行程的过程。\n\n#### 5.1.2 路由器如何转发分组\n\n**转发表：**每台路由器有一张。路由器根据到达分组的首部值在转发表中查询，找 到相应的输出链路接口，并 将分组转发出去。\n\n![转发](https://img.cetacis.dev/uploads/big/1b9120823790432c9a7e4c0f15cbd631.png)\n\n**转发表是如何配置的：**\n\n* 转发表的内容由选路算法决定\n* 集中式（多台路由器有一个数据中心，或者由单点计算分发）或分布式（每台路由器单独生成自己的转发表） *不管哪一种，都有多台路由之间的交互*\n\n#### 1. 控制平面\n\n传统方式：每个路由器都有单独的路由算法组件，路由器之间通过交互来实现控制平面\n\nSDN方法：一个分离的(通常是远程的)控制器和路由器本地的控制代理 (local controlagents，CAs) 交互。软件定义网络，由远程的控制器计算分发转发表。可以由isp或者专门的公司管理。\n\n#### 2. 一些术语\n\n**分组交换机：**一台通用分组交换设备，根据**分组首部值**，从输入链路接 口到输出链路接口传送分组。\n\n**链路层交换机：**根据*链路层字段值*作转发决定的分组交换机。 \n\n**路由器：**根据*网络层字段值*作转发决定的分组交换机。\n\n#### 3. 建立连接\n\n**传输层连接**: 如TCP协议，在数据实际传输之前，需要发送方 和接收方经过三次握手建立所需的状态信息。两个进程之间 建立连接\n\n**网络层连接**: 指网络层数据分组开始传输前，在所选择的从源 到目的地路径上的各路由器之间相互握手，建立连接状态。\n\n如ATM、帧中继、MPLS的网络层。(已经很少使用)。如今的因特网网络层不执行连接建立。\n\n### 5.1.3 网络服务模型\n\n问题：\n\n* 发送主机的运输层是否能依靠网络层将分组交付到目的地; \n* 多个分组是否能按发送顺序交付给接收主机的运输层; \n* 传输两个连续分组的时间间隔是否与接收到的时间间隔相同; \n* 网络层是否能提供网络拥塞的反馈信息;\n\n由网络层提供的服务模型来确定\n\n#### **网络层可能提供的服务**\n\n1. **网络层可能提供的服务**\n\n   - 确保交付:确保分组到达目的地。\n\n   - 有序分组交付:按发送顺序到达。\n\n   - 具有时延上界的确保交付:主机到主\n\n     机的时延。\n\n   - 确保最小带宽:当发送主机以低于特\n\n     定比特率的速率发送比特，分组不会\n\n     丢失，在一定时延到达。\n\n   - 确保最大时延抖动:发送方发送两个\n\n     连续分组的时间间隔与接收到的间隔 相同。\n\n2. **因特网的网络层提供的服务**• 单一服务，即尽力而为服务(best-effort service) 。\n   * 分组间的定时不能被保证;\n   * 分组的接收顺序与发送顺序不一定相同;\n   *  传送的分组不能保证最终交付，即网络可能未向目的地交付分 组。\n\n## 5.2 虚电路与数据报网络\n\n### 5.2.1 网络层与运输层\n\n• 运输层:提供无连接服务和面向连接服务。 如因特网的UDP、TCP 。\n\n• 网络层:提供无连接服务和面向连接服务。\n\n面向连接服务:源和目的主机之间先握手。 \n\n无连接服务:无握手过程。\n\n#### **网络层与运输层区别**\n\n1. 服务对象\n\n网络层:向运输层提供的主机到主机的服务。\n\n运输层:向应用层提供的进程到进程的服务。\n\n2. 服务选择\n\n网络层:任何网络中的网络层只提供两种服务之一， 不会同时提供。\n\n​\t虚电路网络:仅在网络层提供连接服务的计算机网络。\n\n​\t数据报网络:仅在网络层提供无连接服务的计算机网络。（二选一\n\n3. 实现\n\n运输层:面向连接服务在网络边缘的端系统中实现。 \n\n网络层:面向连接服务在端系统及网络核心的路由器中实现。\n\n### 5.2.2 虚电路与数据报网络\n\n#### 1. 虚电路\n\n在数据传输前，需要为每一呼叫建立链接\n\n每个分组携带vc标识符（不是目的主机地址\n\n位于”源-目的地址“上每个路由器会维护经过它的每条链接的”状态“\n\n#### 2. 数据报网络\n\n* 在网络层无呼叫过程\n* 路由器：不需要维护端到端链接的状态\n* 没有网络等级的”链接“概念\n* 使用目的主机的地址进行分组转发\n\n*相同源和目的的分组可能采用不同的路径*\n\n**数据报转发表**\n\n如果为每个目的地址建立一个表项，那么将需要建立大约40亿个表项，因此转发表中采用地址范围来建立表项。某一前缀匹配专门的链路接口\n\n最长前缀的匹配规则。\n\n* 路由器转发表只维持转发信息;\n* 转发表由选路算法修改(1~5分钟更新);虚电路网络转发表随虚电路的建立和拆除更新。\n* 一个端系统发送给另一个端系统的一批分组可能在网络中选 择不同的路径，到达的顺序可能不一致。\n\n**数据报网络的特点**\n\n由互连计算机的需求发展而来。与电话网相反。\n\n* 网络层服务模型简单。\n\n* 端系统功能复杂:高层实现许多功能，如按序传送、可靠数据传输、拥塞 控制与DNS名字解析等;\n\n带来的结果\n\n* 因特网服务模型提供的服务保证最少(可能没有!)，对网络层的需求最小，使得**互连使用各种不同链路层技术的网络变得更加容易。 **\n\n* 许多应用都在位于网络边缘的主机(服务器)上实现。\n\n源主机和中转路由器都不知道完整路径\n\n## 5.3 路由器的工作原理\n\n网络层转发功能: 将分组从路由器的输入链路传送到适当的输出链路。\n\n### 5.3.1 路由器的体系结构:\n\n![路由器整体结构](https://img.cetacis.dev/uploads/big/f7f701b9a9f06ba62b8c90a30d699d5d.png)\n\n选路处理器：选路算法\n\n输入端口：确定要转发的方向\n\n### 5.3.2 输入端口\n\n物理层-第一个线路端接模块：将一条物理链路端接到路由器的物理层; bit为单位接收数据\n\n链路层-第二个数据链路处理模块:实现路由器的数据链路层功能;进行分析，解封装\n\n网络层-第三个查找与转发模块:实现查找与转发功能，以便分组通过路由器交换结构 转发到适当的输出端口;分散式转发：根据数据报的目的地址，使用输入端口内存中缓存的转发 表查找输出端口\n\n交换结构：实现转发\n\n输入端口——查找转发模块\n\n确定将一个到达的分组通过交换结构转发给哪个输出端口。 通过查找转发表实现，这里的转发表是存储在输入端口的内存中。\n\n#### 1.**分散式转发:**\n\n选路处理器计算转发表，给每个输入端口存放一份转发表拷贝。 \n\n在每个输入端口本地做出交换决策，无须激活中央选路处理器。 \n\n可避免在路由器中某个单点产生转发处理瓶颈。\n\n#### 2.表\n\n**查表速度**\n\n查表:搜索转发表，查找最长匹配的表项，若无相应表项找出默认选路表 项。\n\n查找速度:受许多因素影响，如路由器速度、链路速率、查找算法等。\n\n目标:输入端口的处理速度要超过线路速度。即完成一次查找的时间应少于从输入端口接收一个分组所需的时间(对收到的分组的输入处理在下一个接收操作结束之前完成)。（减少排队）\n\n如，对运行速率为2.5Gbit/s的OC48链路，若分组长256B，查找速度 大约为每秒一百万次。\n\n**查表方法**\n\n线性查找：桉顺序查 （不适合庞大转发表\n\n二分查找：转发表村房子树形结构中\n\n三态内容可寻址内存（TCAM）\n\n**输入端口问题**\n\n* 分组阻塞\n\n来自其他输入端口的分组当前正在使用交换结构。被阻塞的分组必须在输入端口处排队，等待以后调度通过交换结构。除查找这个最基本的动作外，在输入端口还必须采取其他动作:\n\n1. 必须实现物理层和链路层处理\n2. 必须检查分组的版本号、检验和以及TTL字段。\n3. 必须更新用于网络的管理的计数器。（ 管理统计端口的流量，动态调整端口流量。\n\n### 5.3.3 交换结构\n\n#### 1. 三种类型 概述\n\n![](https://img.cetacis.dev/uploads/big/c42a9aa170ffb58d853e9d16f0e7cfa0.png)\n\n#### 2. 经内存的交换结构\n\n早期用计算机作为路由器时采用的结构(第一代)\n\n* 输入端口与输出端口之间的交换由CPU(选路处理器)控制完成;\n\n* 输入端口与输出端口类似I/O设备:\n\n  *  当分组到达输入端口时，通过中断向选路处理 器发出信号，将分组拷贝到处理器内存中;\n\n  *  选路处理器根据分组中的目的地址查表找出适 当的输出端口，将该分组拷贝到输出端口的缓存中。\n\n**转发速度**\n\n交换速度受总线带宽的速度限制 (每个分组穿过两次总线)\n\n若总线带宽为每秒写入或读出B个分组，则总的转发吞吐量 (分组 从输入端口被传送到输出端口的总速率)小于B/2。\n\n#### 3. **经总线的交换结构**\n\n输入端口通过一条共享总线将分组直接传送到输出端口，不需要 选路处理器的干预。\n\n* 每次只能有一个分组通过总线传送。\n* 分组到达一个输入端口时，若总线正忙，会被暂时阻塞，在输入端口排队\n* 路由器交换带宽受总线速率限制。\n\n#### 4. 经交换矩阵交换(经互联网络交换)结构\n\n纵横式交换机:由2n 条总线组成，n 个输入端口与n 个输出端口连接。\n\n到达输入端口的分组沿水平总线穿行，直至与所希望的输出端口的垂直总线交叉点:\n\n* 若该条垂直总线空闲，则分组被传送到输出端口;\n* 否则，该到达的分组被阻塞，必须在输入端口排队。\n\n![](https://img.cetacis.dev/uploads/big/8b2ccbb3fe8ec8f8a93cebaa11444673.png)\n\n高级设计:更为复杂的互 联网络使用多级交换元 素 ， 以使来自不同输入 端口的分组通过交换结 构同时朝着相同的输出 端口前行 。\n\n### 5.3.4 排队\n\n取出存放在输出端口内存中的分组，并将其传输到输出链路上。\n\n当交换结构将分组交付给输出端口的速率超过输出链路速率，就需要排队与缓存管理功能。当输出端口的缓冲区溢出时，就会出现延时和丢包。\n\n#### 1. **输入端口不排队**\n\n若交换结构的速率至少是输入线路速率的n倍，在输入端口处不会出现排队。\n\n#### **2. 输入端口分组排队**\n\n交换结构比输入端口总和的速度慢: 输入队列产生排队\n\n交换结构不够快，即相对于输入线路速度不能快得使所有到达的分 组无延迟地通过它传送，则在输入端口出现分组排队，以等待通过交换 结构传送到输出端口。\n\n线路前部HOL (head-of-the-line)阻塞: 输入队列中后面的分组被位于线路头的一个分组阻塞(即使输出端口空\n\n闲的)，等待通过交换结构发送。\n\n#### 3. 输出端口分组排队\n\n设交换结构的速率至少是线路速率的n倍。\n\n最坏情况:到达每个输入端口的分组都被发往同一个输出端口。\n\n* 在一个单位时间(接收或发送一个分组)内，将有n个分组到达该输出端口， 排队(等待)发送到输出链路上;\n* 在发出队列中一个分组的时间内，又有n个分组到达。\n\n依此类推，最终排队的分组快速增长，很快占满输出端口的存储空间， 使后续分组被丢弃。\n\n#### 4. 分组丢弃方法\n\n若缓存已满，丢弃分组。 \n\n* 丢弃后到的分组(弃尾); \n* 删除一个或多个已排队的分组;\n  * 主动队列管理AQM算法:在缓存填满前丢弃分组或首部加标记，向发送 方提供拥塞信号。\n  * 如，随机早期检测RED算法: 输出队列长度维护一个加权平均值。\n\n### 5.3.5 分组调度程序\n\n在输出端口排队的分组中选出一个发送。 原则:\n\n先来先服务FCFS:简单。\n\n优先权排队:具有优先级。\n\n加权公平排队WFQ:在具有排队分组的不同端到端连接之间公平地共享输 出链路。\n\n#### 1. 先来先服务FCFS\n\n* 按到达的顺序发送分组;\n* 如果分组到达时，没有足够的缓存空间，该如何丢弃分组?\n  *  尾弃\n  * 基于优先级删除 (比如已有跳数)\n  * 随机删除\n\n#### 2. 优先权排队\n\n**优先级调度**:\n\n* 输出队列分类为多个具有不同优先级队列;\n\n* 根据到达分组的类型，引导到不同优先级的 队列中。\n\n* 优先发送具有最高优先级队列中的分组;\n\n但是在低优先级发送时，高优先级不能抢占低优先级。\n\n#### 3. 循环加权公平队列\n\n**循环队列规则**:\n\n* 输出队列按类分为多个队列，不同类之间没有严格的服务优先权区分。 \n* 据到达分组的类型，引导到不类别的队列中。\n* 循环调度器在这些不同类所对应的队列中轮流提供服务。\n\n**加权公平排队（WFQ）**\n\n* WFQ也循环为各个不同类的队列提供服务;\n\n* 但是不同类的队列，在每个循环周期中，所获得的服务量并不平等，而 是由其权值决定。\n\n## 5.4 网络协议：因特网中的转发和编制\n\n### 5.4.1 因特网中的网络协议 IPv4\n\n#### 1. IPv4 (IP数据报格式)\n\n![](https://img.cetacis.dev/uploads/big/4ab981c8f08db2c1bf606febc875d949.png)\n\n**版本：**IPv4/IPv6\n\n**区分服务**：比如实时流量/分时流量/vip服务 不同的数据报类型。\n\n**总长度：**首部+数据（byte） 应小于mtu（连路层最大传送单元 MTU\n\n**标识：**它是一个计数器，用来产生数据报的标识。\n\n**生存时间TTL：**在一次转发时 -1，当生存时间到0，则销毁此报文，防止形成回环。\n\n**协议：**多种协议，协议字段指出了应将数据部分交给哪一个上层协议\n\n![](https://img.cetacis.dev/uploads/big/ed540030996b58656482000d645b60fd.png)\n\n**首部检验和**:(16 位)字段只检验数据报的首部 不检验数据部分。这里不采用 CRC 检验码而采用简单的计算方法。\n\nIPv4支持首部可变部分，IPv6不支持\n\n#### 2. IPv4数据分片和重组\n\n* 每个数据链路有自己的MTU，链路类型 不同，MTU的值也不同，这里MTU指的 是数据链路帧的数据区的最大字节数（在发送的过程中，可能在链路层有不同的协议，即不同的MTU，会使已有的网络层数据报无法传送，则需要分片（变得更小）或者重组（变得更大）\n* 为了进一步识别出这些分组，需要对分 片进行标识\n\n**问题：**\n\n* 当一台目的主机从相同源收到一系列的数据报的时候，它需要确定，这些数据报中的某些是否是一些原来较大的数据报的片?\n\n在添加源地址和目的地址时，还会为该报文段，添加标识字段， 分片后的每个片，都具有相同的源地址和目的地址，以及相同的标识。（***标识、标志、片偏移***）\n\n标识：同一个源主机分片，每一个+1。\n\n* 如果是某些数据报的片，则它必须进一步确定何时收到了最后一片?\n\n标志字段中MF=0，则标识最后一个片\n\n* 它如何将这些片拼接还原为原来的初始数据报?\n\n通过片偏移字段，标识该片在初始IP数据报中的哪个位置。\n\n**分片的例子**\n\n4000 MTU = 1500\n\n只分数据段 4000 - 20； 1500 - 20\n\n偏移量 ： 第一个 = 0 第二个 1480/8(byte) 第三个 2*1480/8\n\n长度：第一个 = 1500 第二个 = 1500 第三个 = 1040 （4000 - 20 -（1500-20）* 2 +20）\n\n标志：前几个都是0 最后一个是1\n\n标识符：= 都一样\n\n**分片的问题**\n\n* 分片是有开销的。\n\n* 使路由器和端系统更为复杂。\n\n* 分片能够被用于生产致命的DoS攻击。（模拟分片/序号错乱）\n\n  *IPv6取消分片：当无法适应MTU，则返回源主机重发信息*\n\n### 5.4.2 IP\n\n#### 1. IP地址\n\nIP 地址: 分配给主机或路由器**接口**的标识符（每一个路由器、主机都可有多个接口）IP地址与接口相关联\n\n接口: 主机/路由器与物理链路之间的 边界\n\n* 路由器有多个接口\n\n* 主机可以有多个接口 \n* 每个接口有一个IP地址\n\nIP地址两种：\n\n* IPV4:32个二进制位长(4字节)，常用点分十进制表示;\n\n* IPV6:128个二进制位长(16字节) 常用冒号分隔表示\n\n#### 2. IPv4编制\n\n32比特二进制和点分十进制的方法\n\n将4个字节中的每一个字节分别用十进制数来表示，4个十进制数之间如\n\n223.1.1.1 = 11011111 00000001 00000001 00000001\n\n#### 3. IP地址结构\n\nIP 地址是一种分等级的地址结构，包括两部分: \n\n* 网络号:指明主机所在网络的编号。\n* 主机号:主机在网络中的编号。主机号为全0和全1的两个地址不能使用，用于特殊的目的!\n\n**IP地址分两个等级的好处是:**\n\n第一，IP 地址管理机构在分配 IP 地址时**只分配网络号**，而剩下的主机号则由得到该网络号的单位自行分配。这样就方便了 IP 地址的管理。\n\n第二，路由器**仅根据目的主机所连接的网络号来转发分组**(而不考虑目的主 机号)，这样就可以使路由表中的项目数大幅度减少，从而减小了路由表所 占的存储空间。\n\n#### 4. 早期IP地址分类\n\n![早期IP地址分类](https://img.cetacis.dev/uploads/big/6432c55a9ad7a000b62da31ee2470846.png)\n\n* **A类**\n\nA类IP地址的**网络号长度为8位，主机号长度为24位**; \n\nA类地址是从:1.0.0.1~127.255.255.254; \n\n网络号可变长度为7位，从理论上可以有27=128个网络; \n\n网络号为全0和全1(用十进制表示为0与127)的两个地址保留用于特殊目 的，实际允许有126个不同的A类网络; \n\n由于主机号长度为24位，因此每个A类网络的主机IP数理论上为224=16 777 216; \n\n主机IP为全0和全1的两个地址保留用于特殊目的，每个网段实际允许连接 16 777 214个主机; \n\nA类IP地址结构适用于有大量主机的大型网络。 \n\n* **B类**\n\nB类IP地址的**网络号长度为**16位**，**主机号长度为16位\n\nB类IP地址是从:128.0.0.1~191.255.255.254;\n\n 适合国际性大公司与政府机构等中等大小的组织\n\n* **C类**\n\nC类IP地址的**网络号**长度为**24**位**，**主机号**长度为**8位;\n\nC类IP地址是从:192.0.0.1~223.255.255.254;\n\n适用于小公司 普通研究机构\n\n* **D类**\n\n  D类IP地址不标识网络;  224.0.0.0 - 239.255.255.255\n\n  多地址\n\n* **E类** \n\n240.0.0.0-255.255.255.255\n\n实验使用 保留\n\n#### 5. 特殊IP地址段\n\n*  0.0.0.0\n\n这个地址严格上来说都不是真正意义上的IP地址。主要是用来标识不清楚 的网络和主机的。系统遇到无法识别的网络或主机的时候会统一的归纳到 这个地址\n\n* 255.255.255.255 这个地址是受限的广播地址。\n\n主要指一个网段内的所有主机\n\n* 127.0.0.1\n\n这个是预留的一个IP地址，主要是用来识别电脑自己本身的地址。也叫做“localhost”一般用来测试使用的。做开发的人比较熟悉。\n\n* 10.x.x.x, 172.16.x.x-72.31.x.x, 192.168.x.x.\n\n这三个地址段主要是我们私有的内网地址。也就是我们平时企业或者家里局 域网所使用的地址段，我们比较熟悉的应该就是192.168.x.x 这个地址段了， 在公网不能路由。(RFC1918中保留)\n\n#### 6. **互联网中的IP地址**\n\n同一局域网上的主机或路由器的IP地址中的网络号必须相同。 用IP术语来说，具有相同网络号的局域网，称为子网。 ( 在 因特网文献中 ， 子网也称为 1P 网络或直接称为网络 。 )\n\n交换机互连的网络仍然是一个局域网，只能有一个网络号。\n\n路由器总是具有两个或两个以上IP地址。\n\n当两个路由器直接相连时，在连线两端的接口处，可以指明 IP地址也可以不指明IP地址。\n\n![](https://img.cetacis.dev/uploads/big/b3ac94848eeae3738de05f33fd21f42a.png)\n\n#### 7. 子网\n\n**划分子网**\n\nIP 地址: 網絡號+ 主機號 网络号相同的IP地址属于同 一个网络。而网络还可以划 分为若干子网\n\n划分子网的方法：从主机号 借用若干个比特作为子网号 ，剩下的主机位为主机号。\n\n![](https://img.cetacis.dev/uploads/big/053b07a71dee3bdf8edbf9fdf6cb4742.png)\n\n**子網特點**\n\n什么是一个子网 ?\n\n* 设备接口的IP地址具有同 样的网络部分\n* 没有路由器的介入，物理 上能够相互到达\n\n**子网掩码**\n\n- 子网号字段长度是可变的，因此，为了确定子网地址，IP协议提\n\n  供了子网掩码的概念 。\n\n- 子网掩码用来确定网络地址(包括网络号和子网号)和主机地址 的长度。子网掩码长为32位比特，其中的1对应于IP地址中的网 络号和子网号，而子网掩码中的0对应于主机号。\n\n![](https://img.cetacis.dev/uploads/big/19e15b01d1cd5a1d5c9f31d93d302f62.png)\n\n![](https://img.cetacis.dev/uploads/big/aba86e09488e237699bf4ef9342b2473.png)\n\n#### 8. 技术发展\n\n一个A类的IP地址，可以有24bit用于分配主机地址，因此可以 支持 224个主机，但是一个家庭或者组织往往不需要这么多的地 址空间，造成浪费。 \n\n 一个C类的IP地址，只有8bit用于分配主机地址，因此只能支持 256个主机，又不太够用。 \n\n 因此，按传统IP地址分类方式分配IP被CIDR技术取代 \n\n***CIDR*** ： 无类别无间路由 网络前缀+主机号\n\na.b.c.d/x  （x是地址网络部分的bit数 地址中的网络部分可以任意长(**IP**地址前缀或网络前缀)\n\nCIDR将网络前缀都相同的连续的IP地址组成“CIDR地址块”。\n\nCIDR 消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念，因 而可以更加有效地分配 IPv4 的地址空间。\n\n*子网掩码：*/x的计法和255.255.255.0 都属于子网掩码\n\n**构造超网**\n\n一个公司或组织通常被分配一块连续的地址块，即具有相同前缀的一段地址。 \n\n CIDR将网络前缀都相同的连续的IP地址组成“CIDR地址块”。\n 一个CIDR地址块可以表示多个内部的子网的集合，这种地址的聚合称为路由聚合，又称为构成超网。\n\n![](https://img.cetacis.dev/uploads/big/9273227069681117e02deaa2f0510c18.png)\n\n![](https://img.cetacis.dev/uploads/big/05103f17bfe105dad5a7a6cdaab3c9b1.png)\n\n**全0 全1 都是不能作为主机号**\n\n![](https://img.cetacis.dev/uploads/big/e7c98a247bcbc19b1228645cc73a0942.png)\n\n![](https://img.cetacis.dev/uploads/big/bcb4eff878dbb9ff35ca8f74c121defb.png)\n\n单播地址：主机号不为全1或者全0\n\n#### 9. IP地址获取\n\n**主机如何得到IP地址**\n\n**手工指定(保存在系统配置中) **\n\n• Windows: 控制面板->网络   • UNIX/LINUX: 在/etc/rc.config中，可使用ifconfig命令配置 \n\n**DHCP: Dynamic Host Configuration Protocol**\n\n• 自动从一个DHCP服务器得到IP地址 • 方便灵活\n\n**DHCP分配的不仅仅是IP地址，还可分配:**\n• 客户的第一跳路由器的地址(网关) • DNS服务器的IP地址或域名• 子网掩码\n\nDHCP是应用程协议\n\n**动态主机配置协议**\n\nplug-and-play(即插即用) \n\nDHCP概述:\n\n• 主机广播 “DHCP DISCOVER” 消息\n• DHCP 服务器用 “DHCP OFFER” 消息响应\n• 主机请求IP地址: “DHCP REQUEST” 消息\n• DHCP 服务器确认 “DHCP ACK/NACK” 消息 • DHCP 终止租用期”DHCP RELEASE”消息\n\nDHCP具体过程\n\n* DHCP打开udp端口67 等待客户端发来的报文，等待客户端发来的报文\n* DHCP客户从udp端口68发送dhcp发现报文\n* 凡收到dhcp发现报文的dhcp服务器都发出dhcp提供报文。客户端收到多个DHCP提供的报文。\n* 客户端选择一个ip，广播告诉大家我选了某个，未被选中的ip提供者回收ip （DHCP REQUEST）\n* 被选中的DHCP发送确认报文DHCPACK 客户端绑定，开始使用临时IP地址\n\n租用期（lifetime）为T，DHCP有两个计时器T1 T2 。T1 = 0.5T T2 = 0.875T。超时则请求更新租用期\n\n* T1到，客户端发送DHCP REQUEST 要求更新租用期\n* 服务端不同意，发回否认报文 DHCPNACK，客户端必须立即停止使用原来的ip地址，重新申请ip地址（discover）\n* 若同意，服务端发送确认报文 dhcpack 客户得到新的租用期，重新设置计时器\n* 如果服务端不相应T1 到达T2，则重新发送request\n* 客户端可随时终止服务器提供的租用期，只需要发送DHCP RELEASE\n\n![](https://img.cetacis.dev/uploads/big/e06d4aedea07a6bbee0aa09fb5015eac.png)\n\nDiscover ：src: 本机 dest:目标（广播）yiaddr（被分配的ip地址）: 无ip所以为全0 t\n\n​\t\t\t\t\transaction ID: 传输id。相同则为对应恢复\n\noffer: 租用时间 : 3600 secs\n\nrequest: 广播原因：告诉别的dhcp服务器别等了，我已经选了某台了。服务端回收ip。\n\n**DHCP** **中继代理(relay agent)**\n\n- 并不是每个网络上都有 DHCP 服务器，这样会使 DHCP 服务器的数量太多。 现在是每一个网络至少有一个 DHCP 中继代理(通常是一台路由器)，它配置 了 DHCP 服务器的 IP 地址信息。\n\n- DHCP 中继代理收到主机发送的发现报文后，就以单播方式向 DHCP 服 务器转发此报文，并等待其回答。收到 DHCP 服务器回答的提供报文后， DHCP 中继代理再将此提供报文发回给主机。\n\n#### 10 关于ip地址及域名的获得 NAT協議\n\nISP获得地址块方法--ICANN\n\n**ICANN**(Internet Corporation for Assigned Names and Numbers)\n\n* 分配IP地址\n* 管理DNS\n* 分配域名，解决纠纷\n\n*ICANN( Internet Corporation for Assigned Names and Numbers ，互联网名称与数字地址分配机构)是一个非营利性的 国际组织，成立于1998年10月，是一个集合了全球网络界商业、 技术及学术各领域专家的非营利性国际组织，负责互联网协议 (IP)地址的空间分配、协议标识符的指派、通用顶级域名 (gTLD)以及国家和地区顶级域名(ccTLD)系统的管理、以及 根服务器系统的管理。这些服务最初是在美国政府合同下由互联 网号码分配当局(Internet Assigned Numbers Authority，IANA) 以及其它一些组织提供。现在，ICANN行使IANA的职能。*\n\n**NIC**\n\n所有的IP地址都由ICANN规划，然后主要由国际组织NIC(Network Information Center)具体负责统一分配。\n\n目前全世界共有五个这样的网络信息中心\n\n我国申请IP地址要通过APNIC，APNIC的总部设在日本东京大学。申请时要考虑申 请哪一类的IP地址，然后向国内的代理机构提出。\n\nIPV4地址段早就枯竭了\n\n**NAT 网络地址转换**\n\n![](https://img.cetacis.dev/uploads/big/a3dfd50269006d3d1337e17ca1995a23.png)\n\n10.0.##  192.168.## 都是私网ip。他们有共同的源端up地址，有不同的源端口号\n\n动机： 对于外部网络来讲，本地网络只用一个ip地址\n\n* 不需要从isp分配一系列地址——只要一个ip地址用于所有设备\n* 在本地网络 改变设备的ip地址不通知外界\n* 更新isp不用更新本地的设备地址\n* 本地网络内部设备不能被外部世界明确寻址，或不可见（安全）\n\n![](https://img.cetacis.dev/uploads/big/fbf732015ffbbcf2e462d608b041fcab.png)\n\n**执行NAT，路由器必须做到:**\n\n* 外出的分组: 替换每个外出的分组的 (源IP 地址, 端口号) 为 (NAT IP 地址, 新端口号)\n\n  远程客户/服务器用(NAT IP地址, 新端口号)作为目的地来响应。 \n\n* 在NAT转换表中，记录了每个(源IP 地址, 端口号)到 (NAT IP地址, 新端口号) 的对应关系。\n\n* 进来的分组: 对每个进来的分组，用保存在NAT表中的对应的(源 IP 地址, 端口号) 替换分组中的目的域 (NAT IP 地址, 新端口号)\n\n**NAT: 网络地址转换的一些限制**\n\n16-bit 端口号: 一个局域网地址可以同时支持60,000个并发连接!\n\nNAT 存在争议: 端口号，仅用于进程变址  路由器只应该处理到第三层 端口号是运输层\n\n​\t\t\t\t\t\t违反了端到端主张：应用程序设计者在设计时不得不将NAT加以考虑，如P2P应用程序\n\n​\t\t\t\t\t\t应使用IPv6来解决地址短缺问题\n\nUNnP (通用即插即用)\n\n*NAT违背了计算机网络分层的思想，伪首部说明TCP、IP协议没有为严格分层* \n\n（沒有校驗合）\n\n#### 11. **ICMP: (Internet Control Message Protocol**， 因特网控制报文协议）\n\n用于主机路由器之间彼此交流网络层信息：\n\n* 差错报告: 不可到达的主机, 网络,端口,协议\n* 请求/应答 (用于ping,traceroute)\n\n”位於ip之上“\n\n* ICMP消息是裝載在ip分組裡 （ip協議字段標明有否icmp）\n* 但是真正的數據，ICMP包文是在ip數據中的\n\n![](https://img.cetacis.dev/uploads/big/068b64ac5b008cecf35497c348c96165.png)\n\nICMP 报文结构:\n\n类型字段, 编码字段、校验和字 段以及不同报文类型所加载的 数据。如果是差错报告，则后 面的数据包含引起该ICMP报文 的IP分组的报头和分组中的前8 字节的数据。\n\n![重要的icmp报文结构](https://img.cetacis.dev/uploads/big/948e5a2d33e20583af434c9b0b9f5930.png)\n\n![](https://img.cetacis.dev/uploads/big/545b1e03766d41cb8d2f18e42edc6fc3.png)\n\n\n\n#### 13. 虚拟专用网vpn（）\n\n* 多个分散的机构需要形成一个专用网进行通信时，利用因特网来实现多个分散机构的专用网，这样的专用网就称为虚拟专用网VPN：将IP地址\n* 配置成目标的内网ip\n\nvpn的实现：隧道技术\n\n将一个内网中的10.1.0.1的ip数据报封装在数据部分发出，到目的内网解封，好像就是内网之间的交流。\n\n![](https://img.cetacis.dev/uploads/big/92164205c6b85ffc40b924793a5b1f78.png)\n\n#### 14. IPv6\n\n初始动机: 32-bit 地址空间即将用尽。\n\n其他动机:1. 首部格式可帮助加速处理/转发 2. 改变首部利于QoS要求\n\n首部格式改变: 1. IPv6 数据报:扩大的地址容量 2. 简化高效的 40 字节首部 3. 流标签\n\n![](https://img.cetacis.dev/uploads/big/1533821297d0e9d21f88bff644df23ee.png)\n\n增加地址空间 首部简化（减少可选项）流标签 还没有确定 \n\n流量类型:表示流中分组的优先级,类似IPv4中的TOS字段，可用于给出给出一个流中某些数据的优先级。\n\n流标签: 表示分组在同一个 “流”中 (“流”的概念尚未完全定义).\n\n下一个首部: 表示数据的上层协议，类似IPv4中的协议字段。\n\n跳限制：类似于ttl\n\n校验和: 全部去掉，减少每一跳的处理时间\n\n选项: 允许, 但是不是标准首部的一部分，而是用下一个首部域 指出\n\nICMPv6  :新版本的 ICMP （不会重新分片，而是回发错误信息，按照新的方式进行封装）\n• 增加消息类型, 例如“分组太大”     • 多播组管理功能\n\n![](https://img.cetacis.dev/uploads/big/27c91f4920f4dbb0b5afb99f0b9e35ee.png)\n\n地址还有其他压缩方法\n\n**ipv4到ipv6的过渡**\n\n并不是所有的路由器都能够同时升级\n\n• 没有 “标志日”\n\n• 同时有 IPv4 和 IPv6 路由器的网络如何工作?\n\n两种推荐方法:\n\n• 双栈:一些路由器具有双重栈 (v6, v4) 能够在两种格式中转换\n\n• 隧道: 在穿过IPv4路由器时，IPv6分组作为 IPv4分组的负载","source":"_posts/自顶向下的计算机网络4 网络层.md","raw":"---\ndate: 2020/4/2\ntags:\n- 上课笔记\n- 网络层\ncategories:\n- 计算机网络\n- 自顶向下的计算机网络\n- 网络层\n---\n\n# 自顶向下的计算机网络4 网络层\n\n## 5.1 概述\n\n网络层在网络的主机和路由器中出现。\n\n本章主要讨论网络层如何实现主机到主机的通信服务。 将分组从发送主机移动到接收主机。\n\n分两个相互关联的部分讲解:数据平面和控制平面。\n\n### 5.1.1 数据平面与控制平面\n\n**数据平面功能：**\n\n转发：每台路由器的功能。当一个分组到达某个路由器的输入链路时，该路由器必须将其移动到合适的输出链路。\n\n**控制平面功能：**\n\n选路：全网范围决定路由的功能。确定分组从发送方流向接收方时所经过的路由或路径。 通过选路算法计算路径。\n<!-- more -->\n**转发和选路区别：**\n\n转发:将分组从路由器的一个输入链路接口转移到一个合适的输出链路接口 的本地动作。\n\n• 只涉及分组在路由器中从入链路到出链路的传送。 • 通常用硬件实现。\n\n选路:指分组从源到目的地的端到端路径的网络范围动作。\n\n• 涉及网络中的所有路由器，集体经选路协议交互，决定分组从源到目的地的路径。\n\n• 通常由软件实现。\n\n**类比：**转发: 通过单个立交桥的过程 选路: 从起点到目的终点计划行程的过程。\n\n#### 5.1.2 路由器如何转发分组\n\n**转发表：**每台路由器有一张。路由器根据到达分组的首部值在转发表中查询，找 到相应的输出链路接口，并 将分组转发出去。\n\n![转发](https://img.cetacis.dev/uploads/big/1b9120823790432c9a7e4c0f15cbd631.png)\n\n**转发表是如何配置的：**\n\n* 转发表的内容由选路算法决定\n* 集中式（多台路由器有一个数据中心，或者由单点计算分发）或分布式（每台路由器单独生成自己的转发表） *不管哪一种，都有多台路由之间的交互*\n\n#### 1. 控制平面\n\n传统方式：每个路由器都有单独的路由算法组件，路由器之间通过交互来实现控制平面\n\nSDN方法：一个分离的(通常是远程的)控制器和路由器本地的控制代理 (local controlagents，CAs) 交互。软件定义网络，由远程的控制器计算分发转发表。可以由isp或者专门的公司管理。\n\n#### 2. 一些术语\n\n**分组交换机：**一台通用分组交换设备，根据**分组首部值**，从输入链路接 口到输出链路接口传送分组。\n\n**链路层交换机：**根据*链路层字段值*作转发决定的分组交换机。 \n\n**路由器：**根据*网络层字段值*作转发决定的分组交换机。\n\n#### 3. 建立连接\n\n**传输层连接**: 如TCP协议，在数据实际传输之前，需要发送方 和接收方经过三次握手建立所需的状态信息。两个进程之间 建立连接\n\n**网络层连接**: 指网络层数据分组开始传输前，在所选择的从源 到目的地路径上的各路由器之间相互握手，建立连接状态。\n\n如ATM、帧中继、MPLS的网络层。(已经很少使用)。如今的因特网网络层不执行连接建立。\n\n### 5.1.3 网络服务模型\n\n问题：\n\n* 发送主机的运输层是否能依靠网络层将分组交付到目的地; \n* 多个分组是否能按发送顺序交付给接收主机的运输层; \n* 传输两个连续分组的时间间隔是否与接收到的时间间隔相同; \n* 网络层是否能提供网络拥塞的反馈信息;\n\n由网络层提供的服务模型来确定\n\n#### **网络层可能提供的服务**\n\n1. **网络层可能提供的服务**\n\n   - 确保交付:确保分组到达目的地。\n\n   - 有序分组交付:按发送顺序到达。\n\n   - 具有时延上界的确保交付:主机到主\n\n     机的时延。\n\n   - 确保最小带宽:当发送主机以低于特\n\n     定比特率的速率发送比特，分组不会\n\n     丢失，在一定时延到达。\n\n   - 确保最大时延抖动:发送方发送两个\n\n     连续分组的时间间隔与接收到的间隔 相同。\n\n2. **因特网的网络层提供的服务**• 单一服务，即尽力而为服务(best-effort service) 。\n   * 分组间的定时不能被保证;\n   * 分组的接收顺序与发送顺序不一定相同;\n   *  传送的分组不能保证最终交付，即网络可能未向目的地交付分 组。\n\n## 5.2 虚电路与数据报网络\n\n### 5.2.1 网络层与运输层\n\n• 运输层:提供无连接服务和面向连接服务。 如因特网的UDP、TCP 。\n\n• 网络层:提供无连接服务和面向连接服务。\n\n面向连接服务:源和目的主机之间先握手。 \n\n无连接服务:无握手过程。\n\n#### **网络层与运输层区别**\n\n1. 服务对象\n\n网络层:向运输层提供的主机到主机的服务。\n\n运输层:向应用层提供的进程到进程的服务。\n\n2. 服务选择\n\n网络层:任何网络中的网络层只提供两种服务之一， 不会同时提供。\n\n​\t虚电路网络:仅在网络层提供连接服务的计算机网络。\n\n​\t数据报网络:仅在网络层提供无连接服务的计算机网络。（二选一\n\n3. 实现\n\n运输层:面向连接服务在网络边缘的端系统中实现。 \n\n网络层:面向连接服务在端系统及网络核心的路由器中实现。\n\n### 5.2.2 虚电路与数据报网络\n\n#### 1. 虚电路\n\n在数据传输前，需要为每一呼叫建立链接\n\n每个分组携带vc标识符（不是目的主机地址\n\n位于”源-目的地址“上每个路由器会维护经过它的每条链接的”状态“\n\n#### 2. 数据报网络\n\n* 在网络层无呼叫过程\n* 路由器：不需要维护端到端链接的状态\n* 没有网络等级的”链接“概念\n* 使用目的主机的地址进行分组转发\n\n*相同源和目的的分组可能采用不同的路径*\n\n**数据报转发表**\n\n如果为每个目的地址建立一个表项，那么将需要建立大约40亿个表项，因此转发表中采用地址范围来建立表项。某一前缀匹配专门的链路接口\n\n最长前缀的匹配规则。\n\n* 路由器转发表只维持转发信息;\n* 转发表由选路算法修改(1~5分钟更新);虚电路网络转发表随虚电路的建立和拆除更新。\n* 一个端系统发送给另一个端系统的一批分组可能在网络中选 择不同的路径，到达的顺序可能不一致。\n\n**数据报网络的特点**\n\n由互连计算机的需求发展而来。与电话网相反。\n\n* 网络层服务模型简单。\n\n* 端系统功能复杂:高层实现许多功能，如按序传送、可靠数据传输、拥塞 控制与DNS名字解析等;\n\n带来的结果\n\n* 因特网服务模型提供的服务保证最少(可能没有!)，对网络层的需求最小，使得**互连使用各种不同链路层技术的网络变得更加容易。 **\n\n* 许多应用都在位于网络边缘的主机(服务器)上实现。\n\n源主机和中转路由器都不知道完整路径\n\n## 5.3 路由器的工作原理\n\n网络层转发功能: 将分组从路由器的输入链路传送到适当的输出链路。\n\n### 5.3.1 路由器的体系结构:\n\n![路由器整体结构](https://img.cetacis.dev/uploads/big/f7f701b9a9f06ba62b8c90a30d699d5d.png)\n\n选路处理器：选路算法\n\n输入端口：确定要转发的方向\n\n### 5.3.2 输入端口\n\n物理层-第一个线路端接模块：将一条物理链路端接到路由器的物理层; bit为单位接收数据\n\n链路层-第二个数据链路处理模块:实现路由器的数据链路层功能;进行分析，解封装\n\n网络层-第三个查找与转发模块:实现查找与转发功能，以便分组通过路由器交换结构 转发到适当的输出端口;分散式转发：根据数据报的目的地址，使用输入端口内存中缓存的转发 表查找输出端口\n\n交换结构：实现转发\n\n输入端口——查找转发模块\n\n确定将一个到达的分组通过交换结构转发给哪个输出端口。 通过查找转发表实现，这里的转发表是存储在输入端口的内存中。\n\n#### 1.**分散式转发:**\n\n选路处理器计算转发表，给每个输入端口存放一份转发表拷贝。 \n\n在每个输入端口本地做出交换决策，无须激活中央选路处理器。 \n\n可避免在路由器中某个单点产生转发处理瓶颈。\n\n#### 2.表\n\n**查表速度**\n\n查表:搜索转发表，查找最长匹配的表项，若无相应表项找出默认选路表 项。\n\n查找速度:受许多因素影响，如路由器速度、链路速率、查找算法等。\n\n目标:输入端口的处理速度要超过线路速度。即完成一次查找的时间应少于从输入端口接收一个分组所需的时间(对收到的分组的输入处理在下一个接收操作结束之前完成)。（减少排队）\n\n如，对运行速率为2.5Gbit/s的OC48链路，若分组长256B，查找速度 大约为每秒一百万次。\n\n**查表方法**\n\n线性查找：桉顺序查 （不适合庞大转发表\n\n二分查找：转发表村房子树形结构中\n\n三态内容可寻址内存（TCAM）\n\n**输入端口问题**\n\n* 分组阻塞\n\n来自其他输入端口的分组当前正在使用交换结构。被阻塞的分组必须在输入端口处排队，等待以后调度通过交换结构。除查找这个最基本的动作外，在输入端口还必须采取其他动作:\n\n1. 必须实现物理层和链路层处理\n2. 必须检查分组的版本号、检验和以及TTL字段。\n3. 必须更新用于网络的管理的计数器。（ 管理统计端口的流量，动态调整端口流量。\n\n### 5.3.3 交换结构\n\n#### 1. 三种类型 概述\n\n![](https://img.cetacis.dev/uploads/big/c42a9aa170ffb58d853e9d16f0e7cfa0.png)\n\n#### 2. 经内存的交换结构\n\n早期用计算机作为路由器时采用的结构(第一代)\n\n* 输入端口与输出端口之间的交换由CPU(选路处理器)控制完成;\n\n* 输入端口与输出端口类似I/O设备:\n\n  *  当分组到达输入端口时，通过中断向选路处理 器发出信号，将分组拷贝到处理器内存中;\n\n  *  选路处理器根据分组中的目的地址查表找出适 当的输出端口，将该分组拷贝到输出端口的缓存中。\n\n**转发速度**\n\n交换速度受总线带宽的速度限制 (每个分组穿过两次总线)\n\n若总线带宽为每秒写入或读出B个分组，则总的转发吞吐量 (分组 从输入端口被传送到输出端口的总速率)小于B/2。\n\n#### 3. **经总线的交换结构**\n\n输入端口通过一条共享总线将分组直接传送到输出端口，不需要 选路处理器的干预。\n\n* 每次只能有一个分组通过总线传送。\n* 分组到达一个输入端口时，若总线正忙，会被暂时阻塞，在输入端口排队\n* 路由器交换带宽受总线速率限制。\n\n#### 4. 经交换矩阵交换(经互联网络交换)结构\n\n纵横式交换机:由2n 条总线组成，n 个输入端口与n 个输出端口连接。\n\n到达输入端口的分组沿水平总线穿行，直至与所希望的输出端口的垂直总线交叉点:\n\n* 若该条垂直总线空闲，则分组被传送到输出端口;\n* 否则，该到达的分组被阻塞，必须在输入端口排队。\n\n![](https://img.cetacis.dev/uploads/big/8b2ccbb3fe8ec8f8a93cebaa11444673.png)\n\n高级设计:更为复杂的互 联网络使用多级交换元 素 ， 以使来自不同输入 端口的分组通过交换结 构同时朝着相同的输出 端口前行 。\n\n### 5.3.4 排队\n\n取出存放在输出端口内存中的分组，并将其传输到输出链路上。\n\n当交换结构将分组交付给输出端口的速率超过输出链路速率，就需要排队与缓存管理功能。当输出端口的缓冲区溢出时，就会出现延时和丢包。\n\n#### 1. **输入端口不排队**\n\n若交换结构的速率至少是输入线路速率的n倍，在输入端口处不会出现排队。\n\n#### **2. 输入端口分组排队**\n\n交换结构比输入端口总和的速度慢: 输入队列产生排队\n\n交换结构不够快，即相对于输入线路速度不能快得使所有到达的分 组无延迟地通过它传送，则在输入端口出现分组排队，以等待通过交换 结构传送到输出端口。\n\n线路前部HOL (head-of-the-line)阻塞: 输入队列中后面的分组被位于线路头的一个分组阻塞(即使输出端口空\n\n闲的)，等待通过交换结构发送。\n\n#### 3. 输出端口分组排队\n\n设交换结构的速率至少是线路速率的n倍。\n\n最坏情况:到达每个输入端口的分组都被发往同一个输出端口。\n\n* 在一个单位时间(接收或发送一个分组)内，将有n个分组到达该输出端口， 排队(等待)发送到输出链路上;\n* 在发出队列中一个分组的时间内，又有n个分组到达。\n\n依此类推，最终排队的分组快速增长，很快占满输出端口的存储空间， 使后续分组被丢弃。\n\n#### 4. 分组丢弃方法\n\n若缓存已满，丢弃分组。 \n\n* 丢弃后到的分组(弃尾); \n* 删除一个或多个已排队的分组;\n  * 主动队列管理AQM算法:在缓存填满前丢弃分组或首部加标记，向发送 方提供拥塞信号。\n  * 如，随机早期检测RED算法: 输出队列长度维护一个加权平均值。\n\n### 5.3.5 分组调度程序\n\n在输出端口排队的分组中选出一个发送。 原则:\n\n先来先服务FCFS:简单。\n\n优先权排队:具有优先级。\n\n加权公平排队WFQ:在具有排队分组的不同端到端连接之间公平地共享输 出链路。\n\n#### 1. 先来先服务FCFS\n\n* 按到达的顺序发送分组;\n* 如果分组到达时，没有足够的缓存空间，该如何丢弃分组?\n  *  尾弃\n  * 基于优先级删除 (比如已有跳数)\n  * 随机删除\n\n#### 2. 优先权排队\n\n**优先级调度**:\n\n* 输出队列分类为多个具有不同优先级队列;\n\n* 根据到达分组的类型，引导到不同优先级的 队列中。\n\n* 优先发送具有最高优先级队列中的分组;\n\n但是在低优先级发送时，高优先级不能抢占低优先级。\n\n#### 3. 循环加权公平队列\n\n**循环队列规则**:\n\n* 输出队列按类分为多个队列，不同类之间没有严格的服务优先权区分。 \n* 据到达分组的类型，引导到不类别的队列中。\n* 循环调度器在这些不同类所对应的队列中轮流提供服务。\n\n**加权公平排队（WFQ）**\n\n* WFQ也循环为各个不同类的队列提供服务;\n\n* 但是不同类的队列，在每个循环周期中，所获得的服务量并不平等，而 是由其权值决定。\n\n## 5.4 网络协议：因特网中的转发和编制\n\n### 5.4.1 因特网中的网络协议 IPv4\n\n#### 1. IPv4 (IP数据报格式)\n\n![](https://img.cetacis.dev/uploads/big/4ab981c8f08db2c1bf606febc875d949.png)\n\n**版本：**IPv4/IPv6\n\n**区分服务**：比如实时流量/分时流量/vip服务 不同的数据报类型。\n\n**总长度：**首部+数据（byte） 应小于mtu（连路层最大传送单元 MTU\n\n**标识：**它是一个计数器，用来产生数据报的标识。\n\n**生存时间TTL：**在一次转发时 -1，当生存时间到0，则销毁此报文，防止形成回环。\n\n**协议：**多种协议，协议字段指出了应将数据部分交给哪一个上层协议\n\n![](https://img.cetacis.dev/uploads/big/ed540030996b58656482000d645b60fd.png)\n\n**首部检验和**:(16 位)字段只检验数据报的首部 不检验数据部分。这里不采用 CRC 检验码而采用简单的计算方法。\n\nIPv4支持首部可变部分，IPv6不支持\n\n#### 2. IPv4数据分片和重组\n\n* 每个数据链路有自己的MTU，链路类型 不同，MTU的值也不同，这里MTU指的 是数据链路帧的数据区的最大字节数（在发送的过程中，可能在链路层有不同的协议，即不同的MTU，会使已有的网络层数据报无法传送，则需要分片（变得更小）或者重组（变得更大）\n* 为了进一步识别出这些分组，需要对分 片进行标识\n\n**问题：**\n\n* 当一台目的主机从相同源收到一系列的数据报的时候，它需要确定，这些数据报中的某些是否是一些原来较大的数据报的片?\n\n在添加源地址和目的地址时，还会为该报文段，添加标识字段， 分片后的每个片，都具有相同的源地址和目的地址，以及相同的标识。（***标识、标志、片偏移***）\n\n标识：同一个源主机分片，每一个+1。\n\n* 如果是某些数据报的片，则它必须进一步确定何时收到了最后一片?\n\n标志字段中MF=0，则标识最后一个片\n\n* 它如何将这些片拼接还原为原来的初始数据报?\n\n通过片偏移字段，标识该片在初始IP数据报中的哪个位置。\n\n**分片的例子**\n\n4000 MTU = 1500\n\n只分数据段 4000 - 20； 1500 - 20\n\n偏移量 ： 第一个 = 0 第二个 1480/8(byte) 第三个 2*1480/8\n\n长度：第一个 = 1500 第二个 = 1500 第三个 = 1040 （4000 - 20 -（1500-20）* 2 +20）\n\n标志：前几个都是0 最后一个是1\n\n标识符：= 都一样\n\n**分片的问题**\n\n* 分片是有开销的。\n\n* 使路由器和端系统更为复杂。\n\n* 分片能够被用于生产致命的DoS攻击。（模拟分片/序号错乱）\n\n  *IPv6取消分片：当无法适应MTU，则返回源主机重发信息*\n\n### 5.4.2 IP\n\n#### 1. IP地址\n\nIP 地址: 分配给主机或路由器**接口**的标识符（每一个路由器、主机都可有多个接口）IP地址与接口相关联\n\n接口: 主机/路由器与物理链路之间的 边界\n\n* 路由器有多个接口\n\n* 主机可以有多个接口 \n* 每个接口有一个IP地址\n\nIP地址两种：\n\n* IPV4:32个二进制位长(4字节)，常用点分十进制表示;\n\n* IPV6:128个二进制位长(16字节) 常用冒号分隔表示\n\n#### 2. IPv4编制\n\n32比特二进制和点分十进制的方法\n\n将4个字节中的每一个字节分别用十进制数来表示，4个十进制数之间如\n\n223.1.1.1 = 11011111 00000001 00000001 00000001\n\n#### 3. IP地址结构\n\nIP 地址是一种分等级的地址结构，包括两部分: \n\n* 网络号:指明主机所在网络的编号。\n* 主机号:主机在网络中的编号。主机号为全0和全1的两个地址不能使用，用于特殊的目的!\n\n**IP地址分两个等级的好处是:**\n\n第一，IP 地址管理机构在分配 IP 地址时**只分配网络号**，而剩下的主机号则由得到该网络号的单位自行分配。这样就方便了 IP 地址的管理。\n\n第二，路由器**仅根据目的主机所连接的网络号来转发分组**(而不考虑目的主 机号)，这样就可以使路由表中的项目数大幅度减少，从而减小了路由表所 占的存储空间。\n\n#### 4. 早期IP地址分类\n\n![早期IP地址分类](https://img.cetacis.dev/uploads/big/6432c55a9ad7a000b62da31ee2470846.png)\n\n* **A类**\n\nA类IP地址的**网络号长度为8位，主机号长度为24位**; \n\nA类地址是从:1.0.0.1~127.255.255.254; \n\n网络号可变长度为7位，从理论上可以有27=128个网络; \n\n网络号为全0和全1(用十进制表示为0与127)的两个地址保留用于特殊目 的，实际允许有126个不同的A类网络; \n\n由于主机号长度为24位，因此每个A类网络的主机IP数理论上为224=16 777 216; \n\n主机IP为全0和全1的两个地址保留用于特殊目的，每个网段实际允许连接 16 777 214个主机; \n\nA类IP地址结构适用于有大量主机的大型网络。 \n\n* **B类**\n\nB类IP地址的**网络号长度为**16位**，**主机号长度为16位\n\nB类IP地址是从:128.0.0.1~191.255.255.254;\n\n 适合国际性大公司与政府机构等中等大小的组织\n\n* **C类**\n\nC类IP地址的**网络号**长度为**24**位**，**主机号**长度为**8位;\n\nC类IP地址是从:192.0.0.1~223.255.255.254;\n\n适用于小公司 普通研究机构\n\n* **D类**\n\n  D类IP地址不标识网络;  224.0.0.0 - 239.255.255.255\n\n  多地址\n\n* **E类** \n\n240.0.0.0-255.255.255.255\n\n实验使用 保留\n\n#### 5. 特殊IP地址段\n\n*  0.0.0.0\n\n这个地址严格上来说都不是真正意义上的IP地址。主要是用来标识不清楚 的网络和主机的。系统遇到无法识别的网络或主机的时候会统一的归纳到 这个地址\n\n* 255.255.255.255 这个地址是受限的广播地址。\n\n主要指一个网段内的所有主机\n\n* 127.0.0.1\n\n这个是预留的一个IP地址，主要是用来识别电脑自己本身的地址。也叫做“localhost”一般用来测试使用的。做开发的人比较熟悉。\n\n* 10.x.x.x, 172.16.x.x-72.31.x.x, 192.168.x.x.\n\n这三个地址段主要是我们私有的内网地址。也就是我们平时企业或者家里局 域网所使用的地址段，我们比较熟悉的应该就是192.168.x.x 这个地址段了， 在公网不能路由。(RFC1918中保留)\n\n#### 6. **互联网中的IP地址**\n\n同一局域网上的主机或路由器的IP地址中的网络号必须相同。 用IP术语来说，具有相同网络号的局域网，称为子网。 ( 在 因特网文献中 ， 子网也称为 1P 网络或直接称为网络 。 )\n\n交换机互连的网络仍然是一个局域网，只能有一个网络号。\n\n路由器总是具有两个或两个以上IP地址。\n\n当两个路由器直接相连时，在连线两端的接口处，可以指明 IP地址也可以不指明IP地址。\n\n![](https://img.cetacis.dev/uploads/big/b3ac94848eeae3738de05f33fd21f42a.png)\n\n#### 7. 子网\n\n**划分子网**\n\nIP 地址: 網絡號+ 主機號 网络号相同的IP地址属于同 一个网络。而网络还可以划 分为若干子网\n\n划分子网的方法：从主机号 借用若干个比特作为子网号 ，剩下的主机位为主机号。\n\n![](https://img.cetacis.dev/uploads/big/053b07a71dee3bdf8edbf9fdf6cb4742.png)\n\n**子網特點**\n\n什么是一个子网 ?\n\n* 设备接口的IP地址具有同 样的网络部分\n* 没有路由器的介入，物理 上能够相互到达\n\n**子网掩码**\n\n- 子网号字段长度是可变的，因此，为了确定子网地址，IP协议提\n\n  供了子网掩码的概念 。\n\n- 子网掩码用来确定网络地址(包括网络号和子网号)和主机地址 的长度。子网掩码长为32位比特，其中的1对应于IP地址中的网 络号和子网号，而子网掩码中的0对应于主机号。\n\n![](https://img.cetacis.dev/uploads/big/19e15b01d1cd5a1d5c9f31d93d302f62.png)\n\n![](https://img.cetacis.dev/uploads/big/aba86e09488e237699bf4ef9342b2473.png)\n\n#### 8. 技术发展\n\n一个A类的IP地址，可以有24bit用于分配主机地址，因此可以 支持 224个主机，但是一个家庭或者组织往往不需要这么多的地 址空间，造成浪费。 \n\n 一个C类的IP地址，只有8bit用于分配主机地址，因此只能支持 256个主机，又不太够用。 \n\n 因此，按传统IP地址分类方式分配IP被CIDR技术取代 \n\n***CIDR*** ： 无类别无间路由 网络前缀+主机号\n\na.b.c.d/x  （x是地址网络部分的bit数 地址中的网络部分可以任意长(**IP**地址前缀或网络前缀)\n\nCIDR将网络前缀都相同的连续的IP地址组成“CIDR地址块”。\n\nCIDR 消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念，因 而可以更加有效地分配 IPv4 的地址空间。\n\n*子网掩码：*/x的计法和255.255.255.0 都属于子网掩码\n\n**构造超网**\n\n一个公司或组织通常被分配一块连续的地址块，即具有相同前缀的一段地址。 \n\n CIDR将网络前缀都相同的连续的IP地址组成“CIDR地址块”。\n 一个CIDR地址块可以表示多个内部的子网的集合，这种地址的聚合称为路由聚合，又称为构成超网。\n\n![](https://img.cetacis.dev/uploads/big/9273227069681117e02deaa2f0510c18.png)\n\n![](https://img.cetacis.dev/uploads/big/05103f17bfe105dad5a7a6cdaab3c9b1.png)\n\n**全0 全1 都是不能作为主机号**\n\n![](https://img.cetacis.dev/uploads/big/e7c98a247bcbc19b1228645cc73a0942.png)\n\n![](https://img.cetacis.dev/uploads/big/bcb4eff878dbb9ff35ca8f74c121defb.png)\n\n单播地址：主机号不为全1或者全0\n\n#### 9. IP地址获取\n\n**主机如何得到IP地址**\n\n**手工指定(保存在系统配置中) **\n\n• Windows: 控制面板->网络   • UNIX/LINUX: 在/etc/rc.config中，可使用ifconfig命令配置 \n\n**DHCP: Dynamic Host Configuration Protocol**\n\n• 自动从一个DHCP服务器得到IP地址 • 方便灵活\n\n**DHCP分配的不仅仅是IP地址，还可分配:**\n• 客户的第一跳路由器的地址(网关) • DNS服务器的IP地址或域名• 子网掩码\n\nDHCP是应用程协议\n\n**动态主机配置协议**\n\nplug-and-play(即插即用) \n\nDHCP概述:\n\n• 主机广播 “DHCP DISCOVER” 消息\n• DHCP 服务器用 “DHCP OFFER” 消息响应\n• 主机请求IP地址: “DHCP REQUEST” 消息\n• DHCP 服务器确认 “DHCP ACK/NACK” 消息 • DHCP 终止租用期”DHCP RELEASE”消息\n\nDHCP具体过程\n\n* DHCP打开udp端口67 等待客户端发来的报文，等待客户端发来的报文\n* DHCP客户从udp端口68发送dhcp发现报文\n* 凡收到dhcp发现报文的dhcp服务器都发出dhcp提供报文。客户端收到多个DHCP提供的报文。\n* 客户端选择一个ip，广播告诉大家我选了某个，未被选中的ip提供者回收ip （DHCP REQUEST）\n* 被选中的DHCP发送确认报文DHCPACK 客户端绑定，开始使用临时IP地址\n\n租用期（lifetime）为T，DHCP有两个计时器T1 T2 。T1 = 0.5T T2 = 0.875T。超时则请求更新租用期\n\n* T1到，客户端发送DHCP REQUEST 要求更新租用期\n* 服务端不同意，发回否认报文 DHCPNACK，客户端必须立即停止使用原来的ip地址，重新申请ip地址（discover）\n* 若同意，服务端发送确认报文 dhcpack 客户得到新的租用期，重新设置计时器\n* 如果服务端不相应T1 到达T2，则重新发送request\n* 客户端可随时终止服务器提供的租用期，只需要发送DHCP RELEASE\n\n![](https://img.cetacis.dev/uploads/big/e06d4aedea07a6bbee0aa09fb5015eac.png)\n\nDiscover ：src: 本机 dest:目标（广播）yiaddr（被分配的ip地址）: 无ip所以为全0 t\n\n​\t\t\t\t\transaction ID: 传输id。相同则为对应恢复\n\noffer: 租用时间 : 3600 secs\n\nrequest: 广播原因：告诉别的dhcp服务器别等了，我已经选了某台了。服务端回收ip。\n\n**DHCP** **中继代理(relay agent)**\n\n- 并不是每个网络上都有 DHCP 服务器，这样会使 DHCP 服务器的数量太多。 现在是每一个网络至少有一个 DHCP 中继代理(通常是一台路由器)，它配置 了 DHCP 服务器的 IP 地址信息。\n\n- DHCP 中继代理收到主机发送的发现报文后，就以单播方式向 DHCP 服 务器转发此报文，并等待其回答。收到 DHCP 服务器回答的提供报文后， DHCP 中继代理再将此提供报文发回给主机。\n\n#### 10 关于ip地址及域名的获得 NAT協議\n\nISP获得地址块方法--ICANN\n\n**ICANN**(Internet Corporation for Assigned Names and Numbers)\n\n* 分配IP地址\n* 管理DNS\n* 分配域名，解决纠纷\n\n*ICANN( Internet Corporation for Assigned Names and Numbers ，互联网名称与数字地址分配机构)是一个非营利性的 国际组织，成立于1998年10月，是一个集合了全球网络界商业、 技术及学术各领域专家的非营利性国际组织，负责互联网协议 (IP)地址的空间分配、协议标识符的指派、通用顶级域名 (gTLD)以及国家和地区顶级域名(ccTLD)系统的管理、以及 根服务器系统的管理。这些服务最初是在美国政府合同下由互联 网号码分配当局(Internet Assigned Numbers Authority，IANA) 以及其它一些组织提供。现在，ICANN行使IANA的职能。*\n\n**NIC**\n\n所有的IP地址都由ICANN规划，然后主要由国际组织NIC(Network Information Center)具体负责统一分配。\n\n目前全世界共有五个这样的网络信息中心\n\n我国申请IP地址要通过APNIC，APNIC的总部设在日本东京大学。申请时要考虑申 请哪一类的IP地址，然后向国内的代理机构提出。\n\nIPV4地址段早就枯竭了\n\n**NAT 网络地址转换**\n\n![](https://img.cetacis.dev/uploads/big/a3dfd50269006d3d1337e17ca1995a23.png)\n\n10.0.##  192.168.## 都是私网ip。他们有共同的源端up地址，有不同的源端口号\n\n动机： 对于外部网络来讲，本地网络只用一个ip地址\n\n* 不需要从isp分配一系列地址——只要一个ip地址用于所有设备\n* 在本地网络 改变设备的ip地址不通知外界\n* 更新isp不用更新本地的设备地址\n* 本地网络内部设备不能被外部世界明确寻址，或不可见（安全）\n\n![](https://img.cetacis.dev/uploads/big/fbf732015ffbbcf2e462d608b041fcab.png)\n\n**执行NAT，路由器必须做到:**\n\n* 外出的分组: 替换每个外出的分组的 (源IP 地址, 端口号) 为 (NAT IP 地址, 新端口号)\n\n  远程客户/服务器用(NAT IP地址, 新端口号)作为目的地来响应。 \n\n* 在NAT转换表中，记录了每个(源IP 地址, 端口号)到 (NAT IP地址, 新端口号) 的对应关系。\n\n* 进来的分组: 对每个进来的分组，用保存在NAT表中的对应的(源 IP 地址, 端口号) 替换分组中的目的域 (NAT IP 地址, 新端口号)\n\n**NAT: 网络地址转换的一些限制**\n\n16-bit 端口号: 一个局域网地址可以同时支持60,000个并发连接!\n\nNAT 存在争议: 端口号，仅用于进程变址  路由器只应该处理到第三层 端口号是运输层\n\n​\t\t\t\t\t\t违反了端到端主张：应用程序设计者在设计时不得不将NAT加以考虑，如P2P应用程序\n\n​\t\t\t\t\t\t应使用IPv6来解决地址短缺问题\n\nUNnP (通用即插即用)\n\n*NAT违背了计算机网络分层的思想，伪首部说明TCP、IP协议没有为严格分层* \n\n（沒有校驗合）\n\n#### 11. **ICMP: (Internet Control Message Protocol**， 因特网控制报文协议）\n\n用于主机路由器之间彼此交流网络层信息：\n\n* 差错报告: 不可到达的主机, 网络,端口,协议\n* 请求/应答 (用于ping,traceroute)\n\n”位於ip之上“\n\n* ICMP消息是裝載在ip分組裡 （ip協議字段標明有否icmp）\n* 但是真正的數據，ICMP包文是在ip數據中的\n\n![](https://img.cetacis.dev/uploads/big/068b64ac5b008cecf35497c348c96165.png)\n\nICMP 报文结构:\n\n类型字段, 编码字段、校验和字 段以及不同报文类型所加载的 数据。如果是差错报告，则后 面的数据包含引起该ICMP报文 的IP分组的报头和分组中的前8 字节的数据。\n\n![重要的icmp报文结构](https://img.cetacis.dev/uploads/big/948e5a2d33e20583af434c9b0b9f5930.png)\n\n![](https://img.cetacis.dev/uploads/big/545b1e03766d41cb8d2f18e42edc6fc3.png)\n\n\n\n#### 13. 虚拟专用网vpn（）\n\n* 多个分散的机构需要形成一个专用网进行通信时，利用因特网来实现多个分散机构的专用网，这样的专用网就称为虚拟专用网VPN：将IP地址\n* 配置成目标的内网ip\n\nvpn的实现：隧道技术\n\n将一个内网中的10.1.0.1的ip数据报封装在数据部分发出，到目的内网解封，好像就是内网之间的交流。\n\n![](https://img.cetacis.dev/uploads/big/92164205c6b85ffc40b924793a5b1f78.png)\n\n#### 14. IPv6\n\n初始动机: 32-bit 地址空间即将用尽。\n\n其他动机:1. 首部格式可帮助加速处理/转发 2. 改变首部利于QoS要求\n\n首部格式改变: 1. IPv6 数据报:扩大的地址容量 2. 简化高效的 40 字节首部 3. 流标签\n\n![](https://img.cetacis.dev/uploads/big/1533821297d0e9d21f88bff644df23ee.png)\n\n增加地址空间 首部简化（减少可选项）流标签 还没有确定 \n\n流量类型:表示流中分组的优先级,类似IPv4中的TOS字段，可用于给出给出一个流中某些数据的优先级。\n\n流标签: 表示分组在同一个 “流”中 (“流”的概念尚未完全定义).\n\n下一个首部: 表示数据的上层协议，类似IPv4中的协议字段。\n\n跳限制：类似于ttl\n\n校验和: 全部去掉，减少每一跳的处理时间\n\n选项: 允许, 但是不是标准首部的一部分，而是用下一个首部域 指出\n\nICMPv6  :新版本的 ICMP （不会重新分片，而是回发错误信息，按照新的方式进行封装）\n• 增加消息类型, 例如“分组太大”     • 多播组管理功能\n\n![](https://img.cetacis.dev/uploads/big/27c91f4920f4dbb0b5afb99f0b9e35ee.png)\n\n地址还有其他压缩方法\n\n**ipv4到ipv6的过渡**\n\n并不是所有的路由器都能够同时升级\n\n• 没有 “标志日”\n\n• 同时有 IPv4 和 IPv6 路由器的网络如何工作?\n\n两种推荐方法:\n\n• 双栈:一些路由器具有双重栈 (v6, v4) 能够在两种格式中转换\n\n• 隧道: 在穿过IPv4路由器时，IPv6分组作为 IPv4分组的负载","slug":"自顶向下的计算机网络4-网络层","published":1,"updated":"2020-04-10T04:31:49.000Z","title":"自顶向下的计算机网络4-网络层","comments":1,"layout":"post","photos":[],"link":"","_id":"ck985a86k0016slqgh7s4a817","content":"<h1 id=\"自顶向下的计算机网络4-网络层\"><a href=\"#自顶向下的计算机网络4-网络层\" class=\"headerlink\" title=\"自顶向下的计算机网络4 网络层\"></a>自顶向下的计算机网络4 网络层</h1><h2 id=\"5-1-概述\"><a href=\"#5-1-概述\" class=\"headerlink\" title=\"5.1 概述\"></a>5.1 概述</h2><p>网络层在网络的主机和路由器中出现。</p>\n<p>本章主要讨论网络层如何实现主机到主机的通信服务。 将分组从发送主机移动到接收主机。</p>\n<p>分两个相互关联的部分讲解:数据平面和控制平面。</p>\n<h3 id=\"5-1-1-数据平面与控制平面\"><a href=\"#5-1-1-数据平面与控制平面\" class=\"headerlink\" title=\"5.1.1 数据平面与控制平面\"></a>5.1.1 数据平面与控制平面</h3><p><strong>数据平面功能：</strong></p>\n<p>转发：每台路由器的功能。当一个分组到达某个路由器的输入链路时，该路由器必须将其移动到合适的输出链路。</p>\n<p><strong>控制平面功能：</strong></p>\n<p>选路：全网范围决定路由的功能。确定分组从发送方流向接收方时所经过的路由或路径。 通过选路算法计算路径。</p>\n<a id=\"more\"></a>\n<p><strong>转发和选路区别：</strong></p>\n<p>转发:将分组从路由器的一个输入链路接口转移到一个合适的输出链路接口 的本地动作。</p>\n<p>• 只涉及分组在路由器中从入链路到出链路的传送。 • 通常用硬件实现。</p>\n<p>选路:指分组从源到目的地的端到端路径的网络范围动作。</p>\n<p>• 涉及网络中的所有路由器，集体经选路协议交互，决定分组从源到目的地的路径。</p>\n<p>• 通常由软件实现。</p>\n<p><strong>类比：</strong>转发: 通过单个立交桥的过程 选路: 从起点到目的终点计划行程的过程。</p>\n<h4 id=\"5-1-2-路由器如何转发分组\"><a href=\"#5-1-2-路由器如何转发分组\" class=\"headerlink\" title=\"5.1.2 路由器如何转发分组\"></a>5.1.2 路由器如何转发分组</h4><p><strong>转发表：</strong>每台路由器有一张。路由器根据到达分组的首部值在转发表中查询，找 到相应的输出链路接口，并 将分组转发出去。</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/1b9120823790432c9a7e4c0f15cbd631.png\" alt=\"转发\"></p>\n<p><strong>转发表是如何配置的：</strong></p>\n<ul>\n<li>转发表的内容由选路算法决定</li>\n<li>集中式（多台路由器有一个数据中心，或者由单点计算分发）或分布式（每台路由器单独生成自己的转发表） <em>不管哪一种，都有多台路由之间的交互</em></li>\n</ul>\n<h4 id=\"1-控制平面\"><a href=\"#1-控制平面\" class=\"headerlink\" title=\"1. 控制平面\"></a>1. 控制平面</h4><p>传统方式：每个路由器都有单独的路由算法组件，路由器之间通过交互来实现控制平面</p>\n<p>SDN方法：一个分离的(通常是远程的)控制器和路由器本地的控制代理 (local controlagents，CAs) 交互。软件定义网络，由远程的控制器计算分发转发表。可以由isp或者专门的公司管理。</p>\n<h4 id=\"2-一些术语\"><a href=\"#2-一些术语\" class=\"headerlink\" title=\"2. 一些术语\"></a>2. 一些术语</h4><p><strong>分组交换机：</strong>一台通用分组交换设备，根据<strong>分组首部值</strong>，从输入链路接 口到输出链路接口传送分组。</p>\n<p><strong>链路层交换机：</strong>根据<em>链路层字段值</em>作转发决定的分组交换机。 </p>\n<p><strong>路由器：</strong>根据<em>网络层字段值</em>作转发决定的分组交换机。</p>\n<h4 id=\"3-建立连接\"><a href=\"#3-建立连接\" class=\"headerlink\" title=\"3. 建立连接\"></a>3. 建立连接</h4><p><strong>传输层连接</strong>: 如TCP协议，在数据实际传输之前，需要发送方 和接收方经过三次握手建立所需的状态信息。两个进程之间 建立连接</p>\n<p><strong>网络层连接</strong>: 指网络层数据分组开始传输前，在所选择的从源 到目的地路径上的各路由器之间相互握手，建立连接状态。</p>\n<p>如ATM、帧中继、MPLS的网络层。(已经很少使用)。如今的因特网网络层不执行连接建立。</p>\n<h3 id=\"5-1-3-网络服务模型\"><a href=\"#5-1-3-网络服务模型\" class=\"headerlink\" title=\"5.1.3 网络服务模型\"></a>5.1.3 网络服务模型</h3><p>问题：</p>\n<ul>\n<li>发送主机的运输层是否能依靠网络层将分组交付到目的地; </li>\n<li>多个分组是否能按发送顺序交付给接收主机的运输层; </li>\n<li>传输两个连续分组的时间间隔是否与接收到的时间间隔相同; </li>\n<li>网络层是否能提供网络拥塞的反馈信息;</li>\n</ul>\n<p>由网络层提供的服务模型来确定</p>\n<h4 id=\"网络层可能提供的服务\"><a href=\"#网络层可能提供的服务\" class=\"headerlink\" title=\"网络层可能提供的服务\"></a><strong>网络层可能提供的服务</strong></h4><ol>\n<li><p><strong>网络层可能提供的服务</strong></p>\n<ul>\n<li><p>确保交付:确保分组到达目的地。</p>\n</li>\n<li><p>有序分组交付:按发送顺序到达。</p>\n</li>\n<li><p>具有时延上界的确保交付:主机到主</p>\n<p>机的时延。</p>\n</li>\n<li><p>确保最小带宽:当发送主机以低于特</p>\n<p>定比特率的速率发送比特，分组不会</p>\n<p>丢失，在一定时延到达。</p>\n</li>\n<li><p>确保最大时延抖动:发送方发送两个</p>\n<p>连续分组的时间间隔与接收到的间隔 相同。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>因特网的网络层提供的服务</strong>• 单一服务，即尽力而为服务(best-effort service) 。</p>\n<ul>\n<li>分组间的定时不能被保证;</li>\n<li>分组的接收顺序与发送顺序不一定相同;</li>\n<li>传送的分组不能保证最终交付，即网络可能未向目的地交付分 组。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"5-2-虚电路与数据报网络\"><a href=\"#5-2-虚电路与数据报网络\" class=\"headerlink\" title=\"5.2 虚电路与数据报网络\"></a>5.2 虚电路与数据报网络</h2><h3 id=\"5-2-1-网络层与运输层\"><a href=\"#5-2-1-网络层与运输层\" class=\"headerlink\" title=\"5.2.1 网络层与运输层\"></a>5.2.1 网络层与运输层</h3><p>• 运输层:提供无连接服务和面向连接服务。 如因特网的UDP、TCP 。</p>\n<p>• 网络层:提供无连接服务和面向连接服务。</p>\n<p>面向连接服务:源和目的主机之间先握手。 </p>\n<p>无连接服务:无握手过程。</p>\n<h4 id=\"网络层与运输层区别\"><a href=\"#网络层与运输层区别\" class=\"headerlink\" title=\"网络层与运输层区别\"></a><strong>网络层与运输层区别</strong></h4><ol>\n<li>服务对象</li>\n</ol>\n<p>网络层:向运输层提供的主机到主机的服务。</p>\n<p>运输层:向应用层提供的进程到进程的服务。</p>\n<ol start=\"2\">\n<li>服务选择</li>\n</ol>\n<p>网络层:任何网络中的网络层只提供两种服务之一， 不会同时提供。</p>\n<p>​    虚电路网络:仅在网络层提供连接服务的计算机网络。</p>\n<p>​    数据报网络:仅在网络层提供无连接服务的计算机网络。（二选一</p>\n<ol start=\"3\">\n<li>实现</li>\n</ol>\n<p>运输层:面向连接服务在网络边缘的端系统中实现。 </p>\n<p>网络层:面向连接服务在端系统及网络核心的路由器中实现。</p>\n<h3 id=\"5-2-2-虚电路与数据报网络\"><a href=\"#5-2-2-虚电路与数据报网络\" class=\"headerlink\" title=\"5.2.2 虚电路与数据报网络\"></a>5.2.2 虚电路与数据报网络</h3><h4 id=\"1-虚电路\"><a href=\"#1-虚电路\" class=\"headerlink\" title=\"1. 虚电路\"></a>1. 虚电路</h4><p>在数据传输前，需要为每一呼叫建立链接</p>\n<p>每个分组携带vc标识符（不是目的主机地址</p>\n<p>位于”源-目的地址“上每个路由器会维护经过它的每条链接的”状态“</p>\n<h4 id=\"2-数据报网络\"><a href=\"#2-数据报网络\" class=\"headerlink\" title=\"2. 数据报网络\"></a>2. 数据报网络</h4><ul>\n<li>在网络层无呼叫过程</li>\n<li>路由器：不需要维护端到端链接的状态</li>\n<li>没有网络等级的”链接“概念</li>\n<li>使用目的主机的地址进行分组转发</li>\n</ul>\n<p><em>相同源和目的的分组可能采用不同的路径</em></p>\n<p><strong>数据报转发表</strong></p>\n<p>如果为每个目的地址建立一个表项，那么将需要建立大约40亿个表项，因此转发表中采用地址范围来建立表项。某一前缀匹配专门的链路接口</p>\n<p>最长前缀的匹配规则。</p>\n<ul>\n<li>路由器转发表只维持转发信息;</li>\n<li>转发表由选路算法修改(1~5分钟更新);虚电路网络转发表随虚电路的建立和拆除更新。</li>\n<li>一个端系统发送给另一个端系统的一批分组可能在网络中选 择不同的路径，到达的顺序可能不一致。</li>\n</ul>\n<p><strong>数据报网络的特点</strong></p>\n<p>由互连计算机的需求发展而来。与电话网相反。</p>\n<ul>\n<li><p>网络层服务模型简单。</p>\n</li>\n<li><p>端系统功能复杂:高层实现许多功能，如按序传送、可靠数据传输、拥塞 控制与DNS名字解析等;</p>\n</li>\n</ul>\n<p>带来的结果</p>\n<ul>\n<li><p>因特网服务模型提供的服务保证最少(可能没有!)，对网络层的需求最小，使得*<em>互连使用各种不同链路层技术的网络变得更加容易。 *</em></p>\n</li>\n<li><p>许多应用都在位于网络边缘的主机(服务器)上实现。</p>\n</li>\n</ul>\n<p>源主机和中转路由器都不知道完整路径</p>\n<h2 id=\"5-3-路由器的工作原理\"><a href=\"#5-3-路由器的工作原理\" class=\"headerlink\" title=\"5.3 路由器的工作原理\"></a>5.3 路由器的工作原理</h2><p>网络层转发功能: 将分组从路由器的输入链路传送到适当的输出链路。</p>\n<h3 id=\"5-3-1-路由器的体系结构\"><a href=\"#5-3-1-路由器的体系结构\" class=\"headerlink\" title=\"5.3.1 路由器的体系结构:\"></a>5.3.1 路由器的体系结构:</h3><p><img src=\"https://img.cetacis.dev/uploads/big/f7f701b9a9f06ba62b8c90a30d699d5d.png\" alt=\"路由器整体结构\"></p>\n<p>选路处理器：选路算法</p>\n<p>输入端口：确定要转发的方向</p>\n<h3 id=\"5-3-2-输入端口\"><a href=\"#5-3-2-输入端口\" class=\"headerlink\" title=\"5.3.2 输入端口\"></a>5.3.2 输入端口</h3><p>物理层-第一个线路端接模块：将一条物理链路端接到路由器的物理层; bit为单位接收数据</p>\n<p>链路层-第二个数据链路处理模块:实现路由器的数据链路层功能;进行分析，解封装</p>\n<p>网络层-第三个查找与转发模块:实现查找与转发功能，以便分组通过路由器交换结构 转发到适当的输出端口;分散式转发：根据数据报的目的地址，使用输入端口内存中缓存的转发 表查找输出端口</p>\n<p>交换结构：实现转发</p>\n<p>输入端口——查找转发模块</p>\n<p>确定将一个到达的分组通过交换结构转发给哪个输出端口。 通过查找转发表实现，这里的转发表是存储在输入端口的内存中。</p>\n<h4 id=\"1-分散式转发\"><a href=\"#1-分散式转发\" class=\"headerlink\" title=\"1.分散式转发:\"></a>1.<strong>分散式转发:</strong></h4><p>选路处理器计算转发表，给每个输入端口存放一份转发表拷贝。 </p>\n<p>在每个输入端口本地做出交换决策，无须激活中央选路处理器。 </p>\n<p>可避免在路由器中某个单点产生转发处理瓶颈。</p>\n<h4 id=\"2-表\"><a href=\"#2-表\" class=\"headerlink\" title=\"2.表\"></a>2.表</h4><p><strong>查表速度</strong></p>\n<p>查表:搜索转发表，查找最长匹配的表项，若无相应表项找出默认选路表 项。</p>\n<p>查找速度:受许多因素影响，如路由器速度、链路速率、查找算法等。</p>\n<p>目标:输入端口的处理速度要超过线路速度。即完成一次查找的时间应少于从输入端口接收一个分组所需的时间(对收到的分组的输入处理在下一个接收操作结束之前完成)。（减少排队）</p>\n<p>如，对运行速率为2.5Gbit/s的OC48链路，若分组长256B，查找速度 大约为每秒一百万次。</p>\n<p><strong>查表方法</strong></p>\n<p>线性查找：桉顺序查 （不适合庞大转发表</p>\n<p>二分查找：转发表村房子树形结构中</p>\n<p>三态内容可寻址内存（TCAM）</p>\n<p><strong>输入端口问题</strong></p>\n<ul>\n<li>分组阻塞</li>\n</ul>\n<p>来自其他输入端口的分组当前正在使用交换结构。被阻塞的分组必须在输入端口处排队，等待以后调度通过交换结构。除查找这个最基本的动作外，在输入端口还必须采取其他动作:</p>\n<ol>\n<li>必须实现物理层和链路层处理</li>\n<li>必须检查分组的版本号、检验和以及TTL字段。</li>\n<li>必须更新用于网络的管理的计数器。（ 管理统计端口的流量，动态调整端口流量。</li>\n</ol>\n<h3 id=\"5-3-3-交换结构\"><a href=\"#5-3-3-交换结构\" class=\"headerlink\" title=\"5.3.3 交换结构\"></a>5.3.3 交换结构</h3><h4 id=\"1-三种类型-概述\"><a href=\"#1-三种类型-概述\" class=\"headerlink\" title=\"1. 三种类型 概述\"></a>1. 三种类型 概述</h4><p><img src=\"https://img.cetacis.dev/uploads/big/c42a9aa170ffb58d853e9d16f0e7cfa0.png\" alt=\"\"></p>\n<h4 id=\"2-经内存的交换结构\"><a href=\"#2-经内存的交换结构\" class=\"headerlink\" title=\"2. 经内存的交换结构\"></a>2. 经内存的交换结构</h4><p>早期用计算机作为路由器时采用的结构(第一代)</p>\n<ul>\n<li><p>输入端口与输出端口之间的交换由CPU(选路处理器)控制完成;</p>\n</li>\n<li><p>输入端口与输出端口类似I/O设备:</p>\n<ul>\n<li><p>当分组到达输入端口时，通过中断向选路处理 器发出信号，将分组拷贝到处理器内存中;</p>\n</li>\n<li><p>选路处理器根据分组中的目的地址查表找出适 当的输出端口，将该分组拷贝到输出端口的缓存中。</p>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>转发速度</strong></p>\n<p>交换速度受总线带宽的速度限制 (每个分组穿过两次总线)</p>\n<p>若总线带宽为每秒写入或读出B个分组，则总的转发吞吐量 (分组 从输入端口被传送到输出端口的总速率)小于B/2。</p>\n<h4 id=\"3-经总线的交换结构\"><a href=\"#3-经总线的交换结构\" class=\"headerlink\" title=\"3. 经总线的交换结构\"></a>3. <strong>经总线的交换结构</strong></h4><p>输入端口通过一条共享总线将分组直接传送到输出端口，不需要 选路处理器的干预。</p>\n<ul>\n<li>每次只能有一个分组通过总线传送。</li>\n<li>分组到达一个输入端口时，若总线正忙，会被暂时阻塞，在输入端口排队</li>\n<li>路由器交换带宽受总线速率限制。</li>\n</ul>\n<h4 id=\"4-经交换矩阵交换-经互联网络交换-结构\"><a href=\"#4-经交换矩阵交换-经互联网络交换-结构\" class=\"headerlink\" title=\"4. 经交换矩阵交换(经互联网络交换)结构\"></a>4. 经交换矩阵交换(经互联网络交换)结构</h4><p>纵横式交换机:由2n 条总线组成，n 个输入端口与n 个输出端口连接。</p>\n<p>到达输入端口的分组沿水平总线穿行，直至与所希望的输出端口的垂直总线交叉点:</p>\n<ul>\n<li>若该条垂直总线空闲，则分组被传送到输出端口;</li>\n<li>否则，该到达的分组被阻塞，必须在输入端口排队。</li>\n</ul>\n<p><img src=\"https://img.cetacis.dev/uploads/big/8b2ccbb3fe8ec8f8a93cebaa11444673.png\" alt=\"\"></p>\n<p>高级设计:更为复杂的互 联网络使用多级交换元 素 ， 以使来自不同输入 端口的分组通过交换结 构同时朝着相同的输出 端口前行 。</p>\n<h3 id=\"5-3-4-排队\"><a href=\"#5-3-4-排队\" class=\"headerlink\" title=\"5.3.4 排队\"></a>5.3.4 排队</h3><p>取出存放在输出端口内存中的分组，并将其传输到输出链路上。</p>\n<p>当交换结构将分组交付给输出端口的速率超过输出链路速率，就需要排队与缓存管理功能。当输出端口的缓冲区溢出时，就会出现延时和丢包。</p>\n<h4 id=\"1-输入端口不排队\"><a href=\"#1-输入端口不排队\" class=\"headerlink\" title=\"1. 输入端口不排队\"></a>1. <strong>输入端口不排队</strong></h4><p>若交换结构的速率至少是输入线路速率的n倍，在输入端口处不会出现排队。</p>\n<h4 id=\"2-输入端口分组排队\"><a href=\"#2-输入端口分组排队\" class=\"headerlink\" title=\"2. 输入端口分组排队\"></a><strong>2. 输入端口分组排队</strong></h4><p>交换结构比输入端口总和的速度慢: 输入队列产生排队</p>\n<p>交换结构不够快，即相对于输入线路速度不能快得使所有到达的分 组无延迟地通过它传送，则在输入端口出现分组排队，以等待通过交换 结构传送到输出端口。</p>\n<p>线路前部HOL (head-of-the-line)阻塞: 输入队列中后面的分组被位于线路头的一个分组阻塞(即使输出端口空</p>\n<p>闲的)，等待通过交换结构发送。</p>\n<h4 id=\"3-输出端口分组排队\"><a href=\"#3-输出端口分组排队\" class=\"headerlink\" title=\"3. 输出端口分组排队\"></a>3. 输出端口分组排队</h4><p>设交换结构的速率至少是线路速率的n倍。</p>\n<p>最坏情况:到达每个输入端口的分组都被发往同一个输出端口。</p>\n<ul>\n<li>在一个单位时间(接收或发送一个分组)内，将有n个分组到达该输出端口， 排队(等待)发送到输出链路上;</li>\n<li>在发出队列中一个分组的时间内，又有n个分组到达。</li>\n</ul>\n<p>依此类推，最终排队的分组快速增长，很快占满输出端口的存储空间， 使后续分组被丢弃。</p>\n<h4 id=\"4-分组丢弃方法\"><a href=\"#4-分组丢弃方法\" class=\"headerlink\" title=\"4. 分组丢弃方法\"></a>4. 分组丢弃方法</h4><p>若缓存已满，丢弃分组。 </p>\n<ul>\n<li>丢弃后到的分组(弃尾); </li>\n<li>删除一个或多个已排队的分组;<ul>\n<li>主动队列管理AQM算法:在缓存填满前丢弃分组或首部加标记，向发送 方提供拥塞信号。</li>\n<li>如，随机早期检测RED算法: 输出队列长度维护一个加权平均值。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"5-3-5-分组调度程序\"><a href=\"#5-3-5-分组调度程序\" class=\"headerlink\" title=\"5.3.5 分组调度程序\"></a>5.3.5 分组调度程序</h3><p>在输出端口排队的分组中选出一个发送。 原则:</p>\n<p>先来先服务FCFS:简单。</p>\n<p>优先权排队:具有优先级。</p>\n<p>加权公平排队WFQ:在具有排队分组的不同端到端连接之间公平地共享输 出链路。</p>\n<h4 id=\"1-先来先服务FCFS\"><a href=\"#1-先来先服务FCFS\" class=\"headerlink\" title=\"1. 先来先服务FCFS\"></a>1. 先来先服务FCFS</h4><ul>\n<li>按到达的顺序发送分组;</li>\n<li>如果分组到达时，没有足够的缓存空间，该如何丢弃分组?<ul>\n<li>尾弃</li>\n<li>基于优先级删除 (比如已有跳数)</li>\n<li>随机删除</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-优先权排队\"><a href=\"#2-优先权排队\" class=\"headerlink\" title=\"2. 优先权排队\"></a>2. 优先权排队</h4><p><strong>优先级调度</strong>:</p>\n<ul>\n<li><p>输出队列分类为多个具有不同优先级队列;</p>\n</li>\n<li><p>根据到达分组的类型，引导到不同优先级的 队列中。</p>\n</li>\n<li><p>优先发送具有最高优先级队列中的分组;</p>\n</li>\n</ul>\n<p>但是在低优先级发送时，高优先级不能抢占低优先级。</p>\n<h4 id=\"3-循环加权公平队列\"><a href=\"#3-循环加权公平队列\" class=\"headerlink\" title=\"3. 循环加权公平队列\"></a>3. 循环加权公平队列</h4><p><strong>循环队列规则</strong>:</p>\n<ul>\n<li>输出队列按类分为多个队列，不同类之间没有严格的服务优先权区分。 </li>\n<li>据到达分组的类型，引导到不类别的队列中。</li>\n<li>循环调度器在这些不同类所对应的队列中轮流提供服务。</li>\n</ul>\n<p><strong>加权公平排队（WFQ）</strong></p>\n<ul>\n<li><p>WFQ也循环为各个不同类的队列提供服务;</p>\n</li>\n<li><p>但是不同类的队列，在每个循环周期中，所获得的服务量并不平等，而 是由其权值决定。</p>\n</li>\n</ul>\n<h2 id=\"5-4-网络协议：因特网中的转发和编制\"><a href=\"#5-4-网络协议：因特网中的转发和编制\" class=\"headerlink\" title=\"5.4 网络协议：因特网中的转发和编制\"></a>5.4 网络协议：因特网中的转发和编制</h2><h3 id=\"5-4-1-因特网中的网络协议-IPv4\"><a href=\"#5-4-1-因特网中的网络协议-IPv4\" class=\"headerlink\" title=\"5.4.1 因特网中的网络协议 IPv4\"></a>5.4.1 因特网中的网络协议 IPv4</h3><h4 id=\"1-IPv4-IP数据报格式\"><a href=\"#1-IPv4-IP数据报格式\" class=\"headerlink\" title=\"1. IPv4 (IP数据报格式)\"></a>1. IPv4 (IP数据报格式)</h4><p><img src=\"https://img.cetacis.dev/uploads/big/4ab981c8f08db2c1bf606febc875d949.png\" alt=\"\"></p>\n<p><strong>版本：</strong>IPv4/IPv6</p>\n<p><strong>区分服务</strong>：比如实时流量/分时流量/vip服务 不同的数据报类型。</p>\n<p><strong>总长度：</strong>首部+数据（byte） 应小于mtu（连路层最大传送单元 MTU</p>\n<p><strong>标识：</strong>它是一个计数器，用来产生数据报的标识。</p>\n<p><strong>生存时间TTL：</strong>在一次转发时 -1，当生存时间到0，则销毁此报文，防止形成回环。</p>\n<p><strong>协议：</strong>多种协议，协议字段指出了应将数据部分交给哪一个上层协议</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/ed540030996b58656482000d645b60fd.png\" alt=\"\"></p>\n<p><strong>首部检验和</strong>:(16 位)字段只检验数据报的首部 不检验数据部分。这里不采用 CRC 检验码而采用简单的计算方法。</p>\n<p>IPv4支持首部可变部分，IPv6不支持</p>\n<h4 id=\"2-IPv4数据分片和重组\"><a href=\"#2-IPv4数据分片和重组\" class=\"headerlink\" title=\"2. IPv4数据分片和重组\"></a>2. IPv4数据分片和重组</h4><ul>\n<li>每个数据链路有自己的MTU，链路类型 不同，MTU的值也不同，这里MTU指的 是数据链路帧的数据区的最大字节数（在发送的过程中，可能在链路层有不同的协议，即不同的MTU，会使已有的网络层数据报无法传送，则需要分片（变得更小）或者重组（变得更大）</li>\n<li>为了进一步识别出这些分组，需要对分 片进行标识</li>\n</ul>\n<p><strong>问题：</strong></p>\n<ul>\n<li>当一台目的主机从相同源收到一系列的数据报的时候，它需要确定，这些数据报中的某些是否是一些原来较大的数据报的片?</li>\n</ul>\n<p>在添加源地址和目的地址时，还会为该报文段，添加标识字段， 分片后的每个片，都具有相同的源地址和目的地址，以及相同的标识。（<strong><em>标识、标志、片偏移</em></strong>）</p>\n<p>标识：同一个源主机分片，每一个+1。</p>\n<ul>\n<li>如果是某些数据报的片，则它必须进一步确定何时收到了最后一片?</li>\n</ul>\n<p>标志字段中MF=0，则标识最后一个片</p>\n<ul>\n<li>它如何将这些片拼接还原为原来的初始数据报?</li>\n</ul>\n<p>通过片偏移字段，标识该片在初始IP数据报中的哪个位置。</p>\n<p><strong>分片的例子</strong></p>\n<p>4000 MTU = 1500</p>\n<p>只分数据段 4000 - 20； 1500 - 20</p>\n<p>偏移量 ： 第一个 = 0 第二个 1480/8(byte) 第三个 2*1480/8</p>\n<p>长度：第一个 = 1500 第二个 = 1500 第三个 = 1040 （4000 - 20 -（1500-20）* 2 +20）</p>\n<p>标志：前几个都是0 最后一个是1</p>\n<p>标识符：= 都一样</p>\n<p><strong>分片的问题</strong></p>\n<ul>\n<li><p>分片是有开销的。</p>\n</li>\n<li><p>使路由器和端系统更为复杂。</p>\n</li>\n<li><p>分片能够被用于生产致命的DoS攻击。（模拟分片/序号错乱）</p>\n<p><em>IPv6取消分片：当无法适应MTU，则返回源主机重发信息</em></p>\n</li>\n</ul>\n<h3 id=\"5-4-2-IP\"><a href=\"#5-4-2-IP\" class=\"headerlink\" title=\"5.4.2 IP\"></a>5.4.2 IP</h3><h4 id=\"1-IP地址\"><a href=\"#1-IP地址\" class=\"headerlink\" title=\"1. IP地址\"></a>1. IP地址</h4><p>IP 地址: 分配给主机或路由器<strong>接口</strong>的标识符（每一个路由器、主机都可有多个接口）IP地址与接口相关联</p>\n<p>接口: 主机/路由器与物理链路之间的 边界</p>\n<ul>\n<li><p>路由器有多个接口</p>\n</li>\n<li><p>主机可以有多个接口 </p>\n</li>\n<li><p>每个接口有一个IP地址</p>\n</li>\n</ul>\n<p>IP地址两种：</p>\n<ul>\n<li><p>IPV4:32个二进制位长(4字节)，常用点分十进制表示;</p>\n</li>\n<li><p>IPV6:128个二进制位长(16字节) 常用冒号分隔表示</p>\n</li>\n</ul>\n<h4 id=\"2-IPv4编制\"><a href=\"#2-IPv4编制\" class=\"headerlink\" title=\"2. IPv4编制\"></a>2. IPv4编制</h4><p>32比特二进制和点分十进制的方法</p>\n<p>将4个字节中的每一个字节分别用十进制数来表示，4个十进制数之间如</p>\n<p>223.1.1.1 = 11011111 00000001 00000001 00000001</p>\n<h4 id=\"3-IP地址结构\"><a href=\"#3-IP地址结构\" class=\"headerlink\" title=\"3. IP地址结构\"></a>3. IP地址结构</h4><p>IP 地址是一种分等级的地址结构，包括两部分: </p>\n<ul>\n<li>网络号:指明主机所在网络的编号。</li>\n<li>主机号:主机在网络中的编号。主机号为全0和全1的两个地址不能使用，用于特殊的目的!</li>\n</ul>\n<p><strong>IP地址分两个等级的好处是:</strong></p>\n<p>第一，IP 地址管理机构在分配 IP 地址时<strong>只分配网络号</strong>，而剩下的主机号则由得到该网络号的单位自行分配。这样就方便了 IP 地址的管理。</p>\n<p>第二，路由器<strong>仅根据目的主机所连接的网络号来转发分组</strong>(而不考虑目的主 机号)，这样就可以使路由表中的项目数大幅度减少，从而减小了路由表所 占的存储空间。</p>\n<h4 id=\"4-早期IP地址分类\"><a href=\"#4-早期IP地址分类\" class=\"headerlink\" title=\"4. 早期IP地址分类\"></a>4. 早期IP地址分类</h4><p><img src=\"https://img.cetacis.dev/uploads/big/6432c55a9ad7a000b62da31ee2470846.png\" alt=\"早期IP地址分类\"></p>\n<ul>\n<li><strong>A类</strong></li>\n</ul>\n<p>A类IP地址的<strong>网络号长度为8位，主机号长度为24位</strong>; </p>\n<p>A类地址是从:1.0.0.1~127.255.255.254; </p>\n<p>网络号可变长度为7位，从理论上可以有27=128个网络; </p>\n<p>网络号为全0和全1(用十进制表示为0与127)的两个地址保留用于特殊目 的，实际允许有126个不同的A类网络; </p>\n<p>由于主机号长度为24位，因此每个A类网络的主机IP数理论上为224=16 777 216; </p>\n<p>主机IP为全0和全1的两个地址保留用于特殊目的，每个网段实际允许连接 16 777 214个主机; </p>\n<p>A类IP地址结构适用于有大量主机的大型网络。 </p>\n<ul>\n<li><strong>B类</strong></li>\n</ul>\n<p>B类IP地址的<strong>网络号长度为</strong>16位<strong>，</strong>主机号长度为16位</p>\n<p>B类IP地址是从:128.0.0.1~191.255.255.254;</p>\n<p> 适合国际性大公司与政府机构等中等大小的组织</p>\n<ul>\n<li><strong>C类</strong></li>\n</ul>\n<p>C类IP地址的<strong>网络号</strong>长度为<strong>24</strong>位<strong>，</strong>主机号<strong>长度为</strong>8位;</p>\n<p>C类IP地址是从:192.0.0.1~223.255.255.254;</p>\n<p>适用于小公司 普通研究机构</p>\n<ul>\n<li><p><strong>D类</strong></p>\n<p>D类IP地址不标识网络;  224.0.0.0 - 239.255.255.255</p>\n<p>多地址</p>\n</li>\n<li><p><strong>E类</strong> </p>\n</li>\n</ul>\n<p>240.0.0.0-255.255.255.255</p>\n<p>实验使用 保留</p>\n<h4 id=\"5-特殊IP地址段\"><a href=\"#5-特殊IP地址段\" class=\"headerlink\" title=\"5. 特殊IP地址段\"></a>5. 特殊IP地址段</h4><ul>\n<li>0.0.0.0</li>\n</ul>\n<p>这个地址严格上来说都不是真正意义上的IP地址。主要是用来标识不清楚 的网络和主机的。系统遇到无法识别的网络或主机的时候会统一的归纳到 这个地址</p>\n<ul>\n<li>255.255.255.255 这个地址是受限的广播地址。</li>\n</ul>\n<p>主要指一个网段内的所有主机</p>\n<ul>\n<li>127.0.0.1</li>\n</ul>\n<p>这个是预留的一个IP地址，主要是用来识别电脑自己本身的地址。也叫做“localhost”一般用来测试使用的。做开发的人比较熟悉。</p>\n<ul>\n<li>10.x.x.x, 172.16.x.x-72.31.x.x, 192.168.x.x.</li>\n</ul>\n<p>这三个地址段主要是我们私有的内网地址。也就是我们平时企业或者家里局 域网所使用的地址段，我们比较熟悉的应该就是192.168.x.x 这个地址段了， 在公网不能路由。(RFC1918中保留)</p>\n<h4 id=\"6-互联网中的IP地址\"><a href=\"#6-互联网中的IP地址\" class=\"headerlink\" title=\"6. 互联网中的IP地址\"></a>6. <strong>互联网中的IP地址</strong></h4><p>同一局域网上的主机或路由器的IP地址中的网络号必须相同。 用IP术语来说，具有相同网络号的局域网，称为子网。 ( 在 因特网文献中 ， 子网也称为 1P 网络或直接称为网络 。 )</p>\n<p>交换机互连的网络仍然是一个局域网，只能有一个网络号。</p>\n<p>路由器总是具有两个或两个以上IP地址。</p>\n<p>当两个路由器直接相连时，在连线两端的接口处，可以指明 IP地址也可以不指明IP地址。</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/b3ac94848eeae3738de05f33fd21f42a.png\" alt=\"\"></p>\n<h4 id=\"7-子网\"><a href=\"#7-子网\" class=\"headerlink\" title=\"7. 子网\"></a>7. 子网</h4><p><strong>划分子网</strong></p>\n<p>IP 地址: 網絡號+ 主機號 网络号相同的IP地址属于同 一个网络。而网络还可以划 分为若干子网</p>\n<p>划分子网的方法：从主机号 借用若干个比特作为子网号 ，剩下的主机位为主机号。</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/053b07a71dee3bdf8edbf9fdf6cb4742.png\" alt=\"\"></p>\n<p><strong>子網特點</strong></p>\n<p>什么是一个子网 ?</p>\n<ul>\n<li>设备接口的IP地址具有同 样的网络部分</li>\n<li>没有路由器的介入，物理 上能够相互到达</li>\n</ul>\n<p><strong>子网掩码</strong></p>\n<ul>\n<li><p>子网号字段长度是可变的，因此，为了确定子网地址，IP协议提</p>\n<p>供了子网掩码的概念 。</p>\n</li>\n<li><p>子网掩码用来确定网络地址(包括网络号和子网号)和主机地址 的长度。子网掩码长为32位比特，其中的1对应于IP地址中的网 络号和子网号，而子网掩码中的0对应于主机号。</p>\n</li>\n</ul>\n<p><img src=\"https://img.cetacis.dev/uploads/big/19e15b01d1cd5a1d5c9f31d93d302f62.png\" alt=\"\"></p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/aba86e09488e237699bf4ef9342b2473.png\" alt=\"\"></p>\n<h4 id=\"8-技术发展\"><a href=\"#8-技术发展\" class=\"headerlink\" title=\"8. 技术发展\"></a>8. 技术发展</h4><p>一个A类的IP地址，可以有24bit用于分配主机地址，因此可以 支持 224个主机，但是一个家庭或者组织往往不需要这么多的地 址空间，造成浪费。 </p>\n<p> 一个C类的IP地址，只有8bit用于分配主机地址，因此只能支持 256个主机，又不太够用。 </p>\n<p> 因此，按传统IP地址分类方式分配IP被CIDR技术取代 </p>\n<p><strong><em>CIDR</em></strong> ： 无类别无间路由 网络前缀+主机号</p>\n<p>a.b.c.d/x  （x是地址网络部分的bit数 地址中的网络部分可以任意长(<strong>IP</strong>地址前缀或网络前缀)</p>\n<p>CIDR将网络前缀都相同的连续的IP地址组成“CIDR地址块”。</p>\n<p>CIDR 消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念，因 而可以更加有效地分配 IPv4 的地址空间。</p>\n<p><em>子网掩码：</em>/x的计法和255.255.255.0 都属于子网掩码</p>\n<p><strong>构造超网</strong></p>\n<p>一个公司或组织通常被分配一块连续的地址块，即具有相同前缀的一段地址。 </p>\n<p> CIDR将网络前缀都相同的连续的IP地址组成“CIDR地址块”。<br> 一个CIDR地址块可以表示多个内部的子网的集合，这种地址的聚合称为路由聚合，又称为构成超网。</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/9273227069681117e02deaa2f0510c18.png\" alt=\"\"></p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/05103f17bfe105dad5a7a6cdaab3c9b1.png\" alt=\"\"></p>\n<p><strong>全0 全1 都是不能作为主机号</strong></p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/e7c98a247bcbc19b1228645cc73a0942.png\" alt=\"\"></p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/bcb4eff878dbb9ff35ca8f74c121defb.png\" alt=\"\"></p>\n<p>单播地址：主机号不为全1或者全0</p>\n<h4 id=\"9-IP地址获取\"><a href=\"#9-IP地址获取\" class=\"headerlink\" title=\"9. IP地址获取\"></a>9. IP地址获取</h4><p><strong>主机如何得到IP地址</strong></p>\n<p>*<em>手工指定(保存在系统配置中) *</em></p>\n<p>• Windows: 控制面板-&gt;网络   • UNIX/LINUX: 在/etc/rc.config中，可使用ifconfig命令配置 </p>\n<p><strong>DHCP: Dynamic Host Configuration Protocol</strong></p>\n<p>• 自动从一个DHCP服务器得到IP地址 • 方便灵活</p>\n<p><strong>DHCP分配的不仅仅是IP地址，还可分配:</strong><br>• 客户的第一跳路由器的地址(网关) • DNS服务器的IP地址或域名• 子网掩码</p>\n<p>DHCP是应用程协议</p>\n<p><strong>动态主机配置协议</strong></p>\n<p>plug-and-play(即插即用) </p>\n<p>DHCP概述:</p>\n<p>• 主机广播 “DHCP DISCOVER” 消息<br>• DHCP 服务器用 “DHCP OFFER” 消息响应<br>• 主机请求IP地址: “DHCP REQUEST” 消息<br>• DHCP 服务器确认 “DHCP ACK/NACK” 消息 • DHCP 终止租用期”DHCP RELEASE”消息</p>\n<p>DHCP具体过程</p>\n<ul>\n<li>DHCP打开udp端口67 等待客户端发来的报文，等待客户端发来的报文</li>\n<li>DHCP客户从udp端口68发送dhcp发现报文</li>\n<li>凡收到dhcp发现报文的dhcp服务器都发出dhcp提供报文。客户端收到多个DHCP提供的报文。</li>\n<li>客户端选择一个ip，广播告诉大家我选了某个，未被选中的ip提供者回收ip （DHCP REQUEST）</li>\n<li>被选中的DHCP发送确认报文DHCPACK 客户端绑定，开始使用临时IP地址</li>\n</ul>\n<p>租用期（lifetime）为T，DHCP有两个计时器T1 T2 。T1 = 0.5T T2 = 0.875T。超时则请求更新租用期</p>\n<ul>\n<li>T1到，客户端发送DHCP REQUEST 要求更新租用期</li>\n<li>服务端不同意，发回否认报文 DHCPNACK，客户端必须立即停止使用原来的ip地址，重新申请ip地址（discover）</li>\n<li>若同意，服务端发送确认报文 dhcpack 客户得到新的租用期，重新设置计时器</li>\n<li>如果服务端不相应T1 到达T2，则重新发送request</li>\n<li>客户端可随时终止服务器提供的租用期，只需要发送DHCP RELEASE</li>\n</ul>\n<p><img src=\"https://img.cetacis.dev/uploads/big/e06d4aedea07a6bbee0aa09fb5015eac.png\" alt=\"\"></p>\n<p>Discover ：src: 本机 dest:目标（广播）yiaddr（被分配的ip地址）: 无ip所以为全0 t</p>\n<p>​                    ransaction ID: 传输id。相同则为对应恢复</p>\n<p>offer: 租用时间 : 3600 secs</p>\n<p>request: 广播原因：告诉别的dhcp服务器别等了，我已经选了某台了。服务端回收ip。</p>\n<p><strong>DHCP</strong> <strong>中继代理(relay agent)</strong></p>\n<ul>\n<li><p>并不是每个网络上都有 DHCP 服务器，这样会使 DHCP 服务器的数量太多。 现在是每一个网络至少有一个 DHCP 中继代理(通常是一台路由器)，它配置 了 DHCP 服务器的 IP 地址信息。</p>\n</li>\n<li><p>DHCP 中继代理收到主机发送的发现报文后，就以单播方式向 DHCP 服 务器转发此报文，并等待其回答。收到 DHCP 服务器回答的提供报文后， DHCP 中继代理再将此提供报文发回给主机。</p>\n</li>\n</ul>\n<h4 id=\"10-关于ip地址及域名的获得-NAT協議\"><a href=\"#10-关于ip地址及域名的获得-NAT協議\" class=\"headerlink\" title=\"10 关于ip地址及域名的获得 NAT協議\"></a>10 关于ip地址及域名的获得 NAT協議</h4><p>ISP获得地址块方法–ICANN</p>\n<p><strong>ICANN</strong>(Internet Corporation for Assigned Names and Numbers)</p>\n<ul>\n<li>分配IP地址</li>\n<li>管理DNS</li>\n<li>分配域名，解决纠纷</li>\n</ul>\n<p><em>ICANN( Internet Corporation for Assigned Names and Numbers ，互联网名称与数字地址分配机构)是一个非营利性的 国际组织，成立于1998年10月，是一个集合了全球网络界商业、 技术及学术各领域专家的非营利性国际组织，负责互联网协议 (IP)地址的空间分配、协议标识符的指派、通用顶级域名 (gTLD)以及国家和地区顶级域名(ccTLD)系统的管理、以及 根服务器系统的管理。这些服务最初是在美国政府合同下由互联 网号码分配当局(Internet Assigned Numbers Authority，IANA) 以及其它一些组织提供。现在，ICANN行使IANA的职能。</em></p>\n<p><strong>NIC</strong></p>\n<p>所有的IP地址都由ICANN规划，然后主要由国际组织NIC(Network Information Center)具体负责统一分配。</p>\n<p>目前全世界共有五个这样的网络信息中心</p>\n<p>我国申请IP地址要通过APNIC，APNIC的总部设在日本东京大学。申请时要考虑申 请哪一类的IP地址，然后向国内的代理机构提出。</p>\n<p>IPV4地址段早就枯竭了</p>\n<p><strong>NAT 网络地址转换</strong></p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/a3dfd50269006d3d1337e17ca1995a23.png\" alt=\"\"></p>\n<p>10.0.##  192.168.## 都是私网ip。他们有共同的源端up地址，有不同的源端口号</p>\n<p>动机： 对于外部网络来讲，本地网络只用一个ip地址</p>\n<ul>\n<li>不需要从isp分配一系列地址——只要一个ip地址用于所有设备</li>\n<li>在本地网络 改变设备的ip地址不通知外界</li>\n<li>更新isp不用更新本地的设备地址</li>\n<li>本地网络内部设备不能被外部世界明确寻址，或不可见（安全）</li>\n</ul>\n<p><img src=\"https://img.cetacis.dev/uploads/big/fbf732015ffbbcf2e462d608b041fcab.png\" alt=\"\"></p>\n<p><strong>执行NAT，路由器必须做到:</strong></p>\n<ul>\n<li><p>外出的分组: 替换每个外出的分组的 (源IP 地址, 端口号) 为 (NAT IP 地址, 新端口号)</p>\n<p>远程客户/服务器用(NAT IP地址, 新端口号)作为目的地来响应。 </p>\n</li>\n<li><p>在NAT转换表中，记录了每个(源IP 地址, 端口号)到 (NAT IP地址, 新端口号) 的对应关系。</p>\n</li>\n<li><p>进来的分组: 对每个进来的分组，用保存在NAT表中的对应的(源 IP 地址, 端口号) 替换分组中的目的域 (NAT IP 地址, 新端口号)</p>\n</li>\n</ul>\n<p><strong>NAT: 网络地址转换的一些限制</strong></p>\n<p>16-bit 端口号: 一个局域网地址可以同时支持60,000个并发连接!</p>\n<p>NAT 存在争议: 端口号，仅用于进程变址  路由器只应该处理到第三层 端口号是运输层</p>\n<p>​                        违反了端到端主张：应用程序设计者在设计时不得不将NAT加以考虑，如P2P应用程序</p>\n<p>​                        应使用IPv6来解决地址短缺问题</p>\n<p>UNnP (通用即插即用)</p>\n<p><em>NAT违背了计算机网络分层的思想，伪首部说明TCP、IP协议没有为严格分层</em> </p>\n<p>（沒有校驗合）</p>\n<h4 id=\"11-ICMP-Internet-Control-Message-Protocol，-因特网控制报文协议）\"><a href=\"#11-ICMP-Internet-Control-Message-Protocol，-因特网控制报文协议）\" class=\"headerlink\" title=\"11. ICMP: (Internet Control Message Protocol， 因特网控制报文协议）\"></a>11. <strong>ICMP: (Internet Control Message Protocol</strong>， 因特网控制报文协议）</h4><p>用于主机路由器之间彼此交流网络层信息：</p>\n<ul>\n<li>差错报告: 不可到达的主机, 网络,端口,协议</li>\n<li>请求/应答 (用于ping,traceroute)</li>\n</ul>\n<p>”位於ip之上“</p>\n<ul>\n<li>ICMP消息是裝載在ip分組裡 （ip協議字段標明有否icmp）</li>\n<li>但是真正的數據，ICMP包文是在ip數據中的</li>\n</ul>\n<p><img src=\"https://img.cetacis.dev/uploads/big/068b64ac5b008cecf35497c348c96165.png\" alt=\"\"></p>\n<p>ICMP 报文结构:</p>\n<p>类型字段, 编码字段、校验和字 段以及不同报文类型所加载的 数据。如果是差错报告，则后 面的数据包含引起该ICMP报文 的IP分组的报头和分组中的前8 字节的数据。</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/948e5a2d33e20583af434c9b0b9f5930.png\" alt=\"重要的icmp报文结构\"></p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/545b1e03766d41cb8d2f18e42edc6fc3.png\" alt=\"\"></p>\n<h4 id=\"13-虚拟专用网vpn（）\"><a href=\"#13-虚拟专用网vpn（）\" class=\"headerlink\" title=\"13. 虚拟专用网vpn（）\"></a>13. 虚拟专用网vpn（）</h4><ul>\n<li>多个分散的机构需要形成一个专用网进行通信时，利用因特网来实现多个分散机构的专用网，这样的专用网就称为虚拟专用网VPN：将IP地址</li>\n<li>配置成目标的内网ip</li>\n</ul>\n<p>vpn的实现：隧道技术</p>\n<p>将一个内网中的10.1.0.1的ip数据报封装在数据部分发出，到目的内网解封，好像就是内网之间的交流。</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/92164205c6b85ffc40b924793a5b1f78.png\" alt=\"\"></p>\n<h4 id=\"14-IPv6\"><a href=\"#14-IPv6\" class=\"headerlink\" title=\"14. IPv6\"></a>14. IPv6</h4><p>初始动机: 32-bit 地址空间即将用尽。</p>\n<p>其他动机:1. 首部格式可帮助加速处理/转发 2. 改变首部利于QoS要求</p>\n<p>首部格式改变: 1. IPv6 数据报:扩大的地址容量 2. 简化高效的 40 字节首部 3. 流标签</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/1533821297d0e9d21f88bff644df23ee.png\" alt=\"\"></p>\n<p>增加地址空间 首部简化（减少可选项）流标签 还没有确定 </p>\n<p>流量类型:表示流中分组的优先级,类似IPv4中的TOS字段，可用于给出给出一个流中某些数据的优先级。</p>\n<p>流标签: 表示分组在同一个 “流”中 (“流”的概念尚未完全定义).</p>\n<p>下一个首部: 表示数据的上层协议，类似IPv4中的协议字段。</p>\n<p>跳限制：类似于ttl</p>\n<p>校验和: 全部去掉，减少每一跳的处理时间</p>\n<p>选项: 允许, 但是不是标准首部的一部分，而是用下一个首部域 指出</p>\n<p>ICMPv6  :新版本的 ICMP （不会重新分片，而是回发错误信息，按照新的方式进行封装）<br>• 增加消息类型, 例如“分组太大”     • 多播组管理功能</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/27c91f4920f4dbb0b5afb99f0b9e35ee.png\" alt=\"\"></p>\n<p>地址还有其他压缩方法</p>\n<p><strong>ipv4到ipv6的过渡</strong></p>\n<p>并不是所有的路由器都能够同时升级</p>\n<p>• 没有 “标志日”</p>\n<p>• 同时有 IPv4 和 IPv6 路由器的网络如何工作?</p>\n<p>两种推荐方法:</p>\n<p>• 双栈:一些路由器具有双重栈 (v6, v4) 能够在两种格式中转换</p>\n<p>• 隧道: 在穿过IPv4路由器时，IPv6分组作为 IPv4分组的负载</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"自顶向下的计算机网络4-网络层\"><a href=\"#自顶向下的计算机网络4-网络层\" class=\"headerlink\" title=\"自顶向下的计算机网络4 网络层\"></a>自顶向下的计算机网络4 网络层</h1><h2 id=\"5-1-概述\"><a href=\"#5-1-概述\" class=\"headerlink\" title=\"5.1 概述\"></a>5.1 概述</h2><p>网络层在网络的主机和路由器中出现。</p>\n<p>本章主要讨论网络层如何实现主机到主机的通信服务。 将分组从发送主机移动到接收主机。</p>\n<p>分两个相互关联的部分讲解:数据平面和控制平面。</p>\n<h3 id=\"5-1-1-数据平面与控制平面\"><a href=\"#5-1-1-数据平面与控制平面\" class=\"headerlink\" title=\"5.1.1 数据平面与控制平面\"></a>5.1.1 数据平面与控制平面</h3><p><strong>数据平面功能：</strong></p>\n<p>转发：每台路由器的功能。当一个分组到达某个路由器的输入链路时，该路由器必须将其移动到合适的输出链路。</p>\n<p><strong>控制平面功能：</strong></p>\n<p>选路：全网范围决定路由的功能。确定分组从发送方流向接收方时所经过的路由或路径。 通过选路算法计算路径。</p>","more":"<p><strong>转发和选路区别：</strong></p>\n<p>转发:将分组从路由器的一个输入链路接口转移到一个合适的输出链路接口 的本地动作。</p>\n<p>• 只涉及分组在路由器中从入链路到出链路的传送。 • 通常用硬件实现。</p>\n<p>选路:指分组从源到目的地的端到端路径的网络范围动作。</p>\n<p>• 涉及网络中的所有路由器，集体经选路协议交互，决定分组从源到目的地的路径。</p>\n<p>• 通常由软件实现。</p>\n<p><strong>类比：</strong>转发: 通过单个立交桥的过程 选路: 从起点到目的终点计划行程的过程。</p>\n<h4 id=\"5-1-2-路由器如何转发分组\"><a href=\"#5-1-2-路由器如何转发分组\" class=\"headerlink\" title=\"5.1.2 路由器如何转发分组\"></a>5.1.2 路由器如何转发分组</h4><p><strong>转发表：</strong>每台路由器有一张。路由器根据到达分组的首部值在转发表中查询，找 到相应的输出链路接口，并 将分组转发出去。</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/1b9120823790432c9a7e4c0f15cbd631.png\" alt=\"转发\"></p>\n<p><strong>转发表是如何配置的：</strong></p>\n<ul>\n<li>转发表的内容由选路算法决定</li>\n<li>集中式（多台路由器有一个数据中心，或者由单点计算分发）或分布式（每台路由器单独生成自己的转发表） <em>不管哪一种，都有多台路由之间的交互</em></li>\n</ul>\n<h4 id=\"1-控制平面\"><a href=\"#1-控制平面\" class=\"headerlink\" title=\"1. 控制平面\"></a>1. 控制平面</h4><p>传统方式：每个路由器都有单独的路由算法组件，路由器之间通过交互来实现控制平面</p>\n<p>SDN方法：一个分离的(通常是远程的)控制器和路由器本地的控制代理 (local controlagents，CAs) 交互。软件定义网络，由远程的控制器计算分发转发表。可以由isp或者专门的公司管理。</p>\n<h4 id=\"2-一些术语\"><a href=\"#2-一些术语\" class=\"headerlink\" title=\"2. 一些术语\"></a>2. 一些术语</h4><p><strong>分组交换机：</strong>一台通用分组交换设备，根据<strong>分组首部值</strong>，从输入链路接 口到输出链路接口传送分组。</p>\n<p><strong>链路层交换机：</strong>根据<em>链路层字段值</em>作转发决定的分组交换机。 </p>\n<p><strong>路由器：</strong>根据<em>网络层字段值</em>作转发决定的分组交换机。</p>\n<h4 id=\"3-建立连接\"><a href=\"#3-建立连接\" class=\"headerlink\" title=\"3. 建立连接\"></a>3. 建立连接</h4><p><strong>传输层连接</strong>: 如TCP协议，在数据实际传输之前，需要发送方 和接收方经过三次握手建立所需的状态信息。两个进程之间 建立连接</p>\n<p><strong>网络层连接</strong>: 指网络层数据分组开始传输前，在所选择的从源 到目的地路径上的各路由器之间相互握手，建立连接状态。</p>\n<p>如ATM、帧中继、MPLS的网络层。(已经很少使用)。如今的因特网网络层不执行连接建立。</p>\n<h3 id=\"5-1-3-网络服务模型\"><a href=\"#5-1-3-网络服务模型\" class=\"headerlink\" title=\"5.1.3 网络服务模型\"></a>5.1.3 网络服务模型</h3><p>问题：</p>\n<ul>\n<li>发送主机的运输层是否能依靠网络层将分组交付到目的地; </li>\n<li>多个分组是否能按发送顺序交付给接收主机的运输层; </li>\n<li>传输两个连续分组的时间间隔是否与接收到的时间间隔相同; </li>\n<li>网络层是否能提供网络拥塞的反馈信息;</li>\n</ul>\n<p>由网络层提供的服务模型来确定</p>\n<h4 id=\"网络层可能提供的服务\"><a href=\"#网络层可能提供的服务\" class=\"headerlink\" title=\"网络层可能提供的服务\"></a><strong>网络层可能提供的服务</strong></h4><ol>\n<li><p><strong>网络层可能提供的服务</strong></p>\n<ul>\n<li><p>确保交付:确保分组到达目的地。</p>\n</li>\n<li><p>有序分组交付:按发送顺序到达。</p>\n</li>\n<li><p>具有时延上界的确保交付:主机到主</p>\n<p>机的时延。</p>\n</li>\n<li><p>确保最小带宽:当发送主机以低于特</p>\n<p>定比特率的速率发送比特，分组不会</p>\n<p>丢失，在一定时延到达。</p>\n</li>\n<li><p>确保最大时延抖动:发送方发送两个</p>\n<p>连续分组的时间间隔与接收到的间隔 相同。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>因特网的网络层提供的服务</strong>• 单一服务，即尽力而为服务(best-effort service) 。</p>\n<ul>\n<li>分组间的定时不能被保证;</li>\n<li>分组的接收顺序与发送顺序不一定相同;</li>\n<li>传送的分组不能保证最终交付，即网络可能未向目的地交付分 组。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"5-2-虚电路与数据报网络\"><a href=\"#5-2-虚电路与数据报网络\" class=\"headerlink\" title=\"5.2 虚电路与数据报网络\"></a>5.2 虚电路与数据报网络</h2><h3 id=\"5-2-1-网络层与运输层\"><a href=\"#5-2-1-网络层与运输层\" class=\"headerlink\" title=\"5.2.1 网络层与运输层\"></a>5.2.1 网络层与运输层</h3><p>• 运输层:提供无连接服务和面向连接服务。 如因特网的UDP、TCP 。</p>\n<p>• 网络层:提供无连接服务和面向连接服务。</p>\n<p>面向连接服务:源和目的主机之间先握手。 </p>\n<p>无连接服务:无握手过程。</p>\n<h4 id=\"网络层与运输层区别\"><a href=\"#网络层与运输层区别\" class=\"headerlink\" title=\"网络层与运输层区别\"></a><strong>网络层与运输层区别</strong></h4><ol>\n<li>服务对象</li>\n</ol>\n<p>网络层:向运输层提供的主机到主机的服务。</p>\n<p>运输层:向应用层提供的进程到进程的服务。</p>\n<ol start=\"2\">\n<li>服务选择</li>\n</ol>\n<p>网络层:任何网络中的网络层只提供两种服务之一， 不会同时提供。</p>\n<p>​    虚电路网络:仅在网络层提供连接服务的计算机网络。</p>\n<p>​    数据报网络:仅在网络层提供无连接服务的计算机网络。（二选一</p>\n<ol start=\"3\">\n<li>实现</li>\n</ol>\n<p>运输层:面向连接服务在网络边缘的端系统中实现。 </p>\n<p>网络层:面向连接服务在端系统及网络核心的路由器中实现。</p>\n<h3 id=\"5-2-2-虚电路与数据报网络\"><a href=\"#5-2-2-虚电路与数据报网络\" class=\"headerlink\" title=\"5.2.2 虚电路与数据报网络\"></a>5.2.2 虚电路与数据报网络</h3><h4 id=\"1-虚电路\"><a href=\"#1-虚电路\" class=\"headerlink\" title=\"1. 虚电路\"></a>1. 虚电路</h4><p>在数据传输前，需要为每一呼叫建立链接</p>\n<p>每个分组携带vc标识符（不是目的主机地址</p>\n<p>位于”源-目的地址“上每个路由器会维护经过它的每条链接的”状态“</p>\n<h4 id=\"2-数据报网络\"><a href=\"#2-数据报网络\" class=\"headerlink\" title=\"2. 数据报网络\"></a>2. 数据报网络</h4><ul>\n<li>在网络层无呼叫过程</li>\n<li>路由器：不需要维护端到端链接的状态</li>\n<li>没有网络等级的”链接“概念</li>\n<li>使用目的主机的地址进行分组转发</li>\n</ul>\n<p><em>相同源和目的的分组可能采用不同的路径</em></p>\n<p><strong>数据报转发表</strong></p>\n<p>如果为每个目的地址建立一个表项，那么将需要建立大约40亿个表项，因此转发表中采用地址范围来建立表项。某一前缀匹配专门的链路接口</p>\n<p>最长前缀的匹配规则。</p>\n<ul>\n<li>路由器转发表只维持转发信息;</li>\n<li>转发表由选路算法修改(1~5分钟更新);虚电路网络转发表随虚电路的建立和拆除更新。</li>\n<li>一个端系统发送给另一个端系统的一批分组可能在网络中选 择不同的路径，到达的顺序可能不一致。</li>\n</ul>\n<p><strong>数据报网络的特点</strong></p>\n<p>由互连计算机的需求发展而来。与电话网相反。</p>\n<ul>\n<li><p>网络层服务模型简单。</p>\n</li>\n<li><p>端系统功能复杂:高层实现许多功能，如按序传送、可靠数据传输、拥塞 控制与DNS名字解析等;</p>\n</li>\n</ul>\n<p>带来的结果</p>\n<ul>\n<li><p>因特网服务模型提供的服务保证最少(可能没有!)，对网络层的需求最小，使得*<em>互连使用各种不同链路层技术的网络变得更加容易。 *</em></p>\n</li>\n<li><p>许多应用都在位于网络边缘的主机(服务器)上实现。</p>\n</li>\n</ul>\n<p>源主机和中转路由器都不知道完整路径</p>\n<h2 id=\"5-3-路由器的工作原理\"><a href=\"#5-3-路由器的工作原理\" class=\"headerlink\" title=\"5.3 路由器的工作原理\"></a>5.3 路由器的工作原理</h2><p>网络层转发功能: 将分组从路由器的输入链路传送到适当的输出链路。</p>\n<h3 id=\"5-3-1-路由器的体系结构\"><a href=\"#5-3-1-路由器的体系结构\" class=\"headerlink\" title=\"5.3.1 路由器的体系结构:\"></a>5.3.1 路由器的体系结构:</h3><p><img src=\"https://img.cetacis.dev/uploads/big/f7f701b9a9f06ba62b8c90a30d699d5d.png\" alt=\"路由器整体结构\"></p>\n<p>选路处理器：选路算法</p>\n<p>输入端口：确定要转发的方向</p>\n<h3 id=\"5-3-2-输入端口\"><a href=\"#5-3-2-输入端口\" class=\"headerlink\" title=\"5.3.2 输入端口\"></a>5.3.2 输入端口</h3><p>物理层-第一个线路端接模块：将一条物理链路端接到路由器的物理层; bit为单位接收数据</p>\n<p>链路层-第二个数据链路处理模块:实现路由器的数据链路层功能;进行分析，解封装</p>\n<p>网络层-第三个查找与转发模块:实现查找与转发功能，以便分组通过路由器交换结构 转发到适当的输出端口;分散式转发：根据数据报的目的地址，使用输入端口内存中缓存的转发 表查找输出端口</p>\n<p>交换结构：实现转发</p>\n<p>输入端口——查找转发模块</p>\n<p>确定将一个到达的分组通过交换结构转发给哪个输出端口。 通过查找转发表实现，这里的转发表是存储在输入端口的内存中。</p>\n<h4 id=\"1-分散式转发\"><a href=\"#1-分散式转发\" class=\"headerlink\" title=\"1.分散式转发:\"></a>1.<strong>分散式转发:</strong></h4><p>选路处理器计算转发表，给每个输入端口存放一份转发表拷贝。 </p>\n<p>在每个输入端口本地做出交换决策，无须激活中央选路处理器。 </p>\n<p>可避免在路由器中某个单点产生转发处理瓶颈。</p>\n<h4 id=\"2-表\"><a href=\"#2-表\" class=\"headerlink\" title=\"2.表\"></a>2.表</h4><p><strong>查表速度</strong></p>\n<p>查表:搜索转发表，查找最长匹配的表项，若无相应表项找出默认选路表 项。</p>\n<p>查找速度:受许多因素影响，如路由器速度、链路速率、查找算法等。</p>\n<p>目标:输入端口的处理速度要超过线路速度。即完成一次查找的时间应少于从输入端口接收一个分组所需的时间(对收到的分组的输入处理在下一个接收操作结束之前完成)。（减少排队）</p>\n<p>如，对运行速率为2.5Gbit/s的OC48链路，若分组长256B，查找速度 大约为每秒一百万次。</p>\n<p><strong>查表方法</strong></p>\n<p>线性查找：桉顺序查 （不适合庞大转发表</p>\n<p>二分查找：转发表村房子树形结构中</p>\n<p>三态内容可寻址内存（TCAM）</p>\n<p><strong>输入端口问题</strong></p>\n<ul>\n<li>分组阻塞</li>\n</ul>\n<p>来自其他输入端口的分组当前正在使用交换结构。被阻塞的分组必须在输入端口处排队，等待以后调度通过交换结构。除查找这个最基本的动作外，在输入端口还必须采取其他动作:</p>\n<ol>\n<li>必须实现物理层和链路层处理</li>\n<li>必须检查分组的版本号、检验和以及TTL字段。</li>\n<li>必须更新用于网络的管理的计数器。（ 管理统计端口的流量，动态调整端口流量。</li>\n</ol>\n<h3 id=\"5-3-3-交换结构\"><a href=\"#5-3-3-交换结构\" class=\"headerlink\" title=\"5.3.3 交换结构\"></a>5.3.3 交换结构</h3><h4 id=\"1-三种类型-概述\"><a href=\"#1-三种类型-概述\" class=\"headerlink\" title=\"1. 三种类型 概述\"></a>1. 三种类型 概述</h4><p><img src=\"https://img.cetacis.dev/uploads/big/c42a9aa170ffb58d853e9d16f0e7cfa0.png\" alt=\"\"></p>\n<h4 id=\"2-经内存的交换结构\"><a href=\"#2-经内存的交换结构\" class=\"headerlink\" title=\"2. 经内存的交换结构\"></a>2. 经内存的交换结构</h4><p>早期用计算机作为路由器时采用的结构(第一代)</p>\n<ul>\n<li><p>输入端口与输出端口之间的交换由CPU(选路处理器)控制完成;</p>\n</li>\n<li><p>输入端口与输出端口类似I/O设备:</p>\n<ul>\n<li><p>当分组到达输入端口时，通过中断向选路处理 器发出信号，将分组拷贝到处理器内存中;</p>\n</li>\n<li><p>选路处理器根据分组中的目的地址查表找出适 当的输出端口，将该分组拷贝到输出端口的缓存中。</p>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>转发速度</strong></p>\n<p>交换速度受总线带宽的速度限制 (每个分组穿过两次总线)</p>\n<p>若总线带宽为每秒写入或读出B个分组，则总的转发吞吐量 (分组 从输入端口被传送到输出端口的总速率)小于B/2。</p>\n<h4 id=\"3-经总线的交换结构\"><a href=\"#3-经总线的交换结构\" class=\"headerlink\" title=\"3. 经总线的交换结构\"></a>3. <strong>经总线的交换结构</strong></h4><p>输入端口通过一条共享总线将分组直接传送到输出端口，不需要 选路处理器的干预。</p>\n<ul>\n<li>每次只能有一个分组通过总线传送。</li>\n<li>分组到达一个输入端口时，若总线正忙，会被暂时阻塞，在输入端口排队</li>\n<li>路由器交换带宽受总线速率限制。</li>\n</ul>\n<h4 id=\"4-经交换矩阵交换-经互联网络交换-结构\"><a href=\"#4-经交换矩阵交换-经互联网络交换-结构\" class=\"headerlink\" title=\"4. 经交换矩阵交换(经互联网络交换)结构\"></a>4. 经交换矩阵交换(经互联网络交换)结构</h4><p>纵横式交换机:由2n 条总线组成，n 个输入端口与n 个输出端口连接。</p>\n<p>到达输入端口的分组沿水平总线穿行，直至与所希望的输出端口的垂直总线交叉点:</p>\n<ul>\n<li>若该条垂直总线空闲，则分组被传送到输出端口;</li>\n<li>否则，该到达的分组被阻塞，必须在输入端口排队。</li>\n</ul>\n<p><img src=\"https://img.cetacis.dev/uploads/big/8b2ccbb3fe8ec8f8a93cebaa11444673.png\" alt=\"\"></p>\n<p>高级设计:更为复杂的互 联网络使用多级交换元 素 ， 以使来自不同输入 端口的分组通过交换结 构同时朝着相同的输出 端口前行 。</p>\n<h3 id=\"5-3-4-排队\"><a href=\"#5-3-4-排队\" class=\"headerlink\" title=\"5.3.4 排队\"></a>5.3.4 排队</h3><p>取出存放在输出端口内存中的分组，并将其传输到输出链路上。</p>\n<p>当交换结构将分组交付给输出端口的速率超过输出链路速率，就需要排队与缓存管理功能。当输出端口的缓冲区溢出时，就会出现延时和丢包。</p>\n<h4 id=\"1-输入端口不排队\"><a href=\"#1-输入端口不排队\" class=\"headerlink\" title=\"1. 输入端口不排队\"></a>1. <strong>输入端口不排队</strong></h4><p>若交换结构的速率至少是输入线路速率的n倍，在输入端口处不会出现排队。</p>\n<h4 id=\"2-输入端口分组排队\"><a href=\"#2-输入端口分组排队\" class=\"headerlink\" title=\"2. 输入端口分组排队\"></a><strong>2. 输入端口分组排队</strong></h4><p>交换结构比输入端口总和的速度慢: 输入队列产生排队</p>\n<p>交换结构不够快，即相对于输入线路速度不能快得使所有到达的分 组无延迟地通过它传送，则在输入端口出现分组排队，以等待通过交换 结构传送到输出端口。</p>\n<p>线路前部HOL (head-of-the-line)阻塞: 输入队列中后面的分组被位于线路头的一个分组阻塞(即使输出端口空</p>\n<p>闲的)，等待通过交换结构发送。</p>\n<h4 id=\"3-输出端口分组排队\"><a href=\"#3-输出端口分组排队\" class=\"headerlink\" title=\"3. 输出端口分组排队\"></a>3. 输出端口分组排队</h4><p>设交换结构的速率至少是线路速率的n倍。</p>\n<p>最坏情况:到达每个输入端口的分组都被发往同一个输出端口。</p>\n<ul>\n<li>在一个单位时间(接收或发送一个分组)内，将有n个分组到达该输出端口， 排队(等待)发送到输出链路上;</li>\n<li>在发出队列中一个分组的时间内，又有n个分组到达。</li>\n</ul>\n<p>依此类推，最终排队的分组快速增长，很快占满输出端口的存储空间， 使后续分组被丢弃。</p>\n<h4 id=\"4-分组丢弃方法\"><a href=\"#4-分组丢弃方法\" class=\"headerlink\" title=\"4. 分组丢弃方法\"></a>4. 分组丢弃方法</h4><p>若缓存已满，丢弃分组。 </p>\n<ul>\n<li>丢弃后到的分组(弃尾); </li>\n<li>删除一个或多个已排队的分组;<ul>\n<li>主动队列管理AQM算法:在缓存填满前丢弃分组或首部加标记，向发送 方提供拥塞信号。</li>\n<li>如，随机早期检测RED算法: 输出队列长度维护一个加权平均值。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"5-3-5-分组调度程序\"><a href=\"#5-3-5-分组调度程序\" class=\"headerlink\" title=\"5.3.5 分组调度程序\"></a>5.3.5 分组调度程序</h3><p>在输出端口排队的分组中选出一个发送。 原则:</p>\n<p>先来先服务FCFS:简单。</p>\n<p>优先权排队:具有优先级。</p>\n<p>加权公平排队WFQ:在具有排队分组的不同端到端连接之间公平地共享输 出链路。</p>\n<h4 id=\"1-先来先服务FCFS\"><a href=\"#1-先来先服务FCFS\" class=\"headerlink\" title=\"1. 先来先服务FCFS\"></a>1. 先来先服务FCFS</h4><ul>\n<li>按到达的顺序发送分组;</li>\n<li>如果分组到达时，没有足够的缓存空间，该如何丢弃分组?<ul>\n<li>尾弃</li>\n<li>基于优先级删除 (比如已有跳数)</li>\n<li>随机删除</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-优先权排队\"><a href=\"#2-优先权排队\" class=\"headerlink\" title=\"2. 优先权排队\"></a>2. 优先权排队</h4><p><strong>优先级调度</strong>:</p>\n<ul>\n<li><p>输出队列分类为多个具有不同优先级队列;</p>\n</li>\n<li><p>根据到达分组的类型，引导到不同优先级的 队列中。</p>\n</li>\n<li><p>优先发送具有最高优先级队列中的分组;</p>\n</li>\n</ul>\n<p>但是在低优先级发送时，高优先级不能抢占低优先级。</p>\n<h4 id=\"3-循环加权公平队列\"><a href=\"#3-循环加权公平队列\" class=\"headerlink\" title=\"3. 循环加权公平队列\"></a>3. 循环加权公平队列</h4><p><strong>循环队列规则</strong>:</p>\n<ul>\n<li>输出队列按类分为多个队列，不同类之间没有严格的服务优先权区分。 </li>\n<li>据到达分组的类型，引导到不类别的队列中。</li>\n<li>循环调度器在这些不同类所对应的队列中轮流提供服务。</li>\n</ul>\n<p><strong>加权公平排队（WFQ）</strong></p>\n<ul>\n<li><p>WFQ也循环为各个不同类的队列提供服务;</p>\n</li>\n<li><p>但是不同类的队列，在每个循环周期中，所获得的服务量并不平等，而 是由其权值决定。</p>\n</li>\n</ul>\n<h2 id=\"5-4-网络协议：因特网中的转发和编制\"><a href=\"#5-4-网络协议：因特网中的转发和编制\" class=\"headerlink\" title=\"5.4 网络协议：因特网中的转发和编制\"></a>5.4 网络协议：因特网中的转发和编制</h2><h3 id=\"5-4-1-因特网中的网络协议-IPv4\"><a href=\"#5-4-1-因特网中的网络协议-IPv4\" class=\"headerlink\" title=\"5.4.1 因特网中的网络协议 IPv4\"></a>5.4.1 因特网中的网络协议 IPv4</h3><h4 id=\"1-IPv4-IP数据报格式\"><a href=\"#1-IPv4-IP数据报格式\" class=\"headerlink\" title=\"1. IPv4 (IP数据报格式)\"></a>1. IPv4 (IP数据报格式)</h4><p><img src=\"https://img.cetacis.dev/uploads/big/4ab981c8f08db2c1bf606febc875d949.png\" alt=\"\"></p>\n<p><strong>版本：</strong>IPv4/IPv6</p>\n<p><strong>区分服务</strong>：比如实时流量/分时流量/vip服务 不同的数据报类型。</p>\n<p><strong>总长度：</strong>首部+数据（byte） 应小于mtu（连路层最大传送单元 MTU</p>\n<p><strong>标识：</strong>它是一个计数器，用来产生数据报的标识。</p>\n<p><strong>生存时间TTL：</strong>在一次转发时 -1，当生存时间到0，则销毁此报文，防止形成回环。</p>\n<p><strong>协议：</strong>多种协议，协议字段指出了应将数据部分交给哪一个上层协议</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/ed540030996b58656482000d645b60fd.png\" alt=\"\"></p>\n<p><strong>首部检验和</strong>:(16 位)字段只检验数据报的首部 不检验数据部分。这里不采用 CRC 检验码而采用简单的计算方法。</p>\n<p>IPv4支持首部可变部分，IPv6不支持</p>\n<h4 id=\"2-IPv4数据分片和重组\"><a href=\"#2-IPv4数据分片和重组\" class=\"headerlink\" title=\"2. IPv4数据分片和重组\"></a>2. IPv4数据分片和重组</h4><ul>\n<li>每个数据链路有自己的MTU，链路类型 不同，MTU的值也不同，这里MTU指的 是数据链路帧的数据区的最大字节数（在发送的过程中，可能在链路层有不同的协议，即不同的MTU，会使已有的网络层数据报无法传送，则需要分片（变得更小）或者重组（变得更大）</li>\n<li>为了进一步识别出这些分组，需要对分 片进行标识</li>\n</ul>\n<p><strong>问题：</strong></p>\n<ul>\n<li>当一台目的主机从相同源收到一系列的数据报的时候，它需要确定，这些数据报中的某些是否是一些原来较大的数据报的片?</li>\n</ul>\n<p>在添加源地址和目的地址时，还会为该报文段，添加标识字段， 分片后的每个片，都具有相同的源地址和目的地址，以及相同的标识。（<strong><em>标识、标志、片偏移</em></strong>）</p>\n<p>标识：同一个源主机分片，每一个+1。</p>\n<ul>\n<li>如果是某些数据报的片，则它必须进一步确定何时收到了最后一片?</li>\n</ul>\n<p>标志字段中MF=0，则标识最后一个片</p>\n<ul>\n<li>它如何将这些片拼接还原为原来的初始数据报?</li>\n</ul>\n<p>通过片偏移字段，标识该片在初始IP数据报中的哪个位置。</p>\n<p><strong>分片的例子</strong></p>\n<p>4000 MTU = 1500</p>\n<p>只分数据段 4000 - 20； 1500 - 20</p>\n<p>偏移量 ： 第一个 = 0 第二个 1480/8(byte) 第三个 2*1480/8</p>\n<p>长度：第一个 = 1500 第二个 = 1500 第三个 = 1040 （4000 - 20 -（1500-20）* 2 +20）</p>\n<p>标志：前几个都是0 最后一个是1</p>\n<p>标识符：= 都一样</p>\n<p><strong>分片的问题</strong></p>\n<ul>\n<li><p>分片是有开销的。</p>\n</li>\n<li><p>使路由器和端系统更为复杂。</p>\n</li>\n<li><p>分片能够被用于生产致命的DoS攻击。（模拟分片/序号错乱）</p>\n<p><em>IPv6取消分片：当无法适应MTU，则返回源主机重发信息</em></p>\n</li>\n</ul>\n<h3 id=\"5-4-2-IP\"><a href=\"#5-4-2-IP\" class=\"headerlink\" title=\"5.4.2 IP\"></a>5.4.2 IP</h3><h4 id=\"1-IP地址\"><a href=\"#1-IP地址\" class=\"headerlink\" title=\"1. IP地址\"></a>1. IP地址</h4><p>IP 地址: 分配给主机或路由器<strong>接口</strong>的标识符（每一个路由器、主机都可有多个接口）IP地址与接口相关联</p>\n<p>接口: 主机/路由器与物理链路之间的 边界</p>\n<ul>\n<li><p>路由器有多个接口</p>\n</li>\n<li><p>主机可以有多个接口 </p>\n</li>\n<li><p>每个接口有一个IP地址</p>\n</li>\n</ul>\n<p>IP地址两种：</p>\n<ul>\n<li><p>IPV4:32个二进制位长(4字节)，常用点分十进制表示;</p>\n</li>\n<li><p>IPV6:128个二进制位长(16字节) 常用冒号分隔表示</p>\n</li>\n</ul>\n<h4 id=\"2-IPv4编制\"><a href=\"#2-IPv4编制\" class=\"headerlink\" title=\"2. IPv4编制\"></a>2. IPv4编制</h4><p>32比特二进制和点分十进制的方法</p>\n<p>将4个字节中的每一个字节分别用十进制数来表示，4个十进制数之间如</p>\n<p>223.1.1.1 = 11011111 00000001 00000001 00000001</p>\n<h4 id=\"3-IP地址结构\"><a href=\"#3-IP地址结构\" class=\"headerlink\" title=\"3. IP地址结构\"></a>3. IP地址结构</h4><p>IP 地址是一种分等级的地址结构，包括两部分: </p>\n<ul>\n<li>网络号:指明主机所在网络的编号。</li>\n<li>主机号:主机在网络中的编号。主机号为全0和全1的两个地址不能使用，用于特殊的目的!</li>\n</ul>\n<p><strong>IP地址分两个等级的好处是:</strong></p>\n<p>第一，IP 地址管理机构在分配 IP 地址时<strong>只分配网络号</strong>，而剩下的主机号则由得到该网络号的单位自行分配。这样就方便了 IP 地址的管理。</p>\n<p>第二，路由器<strong>仅根据目的主机所连接的网络号来转发分组</strong>(而不考虑目的主 机号)，这样就可以使路由表中的项目数大幅度减少，从而减小了路由表所 占的存储空间。</p>\n<h4 id=\"4-早期IP地址分类\"><a href=\"#4-早期IP地址分类\" class=\"headerlink\" title=\"4. 早期IP地址分类\"></a>4. 早期IP地址分类</h4><p><img src=\"https://img.cetacis.dev/uploads/big/6432c55a9ad7a000b62da31ee2470846.png\" alt=\"早期IP地址分类\"></p>\n<ul>\n<li><strong>A类</strong></li>\n</ul>\n<p>A类IP地址的<strong>网络号长度为8位，主机号长度为24位</strong>; </p>\n<p>A类地址是从:1.0.0.1~127.255.255.254; </p>\n<p>网络号可变长度为7位，从理论上可以有27=128个网络; </p>\n<p>网络号为全0和全1(用十进制表示为0与127)的两个地址保留用于特殊目 的，实际允许有126个不同的A类网络; </p>\n<p>由于主机号长度为24位，因此每个A类网络的主机IP数理论上为224=16 777 216; </p>\n<p>主机IP为全0和全1的两个地址保留用于特殊目的，每个网段实际允许连接 16 777 214个主机; </p>\n<p>A类IP地址结构适用于有大量主机的大型网络。 </p>\n<ul>\n<li><strong>B类</strong></li>\n</ul>\n<p>B类IP地址的<strong>网络号长度为</strong>16位<strong>，</strong>主机号长度为16位</p>\n<p>B类IP地址是从:128.0.0.1~191.255.255.254;</p>\n<p> 适合国际性大公司与政府机构等中等大小的组织</p>\n<ul>\n<li><strong>C类</strong></li>\n</ul>\n<p>C类IP地址的<strong>网络号</strong>长度为<strong>24</strong>位<strong>，</strong>主机号<strong>长度为</strong>8位;</p>\n<p>C类IP地址是从:192.0.0.1~223.255.255.254;</p>\n<p>适用于小公司 普通研究机构</p>\n<ul>\n<li><p><strong>D类</strong></p>\n<p>D类IP地址不标识网络;  224.0.0.0 - 239.255.255.255</p>\n<p>多地址</p>\n</li>\n<li><p><strong>E类</strong> </p>\n</li>\n</ul>\n<p>240.0.0.0-255.255.255.255</p>\n<p>实验使用 保留</p>\n<h4 id=\"5-特殊IP地址段\"><a href=\"#5-特殊IP地址段\" class=\"headerlink\" title=\"5. 特殊IP地址段\"></a>5. 特殊IP地址段</h4><ul>\n<li>0.0.0.0</li>\n</ul>\n<p>这个地址严格上来说都不是真正意义上的IP地址。主要是用来标识不清楚 的网络和主机的。系统遇到无法识别的网络或主机的时候会统一的归纳到 这个地址</p>\n<ul>\n<li>255.255.255.255 这个地址是受限的广播地址。</li>\n</ul>\n<p>主要指一个网段内的所有主机</p>\n<ul>\n<li>127.0.0.1</li>\n</ul>\n<p>这个是预留的一个IP地址，主要是用来识别电脑自己本身的地址。也叫做“localhost”一般用来测试使用的。做开发的人比较熟悉。</p>\n<ul>\n<li>10.x.x.x, 172.16.x.x-72.31.x.x, 192.168.x.x.</li>\n</ul>\n<p>这三个地址段主要是我们私有的内网地址。也就是我们平时企业或者家里局 域网所使用的地址段，我们比较熟悉的应该就是192.168.x.x 这个地址段了， 在公网不能路由。(RFC1918中保留)</p>\n<h4 id=\"6-互联网中的IP地址\"><a href=\"#6-互联网中的IP地址\" class=\"headerlink\" title=\"6. 互联网中的IP地址\"></a>6. <strong>互联网中的IP地址</strong></h4><p>同一局域网上的主机或路由器的IP地址中的网络号必须相同。 用IP术语来说，具有相同网络号的局域网，称为子网。 ( 在 因特网文献中 ， 子网也称为 1P 网络或直接称为网络 。 )</p>\n<p>交换机互连的网络仍然是一个局域网，只能有一个网络号。</p>\n<p>路由器总是具有两个或两个以上IP地址。</p>\n<p>当两个路由器直接相连时，在连线两端的接口处，可以指明 IP地址也可以不指明IP地址。</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/b3ac94848eeae3738de05f33fd21f42a.png\" alt=\"\"></p>\n<h4 id=\"7-子网\"><a href=\"#7-子网\" class=\"headerlink\" title=\"7. 子网\"></a>7. 子网</h4><p><strong>划分子网</strong></p>\n<p>IP 地址: 網絡號+ 主機號 网络号相同的IP地址属于同 一个网络。而网络还可以划 分为若干子网</p>\n<p>划分子网的方法：从主机号 借用若干个比特作为子网号 ，剩下的主机位为主机号。</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/053b07a71dee3bdf8edbf9fdf6cb4742.png\" alt=\"\"></p>\n<p><strong>子網特點</strong></p>\n<p>什么是一个子网 ?</p>\n<ul>\n<li>设备接口的IP地址具有同 样的网络部分</li>\n<li>没有路由器的介入，物理 上能够相互到达</li>\n</ul>\n<p><strong>子网掩码</strong></p>\n<ul>\n<li><p>子网号字段长度是可变的，因此，为了确定子网地址，IP协议提</p>\n<p>供了子网掩码的概念 。</p>\n</li>\n<li><p>子网掩码用来确定网络地址(包括网络号和子网号)和主机地址 的长度。子网掩码长为32位比特，其中的1对应于IP地址中的网 络号和子网号，而子网掩码中的0对应于主机号。</p>\n</li>\n</ul>\n<p><img src=\"https://img.cetacis.dev/uploads/big/19e15b01d1cd5a1d5c9f31d93d302f62.png\" alt=\"\"></p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/aba86e09488e237699bf4ef9342b2473.png\" alt=\"\"></p>\n<h4 id=\"8-技术发展\"><a href=\"#8-技术发展\" class=\"headerlink\" title=\"8. 技术发展\"></a>8. 技术发展</h4><p>一个A类的IP地址，可以有24bit用于分配主机地址，因此可以 支持 224个主机，但是一个家庭或者组织往往不需要这么多的地 址空间，造成浪费。 </p>\n<p> 一个C类的IP地址，只有8bit用于分配主机地址，因此只能支持 256个主机，又不太够用。 </p>\n<p> 因此，按传统IP地址分类方式分配IP被CIDR技术取代 </p>\n<p><strong><em>CIDR</em></strong> ： 无类别无间路由 网络前缀+主机号</p>\n<p>a.b.c.d/x  （x是地址网络部分的bit数 地址中的网络部分可以任意长(<strong>IP</strong>地址前缀或网络前缀)</p>\n<p>CIDR将网络前缀都相同的连续的IP地址组成“CIDR地址块”。</p>\n<p>CIDR 消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念，因 而可以更加有效地分配 IPv4 的地址空间。</p>\n<p><em>子网掩码：</em>/x的计法和255.255.255.0 都属于子网掩码</p>\n<p><strong>构造超网</strong></p>\n<p>一个公司或组织通常被分配一块连续的地址块，即具有相同前缀的一段地址。 </p>\n<p> CIDR将网络前缀都相同的连续的IP地址组成“CIDR地址块”。<br> 一个CIDR地址块可以表示多个内部的子网的集合，这种地址的聚合称为路由聚合，又称为构成超网。</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/9273227069681117e02deaa2f0510c18.png\" alt=\"\"></p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/05103f17bfe105dad5a7a6cdaab3c9b1.png\" alt=\"\"></p>\n<p><strong>全0 全1 都是不能作为主机号</strong></p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/e7c98a247bcbc19b1228645cc73a0942.png\" alt=\"\"></p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/bcb4eff878dbb9ff35ca8f74c121defb.png\" alt=\"\"></p>\n<p>单播地址：主机号不为全1或者全0</p>\n<h4 id=\"9-IP地址获取\"><a href=\"#9-IP地址获取\" class=\"headerlink\" title=\"9. IP地址获取\"></a>9. IP地址获取</h4><p><strong>主机如何得到IP地址</strong></p>\n<p>*<em>手工指定(保存在系统配置中) *</em></p>\n<p>• Windows: 控制面板-&gt;网络   • UNIX/LINUX: 在/etc/rc.config中，可使用ifconfig命令配置 </p>\n<p><strong>DHCP: Dynamic Host Configuration Protocol</strong></p>\n<p>• 自动从一个DHCP服务器得到IP地址 • 方便灵活</p>\n<p><strong>DHCP分配的不仅仅是IP地址，还可分配:</strong><br>• 客户的第一跳路由器的地址(网关) • DNS服务器的IP地址或域名• 子网掩码</p>\n<p>DHCP是应用程协议</p>\n<p><strong>动态主机配置协议</strong></p>\n<p>plug-and-play(即插即用) </p>\n<p>DHCP概述:</p>\n<p>• 主机广播 “DHCP DISCOVER” 消息<br>• DHCP 服务器用 “DHCP OFFER” 消息响应<br>• 主机请求IP地址: “DHCP REQUEST” 消息<br>• DHCP 服务器确认 “DHCP ACK/NACK” 消息 • DHCP 终止租用期”DHCP RELEASE”消息</p>\n<p>DHCP具体过程</p>\n<ul>\n<li>DHCP打开udp端口67 等待客户端发来的报文，等待客户端发来的报文</li>\n<li>DHCP客户从udp端口68发送dhcp发现报文</li>\n<li>凡收到dhcp发现报文的dhcp服务器都发出dhcp提供报文。客户端收到多个DHCP提供的报文。</li>\n<li>客户端选择一个ip，广播告诉大家我选了某个，未被选中的ip提供者回收ip （DHCP REQUEST）</li>\n<li>被选中的DHCP发送确认报文DHCPACK 客户端绑定，开始使用临时IP地址</li>\n</ul>\n<p>租用期（lifetime）为T，DHCP有两个计时器T1 T2 。T1 = 0.5T T2 = 0.875T。超时则请求更新租用期</p>\n<ul>\n<li>T1到，客户端发送DHCP REQUEST 要求更新租用期</li>\n<li>服务端不同意，发回否认报文 DHCPNACK，客户端必须立即停止使用原来的ip地址，重新申请ip地址（discover）</li>\n<li>若同意，服务端发送确认报文 dhcpack 客户得到新的租用期，重新设置计时器</li>\n<li>如果服务端不相应T1 到达T2，则重新发送request</li>\n<li>客户端可随时终止服务器提供的租用期，只需要发送DHCP RELEASE</li>\n</ul>\n<p><img src=\"https://img.cetacis.dev/uploads/big/e06d4aedea07a6bbee0aa09fb5015eac.png\" alt=\"\"></p>\n<p>Discover ：src: 本机 dest:目标（广播）yiaddr（被分配的ip地址）: 无ip所以为全0 t</p>\n<p>​                    ransaction ID: 传输id。相同则为对应恢复</p>\n<p>offer: 租用时间 : 3600 secs</p>\n<p>request: 广播原因：告诉别的dhcp服务器别等了，我已经选了某台了。服务端回收ip。</p>\n<p><strong>DHCP</strong> <strong>中继代理(relay agent)</strong></p>\n<ul>\n<li><p>并不是每个网络上都有 DHCP 服务器，这样会使 DHCP 服务器的数量太多。 现在是每一个网络至少有一个 DHCP 中继代理(通常是一台路由器)，它配置 了 DHCP 服务器的 IP 地址信息。</p>\n</li>\n<li><p>DHCP 中继代理收到主机发送的发现报文后，就以单播方式向 DHCP 服 务器转发此报文，并等待其回答。收到 DHCP 服务器回答的提供报文后， DHCP 中继代理再将此提供报文发回给主机。</p>\n</li>\n</ul>\n<h4 id=\"10-关于ip地址及域名的获得-NAT協議\"><a href=\"#10-关于ip地址及域名的获得-NAT協議\" class=\"headerlink\" title=\"10 关于ip地址及域名的获得 NAT協議\"></a>10 关于ip地址及域名的获得 NAT協議</h4><p>ISP获得地址块方法–ICANN</p>\n<p><strong>ICANN</strong>(Internet Corporation for Assigned Names and Numbers)</p>\n<ul>\n<li>分配IP地址</li>\n<li>管理DNS</li>\n<li>分配域名，解决纠纷</li>\n</ul>\n<p><em>ICANN( Internet Corporation for Assigned Names and Numbers ，互联网名称与数字地址分配机构)是一个非营利性的 国际组织，成立于1998年10月，是一个集合了全球网络界商业、 技术及学术各领域专家的非营利性国际组织，负责互联网协议 (IP)地址的空间分配、协议标识符的指派、通用顶级域名 (gTLD)以及国家和地区顶级域名(ccTLD)系统的管理、以及 根服务器系统的管理。这些服务最初是在美国政府合同下由互联 网号码分配当局(Internet Assigned Numbers Authority，IANA) 以及其它一些组织提供。现在，ICANN行使IANA的职能。</em></p>\n<p><strong>NIC</strong></p>\n<p>所有的IP地址都由ICANN规划，然后主要由国际组织NIC(Network Information Center)具体负责统一分配。</p>\n<p>目前全世界共有五个这样的网络信息中心</p>\n<p>我国申请IP地址要通过APNIC，APNIC的总部设在日本东京大学。申请时要考虑申 请哪一类的IP地址，然后向国内的代理机构提出。</p>\n<p>IPV4地址段早就枯竭了</p>\n<p><strong>NAT 网络地址转换</strong></p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/a3dfd50269006d3d1337e17ca1995a23.png\" alt=\"\"></p>\n<p>10.0.##  192.168.## 都是私网ip。他们有共同的源端up地址，有不同的源端口号</p>\n<p>动机： 对于外部网络来讲，本地网络只用一个ip地址</p>\n<ul>\n<li>不需要从isp分配一系列地址——只要一个ip地址用于所有设备</li>\n<li>在本地网络 改变设备的ip地址不通知外界</li>\n<li>更新isp不用更新本地的设备地址</li>\n<li>本地网络内部设备不能被外部世界明确寻址，或不可见（安全）</li>\n</ul>\n<p><img src=\"https://img.cetacis.dev/uploads/big/fbf732015ffbbcf2e462d608b041fcab.png\" alt=\"\"></p>\n<p><strong>执行NAT，路由器必须做到:</strong></p>\n<ul>\n<li><p>外出的分组: 替换每个外出的分组的 (源IP 地址, 端口号) 为 (NAT IP 地址, 新端口号)</p>\n<p>远程客户/服务器用(NAT IP地址, 新端口号)作为目的地来响应。 </p>\n</li>\n<li><p>在NAT转换表中，记录了每个(源IP 地址, 端口号)到 (NAT IP地址, 新端口号) 的对应关系。</p>\n</li>\n<li><p>进来的分组: 对每个进来的分组，用保存在NAT表中的对应的(源 IP 地址, 端口号) 替换分组中的目的域 (NAT IP 地址, 新端口号)</p>\n</li>\n</ul>\n<p><strong>NAT: 网络地址转换的一些限制</strong></p>\n<p>16-bit 端口号: 一个局域网地址可以同时支持60,000个并发连接!</p>\n<p>NAT 存在争议: 端口号，仅用于进程变址  路由器只应该处理到第三层 端口号是运输层</p>\n<p>​                        违反了端到端主张：应用程序设计者在设计时不得不将NAT加以考虑，如P2P应用程序</p>\n<p>​                        应使用IPv6来解决地址短缺问题</p>\n<p>UNnP (通用即插即用)</p>\n<p><em>NAT违背了计算机网络分层的思想，伪首部说明TCP、IP协议没有为严格分层</em> </p>\n<p>（沒有校驗合）</p>\n<h4 id=\"11-ICMP-Internet-Control-Message-Protocol，-因特网控制报文协议）\"><a href=\"#11-ICMP-Internet-Control-Message-Protocol，-因特网控制报文协议）\" class=\"headerlink\" title=\"11. ICMP: (Internet Control Message Protocol， 因特网控制报文协议）\"></a>11. <strong>ICMP: (Internet Control Message Protocol</strong>， 因特网控制报文协议）</h4><p>用于主机路由器之间彼此交流网络层信息：</p>\n<ul>\n<li>差错报告: 不可到达的主机, 网络,端口,协议</li>\n<li>请求/应答 (用于ping,traceroute)</li>\n</ul>\n<p>”位於ip之上“</p>\n<ul>\n<li>ICMP消息是裝載在ip分組裡 （ip協議字段標明有否icmp）</li>\n<li>但是真正的數據，ICMP包文是在ip數據中的</li>\n</ul>\n<p><img src=\"https://img.cetacis.dev/uploads/big/068b64ac5b008cecf35497c348c96165.png\" alt=\"\"></p>\n<p>ICMP 报文结构:</p>\n<p>类型字段, 编码字段、校验和字 段以及不同报文类型所加载的 数据。如果是差错报告，则后 面的数据包含引起该ICMP报文 的IP分组的报头和分组中的前8 字节的数据。</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/948e5a2d33e20583af434c9b0b9f5930.png\" alt=\"重要的icmp报文结构\"></p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/545b1e03766d41cb8d2f18e42edc6fc3.png\" alt=\"\"></p>\n<h4 id=\"13-虚拟专用网vpn（）\"><a href=\"#13-虚拟专用网vpn（）\" class=\"headerlink\" title=\"13. 虚拟专用网vpn（）\"></a>13. 虚拟专用网vpn（）</h4><ul>\n<li>多个分散的机构需要形成一个专用网进行通信时，利用因特网来实现多个分散机构的专用网，这样的专用网就称为虚拟专用网VPN：将IP地址</li>\n<li>配置成目标的内网ip</li>\n</ul>\n<p>vpn的实现：隧道技术</p>\n<p>将一个内网中的10.1.0.1的ip数据报封装在数据部分发出，到目的内网解封，好像就是内网之间的交流。</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/92164205c6b85ffc40b924793a5b1f78.png\" alt=\"\"></p>\n<h4 id=\"14-IPv6\"><a href=\"#14-IPv6\" class=\"headerlink\" title=\"14. IPv6\"></a>14. IPv6</h4><p>初始动机: 32-bit 地址空间即将用尽。</p>\n<p>其他动机:1. 首部格式可帮助加速处理/转发 2. 改变首部利于QoS要求</p>\n<p>首部格式改变: 1. IPv6 数据报:扩大的地址容量 2. 简化高效的 40 字节首部 3. 流标签</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/1533821297d0e9d21f88bff644df23ee.png\" alt=\"\"></p>\n<p>增加地址空间 首部简化（减少可选项）流标签 还没有确定 </p>\n<p>流量类型:表示流中分组的优先级,类似IPv4中的TOS字段，可用于给出给出一个流中某些数据的优先级。</p>\n<p>流标签: 表示分组在同一个 “流”中 (“流”的概念尚未完全定义).</p>\n<p>下一个首部: 表示数据的上层协议，类似IPv4中的协议字段。</p>\n<p>跳限制：类似于ttl</p>\n<p>校验和: 全部去掉，减少每一跳的处理时间</p>\n<p>选项: 允许, 但是不是标准首部的一部分，而是用下一个首部域 指出</p>\n<p>ICMPv6  :新版本的 ICMP （不会重新分片，而是回发错误信息，按照新的方式进行封装）<br>• 增加消息类型, 例如“分组太大”     • 多播组管理功能</p>\n<p><img src=\"https://img.cetacis.dev/uploads/big/27c91f4920f4dbb0b5afb99f0b9e35ee.png\" alt=\"\"></p>\n<p>地址还有其他压缩方法</p>\n<p><strong>ipv4到ipv6的过渡</strong></p>\n<p>并不是所有的路由器都能够同时升级</p>\n<p>• 没有 “标志日”</p>\n<p>• 同时有 IPv4 和 IPv6 路由器的网络如何工作?</p>\n<p>两种推荐方法:</p>\n<p>• 双栈:一些路由器具有双重栈 (v6, v4) 能够在两种格式中转换</p>\n<p>• 隧道: 在穿过IPv4路由器时，IPv6分组作为 IPv4分组的负载</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"ck849ava60000thes4u0if3ql","category_id":"ck849avae0002thesc8lk2a0b","_id":"ck849avaq000bthes0md93uyo"},{"post_id":"ck849avan0005thes0spw6l0a","category_id":"ck849avax000jthesbnv93gdh","_id":"ck849avb3000zthes616sbnsk"},{"post_id":"ck985a7820005slqg33gicbpi","category_id":"ck985a78f000gslqgfkqi5xp5","_id":"ck985a78i000nslqg52zi3ww3"},{"post_id":"ck985a7770000slqg9sbp9xme","category_id":"ck985a77m0002slqg6zy68nez","_id":"ck985a78i000pslqg72nx9g1y"},{"post_id":"ck985a7770000slqg9sbp9xme","category_id":"ck985a78h000kslqg2px17xy2","_id":"ck985a78j000rslqgeovwd06b"},{"post_id":"ck985a77h0001slqgh9lyecxj","category_id":"ck985a7850008slqghfi06l40","_id":"ck985a78k000tslqg8jo73vbo"},{"post_id":"ck985a77h0001slqgh9lyecxj","category_id":"ck985a78i000qslqgdxl2f1ul","_id":"ck985a78k000vslqg3s85ap9s"},{"post_id":"ck985a7800004slqg0bon0871","category_id":"ck985a788000cslqgda3hcylx","_id":"ck985a78l000wslqg9y0dcgaj"},{"post_id":"ck985a7800004slqg0bon0871","category_id":"ck985a78j000sslqg7krlaqqc","_id":"ck985a78l000xslqg06wrcsn5"},{"post_id":"ck985a7840007slqgay5935i2","category_id":"ck985a77m0002slqg6zy68nez","_id":"ck985a78l000yslqgei733njl"},{"post_id":"ck985a7840007slqgay5935i2","category_id":"ck985a78i000oslqg0r6bgpja","_id":"ck985a78l000zslqge07fd201"},{"post_id":"ck985a7840007slqgay5935i2","category_id":"ck985a78k000uslqg1lgc6t6m","_id":"ck985a78l0010slqg0dpr6msb"},{"post_id":"ck985a86e0012slqgg1saa5fu","category_id":"ck985a78f000gslqgfkqi5xp5","_id":"ck985a86l0017slqg1tlj7ss9"},{"post_id":"ck67gmura0003o3mx7jiyb4wo","category_id":"ck985a86k0014slqg30j6col1","_id":"ck985a86t001aslqgfcfaa2pp"},{"post_id":"ck67gmur70001o3mxb5gugexw","category_id":"ck985a77m0002slqg6zy68nez","_id":"ck985a86y001fslqg2jke5l9d"},{"post_id":"ck67gmur70001o3mxb5gugexw","category_id":"ck985a86p0019slqg4rhfgftk","_id":"ck985a86y001gslqgbvf4d50v"},{"post_id":"ck985a86k0016slqgh7s4a817","category_id":"ck985a77m0002slqg6zy68nez","_id":"ck985a86z001hslqggd7v9hft"},{"post_id":"ck985a86k0016slqgh7s4a817","category_id":"ck985a78i000oslqg0r6bgpja","_id":"ck985a872001jslqgbgs79xtq"},{"post_id":"ck985a86k0016slqgh7s4a817","category_id":"ck985a86u001bslqgegpkdhrh","_id":"ck985a873001kslqg18vz9xbl"},{"post_id":"ck849avar000ethesg7jz7nfq","category_id":"ck985a788000cslqgda3hcylx","_id":"ck985a874001mslqgdcycdu8n"},{"post_id":"ck849avar000ethesg7jz7nfq","category_id":"ck985a86x001eslqghbchaz8r","_id":"ck985a875001oslqg9b401ruj"},{"post_id":"ck849ava60000thes4u0if3ql","category_id":"ck985a86z001islqg66c38e4l","_id":"ck985a876001pslqg2ve0ff12"},{"post_id":"ck849avan0006these8jg6962","category_id":"ck849avae0002thesc8lk2a0b","_id":"ck985a877001rslqg82gf7ocx"},{"post_id":"ck849avan0006these8jg6962","category_id":"ck985a873001lslqg68uq7grp","_id":"ck985a877001sslqg6r7ufa8i"},{"post_id":"ck849avap0009thes23137m0x","category_id":"ck849avae0002thesc8lk2a0b","_id":"ck985a877001tslqgejtc2j6j"},{"post_id":"ck849avap0009thes23137m0x","category_id":"ck985a873001lslqg68uq7grp","_id":"ck985a877001uslqggi07fcd6"},{"post_id":"ck849avaq000athesfk5l69r8","category_id":"ck849avae0002thesc8lk2a0b","_id":"ck985a878001vslqg6ekv22dt"},{"post_id":"ck849avaq000athesfk5l69r8","category_id":"ck985a873001lslqg68uq7grp","_id":"ck985a878001wslqgfwf18z0r"},{"post_id":"ck67gmurb0004o3mxeyimhkvr","category_id":"ck985a86k0014slqg30j6col1","_id":"ck985a8ha001xslqgbowe3wji"},{"post_id":"ck67gmur30000o3mx3quwfqq0","category_id":"ck985a86k0014slqg30j6col1","_id":"ck985a8hb001zslqg8q4j524v"},{"post_id":"ck849aval0004thes0j7d8lhs","category_id":"ck985a788000cslqgda3hcylx","_id":"ck985a8hc0020slqge1592qs9"},{"post_id":"ck849aval0004thes0j7d8lhs","category_id":"ck985a8hb001yslqg9tveeojk","_id":"ck985a8hi0021slqg4amng8xb"}],"PostTag":[{"post_id":"ck67gmur30000o3mx3quwfqq0","tag_id":"ck67gmur80002o3mx57752kd7","_id":"ck67gmurc0007o3mx8r1wa6l2"},{"post_id":"ck67gmur30000o3mx3quwfqq0","tag_id":"ck67gmurc0005o3mx6llk4hvv","_id":"ck67gmurc0008o3mx3fsa5j55"},{"post_id":"ck67gmur70001o3mxb5gugexw","tag_id":"ck67gmurc0006o3mx8jwu50wv","_id":"ck67gmurf000do3mxeb6o8zko"},{"post_id":"ck67gmur70001o3mxb5gugexw","tag_id":"ck67gmurd0009o3mx66y38zm1","_id":"ck67gmurf000eo3mx4h0w2k13"},{"post_id":"ck67gmur70001o3mxb5gugexw","tag_id":"ck67gmurd000ao3mxcm9sgfdb","_id":"ck67gmurf000go3mxhxreanys"},{"post_id":"ck67gmur70001o3mxb5gugexw","tag_id":"ck67gmurc0005o3mx6llk4hvv","_id":"ck67gmurf000ho3mx3romc2rf"},{"post_id":"ck67gmura0003o3mx7jiyb4wo","tag_id":"ck67gmur80002o3mx57752kd7","_id":"ck67gmurf000jo3mx50db2xmk"},{"post_id":"ck67gmura0003o3mx7jiyb4wo","tag_id":"ck67gmurc0005o3mx6llk4hvv","_id":"ck67gmurg000ko3mxbkj0gz7u"},{"post_id":"ck67gmurb0004o3mxeyimhkvr","tag_id":"ck67gmur80002o3mx57752kd7","_id":"ck67gmurg000lo3mxae7v231t"},{"post_id":"ck67gmurb0004o3mxeyimhkvr","tag_id":"ck67gmurc0005o3mx6llk4hvv","_id":"ck67gmurg000mo3mxgxcz94zr"},{"post_id":"ck849ava60000thes4u0if3ql","tag_id":"ck849avak0003thes0zedeo2u","_id":"ck849avas000fthesfzt494b7"},{"post_id":"ck849ava60000thes4u0if3ql","tag_id":"ck849avao0008thes1sr94g7d","_id":"ck849avaw000ithes7rnqbpyg"},{"post_id":"ck849aval0004thes0j7d8lhs","tag_id":"ck67gmurc0005o3mx6llk4hvv","_id":"ck849avb3000ythes2kc2bnd2"},{"post_id":"ck849aval0004thes0j7d8lhs","tag_id":"ck849avay000kthes1owh562t","_id":"ck849avb30010thesal5qfly7"},{"post_id":"ck849avan0005thes0spw6l0a","tag_id":"ck67gmurc0005o3mx6llk4hvv","_id":"ck849avb30013thes357jdabj"},{"post_id":"ck849avan0005thes0spw6l0a","tag_id":"ck849avb1000rthesd85g2o14","_id":"ck849avb30014thesdwvehub8"},{"post_id":"ck849avan0006these8jg6962","tag_id":"ck67gmurc0005o3mx6llk4hvv","_id":"ck849avb50019thesamz70ec1"},{"post_id":"ck849avan0006these8jg6962","tag_id":"ck849avb2000xthes95zhhgmi","_id":"ck849avb5001athes6d8w869f"},{"post_id":"ck849avan0006these8jg6962","tag_id":"ck849avb30012thes05io01vg","_id":"ck849avb5001cthesexzdhqpz"},{"post_id":"ck849avan0006these8jg6962","tag_id":"ck849avb40015thesdmbf63uq","_id":"ck849avb5001dthesbqhka4y3"},{"post_id":"ck849avan0006these8jg6962","tag_id":"ck849avb40016thes19sh881a","_id":"ck849avb5001ftheshj0b7nrp"},{"post_id":"ck849avan0006these8jg6962","tag_id":"ck849avb40017thes1rp789to","_id":"ck849avb6001gthesfym8gnf4"},{"post_id":"ck849avap0009thes23137m0x","tag_id":"ck67gmurc0005o3mx6llk4hvv","_id":"ck849avb7001kthesapubad5k"},{"post_id":"ck849avap0009thes23137m0x","tag_id":"ck849avb40018thes6b94cc6m","_id":"ck849avb7001lthes12b6apsg"},{"post_id":"ck849avap0009thes23137m0x","tag_id":"ck849avb5001bthesasx435se","_id":"ck849avb7001nthes8m5gcfb3"},{"post_id":"ck849avap0009thes23137m0x","tag_id":"ck849avb5001ethescvsg38an","_id":"ck849avb7001othesc5mkcikb"},{"post_id":"ck849avap0009thes23137m0x","tag_id":"ck849avb6001hthes1ap26j4t","_id":"ck849avb7001qthes7k4q0bos"},{"post_id":"ck849avap0009thes23137m0x","tag_id":"ck849avb6001ithescm3dcx5e","_id":"ck849avb7001rthes4w2f5bjf"},{"post_id":"ck849avaq000athesfk5l69r8","tag_id":"ck67gmurc0005o3mx6llk4hvv","_id":"ck849avb9001wthesd4bnc746"},{"post_id":"ck849avaq000athesfk5l69r8","tag_id":"ck849avb6001jthesa7jx5o4m","_id":"ck849avb9001xthesemr9hrum"},{"post_id":"ck849avaq000athesfk5l69r8","tag_id":"ck849avb7001mtheshptm57m3","_id":"ck849avb9001ythes29adcypd"},{"post_id":"ck849avaq000athesfk5l69r8","tag_id":"ck849avb7001pthes0unr0kq8","_id":"ck849avb9001ztheshlykdzhx"},{"post_id":"ck849avaq000athesfk5l69r8","tag_id":"ck849avb8001sthes5kgz7ou0","_id":"ck849avb90020thes9hz89tvh"},{"post_id":"ck849avaq000athesfk5l69r8","tag_id":"ck849avb8001ttheshg8ogipf","_id":"ck849avb90021theshdqoh3hn"},{"post_id":"ck849avaq000athesfk5l69r8","tag_id":"ck849avb8001uthes26ppa5go","_id":"ck849avba0022thesfehoeexq"},{"post_id":"ck849avar000ethesg7jz7nfq","tag_id":"ck849avak0003thes0zedeo2u","_id":"ck849avba0023thes955pen1k"},{"post_id":"ck849avar000ethesg7jz7nfq","tag_id":"ck849avb8001vthes2d0r09y6","_id":"ck849avba0024thes9y8a2pwe"},{"post_id":"ck985a7800004slqg0bon0871","tag_id":"ck849avak0003thes0zedeo2u","_id":"ck985a7840006slqg8fzk6jgc"},{"post_id":"ck985a7800004slqg0bon0871","tag_id":"ck849avao0008thes1sr94g7d","_id":"ck985a787000aslqg21d1fs5x"},{"post_id":"ck985a7820005slqg33gicbpi","tag_id":"ck67gmurc0005o3mx6llk4hvv","_id":"ck985a787000bslqg7qdv0nra"},{"post_id":"ck985a7820005slqg33gicbpi","tag_id":"ck849avar000dthes1cl94kmm","_id":"ck985a78e000eslqgh6f37dpi"},{"post_id":"ck985a7770000slqg9sbp9xme","tag_id":"ck985a77z0003slqg12ak12vk","_id":"ck985a78f000fslqg652bboom"},{"post_id":"ck985a7770000slqg9sbp9xme","tag_id":"ck985a7860009slqgcrrbaacm","_id":"ck985a78g000islqg925sbast"},{"post_id":"ck985a77h0001slqgh9lyecxj","tag_id":"ck985a788000dslqg2ivfhst7","_id":"ck985a78g000jslqgefah9xfl"},{"post_id":"ck985a7840007slqgay5935i2","tag_id":"ck849avak0003thes0zedeo2u","_id":"ck985a78h000lslqgf6i95nma"},{"post_id":"ck985a7840007slqgay5935i2","tag_id":"ck985a78f000hslqg6km01en6","_id":"ck985a78i000mslqg5na2226r"},{"post_id":"ck985a86e0012slqgg1saa5fu","tag_id":"ck67gmurc0005o3mx6llk4hvv","_id":"ck985a86i0013slqgbfq228bt"},{"post_id":"ck985a86e0012slqgg1saa5fu","tag_id":"ck849avar000dthes1cl94kmm","_id":"ck985a86k0015slqg4a6k0ioi"},{"post_id":"ck985a86k0016slqgh7s4a817","tag_id":"ck849avak0003thes0zedeo2u","_id":"ck985a86u001cslqgbx6y4idu"},{"post_id":"ck985a86k0016slqgh7s4a817","tag_id":"ck985a86n0018slqghyj6gkfm","_id":"ck985a86w001dslqgfvbb8s4o"}],"Tag":[{"name":"begin","_id":"ck60m0j1s0000wdux3cjwdj8b"},{"name":"liu","_id":"ck63irvjm0003xnmxagug91sx"},{"name":"Spo,123t","_id":"ck63irvjn0004xnmxhrnmg51k"},{"name":"git","_id":"ck67gmur80002o3mx57752kd7"},{"name":"自学笔记","_id":"ck67gmurc0005o3mx6llk4hvv"},{"name":"blog","_id":"ck67gmurc0006o3mx8jwu50wv"},{"name":"服务器","_id":"ck67gmurd0009o3mx66y38zm1"},{"name":"hexo","_id":"ck67gmurd000ao3mxcm9sgfdb"},{"name":"上课笔记","_id":"ck849avak0003thes0zedeo2u"},{"name":"进程","_id":"ck849avao0008thes1sr94g7d"},{"name":"终端基础操作","_id":"ck849avar000dthes1cl94kmm"},{"name":"u3d","_id":"ck849avay000kthes1owh562t"},{"name":"算法","_id":"ck849avb1000rthesd85g2o14"},{"name":"符号解析","_id":"ck849avb2000xthes95zhhgmi"},{"name":"重定位","_id":"ck849avb30012thes05io01vg"},{"name":"静态/动态链接","_id":"ck849avb40015thesdmbf63uq"},{"name":"装载","_id":"ck849avb40016thes19sh881a"},{"name":"共享库","_id":"ck849avb40017thes1rp789to"},{"name":"内存","_id":"ck849avb40018thes6b94cc6m"},{"name":"堆","_id":"ck849avb5001bthesasx435se"},{"name":"栈","_id":"ck849avb5001ethescvsg38an"},{"name":"运行库","_id":"ck849avb6001hthes1ap26j4t"},{"name":"系统调用","_id":"ck849avb6001ithescm3dcx5e"},{"name":"硬件基础","_id":"ck849avb6001jthesa7jx5o4m"},{"name":"操作系统","_id":"ck849avb7001mtheshptm57m3"},{"name":"编译器","_id":"ck849avb7001pthes0unr0kq8"},{"name":"编译过程","_id":"ck849avb8001sthes5kgz7ou0"},{"name":"目标文件","_id":"ck849avb8001ttheshg8ogipf"},{"name":"链接器","_id":"ck849avb8001uthes26ppa5go"},{"name":"unity","_id":"ck849avb8001vthes2d0r09y6"},{"name":"计算机网络","_id":"ck985a77z0003slqg12ak12vk"},{"name":"代理","_id":"ck985a7860009slqgcrrbaacm"},{"name":"ios","_id":"ck985a788000dslqg2ivfhst7"},{"name":"运输层","_id":"ck985a78f000hslqg6km01en6"},{"name":"网络层","_id":"ck985a86n0018slqghyj6gkfm"}]}}